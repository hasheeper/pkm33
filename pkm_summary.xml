<?xml version="1.0" ?>
<pkm_project>
    <directory name="battle">
        <file name="battle-damage.js"><![CDATA[/**
 * ===========================================
 * BATTLE-DAMAGE.JS - ä¼¤å®³ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ä¼¤å®³è®¡ç®—ä¸åº”ç”¨
 * - å‘½ä¸­/Miss å¤„ç†
 * - ç‰¹æ€§å…ç–«æ£€æµ‹
 * - Protect å®ˆä½æ‹¦æˆª
 * - æ›¿èº«å¸æ”¶
 * - å‰¯ä½œç”¨è§¦å‘
 */
// ============================================
// ä¼¤å®³è®¡ç®—ä¸åº”ç”¨
// ============================================
/**
 * ä¼¤å®³è®¡ç®—ä¸åº”ç”¨ (å«å¤šæ®µæ”»å‡»ã€åä¼¤ã€å¸è¡€ã€èƒ½åŠ›å˜åŒ–)
 * @param {Object} attacker æ”»å‡»æ–¹
 * @param {Object} defender é˜²å¾¡æ–¹
 * @param {Object} move æ‹›å¼
 * @param {string} spriteIdRef ç›®æ ‡ç²¾çµå›¾ ID ('player-sprite' æˆ– 'enemy-sprite')
 * @returns {Object} ä¼¤å®³ç»“æœ
 */
function applyDamage(attacker, defender, move, spriteIdRef) {
    const battle = window.battle;
    // === å…³é”®ä¿®å¤ï¼šåœ¨è®¡ç®—ä¼¤å®³å‰æ£€æŸ¥ onUseï¼ˆå¦‚ Fake Out é¦–å›åˆé™åˆ¶ï¼‰ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    const isPlayerAttacking = spriteIdRef !== 'player-sprite';
    // åªå¯¹æ”»å‡»æŠ€åšå‰ç½®æ£€æŸ¥ï¼Œå˜åŒ–æŠ€çš„ onUse åœ¨åé¢å¤„ç†
    const moveCategory = move.cat || '';
    const isStatusMove = moveCategory === 'status' || move.power === 0;
    if (handler && handler.onUse && !isStatusMove) {
        let preLogs = [];
        const preCheck = handler.onUse(attacker, defender, preLogs, battle, isPlayerAttacking);
        if (preCheck && preCheck.failed) {
            preLogs.forEach(txt => log(`<span style="color:#e74c3c">${txt}</span>`));
            return { damage: 0, effectiveness: 0, miss: false, failed: true };
        }
        preLogs.forEach(txt => log(txt));
    }
    // ä½¿ç”¨ battle-engine çš„ä¼¤å®³è®¡ç®—
    const result = calcDamage(attacker, defender, move);
    // 0. å¤„ç†ç‰¹æ€§å…ç–« (æ¼‚æµ®ã€é¿é›·é’ˆç­‰)
    if (result.abilityImmune) {
        log(`<b style='color:#9b59b6'>${defender.cnName} çš„ ${result.abilityImmune} å¸æ”¶/å…ç–«äº†æ”»å‡»!</b>`);
        return result;
    }
    // 0. å¤„ç† Protect å®ˆä½æ‹¦æˆª
    if (result.blocked) {
        log(`<b style='color:#3498db'>${defender.cnName} å®ˆä½äº†è‡ªå·±ï¼Œå…å—äº†æ”»å‡»!</b>`);
        if (defender.volatile) {
            defender.volatile.protect = false;
        }
        // High Jump Kick / Jump Kick å¤±è´¥åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        return result;
    }
    // I. å¤„ç† MISS
    if (result.miss) {
        if (result.insightMiracle) {
            log(`<b style="color:#d4ac0d; text-shadow:0 0 5px gold;">âœ¨ ä¸å¯èƒ½çš„å¥‡è¿¹ï¼${defender.cnName} çœ‹ç©¿äº†ç»å¯¹å‘½ä¸­çš„è½¨è¿¹ï¼(Insight EX)</b>`);
        } else if (result.insightDodge && defender.avs && defender.avs.insight >= 100) {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ”»å‡»æ²¡æœ‰å‘½ä¸­!</b>`);
            log(`<b style="color:#a78bfa">âœ¨ ${defender.cnName} å‡­å€ŸçµçŠ€æ„Ÿåº”é¢„åˆ¤äº†æ”»å‡»è½¨è¿¹! (Insight${defender.avsEvolutionBoost ? ' x2' : ''})</b>`);
        } else {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ”»å‡»æ²¡æœ‰å‘½ä¸­!</b>`);
        }
        // High Jump Kick / Jump Kick å¤±è´¥åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        return result;
    }
    // II. å˜åŒ–æŠ€ (Power=0, Status Move)
    if (result.damage === 0 && move.power === 0) {
        // æ£€æŸ¥æ˜¯å¦ä¸ºåå¼¹æŠ€èƒ½ï¼ˆCounter/Mirror Coat/Metal Burstï¼‰
        const reflectHandler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
        if (reflectHandler && reflectHandler.isReflectMove) {
            let reflectLogs = [];
            const reflectResult = reflectHandler.onUse(attacker, defender, reflectLogs, battle, spriteIdRef !== 'player-sprite');
            reflectLogs.forEach(txt => log(txt));
            if (reflectResult && reflectResult.failed) {
                return result;
            }
            if (reflectResult && reflectResult.damage > 0) {
                defender.takeDamage(reflectResult.damage);
                log(`é€ æˆäº† <b style="color:#e74c3c">${reflectResult.damage}</b> ä¼¤å®³ï¼`);
                const targetEl = document.getElementById(spriteIdRef);
                if (targetEl) {
                    targetEl.classList.remove('shake-hit-anim');
                    void targetEl.offsetWidth;
                    targetEl.classList.add('shake-hit-anim');
                    if (defender.currHp <= 0) {
                        targetEl.classList.add('fainting');
                    }
                }
                result.damage = reflectResult.damage;
                updateAllVisuals();
            }
            return result;
        }
        // å˜åŒ–æŠ€ Miss åˆ¤å®š
        if (result.miss) {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ²¡æœ‰å‘½ä¸­!</b>`);
            return result;
        }
        // å¤„ç† Volatile çŠ¶æ€æŠ€èƒ½ (Taunt, Substitute ç­‰)
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyVolatileStatus) {
            const volatileResult = MoveEffects.applyVolatileStatus(attacker, defender, move);
            if (volatileResult.success) {
                volatileResult.logs.forEach(txt => log(txt));
                return result;
            } else if (volatileResult.logs.length > 0) {
                volatileResult.logs.forEach(txt => log(txt));
                return result;
            }
        }
        // å¤„ç†å˜åŒ–æŠ€çš„èƒ½åŠ›å˜åŒ–
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, 0, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        if (fxLogs.length > 0) {
            fxLogs.forEach(txt => log(txt));
        } else {
            log(`...${move.cn}! (å˜åŒ–æŠ€èƒ½)`);
        }
        result.pivot = fxResult.pivot || false;
        return result;
    }
    // === Disguise (ç”»çš®) ç‰¹æ€§å¤„ç† ===
    if (defender.disguiseBustDamage && defender.disguiseBustDamage > 0) {
        log(`<b style="color:#9b59b6">ğŸ­ ${defender.cnName} çš„ç”»çš®ç ´æŸäº†!</b>`);
        log(`<b style="color:#3498db">${defender.cnName} å…ç–«äº†è¿™æ¬¡æ”»å‡»!</b>`);
        defender.takeDamage(defender.disguiseBustDamage);
        log(`<span style="color:#e67e22">${defender.cnName} å—åˆ°äº†ç”»çš®ç ´æŸçš„ä¼¤å®³! (-${defender.disguiseBustDamage})</span>`);
        defender.disguiseBustDamage = 0;
        updateAllVisuals();
        return result;
    }
    // III. å¦‚æœæœ‰ä¼¤å®³ -> æ‰£è¡€
    const dmgCategory = (move.cat || result.category || 'physical').toLowerCase();
    if (result.damage > 0) {
        // æ£€æŸ¥æ›¿èº«æ˜¯å¦å¸æ”¶ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.checkSubstitute) {
            const subResult = MoveEffects.checkSubstitute(defender, result.damage, move);
            if (subResult.absorbed) {
                subResult.logs.forEach(txt => log(txt));
                result.damage = 0;
                updateAllVisuals();
                return result;
            }
        }
        defender.takeDamage(result.damage, dmgCategory);
        // === æ’­æ”¾æ‰“å‡»éŸ³æ•ˆ ===
        if (typeof window.playHitSFX === 'function') {
            window.playHitSFX(result.effectiveness, result.isCrit);
        }
        // Focus Sash è§¦å‘æ—¥å¿—
        if (defender.focusSashTriggered) {
            log(`<b style="color:#f1c40f">ğŸ›¡ï¸ ${defender.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼å‹‰å¼ºæ’‘ä½äº†æ”»å‡»ï¼</b>`);
            defender.focusSashTriggered = false;
        }
        // AVs: Trust (ä¿¡èµ–) é”è¡€è§¦å‘æ—¥å¿—
        if (defender.trustEndureTriggered) {
            log(`<b style="color:#e91e63">ğŸ’– ${defender.cnName} å‡­å€Ÿä¸è®­ç»ƒå®¶çš„ç¾ç»Šï¼Œç”¨è„¸æ¥ä¸‹äº†è‡´å‘½ä¸€å‡»! (Trust)</b>`);
            defender.trustEndureTriggered = false;
        }
        // Second Wind (ç¬¬äºŒæ°”æ¯) è§¦å‘æ—¥å¿—
        if (defender.secondWindActivated) {
            log(`<b style="color:#ff6b35">ğŸ”¥ ${defender.cnName} çš„ç¬¬äºŒæ°”æ¯è§‰é†’äº†!</b>`);
            log(`<b style="color:#ff6b35">ğŸ’ª å…¨å±æ€§æå‡! æ”»å‡»+1 é˜²å¾¡+1 ç‰¹æ”»+1 ç‰¹é˜²+1 é€Ÿåº¦+1!</b>`);
            defender.secondWindActivated = false;
        }
        // æ’­æ”¾å—å‡»åŠ¨ç”»
        const targetEl = document.getElementById(spriteIdRef);
        if (targetEl) {
            targetEl.classList.remove('shake-hit-anim');
            targetEl.classList.remove('fainting');
            void targetEl.offsetWidth;
            targetEl.classList.add('shake-hit-anim');
            if (defender.currHp <= 0) {
                targetEl.classList.add('fainting');
                setTimeout(() => {
                    targetEl.classList.remove('fainting');
                    targetEl.classList.add('fainted-hidden');
                }, 750);
            }
        }
        // æ„å»ºä¼¤å®³æ–‡æœ¬
        let infoParts = [];
        if (result.hitCount > 1) {
            infoParts.push(`<span style="color:#9b59b6">(å‘½ä¸­ ${result.hitCount} æ¬¡)</span>`);
        }
        if (result.effectiveness >= 2) infoParts.push('<b style="color:#e74c3c">(æ•ˆæœæ‹”ç¾¤!)</b>');
        else if (result.effectiveness <= 0.5 && result.effectiveness > 0) infoParts.push('(æ•ˆæœä¸å¥½...)');
        if (result.isCrit) {
            infoParts.push('<b class="hl-crit">å‡»ä¸­è¦å®³!</b>');
            if (attacker.avs && attacker.avs.passion >= 100) {
                infoParts.push(`<b style="color:#f59e0b">ğŸ”¥ (Passion${attacker.avsEvolutionBoost ? ' x2' : ''})</b>`);
            }
        }
        const infoStr = infoParts.join(' ');
        if (result.damage <= 2 && result.effectiveness > 0) {
            log(`é€ æˆäº† <span style="color:#95a5a6">${result.damage}</span> ä¼¤å®³... (ä»¿ä½›æ˜¯åœ¨ç»™å¯¹æ‰‹æŒ ç—’ç—’) ${infoStr}`);
        } else {
            log(`é€ æˆäº† ${result.damage} ä¼¤å®³ ${infoStr}`);
        }
    } else if (result.effectiveness === 0) {
        log(`<b>å¯¹å…¶æ²¡æœ‰æ•ˆæœ!</b>`);
        // High Jump Kick / Jump Kick æ‰“åˆ°å…ç–«å±æ€§æ—¶çš„åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        result.pivot = false;
        return result;
    }
    // IV. è§¦å‘å‰¯ä½œç”¨
    let pivotTriggered = false;
    if (defender.currHp > 0) {
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, result.damage, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        pivotTriggered = fxResult.pivot || false;
        fxLogs.forEach(txt => log(`<span style="font-size:0.95em;color:#e67e22">${txt}</span>`));
    } else {
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, result.damage, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        pivotTriggered = fxResult.pivot || false;
        const attackerOnlyLogs = fxLogs.filter(txt => 
            txt.includes(attacker.cnName) || 
            txt.includes('åä½œç”¨åŠ›') || 
            txt.includes('å¸å–')
        );
        attackerOnlyLogs.forEach(txt => log(`<span style="font-size:0.95em;color:#e67e22">${txt}</span>`));
    }
    // V. æ›´æ–°æ”»å‡»æ–¹è¡€æ¡
    updateAllVisuals();
    // VI. è¿”å›ç»“æœ
    result.pivot = pivotTriggered;
    return result;
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.applyDamage = applyDamage;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { applyDamage };
}
]]></file>
        <file name="battle-switch.js"><![CDATA[/**
 * ===========================================
 * BATTLE-SWITCH.JS - æ¢äººç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - Pivot æ¢äºº (U-turn/Volt Switch)
 * - å¼ºåˆ¶æ¢äºº
 * - å€’ä¸‹å¤„ç†
 * - å…¥åœºç‰¹æ€§è§¦å‘
 */
// ============================================
// è¾…åŠ©å‡½æ•°
// ============================================
/**
 * æ£€æŸ¥æ˜¯å¦æœ‰å¯æ¢å…¥çš„å­˜æ´»å®å¯æ¢¦
 */
function hasAliveSwitch(party, currentIndex) {
    return party.some((pm, idx) => 
        idx !== currentIndex && pm && pm.isAlive && pm.isAlive() && pm.currHp > 0
    );
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// Pivot æ¢äºº
// ============================================
/**
 * å¤„ç†ç©å®¶ Pivot æ¢äººï¼ˆU-turn/Volt Switch ç­‰ï¼‰
 * ä½¿ç”¨ Promise ç­‰å¾…ç©å®¶é€‰æ‹©
 */
function handlePlayerPivot() {
    const battle = window.battle;
    console.log('[handlePlayerPivot] Starting pivot switch');
    log(`<span style="color:#3498db">é€‰æ‹©è¦æ¢å…¥çš„å®å¯æ¢¦!</span>`);
    battle.phase = 'pivot_switch';
    battle.pivotSide = 'player';
    // æ˜¾ç¤ºæ¢äººèœå•ï¼ˆä¸å¯å–æ¶ˆï¼‰
    if (typeof window.renderSwitchMenu === 'function') {
        window.renderSwitchMenu(false);
    }
    console.log('[handlePlayerPivot] Waiting for player selection...');
    return new Promise((resolve) => {
        battle.pivotResolve = resolve;
    });
}
/**
 * å¤„ç†æ•Œæ–¹ Pivot æ¢äººï¼ˆAI è‡ªåŠ¨é€‰æ‹©ï¼‰
 */
async function handleEnemyPivot() {
    const battle = window.battle;
    const currentE = battle.getEnemy();
    const p = battle.getPlayer();
    // AI é€‰æ‹©æœ€ä½³æ¢å…¥ç›®æ ‡
    let bestIndex = -1;
    let bestScore = -Infinity;
    for (let i = 0; i < battle.enemyParty.length; i++) {
        const ally = battle.enemyParty[i];
        if (!ally || i === battle.enemyActive) continue;
        if (!ally.isAlive || !ally.isAlive() || ally.currHp <= 0) continue;
        let score = 0;
        // æ£€æŸ¥ç©å®¶æœ€å¼ºæŠ€èƒ½å¯¹è¯¥å®å¯æ¢¦çš„æ•ˆæœ
        for (const pMove of p.moves) {
            const moveType = pMove.type || 'Normal';
            const eff = window.getTypeEffectiveness ? 
                window.getTypeEffectiveness(moveType, ally.types || ['Normal']) : 1;
            if (eff === 0) score += 500;
            else if (eff <= 0.5) score += 200;
            else if (eff >= 2) score -= 100;
        }
        // æ£€æŸ¥è¯¥å®å¯æ¢¦å¯¹ç©å®¶çš„å…‹åˆ¶
        for (const aMove of ally.moves || []) {
            const moveType = aMove.type || 'Normal';
            const eff = window.getTypeEffectiveness ? 
                window.getTypeEffectiveness(moveType, p.types || ['Normal']) : 1;
            if (eff >= 2) score += 150;
        }
        if (score > bestScore) {
            bestScore = score;
            bestIndex = i;
        }
    }
    // å¦‚æœæ‰¾åˆ°åˆé€‚ç›®æ ‡ï¼Œæ‰§è¡Œæ¢äºº
    if (bestIndex !== -1) {
        log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${currentE.cnName}ï¼</span>`);
        // æ¸…é™¤ Choice é”æ‹›çŠ¶æ€
        if (currentE.choiceLockedMove) {
            console.log(`[CHOICE] ${currentE.name} æ¢ä¸‹ï¼Œè§£é™¤ ${currentE.choiceLockedMove} é”å®š`);
            delete currentE.choiceLockedMove;
        }
        // å¦‚æœæ¢ä¸‹çš„å®å¯æ¢¦å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œæ¢å¤æ‹›å¼
        if (currentE.isDynamaxed && typeof window.applyDynamaxState === 'function') {
            console.log(`[SWITCH] Enemy ${currentE.name} was Dynamaxed, restoring moves`);
            window.applyDynamaxState(currentE, false);
        }
        // é‡ç½®èƒ½åŠ›ç­‰çº§
        if (typeof currentE.resetBoosts === 'function') {
            currentE.resetBoosts();
        }
        battle.enemyActive = bestIndex;
        const newE = battle.getEnemy();
        log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
        updateAllVisuals('enemy');
        await wait(500);
        triggerEntryAbilities(newE, p);
        // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
    }
}
// ============================================
// å€’ä¸‹å¤„ç†
// ============================================
/**
 * å¤„ç†æ•Œæ–¹å€’ä¸‹
 */
async function handleEnemyFainted(e) {
    if (typeof window.playSFX === 'function') window.playSFX('FAINT');
    const battle = window.battle;
    // å¦‚æœæ•Œæ–¹å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œå…ˆæ¸…ç†æå·¨åŒ–è§†è§‰æ•ˆæœ
    if (e.isDynamaxed) {
        if (e.originalName) {
            e.name = e.originalName;
            delete e.originalName;
        }
        if (typeof window.endDynamaxAnimation === 'function') {
            await window.endDynamaxAnimation(e, false);
        }
        e.isDynamaxed = false;
        delete e.preDynamaxMaxHp;
        delete e.preDynamaxCurrHp;
        if (typeof window.applyDynamaxState === 'function') {
            window.applyDynamaxState(e, false);
        }
    }
    log(`æ•Œæ–¹çš„ ${e.cnName} å€’ä¸‹äº†!`);
    // Battle Bond (ç‰µç»Šå˜èº«) è§¦å‘æ£€æŸ¥
    const p = battle.getPlayer();
    if (p && p.isAlive() && typeof window.checkBattleBondTransform === 'function') {
        const bondResult = window.checkBattleBondTransform(p);
        if (bondResult && bondResult.success) {
            log(`<span style="color:#3b82f6">ğŸŒŠ ${bondResult.oldName} çš„ç‰µç»Š... å˜èº«ä¸º ${bondResult.newName}ï¼</span>`);
            updateAllVisuals('player');
            await wait(800);
        }
    }
    const battleEnd = battle.checkBattleEnd();
    if (battleEnd === 'win') {
        log("ğŸ† <b style='color:#27ae60'>æ•Œæ–¹å…¨éƒ¨æˆ˜è´¥ï¼ä½ èµ¢äº†ï¼</b>");
        const t = battle.trainer;
        if (t && t.id !== 'wild' && t.lines?.lose) {
            log(`<i>${t.name}: "${t.lines.lose}"</i>`);
        }
        setTimeout(() => {
            if (typeof window.battleEndSequence === 'function') {
                window.battleEndSequence('win');
            }
        }, 2000);
        return;
    }
    // æ•Œæ–¹æ¢äºº
    await wait(1000);
    if (battle.nextAliveEnemy()) {
        const newE = battle.getEnemy();
        log(`æ•Œæ–¹æ´¾å‡º <b>${newE.cnName}</b> (Lv.${newE.level})!`);
        // === æ’­æ”¾æ•Œæ–¹æ–°å®å¯æ¢¦å«å£° ===
        if (typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(newE.name);
        }
        // æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºè‡ªåŠ¨å˜å½¢ (Primal/Crowned)
        if (typeof window.checkInitTransform === 'function' && newE.needsInitTransform) {
            console.log('[FORM] Checking enemy switch-in init transform:', newE.name);
            const result = window.checkInitTransform(newE);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                const newSpriteUrl = newE.getSprite(false);
                const preloader = new Image();
                preloader.src = newSpriteUrl;
                await wait(100);
            }
        }
        // æ£€æŸ¥æ¢å…¥çš„æ•Œæ–¹æ˜¯å¦éœ€è¦æå·¨åŒ–
        const enemyUnlocks = battle.enemyUnlocks || {};
        const isNewEnemyDynamax = (newE.mechanic === 'dynamax') || 
                                   (newE.canDynamax && newE.mechanic !== 'mega' && newE.mechanic !== 'tera') ||
                                   (newE.megaTargetId && newE.megaTargetId.includes('gmax'));
        if (enemyUnlocks.enable_dynamax && isNewEnemyDynamax && !newE.isDynamaxed && !battle.enemyMaxUsed) {
            battle.enemyMaxUsed = true;
            const oldName = newE.cnName;
            const oldMaxHp = newE.maxHp;
            const oldCurrHp = newE.currHp;
            newE.originalName = newE.name;
            updateAllVisuals('enemy');
            await wait(600);
            log(`<b style="color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
            log(`æ•Œæ–¹çš„ ${oldName} æå·¨åŒ–äº†ï¼`);
            const spriteEl = document.getElementById('enemy-sprite');
            if (spriteEl) {
                spriteEl.classList.add('dynamax-burst');
                await wait(400);
                const gmaxFormId = newE.megaTargetId;
                if (gmaxFormId && gmaxFormId.includes('gmax') && !newE.isGenericDynamax) {
                    newE.name = gmaxFormId.charAt(0).toUpperCase() + gmaxFormId.slice(1);
                    const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
                    const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani/${gmaxSpriteId}.gif`;
                    if (typeof window.smartLoadSprite === 'function') {
                        window.smartLoadSprite('enemy-sprite', gmaxSpriteUrl, false);
                    }
                    console.log(`[DYNAMAX] æ•Œæ–¹æ¢å…¥æå·¨åŒ–ï¼Œåˆ‡æ¢ç²¾çµå›¾: ${gmaxSpriteUrl}`);
                } else if (newE.isGenericDynamax) {
                    console.log(`[DYNAMAX] æ•Œæ–¹é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${newE.name}`);
                }
                await wait(400);
                spriteEl.classList.remove('dynamax-burst');
                spriteEl.classList.add('state-dynamax');
            }
            const hpMultiplier = 1.5;
            newE.maxHp = Math.floor(oldMaxHp * hpMultiplier);
            newE.currHp = Math.floor(oldCurrHp * hpMultiplier);
            newE.isDynamaxed = true;
            newE.dynamaxTurns = 3;
            newE.preDynamaxMaxHp = oldMaxHp;
            newE.preDynamaxCurrHp = oldCurrHp;
            if (typeof window.applyDynamaxState === 'function') {
                window.applyDynamaxState(newE, true);
            }
            log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${newE.dynamaxTurns}]</span>`);
            await wait(400);
        }
        updateAllVisuals('enemy');
        triggerEntryAbilities(newE, battle.getPlayer());
        // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
        battle.locked = false;
    } else {
        log("ğŸ† <b style='color:#27ae60'>æ•Œæ–¹å…¨éƒ¨æˆ˜è´¥ï¼ä½ èµ¢äº†ï¼</b>");
        setTimeout(() => {
            if (typeof window.battleEndSequence === 'function') {
                window.battleEndSequence('win');
            }
        }, 2000);
    }
}
/**
 * å¤„ç†ç©å®¶å€’ä¸‹
 */
async function handlePlayerFainted(p) {
    if (typeof window.playSFX === 'function') window.playSFX('FAINT');
    const battle = window.battle;
    // å¦‚æœå¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œå…ˆæ¸…ç†æå·¨åŒ–è§†è§‰æ•ˆæœ
    if (p.isDynamaxed) {
        if (p.originalName) {
            p.name = p.originalName;
            delete p.originalName;
        }
        if (typeof window.endDynamaxAnimation === 'function') {
            await window.endDynamaxAnimation(p, true);
        }
        p.isDynamaxed = false;
        delete p.preDynamaxMaxHp;
        delete p.preDynamaxCurrHp;
        if (typeof window.applyDynamaxState === 'function') {
            window.applyDynamaxState(p, false);
        }
    }
    log(`<b style="color:red">ç³Ÿç³•! ${p.cnName} å¤±å»äº†æˆ˜æ–—èƒ½åŠ›!</b>`);
    await wait(500);
    if (typeof window.checkPlayerDefeatOrForceSwitch === 'function') {
        window.checkPlayerDefeatOrForceSwitch();
    }
}
// ============================================
// å…¥åœºç‰¹æ€§
// ============================================
/**
 * è§¦å‘å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰)
 */
function triggerEntryAbilities(pokemon, opponent) {
    const battle = window.battle;
    if (!pokemon || !opponent) return;
    if (typeof AbilityHandlers === 'undefined') return;
    const h = AbilityHandlers[pokemon.ability];
    if (h && h.onStart) {
        let logs = [];
        h.onStart(pokemon, opponent, logs, battle);
        logs.forEach(t => log(t));
        updateAllVisuals();
    }
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.hasAliveSwitch = hasAliveSwitch;
    window.handlePlayerPivot = handlePlayerPivot;
    window.handleEnemyPivot = handleEnemyPivot;
    window.handleEnemyFainted = handleEnemyFainted;
    window.handlePlayerFainted = handlePlayerFainted;
    window.triggerEntryAbilities = triggerEntryAbilities;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        hasAliveSwitch,
        handlePlayerPivot,
        handleEnemyPivot,
        handleEnemyFainted,
        handlePlayerFainted,
        triggerEntryAbilities
    };
}
]]></file>
        <file name="battle-turns.js"><![CDATA[/**
 * ===========================================
 * BATTLE-TURNS.JS - å›åˆæ‰§è¡Œ
 * ===========================================
 * 
 * èŒè´£:
 * - æ‰§è¡Œç©å®¶å›åˆ
 * - æ‰§è¡Œæ•Œæ–¹å›åˆ
 * - ç‹¬ç«‹æ•Œæ–¹å›åˆ (æ¢äººå)
 * - Z/Max æ‹›å¼ä½¿ç”¨æ ‡è®°
 */
// ============================================
// è¾…åŠ©å‡½æ•°
// ============================================
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// ç©å®¶å›åˆæ‰§è¡Œ
// ============================================
/**
 * æ‰§è¡Œç©å®¶å›åˆ
 * @param {Object} p ç©å®¶å®å¯æ¢¦
 * @param {Object} e æ•Œæ–¹å®å¯æ¢¦
 * @param {Object} move æ‹›å¼
 * @returns {Object} åŒ…å« pivot æ ‡è®°çš„ç»“æœ
 */
async function executePlayerTurn(p, e, move) {
    const battle = window.battle;
    // çŠ¶æ€é˜»æ–­æ£€æµ‹
    if (typeof window.checkCanMove === 'function') {
        const check = window.checkCanMove(p);
        if (check.msg) {
            log(`<span style="color:#e67e22">${check.msg}</span>`);
        }
        if (!check.can) {
            await wait(500);
            return { pivot: false };
        }
    }
    log(`[${p.cnName}] ä½¿ç”¨äº† <b>${move.cn}</b>!`);
    await wait(600);
    const result = applyDamage(p, e, move, 'enemy-sprite');
    // è®°å½•æœ¬å›åˆä½¿ç”¨çš„æŠ€èƒ½
    p.lastMoveUsed = move.name;
    // =========================================================
    // Z-Move / Max Move ä½¿ç”¨æ ‡è®° (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
    // =========================================================
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æµ‹å¹¶æ ‡è®° Z æ‹›å¼ä½¿ç”¨
    const isZMove = moveData.isZ || 
        (moveData.pp === 1 && moveData.basePower >= 100 && moveData.isNonstandard === 'Past') ||
        (move.name || '').length > 25;
    if (isZMove && !battle.playerZUsed) {
        battle.playerZUsed = true;
        console.log(`[Z-MOVE] ç©å®¶ä½¿ç”¨äº† Z æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<div style="padding:8px; border:2px solid gold; background:linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.9)); text-align:center; border-radius:8px; margin:5px 0;">`);
        log(`<b style="font-size:1.1rem; background: linear-gradient(90deg, #a855f7, #ec4899); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">âœ¨ Z-POWER UNLEASHED âœ¨</b>`);
        log(`<div style="color:#666; font-size:0.85em; margin-top:4px;">å…¨åŠ›çš„å§¿æ€... ZåŠ›é‡å·²é‡Šæ”¾ï¼</div>`);
        log(`</div>`);
        const stage = document.querySelector('.battle-stage');
        if (stage) {
            stage.classList.add('shake-hit-anim');
            setTimeout(() => stage.classList.remove('shake-hit-anim'), 500);
        }
    }
    // æ£€æµ‹å¹¶æ ‡è®°æå·¨æ‹›å¼ä½¿ç”¨
    const isMaxMove = moveData.isMax || 
        (move.name || '').startsWith('Max ') || (move.name || '').startsWith('G-Max ');
    if (isMaxMove && !battle.playerMaxUsed) {
        battle.playerMaxUsed = true;
        console.log(`[MAX MOVE] ç©å®¶ä½¿ç”¨äº†æå·¨æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<div style="padding:8px; border:2px solid #e11d48; background:linear-gradient(135deg, rgba(225,29,72,0.1), rgba(255,255,255,0.9)); text-align:center; border-radius:8px; margin:5px 0;">`);
        log(`<b style="font-size:1.1rem; color:#e11d48;">ğŸ’¥ MAX POWER ğŸ’¥</b>`);
        log(`<div style="color:#666; font-size:0.85em; margin-top:4px;">æå·¨ä¹‹åŠ›å€¾æ³»è€Œå‡ºï¼</div>`);
        log(`</div>`);
    }
    updateAllVisuals();
    // === æ£€æŸ¥å±æœº BGM åˆ‡æ¢ (é¦†ä¸»æˆ˜ä¸“ç”¨) ===
    if (typeof checkCrisisBgm === 'function') {
        checkCrisisBgm();
    }
    return { pivot: result?.pivot || false };
}
// ============================================
// æ•Œæ–¹å›åˆæ‰§è¡Œ
// ============================================
/**
 * æ‰§è¡Œæ•Œæ–¹å›åˆ
 * @param {Object} e æ•Œæ–¹å®å¯æ¢¦
 * @param {Object} p ç©å®¶å®å¯æ¢¦
 * @param {Object} move æ‹›å¼
 * @returns {Object} åŒ…å« pivot æ ‡è®°çš„ç»“æœ
 */
async function executeEnemyTurn(e, p, move) {
    const battle = window.battle;
    console.log('[executeEnemyTurn] Starting:', { 
        enemy: e?.cnName, 
        player: p?.cnName, 
        move: move?.name || move?.cn 
    });
    if (!e || !e.isAlive()) {
        console.log('[executeEnemyTurn] Enemy invalid or dead');
        return { pivot: false };
    }
    // å¦‚æœæ²¡æœ‰æ‹›å¼ï¼ˆæ•Œæ–¹æ¢äººåœºæ™¯ï¼‰ï¼Œè·³è¿‡æ”»å‡»
    if (!move) {
        console.log('[executeEnemyTurn] No move provided, skipping');
        return { pivot: false };
    }
    await wait(800);
    // çŠ¶æ€é˜»æ–­æ£€æµ‹
    if (typeof window.checkCanMove === 'function') {
        const check = window.checkCanMove(e);
        if (check.msg) {
            log(`<span style="color:#e67e22">${check.msg}</span>`);
        }
        if (!check.can) {
            return { pivot: false };
        }
    }
    const moveName = move.cn || move.name || 'Unknown';
    log(`[${e.cnName}] ä½¿å‡º <b>${moveName}</b>!`);
    await wait(500);
    const result = applyDamage(e, p, move, 'player-sprite');
    // è®°å½•æœ¬å›åˆä½¿ç”¨çš„æŠ€èƒ½
    e.lastMoveUsed = move.name;
    // =========================================================
    // Choice é“å…·é”æ‹›ï¼ˆè®²ç©¶å¤´å¸¦/çœ¼é•œ/å›´å·¾ï¼‰
    // =========================================================
    const eItem = e.item || '';
    const eIsChoiceItem = eItem.includes('Choice') || eItem.includes('è®²ç©¶');
    if (eIsChoiceItem && !e.choiceLockedMove) {
        e.choiceLockedMove = move.name;
        console.log(`[CHOICE] ${e.name} è¢« ${eItem} é”å®šåœ¨ ${move.name}`);
    }
    // =========================================================
    // Z-Move / Max Move ä½¿ç”¨æ ‡è®° (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
    // =========================================================
    const eMoveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const eMoveData = (typeof MOVES !== 'undefined' && MOVES[eMoveId]) ? MOVES[eMoveId] : {};
    // æ£€æµ‹å¹¶æ ‡è®° Z æ‹›å¼ä½¿ç”¨
    const eIsZMove = eMoveData.isZ || move.isZ ||
        (eMoveData.pp === 1 && eMoveData.basePower >= 100 && eMoveData.isNonstandard === 'Past');
    if (eIsZMove && !battle.enemyZUsed) {
        battle.enemyZUsed = true;
        console.log(`[Z-MOVE] æ•Œæ–¹ä½¿ç”¨äº† Z æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<b style="color:#fbbf24; text-shadow: 0 0 10px #fbbf24;">âœ¨ Z-POWER UNLEASHED âœ¨</b>`);
        log(`<span style="color:#fbbf24">${e.cnName} é‡Šæ”¾äº†å…¨éƒ¨çš„ Z åŠ›é‡ï¼</span>`);
    }
    // æ£€æµ‹å¹¶æ ‡è®°æå·¨æ‹›å¼ä½¿ç”¨
    const eIsMaxMove = eMoveData.isMax || 
        (move.name || '').startsWith('Max ') || (move.name || '').startsWith('G-Max ');
    if (eIsMaxMove && !battle.enemyMaxUsed) {
        battle.enemyMaxUsed = true;
        console.log(`[MAX MOVE] æ•Œæ–¹ä½¿ç”¨äº†æå·¨æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
    }
    updateAllVisuals();
    console.log('[executeEnemyTurn] Completed');
    return { pivot: result?.pivot || false };
}
// ============================================
// ç‹¬ç«‹æ•Œæ–¹å›åˆ
// ============================================
/**
 * ç‹¬ç«‹æ•Œæ–¹å›åˆ (ç”¨äºæ¢äººåæ•Œæ–¹æ”»å‡»)
 */
async function enemyTurn() {
    const battle = window.battle;
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!e || !e.isAlive()) {
        battle.locked = false;
        return;
    }
    // è·å–æ•Œæ–¹ AI å†³ç­–
    let move = null;
    let enemyAction = null;
    if (typeof window.getAiAction === 'function') {
        enemyAction = window.getAiAction(e, p, battle.aiDifficulty || 'normal', battle.enemyParty, {
            turnCount: battle.turnCount || 1
        });
    }
    // å¤„ç† AI æ¢äººå†³ç­–
    if (enemyAction && enemyAction.type === 'switch' && typeof enemyAction.index === 'number') {
        const switchTarget = battle.enemyParty[enemyAction.index];
        if (switchTarget && switchTarget.isAlive() && switchTarget !== e) {
            log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${e.cnName}ï¼</span>`);
            if (e.choiceLockedMove) {
                console.log(`[CHOICE] ${e.name} æ¢ä¸‹ï¼Œè§£é™¤ ${e.choiceLockedMove} é”å®š`);
                delete e.choiceLockedMove;
            }
            if (e.isDynamaxed && typeof window.applyDynamaxState === 'function') {
                console.log(`[SWITCH] Enemy ${e.name} was Dynamaxed, restoring moves`);
                window.applyDynamaxState(e, false);
            }
            if (typeof e.resetBoosts === 'function') {
                e.resetBoosts();
            }
            battle.enemyActive = enemyAction.index;
            const newE = battle.getEnemy();
            log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
            // æ£€æŸ¥è¿›åœºå˜å½¢
            if (typeof window.checkInitTransform === 'function' && newE.needsInitTransform) {
                const result = window.checkInitTransform(newE);
                if (result) {
                    log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                }
            }
            updateAllVisuals('enemy');
            if (typeof window.triggerEntryAbilities === 'function') {
                window.triggerEntryAbilities(newE, p);
            }
            // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
            if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
                const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
                hazardLogs.forEach(msg => log(msg));
                if (hazardLogs.length > 0) updateAllVisuals();
            }
            battle.locked = false;
            return;
        }
    }
    // æ™®é€šæ”»å‡»
    if (enemyAction && enemyAction.move) {
        move = enemyAction.move;
    }
    // å›é€€åˆ°æ—§ AI
    if (!move && typeof window.getAiMove === 'function') {
        move = window.getAiMove(e, p, battle.aiDifficulty || 'normal');
    }
    if (!move) {
        move = e.moves[Math.floor(Math.random() * e.moves.length)];
    }
    // æ‰§è¡Œæ•Œæ–¹å›åˆ
    await executeEnemyTurn(e, p, move);
    // æ£€æŸ¥ç©å®¶æ˜¯å¦å€’ä¸‹
    if (!p.isAlive()) {
        if (typeof window.handlePlayerFainted === 'function') {
            await window.handlePlayerFainted(p);
        }
        return;
    }
    battle.locked = false;
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.executePlayerTurn = executePlayerTurn;
    window.executeEnemyTurn = executeEnemyTurn;
    window.enemyTurn = enemyTurn;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        executePlayerTurn,
        executeEnemyTurn,
        enemyTurn
    };
}
]]></file>
    </directory>
    <directory name="data">
        <directory name="bgm"/>
        <directory name="sfx"/>
        <file name="move-constants.js"><![CDATA[/**
 * =============================================
 * MOVE CONSTANTS - æ‹›å¼ç¡¬ç¼–ç æ•°æ®
 * =============================================
 * 
 * æœ¬æ–‡ä»¶å­˜æ”¾æ‰€æœ‰æ‹›å¼ç›¸å…³çš„ç¡¬ç¼–ç æ•°æ®ï¼Œ
 * ä½œä¸º MOVES æ•°æ®åº“çš„è¡¥å……/åå¤‡ã€‚
 * 
 * battle-engine.js ä¸­çš„æ ¸å¿ƒé€»è¾‘ä¼šä¼˜å…ˆè¯»å– MOVES æ•°æ®ï¼Œ
 * å¦‚æœ MOVES ä¸­æ²¡æœ‰å¯¹åº”æ•°æ®ï¼Œåˆ™ä½¿ç”¨è¿™é‡Œçš„ç¡¬ç¼–ç ã€‚
 */
// ============================================
// 1. æ‹›å¼ä¼˜å…ˆçº§æ˜ å°„ (Priority Map)
// ============================================
// ç”¨äº getMovePriority() å‡½æ•°çš„åå¤‡æ•°æ®
const PRIORITY_MAP = {
    // +5
    'Helping Hand': 5,
    // +4 (å®ˆä½ç±»)
    'Protect': 4, 
    'Detect': 4, 
    'Endure': 4, 
    'Magic Coat': 4, 
    'Snatch': 4,
    'King\'s Shield': 4, 
    'Spiky Shield': 4, 
    'Baneful Bunker': 4, 
    'Obstruct': 4, 
    'Silk Trap': 4,
    // +3
    'Fake Out': 3, 
    'Quick Guard': 3, 
    'Wide Guard': 3, 
    'Crafty Shield': 3,
    // +2
    'Extreme Speed': 2, 
    'Feint': 2, 
    'First Impression': 2, 
    'Accelerock': 2,
    // +1 (å¸¸è§å…ˆåˆ¶æŠ€)
    'Aqua Jet': 1, 
    'Bullet Punch': 1, 
    'Ice Shard': 1, 
    'Mach Punch': 1,
    'Quick Attack': 1, 
    'Shadow Sneak': 1, 
    'Sucker Punch': 1, 
    'Vacuum Wave': 1,
    'Water Shuriken': 1, 
    'Jet Punch': 1, 
    'Grassy Glide': 1,
    // -1
    'Vital Throw': -1,
    // -3
    'Focus Punch': -3,
    // -4
    'Avalanche': -4, 
    'Revenge': -4,
    // -5
    'Counter': -5, 
    'Mirror Coat': -5,
    // -6
    'Circle Throw': -6, 
    'Dragon Tail': -6, 
    'Roar': -6, 
    'Whirlwind': -6,
    // -7
    'Trick Room': -7
};
// ============================================
// 2. åä¼¤æŠ€èƒ½æ˜ å°„ (Recoil Moves)
// ============================================
// æ ¼å¼: { æ‹›å¼å: [åˆ†å­, åˆ†æ¯] } è¡¨ç¤ºåä¼¤ = ä¼¤å®³ * åˆ†å­/åˆ†æ¯
const RECOIL_MOVES = {
    'Brave Bird': [1, 3],
    'Double-Edge': [1, 3],
    'Flare Blitz': [1, 3],
    'Head Smash': [1, 2],
    'Wood Hammer': [1, 3],
    'Take Down': [1, 4],
    'Wild Charge': [1, 4],
    'Volt Tackle': [1, 3],
    'Submission': [1, 4],
    'Wave Crash': [1, 3],
    'Light of Ruin': [1, 2],
    'Head Charge': [1, 4]
};
// ============================================
// 3. å¸è¡€æŠ€èƒ½æ˜ å°„ (Drain Moves)
// ============================================
// æ ¼å¼: { æ‹›å¼å: [åˆ†å­, åˆ†æ¯] } è¡¨ç¤ºå›å¤ = ä¼¤å®³ * åˆ†å­/åˆ†æ¯
const DRAIN_MOVES = {
    'Giga Drain': [1, 2],
    'Drain Punch': [1, 2],
    'Horn Leech': [1, 2],
    'Absorb': [1, 2],
    'Mega Drain': [1, 2],
    'Leech Life': [1, 2],
    'Draining Kiss': [3, 4],
    'Oblivion Wing': [3, 4],
    'Parabolic Charge': [1, 2],
    'Dream Eater': [1, 2],
    'Bitter Blade': [1, 2],
    'Bouncy Bubble': [1, 2]
};
// ============================================
// 4. æŸç¼šç±»æŠ€èƒ½ (Trapping Moves)
// ============================================
// è¿™äº›æŠ€èƒ½ä¼šè®©ç›®æ ‡è¿›å…¥ partiallytrapped çŠ¶æ€
const TRAPPING_MOVES = [
    'Fire Spin',
    'Whirlpool',
    'Bind',
    'Wrap',
    'Sand Tomb',
    'Magma Storm',
    'Infestation',
    'Clamp',
    'Snap Trap',
    'Thunder Cage'
];
// ============================================
// 5. å¿…å®šæš´å‡»æŠ€èƒ½ (Always Crit Moves)
// ============================================
const ALWAYS_CRIT_MOVES = [
    'Surging Strikes',
    'Wicked Blow',
    'Frost Breath',
    'Storm Throw',
    'Zippy Zap',
    'Flower Trick'
];
// ============================================
// 6. AI è¯„åˆ†ç”¨ - å¼ºåŒ–æŠ€èƒ½åˆ—è¡¨ (Boost Moves)
// ============================================
const AI_BOOST_MOVES = [
    'Swords Dance',
    'Calm Mind',
    'Dragon Dance',
    'Nasty Plot',
    'Quiver Dance',
    'Shell Smash',
    'Bulk Up',
    'Hone Claws',
    'Work Up',
    'Agility',
    'Rock Polish',
    'Autotomize',
    'Coil',
    'Shift Gear',
    'Cotton Guard',
    'Iron Defense',
    'Amnesia',
    'Acid Armor',
    'Barrier',
    'Cosmic Power',
    'Defend Order',
    'Stockpile'
];
// ============================================
// 7. AI è¯„åˆ†ç”¨ - çŠ¶æ€æŠ€èƒ½åˆ—è¡¨ (Status Inflict Moves)
// ============================================
const AI_STATUS_MOVES = [
    'Thunder Wave',
    'Will-O-Wisp',
    'Toxic',
    'Spore',
    'Sleep Powder',
    'Hypnosis',
    'Sing',
    'Stun Spore',
    'Glare',
    'Nuzzle',
    'Lovely Kiss',
    'Dark Void',
    'Grass Whistle',
    'Yawn'
];
// ============================================
// 8. AI è¯„åˆ†ç”¨ - ç¡çœ æŠ€èƒ½åˆ—è¡¨ (Sleep Moves)
// ============================================
const AI_SLEEP_MOVES = [
    'Spore',
    'Sleep Powder',
    'Hypnosis',
    'Sing',
    'Lovely Kiss',
    'Dark Void',
    'Grass Whistle'
];
// ============================================
// 9. AI è¯„åˆ†ç”¨ - éº»ç—¹æŠ€èƒ½åˆ—è¡¨ (Paralyze Moves)
// ============================================
const AI_PARALYZE_MOVES = [
    'Thunder Wave',
    'Glare',
    'Stun Spore',
    'Nuzzle'
];
// ============================================
// 10. AI è¯„åˆ†ç”¨ - å›å¤æŠ€èƒ½åˆ—è¡¨ (Heal Moves)
// ============================================
const AI_HEAL_MOVES = [
    'Recover',
    'Roost',
    'Soft-Boiled',
    'Slack Off',
    'Moonlight',
    'Morning Sun',
    'Synthesis',
    'Wish',
    'Rest',
    'Milk Drink',
    'Shore Up',
    'Strength Sap',
    'Jungle Healing',
    'Life Dew'
];
// ============================================
// 11. AI è¯„åˆ†ç”¨ - å®ˆä½æŠ€èƒ½åˆ—è¡¨ (Protect Moves)
// ============================================
const AI_PROTECT_MOVES = [
    'Protect',
    'Detect',
    'King\'s Shield',
    'Spiky Shield',
    'Baneful Bunker',
    'Obstruct',
    'Silk Trap',
    'Max Guard'
];
// ============================================
// 12. å®å¯æ¢¦å½¢æ€åç¼€ (Form Suffixes)
// ============================================
// ç”¨äº extractBaseFormId() å‡½æ•°
const FORM_SUFFIXES = [
    'starter',      // æ­æ¡£å½¢æ€ (Let's Go)
    'gmax',         // æå·¨åŒ–
    'megax', 'megay', 'mega',  // Megaè¿›åŒ–
    'alola', 'galar', 'hisui', 'paldea',  // åœ°åŒºå½¢æ€
    'therian', 'incarnate',  // çµå…½/åŒ–èº«
    'origin', 'altered',     // èµ·æº/å¦ä¸€å½¢æ€
    'crowned', 'hero',       // ç‹å† /è‹±é›„
    'eternamax',    // æ— æå·¨åŒ–
    'primal',       // åŸå§‹å›å½’
    'ultra',        // ç©¶æ
    'ash',          // å°æ™ºç‰ˆ
    'totem',        // éœ¸ä¸»
    'cosplay', 'phd', 'libre', 'popstar', 'rockstar', 'belle', // çš®å¡ä¸˜æ¢è£…
    'original', 'hoenn', 'sinnoh', 'unova', 'kalos', 'partner', 'world'  // å¸½å­çš®å¡ä¸˜
];
// ============================================
// 13. é»˜è®¤åå¤‡æ‹›å¼ (Fallback Moves)
// ============================================
const FALLBACK_MOVES = [
    'Tackle',
    'Quick Attack',
    'Ember',
    'Water Gun',
    'Vine Whip'
];
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€ (Export to Window)
// ============================================
if (typeof window !== 'undefined') {
    window.MOVE_CONSTANTS = {
        PRIORITY_MAP,
        RECOIL_MOVES,
        DRAIN_MOVES,
        TRAPPING_MOVES,
        ALWAYS_CRIT_MOVES,
        AI_BOOST_MOVES,
        AI_STATUS_MOVES,
        AI_SLEEP_MOVES,
        AI_PARALYZE_MOVES,
        AI_HEAL_MOVES,
        AI_PROTECT_MOVES,
        FORM_SUFFIXES,
        FALLBACK_MOVES
    };
    // ä¹Ÿå•ç‹¬å¯¼å‡ºå¸¸ç”¨çš„
    window.PRIORITY_MAP = PRIORITY_MAP;
    window.RECOIL_MOVES = RECOIL_MOVES;
    window.DRAIN_MOVES = DRAIN_MOVES;
    window.TRAPPING_MOVES = TRAPPING_MOVES;
    window.ALWAYS_CRIT_MOVES = ALWAYS_CRIT_MOVES;
    window.FORM_SUFFIXES = FORM_SUFFIXES;
}
]]></file>
        <file name="moves-data.js"><![CDATA[/**
 * Pokemon Showdown Moves Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/moves.ts
 * 
 * æ³¨æ„: å‡½æ•°å›è°ƒã€condition å—å·²è¢«ç§»é™¤ï¼Œä»…ä¿ç•™é™æ€æ•°æ®
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="moves-data.js"></script>
 *   console.log(MOVES.thunderbolt.basePower); // 90
 */
const MOVES = {
	"10000000voltthunderbolt": {
		num: 719,
		accuracy: true,
		basePower: 195,
		category: "Special",
		isNonstandard: "Past",
		name: "10,000,000 Volt Thunderbolt",
		pp: 1,
		priority: 0,
		flags: {},
		isZ: "pikashuniumz",
		critRatio: 3,
		secondary: null,
		target: "normal",
		type: "Electric",
		contestType: "Cool",
	},
	absorb: {
		num: 71,
		accuracy: 100,
		basePower: 20,
		category: "Special",
		name: "Absorb",
		pp: 25,
		priority: 0,
		flags: { protect: 1, mirror: 1, heal: 1, metronome: 1 },
		drain: [1, 2],
		secondary: null,
		target: "normal",
		type: "Grass",
		contestType: "Clever",
	},
	accelerock: {
		num: 709,
		accuracy: 100,
		basePower: 40,
		category: "Physical",
		name: "Accelerock",
		pp: 20,
		priority: 1,
		flags: { contact: 1, protect: 1, mirror: 1, metronome: 1 },
		secondary: null,
		target: "normal",
		type: "Rock",
		contestType: "Cool",
	},
	acid: {
		num: 51,
		accuracy: 100,
		basePower: 40,
		category: "Special",
		name: "Acid",
		pp: 30,
		priority: 0,
		flags: { protect: 1, mirror: 1, metronome: 1 },
		secondary: {
			chance: 10,
			boosts: {
				spd: -1,
			},
		},
		target: "allAdjacentFoes",
		type: "Poison",
		contestType: "Clever",
	},
	acidarmor: {
		num: 151,
		accuracy: true,
		basePower: 0,
		category: "Status",
		name: "Acid Armor",
		pp: 20,
		priority: 0,
		flags: { snatch: 1, metronome: 1 },
		boosts: {
			def: 2,
		},
		secondary: null,
		target: "self",
		type: "Poison",
		zMove: { effect: 'clearnegativeboost' },
		contestType: "Tough",
	},
	aciddownpour: {
		num: 628,
[... truncated: only first 100 lines included ...]
]]></file>
        <file name="pokedex-data.js"><![CDATA[/**
 * Pokemon Showdown Pokedex Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/pokedex.ts
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="pokedex-data.js"></script>
 *   console.log(POKEDEX.pikachu.baseStats);
 */
const POKEDEX = {
	bulbasaur: {
		num: 1,
		name: "Bulbasaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 45, atk: 49, def: 49, spa: 65, spd: 65, spe: 45 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 0.7,
		weightkg: 6.9,
		color: "Green",
		evos: ["Ivysaur"],
		eggGroups: ["Monster", "Grass"],
	},
	ivysaur: {
		num: 2,
		name: "Ivysaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 60, atk: 62, def: 63, spa: 80, spd: 80, spe: 60 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 1,
		weightkg: 13,
		color: "Green",
		prevo: "Bulbasaur",
		evoLevel: 16,
		evos: ["Venusaur"],
		eggGroups: ["Monster", "Grass"],
	},
	venusaur: {
		num: 3,
		name: "Venusaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 82, def: 83, spa: 100, spd: 100, spe: 80 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 2,
		weightkg: 100,
		color: "Green",
		prevo: "Ivysaur",
		evoLevel: 32,
		eggGroups: ["Monster", "Grass"],
		otherFormes: ["Venusaur-Mega"],
		formeOrder: ["Venusaur", "Venusaur-Mega"],
		canGigantamax: "G-Max Vine Lash",
	},
	venusaurmega: {
		num: 3,
		name: "Venusaur-Mega",
		baseSpecies: "Venusaur",
		forme: "Mega",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 100, def: 123, spa: 122, spd: 120, spe: 80 },
		abilities: { 0: "Thick Fat" },
		heightm: 2.4,
		weightkg: 155.5,
		color: "Green",
		eggGroups: ["Monster", "Grass"],
		requiredItem: "Venusaurite",
	},
	venusaurgmax: {
		num: 3,
		name: "Venusaur-Gmax",
		baseSpecies: "Venusaur",
		forme: "Gmax",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 82, def: 83, spa: 100, spd: 100, spe: 80 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 24,
		weightkg: 0,
		color: "Green",
		eggGroups: ["Monster", "Grass"],
		changesFrom: "Venusaur",
	},
	charmander: {
		num: 4,
		name: "Charmander",
		types: ["Fire"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 39, atk: 52, def: 43, spa: 60, spd: 50, spe: 65 },
		abilities: { 0: "Blaze", H: "Solar Power" },
		heightm: 0.6,
		weightkg: 8.5,
		color: "Red",
		evos: ["Charmeleon"],
		eggGroups: ["Monster", "Dragon"],
	},
	charmeleon: {
[... truncated: only first 100 lines included ...]
]]></file>
        <file name="trainer-avs.js"><![CDATA[/**
 * =============================================
 * TRAINER AVs PROFILES - è®­ç»ƒå®¶æƒ…æ„ŸåŠªåŠ›å€¼é…ç½®
 * =============================================
 * 
 * æ´›è¿ªäºšç‰¹åŒº (Rhodia Region) ä¸“å±ç³»ç»Ÿ
 * å—ç¥é¦”ç²‰é›¾ (Ambrosia) å½±å“ï¼Œæ¯ä½è®­ç»ƒå®¶éƒ½æœ‰ç‹¬ç‰¹çš„ AVs å€¾å‘
 * 
 * å››å¤§ç»´åº¦ï¼š
 * - Trust (ä¿¡èµ–): é˜²å®ˆå‘ï¼Œè‡´å‘½ä¼¤å®³æ—¶é”è¡€
 * - Passion (æ¿€æƒ…): è¿›æ”»å‘ï¼Œæš´å‡»ç‡æå‡
 * - Insight (çµçŠ€): å›é¿å‘ï¼Œé—ªé¿ç‡æå‡
 * - Devotion (çŒ®èº«): å›å¤å‘ï¼Œå›åˆæœ«æ²»æ„ˆå¼‚å¸¸
 */
const TRAINER_AVS_PROFILES = {
    // =====================================================
    // éœ“è™¹å•†ä¸šåŒº (Neon District) - ç”µ/æ¯’
    // é¦†ä¸»: Iono & Roxie
    // ä¸“ç²¾: Passion (æ¿€æƒ…)
    // =====================================================
    'iono': {
        name: 'Iono',
        cnName: 'å¥‡æ ‘',
        district: 'Neon',
        specialty: 'Passion',
        description: 'ç›´æ’­å¥³ç‹çš„æˆ˜æ–—é£æ ¼å¦‚åŒå¥¹çš„èŠ‚ç›®ä¸€æ ·çƒ­çƒˆåˆºæ¿€',
        aura: {
            name: 'Adrenaline Rush',
            effect: 'å…¨é˜Ÿæš´å‡»ç‡æå‡ï¼Œå‡»æ€åé€Ÿåº¦+1'
        },
        defaultAVs: {
            trust: 80,
            passion: 220,    // ä¸“ç²¾
            insight: 120,
            devotion: 60
        }
    },
    'roxie': {
        name: 'Roxie',
        cnName: 'éœç±³åŠ ',
        district: 'Neon',
        specialty: 'Passion',
        description: 'æ‘‡æ»šå¥³å­©çš„æ¯’ç³»æ”»åŠ¿å¦‚åŒå¥¹çš„éŸ³ä¹ä¸€æ ·ç‹‚æš´',
        aura: {
            name: 'Toxic Rush',
            effect: 'æ¯’ç³»æ‹›å¼æš´å‡»ç‡é¢å¤–+1'
        },
        defaultAVs: {
            trust: 60,
            passion: 200,    // ä¸“ç²¾
            insight: 100,
            devotion: 80
        }
    },
    // =====================================================
    // ç¹èŠ±æµ·æ»¨åŒº (Bloom District) - è‰/æ°´
    // é¦†ä¸»: Erika & Nessa
    // ä¸“ç²¾: Devotion (çŒ®èº«)
    // =====================================================
    'erika': {
        name: 'Erika',
        cnName: 'è‰ä½³',
        district: 'Bloom',
        specialty: 'Devotion',
        description: 'ä¼˜é›…çš„èŠ±é“å¤§å¸ˆï¼Œå¥¹çš„å®å¯æ¢¦å¦‚åŒèŠ±æœµèˆ¬åšéŸ§',
        aura: {
            name: 'Floral Blessing',
            effect: 'å›å¤æŠ€èƒ½æ•ˆæœ+20%ï¼Œå¼‚å¸¸çŠ¶æ€æŠ—æ€§æå‡'
        },
        defaultAVs: {
            trust: 120,
            passion: 60,
            insight: 80,
            devotion: 220    // ä¸“ç²¾
        }
    },
    'nessa': {
        name: 'Nessa',
        cnName: 'éœ²ç’ƒå¨œ',
        district: 'Bloom',
        specialty: 'Devotion',
        description: 'è¶…æ¨¡å…¼é¦†ä¸»ï¼Œå¥¹çš„æ°´ç³»å®å¯æ¢¦æ‹¥æœ‰æƒŠäººçš„æ¢å¤åŠ›',
        aura: {
            name: 'Tidal Recovery',
            effect: 'æ°´ç³»å®å¯æ¢¦æ¯å›åˆæ¢å¤å°‘é‡HP'
        },
        defaultAVs: {
            trust: 100,
            passion: 80,
            insight: 100,
            devotion: 200    // ä¸“ç²¾
        }
    },
    // =====================================================
    // æš—å½±æ—§è¡—åŒº (Shadow District) - æ¶/å¹½çµ
    // é¦†ä¸»: Marnie & Hex Maniac
    // ä¸“ç²¾: Insight (çµçŠ€)
    // =====================================================
    'marnie': {
        name: 'Marnie',
        cnName: 'ç›ä¿',
        district: 'Shadow',
        specialty: 'Insight',
        description: 'å†·é™çš„æš—ç³»ä½¿è€…ï¼Œæ€»èƒ½é¢„åˆ¤å¯¹æ‰‹çš„è¡ŒåŠ¨',
        aura: {
            name: 'Dark Foresight',
            effect: 'AIé¢„è¯»å‡†ç¡®ç‡æå‡ï¼Œæ›´å®¹æ˜“ä½¿ç”¨æ­£ç¡®çš„ä¿æŠ¤/æ¢äºº'
        },
        defaultAVs: {
            trust: 100,
            passion: 100,
            insight: 220,    // ä¸“ç²¾
            devotion: 80
        }
    },
    'hexmaniac': {
        name: 'Hex Maniac',
        cnName: 'çµå¼‚è¿·',
        district: 'Shadow',
        specialty: 'Insight',
        description: 'ç¥ç§˜çš„çµåª’ï¼Œå¥¹çš„å¹½çµç³»å®å¯æ¢¦å¦‚åŒå¹»å½±èˆ¬éš¾ä»¥æ•æ‰',
        aura: {
            name: 'Phantom Sense',
            effect: 'å¹½çµç³»å®å¯æ¢¦é—ªé¿ç‡é¢å¤–æå‡'
        },
        defaultAVs: {
            trust: 60,
            passion: 80,
            insight: 200,    // ä¸“ç²¾
            devotion: 100
        }
    },
    // =====================================================
    // æè¯£ç«æŠ€åŒº (Apex District) - æ ¼æ–—/å…¨èƒ½
    // é¦†ä¸»: Bea & Cynthia
    // ä¸“ç²¾: å…¨ç»´åº¦ (Total Trust)
    // =====================================================
    'bea': {
        name: 'Bea',
        cnName: 'å½©è±†',
        district: 'Apex',
        specialty: 'Balanced',
        description: 'ç©ºæ‰‹é“å¤§å¸ˆï¼Œè¿½æ±‚æè‡´çš„æˆ˜æ–—è‰ºæœ¯',
        aura: {
            name: 'Fighting Spirit',
            effect: 'æ ¼æ–—ç³»å®å¯æ¢¦æ‹¥æœ‰ Second Windï¼ˆé¦–æ¬¡æ¿’æ­»æ—¶é”è¡€+å…¨å±æ€§+1ï¼‰'
        },
        defaultAVs: {
            trust: 180,
            passion: 180,
            insight: 160,
            devotion: 160
        },
        // ç‰¹æ®Šæœºåˆ¶ï¼šSecond Wind
        secondWind: true
    },
    'cynthia': {
        name: 'Cynthia',
        cnName: 'ç«¹å…°',
        district: 'Apex',
        specialty: 'Total',
        description: 'ç¥å¥¥å† å†›ï¼Œä¼ è¯´ä¸­çš„æœ€å¼ºè®­ç»ƒå®¶',
        aura: {
            name: 'Champion\'s Resolve',
            effect: 'ç‹ç‰Œå®å¯æ¢¦æ‹¥æœ‰ Second Windï¼ˆé¦–æ¬¡æ¿’æ­»æ—¶é”è¡€+å…¨å±æ€§+1ï¼‰'
        },
        defaultAVs: {
            trust: 200,
            passion: 200,
            insight: 200,
            devotion: 200
        },
        // ç‰¹æ®Šæœºåˆ¶ï¼šSecond Wind (ä»…é™ç‹ç‰Œ)
        secondWind: true,
        aceOnly: true
    },
    // =====================================================
    // ç®¡ç†ä¸ç§‘ç ”äººå‘˜
    // =====================================================
    'lusamine': {
        name: 'Lusamine',
        cnName: 'éœ²èç±³å¥ˆ',
        role: 'Executive Director',
        description: 'ä»¥å¤ªåŸºé‡‘ä¼šæ‰§è¡Œè‘£äº‹ï¼Œå¯¹å®å¯æ¢¦æœ‰ç€æ‰­æ›²çš„çˆ±',
        defaultAVs: {
            trust: 60,
            passion: 120,
            insight: 160,
            devotion: 240    // æç«¯çš„çŒ®èº«
        }
    },
    'sonia': {
        name: 'Sonia',
        cnName: 'ç´¢å¦®äºš',
        role: 'Chief Researcher',
        description: 'é¦–å¸­åšå£«ï¼Œè´Ÿè´£å¾¡ä¸‰å®¶é€‰æ‹©å’ŒåˆæœŸå¼•å¯¼',
        defaultAVs: {
            trust: 140,
            passion: 80,
            insight: 180,
            devotion: 100
        }
    },
    // =====================================================
    // ç‰¹é‚€ä»£è¡¨
    // =====================================================
    'gloria': {
        name: 'Gloria',
        cnName: 'ä¼˜è‰',
        role: 'Camping Expert',
        description: 'éœ²è¥æŠ€æœ¯ä¸å’–å–±æ–™ç†æ¨å¹¿å¤§ä½¿',
        defaultAVs: {
            trust: 160,
            passion: 120,
            insight: 100,
            devotion: 140
        }
    },
    'rosa': {
        name: 'Rosa',
        cnName: 'æ¢…ä¾',
        role: 'Idol Trainer',
        description: 'å¶åƒè‰ºäººä¸ç»ƒä¹ ç”Ÿå¯¼å¸ˆ',
        defaultAVs: {
            trust: 200,
            passion: 100,
            insight: 80,
            devotion: 180
        }
    },
    'dawn': {
        name: 'Dawn',
        cnName: 'å°å…‰',
        role: 'Contest Judge',
        description: 'åä¸½å¤§èµ›å¸¸é©»è¯„å§”',
        defaultAVs: {
            trust: 140,
            passion: 140,
            insight: 140,
            devotion: 140
        }
    },
    'serena': {
        name: 'Serena',
        cnName: 'ç‘Ÿè•¾å¨œ',
        role: 'Media Queen',
        description: 'çŸ­è§†é¢‘ä¸æ–°åª’ä½“å¥³ç‹',
        defaultAVs: {
            trust: 120,
            passion: 160,
            insight: 120,
            devotion: 120
        }
    },
    // =====================================================
    // æ´—ç¿ æ—¶ç©ºéš¾æ°‘
    // =====================================================
    'irida': {
        name: 'Irida',
        cnName: 'ä¼Šè•¾è¾¾',
        role: 'Pearl Clan Leader',
        description: 'çç å›¢é¦–é¢†ï¼Œä¸å®å¯æ¢¦æœ‰ç€åŸå§‹çš„é»˜å¥‘',
        defaultAVs: {
            trust: 180,
            passion: 80,
            insight: 200,
            devotion: 120
        }
    },
    'akari': {
        name: 'Akari',
        cnName: 'å°ç…§',
        role: 'Refugee Coordinator',
        description: 'æ—¶ç©ºéš¾æ°‘æ¥å¾…å¤„ä¸»ä»»',
        defaultAVs: {
            trust: 160,
            passion: 100,
            insight: 160,
            devotion: 140
        }
    }
};
/**
 * è·å–è®­ç»ƒå®¶çš„ AVs é…ç½®
 * @param {string} trainerId - è®­ç»ƒå®¶ID
 * @returns {object|null} AVs é…ç½®å¯¹è±¡
 */
function getTrainerAVsProfile(trainerId) {
    if (!trainerId) return null;
    const id = trainerId.toLowerCase().replace(/[^a-z0-9]/g, '');
    return TRAINER_AVS_PROFILES[id] || null;
}
/**
 * ä¸ºå®å¯æ¢¦åº”ç”¨è®­ç»ƒå®¶çš„ AVs é…ç½®
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {string} trainerId - è®­ç»ƒå®¶ID
 * @param {boolean} isAce - æ˜¯å¦ä¸ºç‹ç‰Œå®å¯æ¢¦
 */
function applyTrainerAVs(pokemon, trainerId, isAce = false) {
    const profile = getTrainerAVsProfile(trainerId);
    if (!profile || !pokemon) return;
    // åº”ç”¨é»˜è®¤ AVs
    if (profile.defaultAVs) {
        pokemon.avs = { ...profile.defaultAVs };
    }
    // Second Wind ç‰¹æ®Šæœºåˆ¶ï¼ˆä»…é™ Apex åŒºé¦†ä¸»ï¼‰
    if (profile.secondWind) {
        if (!profile.aceOnly || isAce) {
            pokemon.hasSecondWind = true;
        }
    }
}
// å¯¼å‡º
if (typeof window !== 'undefined') {
    window.TRAINER_AVS_PROFILES = TRAINER_AVS_PROFILES;
    window.getTrainerAVsProfile = getTrainerAVsProfile;
    window.applyTrainerAVs = applyTrainerAVs;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        TRAINER_AVS_PROFILES,
        getTrainerAVsProfile,
        applyTrainerAVs
    };
}
]]></file>
        <file name="trainer-data.js"><![CDATA[/* 
 * è§’è‰²: å°ä¼˜ (Gloria)
 * èº«ä»½: ä¼½å‹’å°”å† å†› / å’–å–±å¤§å¸ˆ
 */
const GLORIA_DATA = {
    // ã€Tier 4 - æå·¨åŒ–å…¨å¼€Â·å† å†›æ¨¡å¼ã€‘
    // ç»“æ„ï¼šåŒ…å« unlocks é…ç½® + party é˜Ÿä¼æ•°ç»„
    4: {
        // ==============================================================
        // [Tier Specific Unlocks] è¯¥éš¾åº¦ä¸‹çš„è§„åˆ™æƒé™
        // ä½çº§Tier (å¦‚ 1 æˆ– 2) å¯ä»¥å…¨è®¾ä¸º false æˆ–å¼€å¯ç‰¹å®šå‰Šå¼±ç‰ˆæœºåˆ¶
        // ==============================================================
        "unlocks": {
            "enable_bond": false,        // 1. æ—  ç¾ç»Š
            "enable_styles": false,      // 2. æ—  åˆšçŒ›/è¿…ç–¾
            "enable_insight": false,     // 3. æ—  å¿ƒçœ¼ (æ—  Limit Break)
            "enable_mega": false,        // 4. æ—  Mega
            "enable_z_move": false,      // 5. æ—  Zæ‹›å¼
            "enable_dynamax": true,      // 6. âœ… æœ¬å±‚çº§å¼€å¯æå·¨åŒ–æƒé™
            "enable_tera": false         // 7. æ—  å¤ªæ™¶åŒ–
        },
        // ==============================================================
        // [Party Data] å®å¯æ¢¦é˜Ÿä¼
        // ==============================================================
        "party": [
            {
                "name": "Zacian-Crowned", 
                "lv": 99, 
                "gender": "N",
                "nature": "Adamant", 
                "ability": "Intrepid Sword", 
                "item": "Rusted Sword", 
                "stats_meta": {
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": ["Behemoth Blade", "Play Rough", "Close Combat", "Swords Dance"],
                "isAce": true, 
                "friendship": { "trust": 255, "passion": 180, "insight": 120, "devotion": 100 }
            },
            {
                "name": "Cinderace", 
                "lv": 95, 
                "gender": "M",
                "nature": "Jolly", 
                "ability": "Libero",
                "item": "Life Orb", 
                "mechanic": "dynamax",
                "stats_meta": {
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": ["Pyro Ball", "Bounce", "High Jump Kick", "Sucker Punch"] 
            },
            {
                "name": "Rillaboom", 
                "lv": 91,
                "gender": "M",
                "nature": "Adamant",
                "ability": "Grassy Surge", 
                "item": "Grassy Seed", 
                "mechanic": "dynamax",
                "stats_meta": {
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": ["Grassy Glide", "Drum Beating", "Horsepower", "U-turn"]
            },
            {
                "name": "Urshifu-Rapid-Strike", 
                "lv": 90,
                "gender": "M",
                "nature": "Jolly",
                "ability": "Unseen Fist", 
                "item": "Choice Band", 
                "stats_meta": {
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": ["Surging Strikes", "Close Combat", "Aqua Jet", "U-turn"]
            },
            {
                "name": "Corviknight", 
                "lv": 88,
                "gender": "M",
                "nature": "Impish",
                "ability": "Mirror Armor", 
                "item": "Leftovers", 
                "stats_meta": {
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": ["Brave Bird", "Body Press", "Roost", "Iron Defense"]
            },
            {
                "name": "Skwovet", 
                "lv": 100, 
                "gender": "F",
                "nature": "Relaxed",
[... truncated: only first 100 lines included ...]
]]></file>
    </directory>
    <directory name="engine">
        <file name="ability-handlers.js"><![CDATA[/**
 * =============================================
 * ABILITY HANDLERS - ç‰¹æ€§å¤„ç†å™¨
 * =============================================
 * 
 * ä»…æ”¶å½• Top 25 + å¸¸è§ RP ç‰¹æ€§ã€‚
 * ä½¿ç”¨ Hook ç³»ç»Ÿæ³¨å…¥åˆ° battle-engine.js çš„å„ä¸ªç¯èŠ‚ã€‚
 */
// ç®€å•çš„è¾…åŠ©å·¥å…·
function isPinching(poke) {
    return poke.currHp > 0 && poke.currHp <= poke.maxHp / 3;
}
const AbilityHandlers = {
    // ============================================
    // A. æš´åŠ›æ•°å€¼ä¿®æ­£
    // ============================================
    // ã€å¤§åŠ›å£«/ç‘œä¼½ä¹‹åŠ›ã€‘ç‰©æ”»ç¿»å€
    'Huge Power': { onModifyStat: (stats) => stats.atk *= 2 },
    'Pure Power': { onModifyStat: (stats) => stats.atk *= 2 },
    // ã€æŠ€æœ¯é«˜æ‰‹ã€‘ä½å¨åŠ›(<=60)æ‹›å¼ x1.5
    'Technician': {
        onBasePower: (power, attacker, defender, move) => {
            if (power <= 60) return power * 1.5;
            return power;
        }
    },
    // ã€é€‚åº”åŠ›ã€‘æœ¬ç³»åŠ æˆä» 1.5 -> 2.0
    'Adaptability': {
        // è¿™ä¸€æ¡æ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬é€šè¿‡ä¿®æ”¹ stab å€ç‡å®ç°ï¼Œéœ€åœ¨ calcDamage é‡Œç‰¹åˆ«åˆ¤æ–­
        onModifySTAB: (stab) => 2
    },
    // ã€æœ‰è‰²çœ¼é•œã€‘æ•ˆæœä¸å¥½(X0.5)æ—¶å˜ä¸ºæ­£å¸¸(X1)
    'Tinted Lens': {
        onModifyEffectiveness: (eff) => {
            if (eff < 1 && eff > 0) return eff * 2;
            return eff;
        }
    },
    // ============================================
    // B. å¾¡ä¸‰å®¶ä¸“å± - ç»å¢ƒçˆ†å‘ (çº¢è¡€å˜èº«)
    // ============================================
    'Blaze': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Fire' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Torrent': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Water' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Overgrow': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Grass' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Swarm': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Bug' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    // ============================================
    // C. ç‰¹æ®Šé˜²å¾¡/å¼€çœ¼
    // ============================================
    // ã€æ¼‚æµ®ã€‘å…ç–«åœ°é¢
    'Levitate': {
        onImmunity: (atkType) => atkType === 'Ground'
    },
    // ã€å¼•ç«ã€‘å…ç–«ç«ç³»
    'Flash Fire': {
        onImmunity: (atkType) => atkType === 'Fire'
    },
    // ã€å‚¨æ°´ã€‘å…ç–«æ°´ç³»
    'Water Absorb': {
        onImmunity: (atkType) => atkType === 'Water'
    },
    // ã€é¿é›·é’ˆã€‘å…ç–«ç”µç³»
    'Lightning Rod': {
        onImmunity: (atkType) => atkType === 'Electric'
    },
    // ã€è“„ç”µã€‘å…ç–«ç”µç³»
    'Volt Absorb': {
        onImmunity: (atkType) => atkType === 'Electric'
    },
    // ã€ç”µæ°”å¼•æ“ã€‘å…ç–«ç”µç³»
    'Motor Drive': {
        onImmunity: (atkType) => atkType === 'Electric'
    },
    // ã€é£Ÿè‰ã€‘å…ç–«è‰ç³»
    'Sap Sipper': {
        onImmunity: (atkType) => atkType === 'Grass'
    },
    // ã€å¹²ç‡¥çš®è‚¤ã€‘å…ç–«æ°´ç³»
    'Dry Skin': {
        onImmunity: (atkType) => atkType === 'Water'
    },
    // ã€ç¥å¥‡é³ç‰‡ã€‘å¼‚å¸¸çŠ¶æ€æ—¶é˜²å¾¡ x1.5 (æ­¤å¤„ç®€åŒ–ä¸ºç‰©é˜²)
    'Marvel Scale': {
        onModifyStat: (stats, poke) => { 
            if (poke.status) stats.def = Math.floor(stats.def * 1.5); 
        }
    },
    // ã€åšç¡¬/ç»“å®ã€‘æ»¡è¡€æ—¶è‡³å°‘ä¿ç•™1è¡€
    'Sturdy': {
        onDamageHack: (damage, defender) => {
            if (defender.currHp === defender.maxHp && damage >= defender.currHp) {
                return defender.currHp - 1; // é”è¡€1
            }
            return damage;
        }
    },
    // ã€ç¥å¥‡å®ˆæŠ¤ã€‘é¬¼è‰ï¼šåªèƒ½è¢«å…‹åˆ¶æŠ€èƒ½æ‰“ä¸­ï¼ˆåœ¨ calcDamage é‡Œç‰¹åˆ¤ï¼‰
    'Wonder Guard': {
        // è¿™ä¸ªé€»è¾‘å¤ªæ·±ï¼Œç¨ååœ¨å¼•æ“é‡Œå†™ä¸€ä¸ª flag æ£€æŸ¥
    },
    // ã€åšè„‚è‚ªã€‘å‡åŠç«/å†°ä¼¤å®³
    'Thick Fat': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (move.type === 'Fire' || move.type === 'Ice') {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ã€æ¯›çš®å¤§è¡£ã€‘ç‰©é˜²ç¿»å€
    'Fur Coat': {
        onModifyStat: (stats) => stats.def *= 2
    },
    // ã€æ»¤é•œ/åšç¡¬å²©çŸ³ã€‘å…‹åˆ¶ä¼¤å®³å‡å°‘25%
    'Filter': {
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            if (effectiveness > 1) return Math.floor(damage * 0.75);
            return damage;
        }
    },
    'Solid Rock': {
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            if (effectiveness > 1) return Math.floor(damage * 0.75);
            return damage;
        }
    },
    // ã€å¤šé‡é³ç‰‡ã€‘æ»¡è¡€æ—¶ä¼¤å®³å‡åŠ
    'Multiscale': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (defender.currHp === defender.maxHp) {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ã€æš—å½±ç›¾ç‰Œã€‘æ»¡è¡€æ—¶ä¼¤å®³å‡åŠ
    'Shadow Shield': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (defender.currHp === defender.maxHp) {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ============================================
    // D. å…¥åœºæ•ˆæœ (Intimidate / Weather)
    // ============================================
    // ã€å¨å“ã€‘
    'Intimidate': {
        onStart: (self, enemy, logs) => {
            if (!enemy || !enemy.isAlive()) return;
            // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æœ‰é˜²æ­¢ä¸‹é™çš„ç‰¹æ€§
            const safe = ['Clear Body', 'White Smoke', 'Full Metal Body', 'Inner Focus', 'Oblivious', 'Hyper Cutter', 'Scrappy', 'Own Tempo'];
            if (enemy.ability && safe.includes(enemy.ability)) {
                logs.push(`(å¯¹æ–¹çš„ ${enemy.ability} å…ç–«äº†å¨å“!)`);
                return;
            }
            if (typeof enemy.applyBoost === 'function') {
                enemy.applyBoost('atk', -1);
                logs.push(`${self.cnName} çš„å¨å“è®©å¯¹æ‰‹ç¨å¾®é€€ç¼©äº†! (æ”»å‡»é™ä½)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
            }
        }
    },
    // ã€é™é›¨ã€‘
    'Drizzle': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'raindance';
            logs.push(`ğŸŒ§ï¸ ${self.cnName} å¸¦æ¥äº†é™é›¨!`);
        }
    },
    // ã€æ—¥ç…§ã€‘
    'Drought': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'sunnyday';
            logs.push(`â˜€ï¸ ${self.cnName} è®©é˜³å…‰å˜å¾—å¼ºçƒˆäº†!`);
        }
    },
    // ã€æ‰¬æ²™ã€‘
    'Sand Stream': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'sandstorm';
            logs.push(`ğŸŒªï¸ ${self.cnName} æ‰¬èµ·äº†æ²™æš´!`);
        }
    },
    // ã€é™é›ªã€‘
    'Snow Warning': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'snow';
            logs.push(`â„ï¸ ${self.cnName} è®©å¤©ç©ºå¼€å§‹ä¸‹é›ªäº†!`);
        }
    },
    // ã€ç”µæ°”åˆ¶é€ è€…ã€‘
    'Electric Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'electricterrain';
            logs.push(`âš¡ ${self.cnName} è„šä¸‹ç”µæµæ¶ŒåŠ¨!`);
        }
    },
    // ã€ç²¾ç¥åˆ¶é€ è€…ã€‘
    'Psychic Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'psychicterrain';
            logs.push(`ğŸ”® ${self.cnName} è„šä¸‹å¥‡å¦™çš„æ„Ÿè§‰è”“å»¶å¼€æ¥!`);
        }
    },
    // ã€é’è‰åˆ¶é€ è€…ã€‘
    'Grassy Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'grassyterrain';
            logs.push(`ğŸŒ¿ ${self.cnName} è„šä¸‹é’è‰èŒ‚ç››!`);
        }
    },
    // ã€è–„é›¾åˆ¶é€ è€…ã€‘
    'Misty Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'mistyterrain';
            logs.push(`ğŸŒ«ï¸ ${self.cnName} è„šä¸‹è–„é›¾å¼¥æ¼«!`);
        }
    },
    // ============================================
    // E. æœºåˆ¶æ€ª
    // ============================================
    // ã€å˜å¹»è‡ªå¦‚ / åˆ©è´ç½—ã€‘
    'Protean': {
        onBeforeMove: (user, move, logs) => {
            if (move.type && move.type !== 'Normal' && !user.types.includes(move.type)) {
                if (user.types[0] !== move.type) { 
                    user.types = [move.type];
                    logs.push(`[å˜å¹»è‡ªå¦‚] ${user.cnName} å˜æˆäº† ${move.type} å±æ€§!`);
                }
            }
        }
    },
    'Libero': {
        onBeforeMove: (user, move, logs) => {
            if (move.type && user.types[0] !== move.type) {
                user.types = [move.type];
                logs.push(`[åˆ©è´ç½—] ${user.cnName} å˜æˆäº† ${move.type} å±æ€§!`);
            }
        }
    },
    // ã€å¼‚å…½æå‡ã€‘å‡»æ€åæå‡æœ€é«˜èƒ½åŠ›
    'Beast Boost': {
        onKill: (attacker, logs) => {
            // æ‰¾æœ€é«˜åŸºç¡€èƒ½åŠ›
            const stats = ['atk', 'def', 'spa', 'spd', 'spe'];
            let best = 'atk';
            let bestVal = attacker.atk || 0;
            for (const s of stats) {
                if (attacker[s] > bestVal) {
                    bestVal = attacker[s];
                    best = s;
                }
            }
            if (typeof attacker.applyBoost === 'function') {
                attacker.applyBoost(best, 1);
                logs.push(`${attacker.cnName} çš„ ${best} æå‡äº†! (å¼‚å…½æå‡)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€è‡ªä¿¡è¿‡å‰©ã€‘å‡»æ€åæ”»å‡»+1
    'Moxie': {
        onKill: (attacker, logs) => {
            if (typeof attacker.applyBoost === 'function') {
                attacker.applyBoost('atk', 1);
                logs.push(`${attacker.cnName} çš„æ”»å‡»æå‡äº†! (è‡ªä¿¡è¿‡å‰©)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€åŠ é€Ÿã€‘å›åˆç»“æŸé€Ÿåº¦+1
    'Speed Boost': {
        onEndTurn: (pokemon, logs) => {
            if (pokemon.boosts && pokemon.boosts.spe < 6) {
                if (typeof pokemon.applyBoost === 'function') {
                    pokemon.applyBoost('spe', 1);
                    logs.push(`${pokemon.cnName} çš„é€Ÿåº¦æå‡äº†! (åŠ é€Ÿ)`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
                }
            }
        }
    },
    // ã€å†ç”ŸåŠ›ã€‘æ¢ä¸‹æ—¶å›å¤1/3è¡€
    'Regenerator': {
        onSwitchOut: (pokemon) => {
            if (pokemon.currHp < pokemon.maxHp && pokemon.currHp > 0) {
                const heal = Math.floor(pokemon.maxHp / 3);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
            }
        }
    },
    // ã€é“æ‹³ã€‘æ‹³å¤´ç±»æ‹›å¼å¨åŠ›x1.2
    'Iron Fist': {
        onBasePower: (power, attacker, defender, move) => {
            const punchMoves = ['Bullet Punch', 'Comet Punch', 'Dizzy Punch', 'Drain Punch', 
                'Dynamic Punch', 'Fire Punch', 'Focus Punch', 'Hammer Arm', 'Ice Punch', 
                'Mach Punch', 'Mega Punch', 'Meteor Mash', 'Power-Up Punch', 'Shadow Punch', 
                'Sky Uppercut', 'Thunder Punch', 'Close Combat'];
            if (punchMoves.includes(move.name)) {
                return Math.floor(power * 1.2);
            }
            return power;
        }
    },
    // ã€å¼ºå£®ä¹‹é¢šã€‘å’¬ç±»æ‹›å¼å¨åŠ›x1.5
    'Strong Jaw': {
        onBasePower: (power, attacker, defender, move) => {
            const biteMoves = ['Bite', 'Crunch', 'Fire Fang', 'Ice Fang', 'Thunder Fang', 
                'Poison Fang', 'Psychic Fangs', 'Hyper Fang', 'Jaw Lock', 'Fishious Rend'];
            if (biteMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ã€ç¡¬çˆªã€‘æ¥è§¦ç±»æ‹›å¼å¨åŠ›x1.3
    'Tough Claws': {
        onBasePower: (power, attacker, defender, move) => {
            // ç®€åŒ–ï¼šç‰©ç†æ‹›å¼å¤§å¤šæ˜¯æ¥è§¦ç±»
            if (move.cat === 'phys' || move.category === 'Physical') {
                return Math.floor(power * 1.3);
            }
            return power;
        }
    },
    // ã€è›®åŠ›ã€‘æ”»å‡»åé™ä½è‡ªèº«æ”»é˜²
    'Sheer Force': {
        // å–æ¶ˆå‰¯ä½œç”¨ä½†å¨åŠ›x1.3ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
        onBasePower: (power, attacker, defender, move) => {
            // å¦‚æœæ‹›å¼æœ‰å‰¯ä½œç”¨ï¼Œå¨åŠ›x1.3
            if (move.secondary || move.secondaries) {
                return Math.floor(power * 1.3);
            }
            return power;
        }
    },
    // ã€æ²™ä¹‹åŠ›ã€‘æ²™æš´ä¸­å²©/åœ°/é’¢å¨åŠ›x1.3
    'Sand Force': {
        onBasePower: (power, attacker, defender, move, battle) => {
            if (battle && battle.weather === 'sandstorm') {
                if (['Rock', 'Ground', 'Steel'].includes(move.type)) {
                    return Math.floor(power * 1.3);
                }
            }
            return power;
        }
    },
    // ã€ç‹™å‡»æ‰‹ã€‘æš´å‡»ä¼¤å®³x1.5
    'Sniper': {
        onCritDamage: (damage) => Math.floor(damage * 1.5)
    },
    // ã€å¤©æ©ã€‘å‰¯ä½œç”¨æ¦‚ç‡ç¿»å€ (ç®€åŒ–ï¼šä¸å®ç°)
    'Serene Grace': {},
    // ã€æ¸…é™¤ä¹‹èº¯ã€‘å…ç–«èƒ½åŠ›ä¸‹é™
    'Clear Body': {
        onTryBoost: (boost, pokemon, source) => {
            // é˜»æ­¢è´Ÿé¢èƒ½åŠ›å˜åŒ–
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    'White Smoke': {
        onTryBoost: (boost, pokemon, source) => {
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    'Full Metal Body': {
        onTryBoost: (boost, pokemon, source) => {
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    // ============================================
    // F. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - æ‹›å¼å¤§å¸ˆç±»
    // ============================================
    // ã€é”‹é”ã€‘åˆ‡å‰²ç±»æ‹›å¼å¨åŠ›x1.5
    'Sharpness': {
        onBasePower: (power, attacker, defender, move) => {
            const slicingMoves = ['Air Cutter', 'Air Slash', 'Aqua Cutter', 'Behemoth Blade', 
                'Cross Poison', 'Cut', 'Fury Cutter', 'Kowtow Cleave', 'Leaf Blade', 
                'Night Slash', 'Psycho Cut', 'Razor Leaf', 'Razor Shell', 'Sacred Sword', 
                'Secret Sword', 'Slash', 'Solar Blade', 'Stone Axe', 'X-Scissor', 'Ceaseless Edge'];
            if (slicingMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ã€è¶…çº§å‘å°„å™¨ã€‘æ³¢å¯¼/æ³¢åŠ¨ç±»æ‹›å¼å¨åŠ›x1.5
    'Mega Launcher': {
        onBasePower: (power, attacker, defender, move) => {
            const pulseMoves = ['Aura Sphere', 'Dark Pulse', 'Dragon Pulse', 'Heal Pulse', 
                'Origin Pulse', 'Terrain Pulse', 'Water Pulse'];
            if (pulseMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ============================================
    // G. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - æŠ—æ€§/çŠ¶æ€ç±»
    // ============================================
    // ã€éš”éŸ³ã€‘å…ç–«å£°éŸ³æ‹›å¼
    'Soundproof': {
        onImmunity: (atkType, move) => {
            const soundMoves = ['Boomburst', 'Bug Buzz', 'Chatter', 'Clanging Scales', 
                'Clangorous Soul', 'Clangorous Soulblaze', 'Confide', 'Disarming Voice', 
                'Echoed Voice', 'Eerie Spell', 'Grass Whistle', 'Growl', 'Heal Bell', 
                'Hyper Voice', 'Metal Sound', 'Noble Roar', 'Overdrive', 'Parting Shot', 
                'Perish Song', 'Relic Song', 'Roar', 'Round', 'Screech', 'Shadow Panic', 
                'Sing', 'Snarl', 'Snore', 'Sparkling Aria', 'Supersonic', 'Uproar'];
            if (move && soundMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ã€æ¯…åŠ›ã€‘å¼‚å¸¸çŠ¶æ€ä¸‹ç‰©æ”»x1.5
    'Guts': {
        onModifyStat: (stats, poke) => { 
            if (poke.status) stats.atk = Math.floor(stats.atk * 1.5); 
        }
    },
    // ã€è½¯å¼±ã€‘åŠè¡€ä»¥ä¸‹æ”»å‡»/ç‰¹æ”»å‡åŠ
    'Defeatist': {
        onModifyStat: (stats, poke) => {
            if (poke.currHp <= poke.maxHp / 2) {
                stats.atk = Math.floor(stats.atk * 0.5);
                stats.spa = Math.floor(stats.spa * 0.5);
            }
        }
    },
    // ============================================
    // H. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å¤©æ°”åŠ é€Ÿç±»
    // ============================================
    // ã€å¶ç»¿ç´ ã€‘æ™´å¤©é€Ÿåº¦ç¿»å€
    'Chlorophyll': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'sunnyday' || battle.weather === 'desolateland')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‚ æ¸¸è‡ªå¦‚ã€‘é›¨å¤©é€Ÿåº¦ç¿»å€
    'Swift Swim': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'raindance' || battle.weather === 'primordialsea')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‹¨æ²™ã€‘æ²™æš´é€Ÿåº¦ç¿»å€
    'Sand Rush': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && battle.weather === 'sandstorm') {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‹¨é›ªã€‘é›ªå¤©é€Ÿåº¦ç¿»å€
    'Slush Rush': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'snow' || battle.weather === 'hail')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€å¤ªé˜³ä¹‹åŠ›ã€‘æ™´å¤©ç‰¹æ”»x1.5
    'Solar Power': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'sunnyday' || battle.weather === 'desolateland')) {
                stats.spa = Math.floor(stats.spa * 1.5);
            }
        }
    },
    // ============================================
    // I. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å¸æ”¶ç³»
    // ============================================
    // ã€é£ŸåœŸã€‘è¢«åœ°é¢æ‰“å›è¡€
    'Earth Eater': {
        onImmunity: (atkType) => atkType === 'Ground',
        onTryHitHeal: (target, move) => {
            if (move.type === 'Ground') {
                return Math.floor(target.maxHp / 4);
            }
            return 0;
        }
    },
    // ============================================
    // J. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å…ç–«ç±»
    // ============================================
    // ã€çŸ³å¤´è„‘è¢‹ã€‘ä¸å—åä¼¤
    'Rock Head': {
        noRecoil: true
    },
    // ã€é­”æ³•é˜²å®ˆã€‘ä¸å—å¤©æ°”/çŠ¶æ€ä¼¤å®³ (ç®€åŒ–)
    'Magic Guard': {
        noIndirectDamage: true
    },
    // ã€ä¸æœè¾“ã€‘è¢«é™èƒ½åŠ›æ—¶æ”»å‡»+2
    'Defiant': {
        onAfterStatDrop: (pokemon, stat, stages, logs) => {
            if (typeof pokemon.applyBoost === 'function') {
                pokemon.applyBoost('atk', 2);
                logs.push(`${pokemon.cnName} çš„æ”»å‡»å¤§å¹…æå‡äº†! (ä¸æœè¾“)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€ç«äº‰å¿ƒã€‘è¢«é™èƒ½åŠ›æ—¶ç‰¹æ”»+2
    'Competitive': {
        onAfterStatDrop: (pokemon, stat, stages, logs) => {
            if (typeof pokemon.applyBoost === 'function') {
                pokemon.applyBoost('spa', 2);
                logs.push(`${pokemon.cnName} çš„ç‰¹æ”»å¤§å¹…æå‡äº†! (ç«äº‰å¿ƒ)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€ç²¾ç¥åŠ›ã€‘å…ç–«ç•ç¼©
    'Inner Focus': {
        noFlinch: true
    },
    // ã€æˆ‘è¡Œæˆ‘ç´ ã€‘å…ç–«æ··ä¹±
    'Own Tempo': {
        noConfusion: true
    },
    // ã€æŸ”è½¯ã€‘å…ç–«éº»ç—¹
    'Limber': {
        onImmunityStatus: (status) => status === 'par'
    },
    // ã€å…ç–«ã€‘å…ç–«ä¸­æ¯’
    'Immunity': {
        onImmunityStatus: (status) => status === 'psn' || status === 'tox'
    },
    // ã€æ°´ä¹‹é¢çº±ã€‘å…ç–«çƒ§ä¼¤
    'Water Veil': {
        onImmunityStatus: (status) => status === 'brn'
    },
    // ã€ç†”å²©é“ ç”²ã€‘å…ç–«å†°å†»
    'Magma Armor': {
        onImmunityStatus: (status) => status === 'frz'
    },
    // ã€ä¸çœ ã€‘å…ç–«ç¡çœ 
    'Insomnia': {
        onImmunityStatus: (status) => status === 'slp'
    },
    'Vital Spirit': {
        onImmunityStatus: (status) => status === 'slp'
    },
    // ã€é³ç²‰ã€‘å…ç–«ç²‰å°˜ç±»æ‹›å¼
    'Overcoat': {
        onImmunity: (atkType, move) => {
            const powderMoves = ['Cotton Spore', 'Poison Powder', 'Powder', 'Rage Powder', 
                'Sleep Powder', 'Spore', 'Stun Spore'];
            if (move && powderMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ã€é˜²å¼¹ã€‘å…ç–«çƒç±»æ‹›å¼
    'Bulletproof': {
        onImmunity: (atkType, move) => {
            const ballMoves = ['Acid Spray', 'Aura Sphere', 'Barrage', 'Beak Blast', 
                'Bullet Seed', 'Egg Bomb', 'Electro Ball', 'Energy Ball', 'Focus Blast', 
                'Gyro Ball', 'Ice Ball', 'Magnet Bomb', 'Mist Ball', 'Mud Bomb', 
                'Octazooka', 'Pollen Puff', 'Pyro Ball', 'Rock Blast', 'Rock Wrecker', 
                'Searing Shot', 'Seed Bomb', 'Shadow Ball', 'Sludge Bomb', 'Weather Ball', 'Zap Cannon'];
            if (move && ballMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ============================================
    // K. ç”»çš® (Disguise) - Mimikyu ä¸“å±
    // ============================================
    // ã€ç”»çš®ã€‘ç¬¬ä¸€æ¬¡å—åˆ°æ”»å‡»ä¼¤å®³æ—¶å…ç–«ï¼Œä½†è‡ªèº«æŸå¤± 1/8 HP
    'Disguise': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            // å¦‚æœç”»çš®å·²ç»ç ´æŸï¼Œæ­£å¸¸å—ä¼¤
            if (defender.disguiseBroken) return damage;
            // ç”»çš®å®Œå¥½æ—¶ï¼Œå…ç–«è¿™æ¬¡ä¼¤å®³
            if (damage > 0) {
                defender.disguiseBroken = true;
                // ç”»çš®ç ´æŸåè‡ªèº«æŸå¤± 1/8 HP
                const bustDamage = Math.floor(defender.maxHp / 8);
                defender.disguiseBustDamage = bustDamage; // æ ‡è®°éœ€è¦æ‰£è¡€
                return 0; // ä¼¤å®³å˜ä¸º 0
            }
            return damage;
        }
    }
};
// å¯¼å‡ºåˆ°å…¨å±€
if (typeof window !== 'undefined') {
    window.AbilityHandlers = AbilityHandlers;
}
]]></file>
        <file name="ai-engine.js"><![CDATA[/**
 * =============================================
 * AI ENGINE - å®å¯æ¢¦æˆ˜æ–— AI ç³»ç»Ÿ
 * =============================================
 * 
 * å››ä¸ªéš¾åº¦ç­‰çº§ï¼š
 * - easy: éšæœºé€‰æ‹©ï¼Œå¶å°”é€‰æœ€ä¼˜
 * - normal: 60% æœ€ä¼˜ï¼Œ30% æ¬¡ä¼˜ï¼Œ10% éšæœº
 * - hard: æ€»æ˜¯é€‰æ‹©å½“å‰æœ€ä¼˜æŠ€èƒ½
 * - expert: å¤§å±€è§‚ AIï¼Œä¼šæ¢äººã€é¢„åˆ¤ã€æ–©æ€è®¡ç®—
 * 
 * v2.0 é«˜çº§è½®è½¬ AI ç‰¹æ€§ï¼š
 * - æŠ˜è¿”æŠ€èƒ½æˆ˜æœ¯è¯„åˆ† (U-turn, Volt Switch ç­‰)
 * - æˆ˜ç•¥æ€§æ¢äºº (æ¸…é™¤è´Ÿé¢çŠ¶æ€/èƒ½åŠ›ä¸‹é™)
 * - é£é™©è¯„ä¼° (è„†çš®è¾“å‡ºæ‰‹æ›´æƒœå‘½)
 * - ç®€æ˜“è¯»æ¢ (é¢„æµ‹ç©å®¶å¿…æ­»æ¢äºº)
 */
const AI_DIFFICULTY = {
    EASY: 'easy',
    NORMAL: 'normal', 
    HARD: 'hard',
    EXPERT: 'expert'
};
/**
 * AI å†³ç­–ç»“æœç±»å‹
 */
const AI_ACTION_TYPE = {
    MOVE: 'move',
    SWITCH: 'switch'
};
// =============================================
// AI ç‰¹æ€§è¯„ä¼°é…ç½®ï¼ˆè½¯ç¼–ç ï¼Œæ•°æ®é©±åŠ¨ï¼‰
// =============================================
// type: é˜²å¾¡æœºåˆ¶ç±»å‹
//   - consumable_shield: ä¸€æ¬¡æ€§æŠ¤ç›¾ï¼ˆç”»çš®ã€å†°ç Œé¹…ï¼‰
//   - damage_reduction: æ»¡è¡€å‡ä¼¤ï¼ˆå¤šé‡é³ç‰‡ã€å¹»å½±é˜²å®ˆï¼‰
//   - endure_lethal: æ»¡è¡€ä¿å‘½ï¼ˆç»“å®ï¼‰
//   - immunity_conditional: æ¡ä»¶å…ç–«ï¼ˆè“„æ°´ã€é¿é›·é’ˆç­‰ï¼‰
// breakValue: æ‰“ç ´æŠ¤ç›¾çš„æˆ˜æœ¯ä»·å€¼
// condition: è§¦å‘æ¡ä»¶ï¼ˆphysical/special/full_hpï¼‰
// bustedFlag: æ£€æµ‹æŠ¤ç›¾æ˜¯å¦å·²ç ´æŸçš„å±æ€§å
const AI_ABILITY_TRAITS = {
    // ä¸€æ¬¡æ€§æŠ¤ç›¾
    'Disguise':      { type: 'consumable_shield', breakValue: 350, bustedFlag: 'disguiseBusted' },
    'Ice Face':      { type: 'consumable_shield', breakValue: 300, condition: 'physical', bustedFlag: 'iceFaceBusted' },
    // æ»¡è¡€å‡ä¼¤
    'Multiscale':    { type: 'damage_reduction', breakValue: 150, condition: 'full_hp' },
    'Shadow Shield': { type: 'damage_reduction', breakValue: 150, condition: 'full_hp' },
    // æ»¡è¡€ä¿å‘½
    'Sturdy':        { type: 'endure_lethal', breakValue: 200, condition: 'full_hp' },
    // æ¡ä»¶å…ç–«ï¼ˆè¿™äº›ä¸éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œæ­£å¸¸ä¼¤å®³è®¡ç®—ä¼šè¿”å›0ï¼‰
    'Wonder Guard':  { type: 'immunity_conditional', note: 'only_supereffective' },
    'Levitate':      { type: 'immunity_conditional', note: 'ground_immune' },
    'Volt Absorb':   { type: 'immunity_conditional', note: 'electric_immune' },
    'Water Absorb':  { type: 'immunity_conditional', note: 'water_immune' },
    'Flash Fire':    { type: 'immunity_conditional', note: 'fire_immune' },
};
// åå¼ºåŒ–æŠ€èƒ½åˆ—è¡¨ï¼ˆé¢å¯¹é«˜å¨èƒæ—¶ä¼˜å…ˆä½¿ç”¨ï¼‰
const AI_COUNTER_MOVES = ['Haze', 'Clear Smog', 'Roar', 'Whirlwind', 'Dragon Tail', 'Circle Throw', 'Topsy-Turvy', 'Spectral Thief'];
/**
 * è·å– AI å†³ç­–ï¼ˆç»Ÿä¸€å…¥å£ï¼‰
 * @param {Pokemon} aiPoke - AI å½“å‰å®å¯æ¢¦
 * @param {Pokemon} playerPoke - ç©å®¶å½“å‰å®å¯æ¢¦
 * @param {string} difficulty - éš¾åº¦ç­‰çº§
 * @param {Pokemon[]} aiParty - AI é˜Ÿä¼ï¼ˆç”¨äºæ¢äººå†³ç­–ï¼‰
 * @param {object} battleContext - æˆ˜æ–—ä¸Šä¸‹æ–‡ï¼ˆå›åˆæ•°ã€å·²ç”¨ Mega ç­‰ï¼‰
 * @returns {object} { type: 'move'|'switch', move?: Move, index?: number, reasoning?: string }
 */
function getAiAction(aiPoke, playerPoke, difficulty = 'hard', aiParty = [], battleContext = {}) {
    if (!aiPoke || !playerPoke) return null;
    const normalizedDiff = (difficulty || 'hard').toLowerCase();
    switch (normalizedDiff) {
        case 'expert':
            return getExpertAiAction(aiPoke, playerPoke, aiParty, battleContext);
        case 'hard': {
            // ã€v2.1ã€‘Hard éš¾åº¦ä¹Ÿæ”¯æŒé£æ ¼é€‰æ‹©
            const hardMove = getHardAiMove(aiPoke, playerPoke, aiParty);
            let chosenStyle = null;
            if (hardMove) {
                const mergedMove = getMergedMoveData(hardMove);
                chosenStyle = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
            }
            return { type: AI_ACTION_TYPE.MOVE, move: hardMove, style: chosenStyle };
        }
        case 'normal': {
            // ã€v2.1ã€‘Normal éš¾åº¦ä¹Ÿæ”¯æŒé£æ ¼é€‰æ‹©ï¼ˆæ¦‚ç‡è¾ƒä½ï¼‰
            const normalMove = getNormalAiMove(aiPoke, playerPoke, aiParty);
            let chosenStyle = null;
            if (normalMove && Math.random() < 0.5) { // 50% æ¦‚ç‡å°è¯•é£æ ¼
                const mergedMove = getMergedMoveData(normalMove);
                chosenStyle = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
            }
            return { type: AI_ACTION_TYPE.MOVE, move: normalMove, style: chosenStyle };
        }
        case 'easy':
        default:
            return { type: AI_ACTION_TYPE.MOVE, move: getEasyAiMove(aiPoke, playerPoke, aiParty) };
    }
}
/* =============================================================
 *  åŸºç¡€ AIï¼šEasy éš¾åº¦
 *  80% éšæœºé€‰æ‹©ï¼Œ20% é€‰æœ€ä¼˜
 * ============================================================= */
function getEasyAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    // 80% æ¦‚ç‡éšæœºé€‰
    if (Math.random() < 0.8) {
        return attacker.moves[Math.floor(Math.random() * attacker.moves.length)];
    }
    // 20% æ¦‚ç‡é€‰æœ€ä¼˜
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    // ä½†å³ä½¿é€‰æœ€ä¼˜ï¼Œä¹Ÿå¯èƒ½é€‰æ¬¡ä¼˜
    if (rankedMoves.length > 1 && Math.random() < 0.5) {
        return rankedMoves[1].move;
    }
    return rankedMoves[0].move;
}
/* =============================================================
 *  æ™®é€š AIï¼šNormal éš¾åº¦
 *  60% æœ€ä¼˜ï¼Œ30% æ¬¡ä¼˜ï¼Œ10% ç¬¬ä¸‰ä¼˜æˆ–éšæœº
 * ============================================================= */
function getNormalAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    const roll = Math.random();
    if (roll < 0.6 || rankedMoves.length === 1) {
        return rankedMoves[0].move;
    }
    if (roll < 0.9 && rankedMoves.length > 1) {
        return rankedMoves[1].move;
    }
    return rankedMoves[Math.min(2, rankedMoves.length - 1)].move;
}
/* =============================================================
 *  å›°éš¾ AIï¼šHard éš¾åº¦
 *  æ€»æ˜¯é€‰æ‹©å½“å‰è¯„åˆ†æœ€é«˜çš„æŠ€èƒ½
 * ============================================================= */
function getHardAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    return rankedMoves[0].move;
}
// æ¢äººå†·å´è¿½è¸ªï¼ˆé˜²æ­¢è¿ç»­æ¢äººï¼‰
let lastSwitchTurn = -999;
// æŠ˜è¿”æŠ€èƒ½åˆ—è¡¨
const PIVOT_MOVES = ['U-turn', 'Volt Switch', 'Flip Turn', 'Parting Shot', 'Teleport', 'Baton Pass'];
/**
 * =======================================================
 * [AI è¡¥ä¸] å¤æ­¦æµæ´¾è¯„ä¼°å™¨ (Style Evaluator)
 * æå‡ AI ä½¿ç”¨ è¿…ç–¾ (Agile) / åˆšçŒ› (Strong) çš„é¢‘ç‡
 * =======================================================
 * @param {Pokemon} aiPoke - AI å½“å‰å®å¯æ¢¦
 * @param {Pokemon} playerPoke - ç©å®¶å½“å‰å®å¯æ¢¦
 * @param {object} baseMove - åŸºç¡€æ‹›å¼
 * @returns {string|null} 'agile' | 'strong' | null
 */
/**
 * AI é£æ ¼ä¼˜åŒ– v3.1 - å¹³è¡¡åšå¼ˆæ¨¡å‹
 * 
 * âš¡ è¿…ç–¾ (Agile): ä¼˜å…ˆåº¦ +1ï¼Œé™ä½å¨åŠ›å’Œå‘½ä¸­
 *   - åœºæ™¯Aï¼ˆé€Ÿåº¦å¿«ï¼‰: å¨åŠ› 0.75x, å‘½ä¸­ 0.9x
 *   - åœºæ™¯Bï¼ˆé€Ÿåº¦æ…¢ï¼‰: å¨åŠ› 0.50x, å‘½ä¸­ 0.85x
 * 
 * ğŸ’ª åˆšçŒ› (Strong): ä¼˜å…ˆåº¦ -1ï¼Œæé«˜å¨åŠ›
 *   - åœºæ™¯Aï¼ˆé€Ÿåº¦æ…¢ï¼‰: å¨åŠ› 1.3x, å‘½ä¸­ 0.8x
 *   - åœºæ™¯Bï¼ˆé€Ÿåº¦å¿«ï¼‰: å¨åŠ› 1.3x, å‘½ä¸­ä¸å˜ï¼ˆå–å…ˆæ‰‹ï¼‰
 */
function tryOptimizeStyle(aiPoke, playerPoke, baseMove) {
    // === åŸºç¡€æ£€æŸ¥ ===
    const unlocks = (typeof battle !== 'undefined') ? battle.enemyUnlocks : {};
    if (unlocks && unlocks.enable_styles === false) return null;
    if (typeof battle !== 'undefined' && battle.enemyStyleCooldown > 0) {
        console.log(`[AI STYLE] å†·å´ä¸­ (${battle.enemyStyleCooldown})`);
        return null;
    }
    // å˜åŒ–æŠ€ä¸ä½¿ç”¨é£æ ¼
    const category = (baseMove.cat || baseMove.category || '').toLowerCase();
    if (category === 'status' || baseMove.power === 0) return null;
    // å…ˆåˆ¶æŠ€ä¸éœ€è¦è¿…ç–¾
    const basePriority = baseMove.priority || 0;
    // === è·å–æˆ˜æ–—æ•°æ® ===
    const normalDmgResult = simulateDamage(aiPoke, playerPoke, baseMove);
    const normalDmg = normalDmgResult.damage;
    const targetHp = playerPoke.currHp;
    const targetMaxHp = playerPoke.maxHp;
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    const mySpeed = getEffectiveSpeed(aiPoke);
    const targetSpeed = getEffectiveSpeed(playerPoke);
    const isTrickRoom = (typeof battle !== 'undefined') && battle.field && battle.field.trickRoom > 0;
    const isFaster = isTrickRoom ? (mySpeed < targetSpeed) : (mySpeed > targetSpeed);
    const isSlower = !isFaster;
    // ä¼¤å®³è®¡ç®—
    const strongDmg = Math.floor(normalDmg * 1.30);
    const agileDmgFast = Math.floor(normalDmg * 0.75);
    const agileDmgSlow = Math.floor(normalDmg * 0.50);
    // è¡€é‡ç™¾åˆ†æ¯”
    const targetHpPct = targetHp / targetMaxHp;
    const myHpPct = myHp / myMaxHp;
    console.log(`[AI STYLE] è¯„ä¼°: ${baseMove.name}, é€Ÿåº¦${isFaster ? 'å¿«' : 'æ…¢'} (${mySpeed} vs ${targetSpeed}), å¯¹æ–¹${Math.floor(targetHpPct*100)}%è¡€, æˆ‘${Math.floor(myHpPct*100)}%è¡€`);
    // =========================================================
    // ğŸ’ª åˆšçŒ›å†³ç­–
    // =========================================================
    // ã€åœºæ™¯1ã€‘æ–©æ€çº¿ï¼šæ™®é€šæ‰“ä¸æ­»ï¼ŒåˆšçŒ›èƒ½æ‰“æ­»ï¼ˆ100%è§¦å‘ï¼‰
    if (normalDmg < targetHp && strongDmg >= targetHp) {
        if (isFaster) {
            console.log(`[AI STYLE] åˆšçŒ›æ–©æ€: ${baseMove.name} (${normalDmg} -> ${strongDmg})`);
            return 'strong';
        } else {
            // é€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8xï¼Œä½†æ–©æ€çº¿å€¼å¾—èµŒ
            console.log(`[AI STYLE] åˆšçŒ›å†’é™©æ–©æ€: ${baseMove.name} (${normalDmg} -> ${strongDmg}, å‘½ä¸­0.8x)`);
            return 'strong';
        }
    }
    // ã€v3.3 ç§»é™¤åœºæ™¯2ã€‘é€Ÿåº¦å¿«æ—¶å–å…ˆæ‰‹å¤ªå±é™©ï¼Œå¦‚æœå¯¹æ–¹èƒ½æ–©æ€è‡ªå·±å°±æ˜¯è‡ªæ€
    // åªä¿ç•™æ–©æ€çº¿åœºæ™¯
    // =========================================================
    // âš¡ è¿…ç–¾å†³ç­–ï¼ˆå…ˆåˆ¶æŠ€è·³è¿‡ï¼‰
    // ã€v3.3ã€‘åªåœ¨æ–©æ€çº¿æ—¶ä½¿ç”¨è¿…ç–¾ï¼Œä¸å†æœ‰å…¶ä»–åœºæ™¯
    // =========================================================
    if (basePriority <= 0) {
        // ã€å”¯ä¸€åœºæ™¯ã€‘é€Ÿåº¦æ…¢ + è¿…ç–¾èƒ½æ–©æ€ = æŠ¢å…ˆæ”¶å‰²
        if (isSlower && agileDmgSlow >= targetHp) {
            console.log(`[AI STYLE] è¿…ç–¾æ–©æ€: ${baseMove.name} (${agileDmgSlow} >= ${targetHp})`);
            return 'agile';
        }
    }
    // é»˜è®¤ä¸ä½¿ç”¨é£æ ¼
    return null;
}
/* =============================================================
 *  ä¸“å®¶ AIï¼šExpert éš¾åº¦
 *  å¤§å±€è§‚å†³ç­–ï¼šæ–©æ€è®¡ç®— + æ¢äººåˆ¤æ–­ + çŠ¶æ€åšå¼ˆ + é«˜çº§è½®è½¬
 * ============================================================= */
function getExpertAiAction(aiPoke, playerPoke, aiParty = [], battleContext = {}) {
    if (!aiPoke || !playerPoke) return null;
    if (!aiPoke.moves || aiPoke.moves.length === 0) return null;
    const turnCount = battleContext.turnCount || 1;
    // ========================================
    // é˜¶æ®µ 0ï¼šç‰¹æ®Šé¦–å›åˆæŠ€èƒ½æ£€æŸ¥
    // ========================================
    const firstTurnMove = checkFirstTurnMoves(aiPoke, playerPoke, turnCount);
    if (firstTurnMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: firstTurnMove, reasoning: 'First turn priority move (Fake Out)' };
    }
    // ========================================
    // é˜¶æ®µ 1ï¼šæ–©æ€çº¿è®¡ç®— (Lethal Check)
    // ã€v3.2ã€‘æ”¯æŒè¿…ç–¾/åˆšçŒ›æ–©æ€
    // ========================================
    const killMove = findKillMove(aiPoke, playerPoke);
    if (killMove) {
        return { 
            type: AI_ACTION_TYPE.MOVE, 
            move: killMove.move, 
            style: killMove.style || null,
            reasoning: killMove.reasoning 
        };
    }
    // ========================================
    // é˜¶æ®µ 1.5ï¼šè¯»æ¢é¢„åˆ¤ (Prediction) [v2.0]
    // å¦‚æœç©å®¶å¿…æ­»ä¸”æ¯”æˆ‘æ…¢ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
    // ========================================
    const predictionMove = evaluatePrediction(aiPoke, playerPoke, aiParty);
    if (predictionMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: predictionMove.move, reasoning: predictionMove.reasoning };
    }
    // ========================================
    // é˜¶æ®µ 2ï¼šå¨èƒè¯„ä¼° - æˆ‘ä¼šæ­»å—ï¼Ÿ
    // ========================================
    const threatAssessment = assessThreat(aiPoke, playerPoke);
    // ========================================
    // é˜¶æ®µ 2.5ï¼šæˆ˜ç•¥æ€§æ¢äººæ£€æŸ¥ (Reset Pivoting) [v2.0]
    // æ£€æŸ¥æ˜¯å¦å› ä¸ºè´Ÿé¢çŠ¶æ€/èƒ½åŠ›ä¸‹é™éœ€è¦æ¢äºº
    // ========================================
    const needsStrategicSwitch = shouldStrategicSwitch(aiPoke);
    // ========================================
    // é˜¶æ®µ 3ï¼šæ¢äººå†³ç­– (Pivot Logic)
    // æ·»åŠ å†·å´ï¼šè‡³å°‘é—´éš” 2 å›åˆæ‰èƒ½å†æ¬¡æ¢äºº
    // ========================================
    const switchCooldown = 2;
    const canSwitch = (turnCount - lastSwitchTurn) >= switchCooldown;
    // ã€ä¿®å¤ã€‘æå·¨åŒ–çŠ¶æ€ä¸‹ç»å¯¹ç¦æ­¢æ¢äººï¼
    // æ­£ä½œè§„åˆ™ï¼šæå·¨åŒ–å®å¯æ¢¦æ¢äººä¼šç«‹åˆ»è§£é™¤æå·¨åŒ–ï¼Œè¿™æ˜¯å·¨å¤§çš„èµ„æºæµªè´¹
    if (aiPoke.isDynamaxed || (aiPoke.dynamaxTurns && aiPoke.dynamaxTurns > 0)) {
        console.log(`[AI] ${aiPoke.name} is Dynamaxed - switching FORBIDDEN`);
        // ç›´æ¥è·³è¿‡æ¢äººå†³ç­–ï¼Œè¿›å…¥æ”»å‡»å†³ç­–
        const bestMove = getHardAiMove(aiPoke, playerPoke, aiParty);
        return { type: AI_ACTION_TYPE.MOVE, move: bestMove, reasoning: 'Dynamax active - must attack' };
    }
    // ä¿®å¤ï¼šå¦‚æœæˆ‘æœ‰ä¼˜åŠ¿ï¼ˆèƒ½ç§’æ€å¯¹æ–¹æˆ–ä¼¤å®³è¿œè¶…å¯¹æ–¹ï¼‰ï¼Œä¸è¦æ¢äººï¼
    // v2.0ï¼šå³ä½¿ä¸å±é™©ï¼Œå¦‚æœçŠ¶æ€å¾ˆå·®ä¹Ÿè€ƒè™‘æ¢äºº
    const shouldConsiderSwitch = threatAssessment.amIInDanger || needsStrategicSwitch;
    if (canSwitch && shouldConsiderSwitch && 
        !threatAssessment.haveAdvantage &&  // å…³é”®ä¿®å¤ï¼šæœ‰ä¼˜åŠ¿æ—¶ä¸æ¢äºº
        aiParty && aiParty.length > 1) {
        const pivotDecision = findBestPivot(aiPoke, playerPoke, aiParty, threatAssessment);
        if (pivotDecision) {
            lastSwitchTurn = turnCount; // è®°å½•æ¢äººå›åˆ
            return pivotDecision;
        }
    }
    // ========================================
    // é˜¶æ®µ 4ï¼šçŠ¶æ€åšå¼ˆä¸å¼ºåŒ–åˆ¤æ–­
    // ========================================
    const strategicMove = evaluateStrategicMoves(aiPoke, playerPoke, threatAssessment);
    if (strategicMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: strategicMove.move, reasoning: strategicMove.reasoning };
    }
    // ========================================
    // é˜¶æ®µ 5ï¼šå¸¸è§„è´ªå©ªé€‰æ‹© (Fallback to Hard AI)
    // ========================================
    const bestMove = getHardAiMove(aiPoke, playerPoke, aiParty);
    // ========================================
    // é˜¶æ®µ 6ï¼šé£æ ¼ä¼˜åŒ– (Style Optimization) [v2.1]
    // å°è¯•ä¸ºæœ€ä¼˜æ‹›å¼é™„åŠ "æµæ´¾ (Style)"
    // ========================================
    let chosenStyle = null;
    if (bestMove) {
        const mergedMove = getMergedMoveData(bestMove);
        const styleSuggestion = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
        if (styleSuggestion) {
            chosenStyle = styleSuggestion;
        }
        // ã€v3.2 ç§»é™¤ã€‘ä¸å†éšæœºä½¿ç”¨é£æ ¼ï¼Œåªåœ¨æœ‰æˆ˜æœ¯ä»·å€¼æ—¶ä½¿ç”¨
    }
    return { 
        type: AI_ACTION_TYPE.MOVE, 
        move: bestMove, 
        style: chosenStyle,
        reasoning: chosenStyle ? `Optimized via ${chosenStyle} style` : 'Standard best move calculation' 
    };
}
/* =============================================================
 *  Expert AI è¾…åŠ©å‡½æ•°
 * ============================================================= */
/**
 * æ£€æŸ¥é¦–å›åˆç‰¹æ®ŠæŠ€èƒ½ï¼ˆå¦‚ Fake Outï¼‰
 */
function checkFirstTurnMoves(aiPoke, playerPoke, turnCount) {
    // å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ turnsOnField è€Œä¸æ˜¯ turnCount
    // Fake Out åªèƒ½åœ¨å®å¯æ¢¦ä¸Šåœºåçš„ç¬¬ä¸€å›åˆä½¿ç”¨
    if ((aiPoke.turnsOnField || 0) > 0) return null;
    const fakeOutMoves = ['Fake Out', 'First Impression'];
    for (const move of aiPoke.moves) {
        if (fakeOutMoves.includes(move.name)) {
            // ç¡®ä¿èƒ½é€ æˆä¼¤å®³ï¼ˆä¸æ˜¯å…ç–«ï¼‰
            const eff = getTypeEffectivenessAI(move.type || 'Normal', playerPoke.types || ['Normal']);
            if (eff > 0) {
                return move;
            }
        }
    }
    return null;
}
/**
 * å¯»æ‰¾æ–©æ€æŠ€èƒ½
 * @returns {object|null} { move, reasoning } æˆ– null
 */
function findKillMove(aiPoke, playerPoke) {
    const targetHp = playerPoke.currHp;
    const targetMaxHp = playerPoke.maxHp;
    const mySpeed = getEffectiveSpeed(aiPoke);
    const targetSpeed = getEffectiveSpeed(playerPoke);
    const isTrickRoom = (typeof battle !== 'undefined') && battle.field && battle.field.trickRoom > 0;
    const aiFaster = isTrickRoom ? (mySpeed < targetSpeed) : (mySpeed > targetSpeed);
    // ã€è°ƒè¯•ã€‘è¾“å‡ºæ–©æ€æ£€æŸ¥ä¿¡æ¯
    console.log(`[AI KILL CHECK] ${aiPoke.name} vs ${playerPoke.name}: targetHp=${targetHp}/${targetMaxHp}, aiFaster=${aiFaster}`);
    let bestKillMove = null;
    let bestKillPriority = -999;
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        const category = (mergedMove.cat || mergedMove.category || '').toLowerCase();
        if (category === 'status' || mergedMove.power === 0) continue;
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        const priority = mergedMove.priority || 0;
        const normalDmg = dmgResult.damage;
        // ã€è°ƒè¯•ã€‘è¾“å‡ºæ¯ä¸ªæŠ€èƒ½çš„ä¼¤å®³
        if (normalDmg >= targetHp * 0.5) {
            console.log(`[AI KILL CHECK] ${mergedMove.name}: dmg=${normalDmg}, targetHp=${targetHp}, canKill=${normalDmg >= targetHp}`);
        }
        // ã€v3.2ã€‘è®¡ç®—è¿…ç–¾ä¼¤å®³ï¼ˆé€Ÿåº¦æ…¢æ—¶ç”¨0.5xï¼‰
        const agileDmg = Math.floor(normalDmg * 0.50);
        // èƒ½æ–©æ€
        if (normalDmg >= targetHp) {
            // é€Ÿåº¦å¿« + èƒ½ç§’ = å®Œç¾æ–©æ€
            if (aiFaster && priority >= bestKillPriority) {
                bestKillMove = { move, reasoning: 'Speed advantage kill', style: null };
                bestKillPriority = priority;
            }
            // é€Ÿåº¦æ…¢ä½†æœ‰å…ˆåˆ¶æŠ€ = å…ˆåˆ¶æ–©æ€
            else if (!aiFaster && priority > 0 && priority > bestKillPriority) {
                bestKillMove = { move, reasoning: 'Priority move kill', style: null };
                bestKillPriority = priority;
            }
            // ã€v3.4 ä¿®å¤ã€‘é€Ÿåº¦æ…¢ + æ™®é€šèƒ½æ–©æ€ + è¿…ç–¾ä¹Ÿèƒ½æ–©æ€ = ç”¨è¿…ç–¾æŠ¢å…ˆæ‰‹
            else if (!aiFaster && priority <= 0 && agileDmg >= targetHp) {
                console.log(`[AI STYLE] è¿…ç–¾æŠ¢å…ˆæ–©æ€: ${mergedMove.name} (${agileDmg} >= ${targetHp})`);
                bestKillMove = { move, reasoning: 'Agile style kill', style: 'agile' };
                bestKillPriority = 999;
            }
            // é€Ÿåº¦æ…¢æ— å…ˆåˆ¶ï¼Œè¿…ç–¾æ€ä¸æ­»ï¼ˆèµŒå¯¹é¢ä¸ç§’æˆ‘ï¼‰
            else if (!bestKillMove && normalDmg >= targetHp * 1.2) {
                bestKillMove = { move, reasoning: 'Overkill gamble', style: null };
            }
        }
        // é€Ÿåº¦æ…¢ + æ™®é€šæ€ä¸æ­» + è¿…ç–¾èƒ½æ–©æ€ = è¿…ç–¾æŠ¢å…ˆæ–©æ€
        else if (!aiFaster && priority <= 0 && agileDmg >= targetHp) {
            console.log(`[AI STYLE] è¿…ç–¾æ–©æ€æ£€æµ‹: ${mergedMove.name} (${normalDmg}*0.5=${agileDmg} >= ${targetHp})`);
            bestKillMove = { move, reasoning: 'Agile style kill', style: 'agile' };
            bestKillPriority = 999;
        }
        // ã€v3.3 ç§»é™¤åˆšçŒ›æ–©æ€ã€‘é€Ÿåº¦å¿«æ—¶ç”¨åˆšçŒ›ä¼šå–å…ˆæ‰‹ï¼Œå¤ªå±é™©
        // åˆšçŒ›åªåœ¨ tryOptimizeStyle ä¸­çš„æ–©æ€çº¿åœºæ™¯ä½¿ç”¨ï¼ˆé€Ÿåº¦æ…¢æ—¶ï¼‰
    }
    return bestKillMove;
}
/**
 * å¨èƒè¯„ä¼°ï¼šåˆ¤æ–­ AI æ˜¯å¦å¤„äºå±é™©
 * v2.0ï¼šåŠ å…¥è§’è‰²ç±»å‹åˆ¤æ–­ï¼ˆSweeper æ›´æƒœå‘½ï¼‰
 */
function assessThreat(aiPoke, playerPoke) {
    let maxIncomingDmg = 0;
    let worstPlayerMove = null;
    let worstMoveType = null;
    // æ¨¡æ‹Ÿç©å®¶æ‰€æœ‰æŠ€èƒ½å¯¹ AI çš„ä¼¤å®³
    for (const pMove of playerPoke.moves) {
        const mergedMove = getMergedMoveData(pMove);
        const dmgResult = simulateDamage(playerPoke, aiPoke, mergedMove);
        if (dmgResult.damage > maxIncomingDmg) {
            maxIncomingDmg = dmgResult.damage;
            worstPlayerMove = mergedMove;
            worstMoveType = mergedMove.type;
        }
    }
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    const hpPercent = myHp / myMaxHp;
    // === æ–°å¢ï¼šè¯„ä¼°æˆ‘çš„åå‡»èƒ½åŠ› ===
    let canKillPlayer = false;
    let myBestDamage = 0;
    let myBestMove = null;
    for (const myMove of aiPoke.moves) {
        const mergedMove = getMergedMoveData(myMove);
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        if (dmgResult.damage > myBestDamage) {
            myBestDamage = dmgResult.damage;
            myBestMove = mergedMove;
        }
        if (dmgResult.damage >= playerPoke.currHp) {
            canKillPlayer = true;
        }
    }
    // åˆ¤æ–­æ˜¯å¦æœ‰ä¼˜åŠ¿ï¼šèƒ½ç§’æ€å¯¹æ–¹ï¼Œæˆ–è€…æˆ‘çš„ä¼¤å®³è¿œè¶…å¯¹æ–¹
    const haveAdvantage = canKillPlayer || (myBestDamage > maxIncomingDmg * 1.3);
    // === v2.0ï¼šè§’è‰²ç±»å‹åˆ¤æ–­ ===
    // é«˜é€Ÿè„†çš® (Sweeper)ï¼šé€Ÿåº¦é«˜ + æ”»å‡»/ç‰¹æ”»é«˜ + é˜²å¾¡ä½
    const baseSpe = aiPoke.baseStats?.spe || aiPoke.spe || 80;
    const baseAtk = aiPoke.baseStats?.atk || aiPoke.atk || 80;
    const baseSpa = aiPoke.baseStats?.spa || aiPoke.spa || 80;
    const baseDef = aiPoke.baseStats?.def || aiPoke.def || 80;
    const baseSpd = aiPoke.baseStats?.spd || aiPoke.spd || 80;
    const isSweeper = baseSpe >= 95 && (baseAtk >= 100 || baseSpa >= 100);
    const isBulky = (baseDef + baseSpd) >= 180;
    // å±é™©é˜ˆå€¼ï¼šè„†çš®è¾“å‡ºæ‰‹æ›´æƒœå‘½
    // Sweeper: å—åˆ° 45% ä»¥ä¸Šä¼¤å®³å°±è§†ä¸ºå±é™©
    // Tank: å—åˆ° 88% ä»¥ä¸Šä¼¤å®³æ‰è§†ä¸ºå±é™©
    const dangerThreshold = isSweeper ? 0.45 : (isBulky ? 0.88 : 0.7);
    const willDieNextTurn = maxIncomingDmg >= myHp;
    const playerFaster = getEffectiveSpeed(playerPoke) > getEffectiveSpeed(aiPoke);
    // v2.0 å±é™©åˆ¤å®šï¼š
    // 1. ä¸‹å›åˆå¿…æ­»ä¸”å¯¹æ–¹é€Ÿåº¦å¿«
    // 2. æˆ–è€…å—åˆ°çš„ä¼¤å®³è¶…è¿‡è§’è‰²ç±»å‹é˜ˆå€¼ä¸”å¯¹æ–¹é€Ÿåº¦å¿«
    const significantDamage = maxIncomingDmg >= myMaxHp * dangerThreshold;
    const amIInDanger = (willDieNextTurn && playerFaster) || 
                        (significantDamage && playerFaster && hpPercent < 0.8);
    return {
        maxIncomingDmg,
        worstPlayerMove,
        worstMoveType,
        willDieNextTurn,
        playerFaster,
        amIInDanger,
        // æ–°å¢è¿”å›å€¼
        haveAdvantage,
        canKillPlayer,
        myBestDamage,
        myBestMove,
        // v2.0 è§’è‰²ç±»å‹
        isSweeper,
        isBulky,
        dangerThreshold
    };
}
/**
 * å¯»æ‰¾æœ€ä½³æ¢äººç›®æ ‡
 */
function findBestPivot(aiPoke, playerPoke, aiParty, threatAssessment) {
    const { worstPlayerMove, worstMoveType, maxIncomingDmg } = threatAssessment;
    if (!worstPlayerMove) return null;
    let bestPivotIndex = -1;
    let bestPivotScore = -Infinity;
    let bestPivotReasoning = '';
    for (let i = 0; i < aiParty.length; i++) {
        const ally = aiParty[i];
        // è·³è¿‡è‡ªå·±å’Œå·²å€’ä¸‹çš„ï¼ˆä¸¥æ ¼æ£€æŸ¥ HP > 0ï¼‰
        if (!ally) continue;
        if (ally === aiPoke) continue;
        if (typeof ally.isAlive !== 'function' || !ally.isAlive()) continue;
        if (!ally.currHp || ally.currHp <= 0) continue;
        // è®¡ç®—é˜Ÿå‹æ‰¿å—ä¼¤å®³
        const simDmg = simulateDamage(playerPoke, ally, worstPlayerMove);
        const allyHpPercent = simDmg.damage / ally.maxHp;
        // è®¡ç®—å±æ€§å…‹åˆ¶
        const eff = getTypeEffectivenessAI(worstMoveType || 'Normal', ally.types || ['Normal']);
        let pivotScore = 0;
        let reasoning = '';
        // [æˆ˜æœ¯ä¿®æ­£] é˜²æ­¢è‡ªæ€å¼æ¢äººï¼šè¢«å…‹åˆ¶ (2x+) ç›´æ¥è´Ÿåˆ†
        if (eff >= 2) {
            pivotScore = -10000; // ç»å¯¹ä¸æ¢ï¼è¿™æ˜¯é€æ­»
            reasoning = `SUICIDE SWITCH BLOCKED: ${ally.cnName || ally.name} is weak to ${worstMoveType}`;
            console.log(`[AI TACTIC] é˜»æ­¢è‡ªæ€æ¢äºº: ${ally.cnName} å¼± ${worstMoveType} (${eff}x)`);
        }
        // å…ç–« = ç»å¯¹æœ€é«˜ä¼˜å…ˆçº§ï¼ˆå¿…é¡»é€‰æ‹©å…ç–«çš„å®å¯æ¢¦ï¼‰
        else if (eff === 0) {
            pivotScore = 99999;
            reasoning = `Perfect Immunity switch to ${ally.cnName || ally.name}`;
        }
        // æŠµæŠ— (0.5x æˆ–æ›´ä½)
        else if (eff <= 0.5) {
            pivotScore = 5000 - allyHpPercent * 1000;
            reasoning = `Resist switch to ${ally.cnName || ally.name}`;
        }
        // æ™®é€šæ•ˆæœä½†ä¼¤å®³å¯æ§ (<40% HP)
        else if (allyHpPercent < 0.4) {
            pivotScore = 2000 - allyHpPercent * 1000;
            reasoning = `Safe switch to ${ally.cnName || ally.name}`;
        }
        // ä¼¤å®³è¾ƒé«˜ä½†æ¯”ç•™åœºå¥½
        else if (allyHpPercent < 0.7 && threatAssessment.willDieNextTurn) {
            pivotScore = 500 - allyHpPercent * 500;
            reasoning = `Sacrifice switch to ${ally.cnName || ally.name}`;
        }
        // [æˆ˜æœ¯ä¿®æ­£] æ™®é€šæ•ˆæœä½†ä¼šè¢«ç§’æ€ï¼Œä¹Ÿä¸æ¢
        else if (allyHpPercent >= 0.9) {
            pivotScore = -5000; // ä¼šè¢«ç§’æ€ï¼Œä¸æ¢
            reasoning = `OHKO SWITCH BLOCKED: ${ally.cnName || ally.name} would be KO'd`;
        }
        // é¢å¤–åŠ åˆ†ï¼šé˜Ÿå‹èƒ½åæ€ç©å®¶
        if (pivotScore > 0) {
            const allyKillMove = findKillMoveForAlly(ally, playerPoke);
            if (allyKillMove) {
                pivotScore += 1000;
                reasoning += ' (can revenge kill)';
            }
        }
        if (pivotScore > bestPivotScore) {
            bestPivotScore = pivotScore;
            bestPivotIndex = i;
            bestPivotReasoning = reasoning;
        }
    }
    // åªæœ‰å½“æ¢äººæ˜æ˜¾æ¯”ç•™åœºå¥½æ—¶æ‰æ¢
    // ç•™åœºç­‰æ­» vs æ¢äººèƒ½æ´»
    if (bestPivotIndex !== -1 && bestPivotScore > 0) {
        return {
            type: AI_ACTION_TYPE.SWITCH,
            index: bestPivotIndex,
            reasoning: bestPivotReasoning
        };
    }
    return null;
}
/**
 * æ£€æŸ¥é˜Ÿå‹æ˜¯å¦èƒ½åæ€
 */
function findKillMoveForAlly(ally, target) {
    if (!ally.moves) return null;
    for (const move of ally.moves) {
        const mergedMove = getMergedMoveData(move);
        const dmgResult = simulateDamage(ally, target, mergedMove);
        if (dmgResult.damage >= target.currHp) {
            return move;
        }
    }
    return null;
}
/**
 * v2.0ï¼šæˆ˜ç•¥æ€§æ¢äººæ£€æŸ¥
 * æ£€æŸ¥æ˜¯å¦å› ä¸ºè´Ÿé¢çŠ¶æ€éœ€è¦æ¢äººï¼ˆè€Œéä»…ä»…æ˜¯ä¿å‘½ï¼‰
 */
function shouldStrategicSwitch(aiPoke) {
    // 1. è¢«å¤§å¹…é™èƒ½åŠ› (æµæ˜Ÿç¾¤/è¿‘èº«æˆ˜åé—ç—‡ æˆ– è¢«å¨å“å¤šæ¬¡)
    const boosts = aiPoke.boosts || {};
    if ((boosts.atk || 0) <= -2 || (boosts.spa || 0) <= -2) {
        return true;
    }
    // 2. é€Ÿåº¦è¢«å¤§å¹…é™ä½ï¼ˆé»é»ç½‘/å²©çŸ³å°é”ï¼‰
    if ((boosts.spe || 0) <= -2) {
        return true;
    }
    // 3. å³å°†ç¡ç€ (å“ˆæ¬ )
    const volatile = aiPoke.volatile || aiPoke.volatileStatus || {};
    if (volatile.yawn || volatile.Yawn) {
        return true;
    }
    // 4. ç­äº¡ä¹‹æ­Œå€’è®¡æ—¶
    if (volatile.perishsong || volatile.PerishSong) {
        return true;
    }
    // 5. è¢«æŒ‘è¡…ä½†ä¸»è¦æ˜¯è¾…åŠ©å‹
    if (volatile.taunt || volatile.Taunt) {
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ”»å‡»æŠ€èƒ½
        const attackMoves = (aiPoke.moves || []).filter(m => {
            const cat = (m.cat || m.category || '').toLowerCase();
            return cat !== 'status';
        });
        if (attackMoves.length <= 1) {
            return true;
        }
    }
    return false;
}
/**
 * v2.0ï¼šè¯»æ¢é¢„åˆ¤
 * å¦‚æœç©å®¶å½“å‰å®å¯æ¢¦å¿…æ­»ä¸”æ¯” AI æ…¢ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
 */
function evaluatePrediction(aiPoke, playerPoke, aiParty) {
    // æ£€æŸ¥ç©å®¶æ˜¯å¦å¿…æ­»
    const playerHp = playerPoke.currHp;
    const playerMaxHp = playerPoke.maxHp;
    const playerHpPercent = playerHp / playerMaxHp;
    // ç©å®¶è¡€é‡å¤ªä½ (<= 20%) ä¸”æ¯” AI æ…¢
    if (playerHpPercent > 0.2) return null;
    const aiFaster = getEffectiveSpeed(aiPoke) > getEffectiveSpeed(playerPoke);
    if (!aiFaster) return null;
    // æ£€æŸ¥ AI æ˜¯å¦èƒ½ç§’æ€å½“å‰ç©å®¶
    let canKillCurrent = false;
    let bestKillMove = null;
    let bestKillDamage = 0;
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        if (dmgResult.damage >= playerHp) {
            canKillCurrent = true;
            if (dmgResult.damage > bestKillDamage) {
                bestKillDamage = dmgResult.damage;
                bestKillMove = mergedMove;
            }
        }
    }
    if (!canKillCurrent || !bestKillMove) return null;
    // ç©å®¶å¿…æ­»ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
    // é¢„è¯»é€»è¾‘ï¼šå¦‚æœæœ€ä½³æŠ€èƒ½æ˜¯å•å±æ€§å…‹åˆ¶æŠ€èƒ½ï¼Œè€ƒè™‘æ¢ä¸€ä¸ªè¦†ç›–é¢æ›´å¹¿çš„æŠ€èƒ½
    const coveragePairs = {
        'Ground': ['Ice', 'Rock', 'Water'],      // åœ°é¢è¢«é£è¡Œå…ç–«ï¼Œç”¨å†°/å²©çŸ³æ‰“
        'Electric': ['Ice', 'Grass', 'Ground'],  // ç”µè¢«åœ°é¢å…ç–«ï¼Œç”¨å†°/è‰æ‰“
        'Fighting': ['Flying', 'Psychic'],       // æ ¼æ–—è¢«å¹½çµå…ç–«ï¼Œç”¨é£è¡Œ/è¶…èƒ½æ‰“
        'Normal': ['Fighting', 'Ghost'],         // ä¸€èˆ¬è¢«å¹½çµå…ç–«
        'Poison': ['Ground', 'Psychic']          // æ¯’è¢«é’¢å…ç–«
    };
    const bestMoveType = bestKillMove.type;
    const coverageTypes = coveragePairs[bestMoveType];
    if (!coverageTypes) return null;
    // æ‰¾ä¸€ä¸ªè¦†ç›–æŠ€èƒ½
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        if (coverageTypes.includes(mergedMove.type) && (mergedMove.basePower || mergedMove.power || 0) >= 60) {
            // 50% æ¦‚ç‡ä½¿ç”¨é¢„è¯»æŠ€èƒ½ï¼ˆä¸è¦å¤ªæ¿€è¿›ï¼‰
            if (Math.random() < 0.5) {
                return {
                    move: move,
                    reasoning: `Prediction: expecting switch, using ${mergedMove.type} coverage`
                };
            }
        }
    }
    return null;
}
/**
 * è¯„ä¼°æˆ˜ç•¥æ€§æŠ€èƒ½ï¼ˆå¼ºåŒ–ã€çŠ¶æ€ã€å›å¤ï¼‰
 */
function evaluateStrategicMoves(aiPoke, playerPoke, threatAssessment) {
    const MC = (typeof MOVE_CONSTANTS !== 'undefined') ? MOVE_CONSTANTS : {};
    const myHpPercent = aiPoke.currHp / aiPoke.maxHp;
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    // å¦‚æœå¤„äºå±é™©ï¼Œä¸è¦å¼ºåŒ–ï¼Œç›´æ¥æ‰“
    if (threatAssessment.amIInDanger) {
        console.log('[AI] amIInDanger=true, skipping strategic moves');
        return null;
    }
    // å…³é”®ä¿®å¤ï¼šå¦‚æœä¸‹å›åˆå¿…æ­»ä¸”å¯¹æ–¹é€Ÿåº¦å¿«ï¼Œç»å¯¹ä¸è¦ç”¨å¼ºåŒ–æŠ€
    // è¿™æ˜¯æœ€åçš„å®‰å…¨ç½‘ï¼Œé˜²æ­¢ AI è‡ªæ€å¼å‰‘èˆ
    if (threatAssessment.willDieNextTurn && threatAssessment.playerFaster) {
        console.log('[AI] Will die next turn to faster opponent, skipping strategic moves');
        return null;
    }
    // ã€æ–°å¢ã€‘2HKO æ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹èƒ½ä¸¤å›åˆå‡»æ€ä¸”é€Ÿåº¦æ›´å¿«ï¼Œä¸è¦å¼ºåŒ–
    // è¿™é˜²æ­¢äº†"æ»¡è¡€å‰‘èˆè¢«ç§’"çš„è‡ªæ€è¡Œä¸º
    const canBe2HKOd = threatAssessment.maxIncomingDmg * 2 >= myHp;
    if (canBe2HKOd && threatAssessment.playerFaster) {
        console.log(`[AI] Can be 2HKO'd by faster opponent (${threatAssessment.maxIncomingDmg}x2 >= ${myHp}), skipping strategic moves`);
        return null;
    }
    // ã€æ–°å¢ã€‘å±æ€§å…‹åˆ¶æ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹æœ‰ 2 å€å…‹åˆ¶æŠ€èƒ½ä¸”é€Ÿåº¦æ›´å¿«ï¼Œä¸è¦å¼ºåŒ–
    if (threatAssessment.worstMoveType && threatAssessment.playerFaster) {
        const eff = getTypeEffectivenessAI(threatAssessment.worstMoveType, aiPoke.types || ['Normal']);
        if (eff >= 2) {
            console.log(`[AI] Weak to ${threatAssessment.worstMoveType} (${eff}x) and slower, skipping strategic moves`);
            return null;
        }
    }
    let bestStrategicMove = null;
    let bestStrategicScore = 0;
    for (const move of aiPoke.moves) {
        const moveName = move.name || '';
        let score = 0;
        let reasoning = '';
        // === å¼ºåŒ–æŠ€èƒ½ ===
        // ã€ä¿®å¤ã€‘ä½¿ç”¨ moves-data.js çš„ boosts å­—æ®µæ£€æµ‹å¼ºåŒ–æŠ€ï¼Œè€Œä¸æ˜¯ç¡¬ç¼–ç åˆ—è¡¨
        const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
        const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
        const boosts = moveData.boosts || null;
        const target = moveData.target || 'normal';
        // æ£€æµ‹æ˜¯å¦æ˜¯è‡ªèº«å¼ºåŒ–æŠ€èƒ½
        const isSelfBoost = boosts && ['self', 'allySide', 'adjacentAllyOrSelf'].includes(target);
        if (isSelfBoost) {
            // ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ‰€æœ‰æ­£é¢å¼ºåŒ–æ˜¯å¦å·²æ»¡çº§ (+6)
            const currentBoosts = aiPoke.boosts || {};
            let anyBoostMaxed = false;
            for (const stat of Object.keys(boosts)) {
                if (boosts[stat] > 0 && (currentBoosts[stat] || 0) >= 6) {
                    console.log(`[AI STRATEGIC] ${aiPoke.cnName} çš„ ${stat} å·²æ»¡çº§ (+6)ï¼Œç¦æ­¢ä½¿ç”¨ ${moveName}`);
                    anyBoostMaxed = true;
                    break;
                }
            }
            if (!anyBoostMaxed) {
                // æ£€æŸ¥ç›¸å…³èƒ½åŠ›æ˜¯å¦å·²ç»å¼ºåŒ–è¶³å¤Ÿ
                const relevantBoost = aiPoke.spa > aiPoke.atk ? (currentBoosts.spa || 0) : (currentBoosts.atk || 0);
                const defBoost = currentBoosts.def || 0;
                const spdBoost = currentBoosts.spd || 0;
                // æ”»å‡»/ç‰¹æ”»å¼ºåŒ–
                if (boosts.atk > 0 || boosts.spa > 0) {
                    if (myHpPercent > 0.6 && relevantBoost < 2) {
                        score = 150;
                        reasoning = 'Setup opportunity';
                    } else if (myHpPercent > 0.4 && relevantBoost === 0) {
                        score = 80;
                        reasoning = 'Risky setup';
                    }
                }
                // é˜²å¾¡å¼ºåŒ–ï¼ˆå¦‚ Iron Defenseï¼‰
                else if (boosts.def > 0 && defBoost < 2) {
                    if (myHpPercent > 0.7) {
                        score = 80;
                        reasoning = 'Defensive setup';
                    }
                }
                // ç‰¹é˜²å¼ºåŒ–ï¼ˆå¦‚ Amnesiaï¼‰
                else if (boosts.spd > 0 && spdBoost < 2) {
                    if (myHpPercent > 0.7) {
                        score = 80;
                        reasoning = 'Special defense setup';
                    }
                }
            }
        }
        // === å›å¤æŠ€èƒ½ ===
        const healMoves = MC.AI_HEAL_MOVES || ['Recover', 'Roost', 'Soft-Boiled', 'Slack Off', 'Moonlight', 'Morning Sun', 'Synthesis'];
        if (healMoves.includes(moveName)) {
            if (myHpPercent < 0.4) {
                score = 200;
                reasoning = 'Critical heal';
            } else if (myHpPercent < 0.6) {
                score = 100;
                reasoning = 'Preventive heal';
            }
        }
        // === çŠ¶æ€æŠ€èƒ½ ===
        const statusMoves = MC.AI_STATUS_MOVES || ['Thunder Wave', 'Will-O-Wisp', 'Toxic', 'Spore'];
        if (statusMoves.includes(moveName) && !playerPoke.status) {
            // å¯¹æ‰‹æ²¡æœ‰çŠ¶æ€æ‰ç”¨
            const sleepMoves = MC.AI_SLEEP_MOVES || ['Spore', 'Sleep Powder', 'Hypnosis'];
            if (sleepMoves.includes(moveName)) {
                score = 180;
                reasoning = 'Sleep opportunity';
            } else if (moveName === 'Thunder Wave' && getEffectiveSpeed(playerPoke) > getEffectiveSpeed(aiPoke)) {
                score = 120;
                reasoning = 'Speed control';
            } else if (moveName === 'Will-O-Wisp' && playerPoke.atk > playerPoke.spa) {
                score = 110;
                reasoning = 'Physical attacker burn';
            } else if (moveName === 'Toxic') {
                score = 90;
                reasoning = 'Chip damage';
            }
        }
        if (score > bestStrategicScore) {
            bestStrategicScore = score;
            bestStrategicMove = { move, reasoning };
        }
    }
    // åªæœ‰å½“æˆ˜ç•¥åˆ†æ•°è¶³å¤Ÿé«˜æ—¶æ‰é€‰æ‹©æˆ˜ç•¥æŠ€èƒ½
    // å¦åˆ™è®©å¸¸è§„ä¼¤å®³è®¡ç®—æ¥å†³å®š
    if (bestStrategicScore >= 100) {
        return bestStrategicMove;
    }
    return null;
}
/* =============================================================
 *  é€šç”¨è¾…åŠ©å‡½æ•°
 * ============================================================= */
/**
 * å¯¹æŠ€èƒ½æŒ‰è¯„åˆ†æ’åº
 */
function rankMovesByScore(attacker, defender, aiParty = null) {
    if (!attacker?.moves) return [];
    // ã€ä¿®å¤ã€‘Choice é“å…·é”æ‹›æ£€æŸ¥
    // å¦‚æœæŒæœ‰ Choice é“å…·ä¸”å·²ç»é”å®šäº†æŠ€èƒ½ï¼Œåªèƒ½ä½¿ç”¨é‚£ä¸ªæŠ€èƒ½
    // ä½¿ç”¨ items-data.js çš„ isChoiceItem å‡½æ•°
    const item = attacker.item || '';
    const checkIsChoice = typeof window !== 'undefined' && typeof window.isChoiceItem === 'function' 
        ? window.isChoiceItem 
        : (i) => i && (i.includes('Choice') || i.includes('è®²ç©¶'));
    const hasChoiceItem = checkIsChoice(item);
    const lockedMove = attacker.choiceLockedMove;
    if (hasChoiceItem && lockedMove) {
        // æ‰¾åˆ°è¢«é”å®šçš„æŠ€èƒ½
        const locked = attacker.moves.find(m => m.name === lockedMove);
        if (locked) {
            console.log(`[AI CHOICE] ${attacker.name} è¢« ${item} é”å®šåœ¨ ${lockedMove}`);
            const mergedMove = getMergedMoveData(locked);
            return [{
                move: locked,
                score: calcMoveScore(attacker, defender, mergedMove, aiParty)
            }];
        }
    }
    return attacker.moves.map(move => {
        const mergedMove = getMergedMoveData(move);
        return {
            move,
            score: calcMoveScore(attacker, defender, mergedMove, aiParty)
        };
    }).sort((a, b) => b.score - a.score);
}
/**
 * è·å–åˆå¹¶åçš„æŠ€èƒ½æ•°æ®ï¼ˆæœ¬åœ° + MOVES æ•°æ®åº“ï¼‰
 */
function getMergedMoveData(move) {
    const id = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    let merged = {
        ...move,
        type: move.type || 'Normal',
        cat: move.cat || move.category || 'phys'
    };
    if (typeof MOVES !== 'undefined' && MOVES[id]) {
        const staticData = MOVES[id];
        merged = {
            ...staticData,
            ...move,
            type: move.type || staticData.type || 'Normal',
            basePower: move.power ?? staticData.basePower ?? 0,
            power: move.power ?? staticData.basePower ?? 0,
            priority: staticData.priority ?? move.priority ?? 0,
            cat: (move.cat || (staticData.category ? staticData.category.toLowerCase() : 'phys')),
            // ã€ä¿®å¤ã€‘ç¡®ä¿ boosts å’Œ target ä» staticData è·å–ï¼ˆç”¨äºå¼ºåŒ–æŠ€æ£€æµ‹ï¼‰
            boosts: move.boosts || staticData.boosts || null,
            target: move.target || staticData.target || 'normal'
        };
    }
    return merged;
}
/**
 * æ¨¡æ‹Ÿä¼¤å®³è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼Œç”¨äº AI å†³ç­–ï¼‰
 * ä¿æŒçº¯å‡€ï¼šè¯¥æ˜¯0å°±æ˜¯0ï¼Œä¸åœ¨è¿™é‡Œåšç‰¹æ€§é­”æ”¹
 */
function simulateDamage(attacker, defender, move) {
    // å¦‚æœæœ‰å…¨å±€ calcDamage å‡½æ•°ï¼Œä½¿ç”¨å®ƒ
    if (typeof calcDamage === 'function') {
        try {
            const result = calcDamage(attacker, defender, move);
            return {
                damage: result.damage || result.singleHitDamage || 0,
                effectiveness: (result.effectiveness !== undefined) ? result.effectiveness : 1
            };
        } catch (e) {
            // å›é€€åˆ°ç®€åŒ–è®¡ç®—
        }
    }
    // ç®€åŒ–ä¼¤å®³è®¡ç®—
    const moveName = move.name || '';
    const category = (move.cat || move.category || '').toLowerCase();
    const isStatus = category === 'status' || move.power === 0 || move.basePower === 0;
    if (isStatus) {
        return { damage: 0, effectiveness: 1 };
    }
    const usesSpecial = category === 'spec' || category === 'special';
    let atkStat = usesSpecial ? (attacker.getStat?.('spa') || attacker.spa) : (attacker.getStat?.('atk') || attacker.atk);
    const defStat = usesSpecial ? (defender.getStat?.('spd') || defender.spd) : (defender.getStat?.('def') || defender.def);
    // çƒ§ä¼¤å‡åŠç‰©æ”»
    if (!usesSpecial && attacker.status === 'brn') {
        atkStat = Math.floor(atkStat * 0.5);
    }
    const eff = getTypeEffectivenessAI(move.type || 'Normal', defender.types || ['Normal'], moveName);
    if (eff === 0) return { damage: 0, effectiveness: 0 };
    const stab = (attacker.types || []).includes(move.type) ? 1.5 : 1.0;
    const power = move.basePower ?? move.power ?? 0;
    const level = attacker.level || 50;
    const baseDamage = ((2 * level / 5 + 2) * power * (atkStat / Math.max(1, defStat)) / 50 + 2) * stab * eff;
    return {
        damage: Math.floor(baseDamage * 0.925),
        effectiveness: eff
    };
}
/**
 * è¯„ä¼°æŠ€èƒ½çš„æˆ˜æœ¯å½±å“åŠ›ï¼ˆè½¯ç¼–ç ï¼Œæ•°æ®é©±åŠ¨ï¼‰
 * ç»¼åˆè€ƒè™‘ï¼šæŠ¤ç›¾ç ´é™¤ã€æ»¡è¡€ä¿å‘½ã€å¨èƒç­‰çº§ç­‰å› ç´ 
 * @returns {object} { totalScore, rawDamage, effectiveness, shieldBreak, threatBonus }
 */
function evaluateMoveImpact(attacker, defender, move) {
    // 1. è·å–åŸºç¡€ä¼¤å®³æ¨¡æ‹Ÿ
    const dmgResult = simulateDamage(attacker, defender, move);
    let baseScore = dmgResult.damage;
    const eff = dmgResult.effectiveness;
    // å…ç–«ç›´æ¥è¿”å›
    if (eff === 0) {
        return { totalScore: -9999, rawDamage: 0, effectiveness: 0 };
    }
    // è·å–æŠ€èƒ½åˆ†ç±»
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    const category = (fullMoveData.category || move.cat || '').toLowerCase();
    const isAttackMove = category !== 'status' && (move.power > 0 || move.basePower > 0);
    // 2. ç‰¹æ€§è¯„ä¼°ï¼ˆè½¯ç¼–ç ï¼Œä»é…ç½®è¯»å–ï¼‰
    const defAbility = defender.ability || '';
    const trait = AI_ABILITY_TRAITS[defAbility];
    let shieldBreak = false;
    if (trait && isAttackMove) {
        // === Case A: æ¶ˆè€—å‹æŠ¤ç›¾ï¼ˆç”»çš®ã€å†°ç Œé¹…ï¼‰===
        if (trait.type === 'consumable_shield') {
            const bustedFlag = trait.bustedFlag || 'shieldBusted';
            const isShieldActive = !defender[bustedFlag];
            // æ£€æŸ¥æ¡ä»¶ï¼ˆå¦‚å†°ç Œé¹…åªé˜²ç‰©ç†ï¼‰
            let conditionMet = true;
            if (trait.condition === 'physical') {
                conditionMet = category === 'physical';
            } else if (trait.condition === 'special') {
                conditionMet = category === 'special';
            }
            if (isShieldActive && conditionMet && dmgResult.damage === 0) {
                // æŠ¤ç›¾æŒ¡ä½äº†æ”»å‡»ï¼Œä½†ç ´ç›¾æœ‰æˆ˜æœ¯ä»·å€¼
                baseScore += trait.breakValue;
                shieldBreak = true;
            }
        }
        // === Case B: æ»¡è¡€å‡ä¼¤ï¼ˆå¤šé‡é³ç‰‡ï¼‰===
        else if (trait.type === 'damage_reduction' && trait.condition === 'full_hp') {
            if (defender.currHp === defender.maxHp && dmgResult.damage > 0) {
                // æ‰“ç ´æ»¡è¡€çŠ¶æ€æœ‰ä»·å€¼
                baseScore += trait.breakValue;
            }
        }
        // === Case C: æ»¡è¡€ä¿å‘½ï¼ˆç»“å®ï¼‰===
        else if (trait.type === 'endure_lethal' && trait.condition === 'full_hp') {
            if (defender.currHp === defender.maxHp && dmgResult.damage > 0) {
                baseScore += trait.breakValue;
            }
        }
    }
    // 3. é“å…·è¯„ä¼°ï¼ˆæ°”åŠ¿æŠ«å¸¦ï¼‰
    const defItem = (defender.item || '').toLowerCase().replace(/[^a-z]/g, '');
    if (defItem === 'focussash' && defender.currHp === defender.maxHp && dmgResult.damage > 0) {
        baseScore += 150; // æ‰“ç ´æ°”è…°çš„æ»¡è¡€çŠ¶æ€
    }
    // 4. å¨èƒç­‰çº§è¯„ä¼°ï¼ˆå¯¹æ‰‹å¼ºåŒ–ç¨‹åº¦ï¼‰
    let threatLevel = 0;
    const defBoosts = defender.boosts || {};
    threatLevel += Math.max(0, (defBoosts.atk || 0) - 1) * 100;
    threatLevel += Math.max(0, (defBoosts.spa || 0) - 1) * 100;
    if ((defBoosts.spe || 0) > 0) threatLevel *= 1.5;
    let threatBonus = 0;
    if (threatLevel > 100) {
        if (isAttackMove) {
            // æ”»å‡»æŠ€èƒ½åŠ åˆ†
            threatBonus = threatLevel;
            // å…‹åˆ¶æŠ€èƒ½é¢å¤–åŠ åˆ†
            if (eff >= 2) threatBonus += threatLevel;
        } else {
            // è¾…åŠ©æŠ€èƒ½ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºåå¼ºåŒ–æŠ€èƒ½
            const isCounterMove = AI_COUNTER_MOVES.includes(move.name);
            if (isCounterMove) {
                threatBonus = threatLevel * 2; // æ•‘å‘½ç¨»è‰
            } else {
                threatBonus = -Math.min(1000, threatLevel * 2); // å¤§å¹…æƒ©ç½š
            }
        }
        baseScore += threatBonus;
    }
    return {
        totalScore: baseScore,
        rawDamage: dmgResult.damage,
        effectiveness: eff,
        shieldBreak,
        threatBonus
    };
}
/**
 * è·å–æœ‰æ•ˆé€Ÿåº¦ï¼ˆè€ƒè™‘éº»ç—¹ã€é¡ºé£ç­‰ï¼‰
 */
function getEffectiveSpeed(pokemon) {
    let spe = pokemon.getStat?.('spe') || pokemon.spe || 100;
    // éº»ç—¹å‡é€Ÿ
    if (pokemon.status === 'par') {
        spe = Math.floor(spe * 0.5);
    }
    return spe;
}
/**
 * è·å–å±æ€§å…‹åˆ¶ï¼ˆä½¿ç”¨å†…ç½®è¡¨ï¼Œé¿å…å¾ªç¯è°ƒç”¨ï¼‰
 */
function getTypeEffectivenessAI(atkType, defTypes, moveName = '') {
    // ç›´æ¥ä½¿ç”¨å†…ç½®è¡¨ï¼Œä¸è°ƒç”¨ window.getTypeEffectiveness é¿å…å¾ªç¯
    const TYPE_CHART = {
        'Normal':   { weak: [],                          resist: ['Rock', 'Steel'],      immune: ['Ghost'] },
        'Fire':     { weak: ['Grass', 'Ice', 'Bug', 'Steel'], resist: ['Fire', 'Water', 'Rock', 'Dragon'], immune: [] },
        'Water':    { weak: ['Fire', 'Ground', 'Rock'],  resist: ['Water', 'Grass', 'Dragon'], immune: [] },
        'Electric': { weak: ['Water', 'Flying'],         resist: ['Electric', 'Grass', 'Dragon'], immune: ['Ground'] },
        'Grass':    { weak: ['Water', 'Ground', 'Rock'], resist: ['Fire', 'Grass', 'Poison', 'Flying', 'Bug', 'Dragon', 'Steel'], immune: [] },
        'Ice':      { weak: ['Grass', 'Ground', 'Flying', 'Dragon'], resist: ['Fire', 'Water', 'Ice', 'Steel'], immune: [] },
        'Fighting': { weak: ['Normal', 'Ice', 'Rock', 'Dark', 'Steel'], resist: ['Poison', 'Flying', 'Psychic', 'Bug', 'Fairy'], immune: ['Ghost'] },
        'Poison':   { weak: ['Grass', 'Fairy'],          resist: ['Poison', 'Ground', 'Rock', 'Ghost'], immune: ['Steel'] },
        'Ground':   { weak: ['Fire', 'Electric', 'Poison', 'Rock', 'Steel'], resist: ['Grass', 'Bug'], immune: ['Flying'] },
        'Flying':   { weak: ['Grass', 'Fighting', 'Bug'], resist: ['Electric', 'Rock', 'Steel'], immune: [] },
        'Psychic':  { weak: ['Fighting', 'Poison'],      resist: ['Psychic', 'Steel'],   immune: ['Dark'] },
        'Bug':      { weak: ['Grass', 'Psychic', 'Dark'], resist: ['Fire', 'Fighting', 'Poison', 'Flying', 'Ghost', 'Steel', 'Fairy'], immune: [] },
        'Rock':     { weak: ['Fire', 'Ice', 'Flying', 'Bug'], resist: ['Fighting', 'Ground', 'Steel'], immune: [] },
        'Ghost':    { weak: ['Psychic', 'Ghost'],        resist: ['Dark'],               immune: ['Normal'] },
        'Dragon':   { weak: ['Dragon'],                  resist: ['Steel'],              immune: ['Fairy'] },
        'Dark':     { weak: ['Psychic', 'Ghost'],        resist: ['Fighting', 'Dark', 'Fairy'], immune: [] },
        'Steel':    { weak: ['Ice', 'Rock', 'Fairy'],    resist: ['Fire', 'Water', 'Electric', 'Steel'], immune: [] },
        'Fairy':    { weak: ['Fighting', 'Dark', 'Dragon'], resist: ['Fire', 'Poison', 'Steel'], immune: [] },
    };
    const chart = TYPE_CHART[atkType];
    if (!chart) return 1;
    let multiplier = 1;
    for (const defType of defTypes) {
        if (chart.immune.includes(defType)) return 0;
        if (chart.weak.includes(defType)) multiplier *= 2;
        if (chart.resist.includes(defType)) multiplier *= 0.5;
    }
    return multiplier;
}
/**
 * æŠ€èƒ½è¯„åˆ†ï¼ˆç”¨äºæ’åºï¼‰
 * @param {Pokemon} attacker - æ”»å‡»æ–¹
 * @param {Pokemon} defender - é˜²å¾¡æ–¹
 * @param {Object} move - æŠ€èƒ½æ•°æ®
 * @param {Pokemon[]} aiParty - AI é˜Ÿä¼ï¼ˆç”¨äºæŠ˜è¿”æŠ€èƒ½æ£€æŸ¥ï¼‰
 */
function calcMoveScore(attacker, defender, move, aiParty = null) {
    if (!move) return -9999;
    const moveName = move.name || '';
    // =========================================================
    // 0. Z-Move / Max Move å…¨åœºå”¯ä¸€é™åˆ¶ (Once Per Battle)
    // è¿™äº›è¶…å¼ºæŠ€èƒ½åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œç”¨è¿‡å°±æ°¸ä¹…å°å°
    // =========================================================
    // è·å–æŠ€èƒ½æ•°æ®åˆ¤æ–­æ˜¯å¦ä¸º Z/Max æ‹›å¼
    const moveId = (moveName || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æµ‹ Z æ‹›å¼ï¼šisZ å­—æ®µ æˆ– isNonstandard === 'Past' ä¸” PP === 1
    const isZMove = moveData.isZ || 
        (moveData.pp === 1 && moveData.basePower >= 100 && moveData.isNonstandard === 'Past');
    // æ£€æµ‹æå·¨æ‹›å¼ï¼šisMax å­—æ®µ æˆ– åç§°åŒ…å« Max/G-Max
    const isMaxMove = moveData.isMax || 
        moveName.startsWith('Max ') || moveName.startsWith('G-Max ');
    // å¦‚æœæ˜¯ Z æ‹›å¼ä¸” AI å·²ç»ç”¨è¿‡ï¼Œæ°¸ä¹…å°å°
    if (isZMove && typeof battle !== 'undefined' && battle.enemyZUsed) {
        console.log(`[AI BAN] Z-Move "${moveName}" å·²ä½¿ç”¨è¿‡ï¼Œç¦æ­¢å†æ¬¡ä½¿ç”¨`);
        return -99999;
    }
    // å¦‚æœæ˜¯æå·¨æ‹›å¼ä¸” AI å·²ç»ç”¨è¿‡ï¼Œæ°¸ä¹…å°å°
    if (isMaxMove && typeof battle !== 'undefined' && battle.enemyMaxUsed) {
        console.log(`[AI BAN] Max Move "${moveName}" å·²ä½¿ç”¨è¿‡ï¼Œç¦æ­¢å†æ¬¡ä½¿ç”¨`);
        return -99999;
    }
    // =========================================================
    // 1. å¤æ‚æŠ€èƒ½é»‘åå• (Complex Move Blacklist)
    // å¼•æ“æœªå®ç°çš„å¤æ‚æœºåˆ¶æŠ€èƒ½ï¼Œç¦æ­¢ AI ä½¿ç”¨
    // =========================================================
    const ENGINE_BANS = [
        // å»¶è¿Ÿä¼¤å®³æŠ€èƒ½ï¼ˆéœ€è¦å…¨å±€é˜Ÿåˆ—ï¼‰
        'Future Sight', 'Doom Desire',
        // åŒæ‰“ä¸“ç”¨æŠ€èƒ½
        'Ally Switch', 'Helping Hand', 'Follow Me', 'Rage Powder',
        'Wide Guard', 'Quick Guard', 'After You', 'Instruct', 'Quash',
        // é“å…·äº¤æ¢/ç§»é™¤ç±»ï¼ˆé“å…·ç³»ç»Ÿæœªå®Œå–„ï¼‰
        'Switcheroo', 'Trick', 'Bestow', 'Fling', 'Thief', 'Covet',
        // ç‰¹æ€§äº¤æ¢ç±»ï¼ˆè¿‡äºå¤æ‚ï¼‰
        'Skill Swap', 'Entrainment', 'Role Play', 'Doodle'
    ];
    if (ENGINE_BANS.includes(moveName)) {
        return -99999; // æ°¸è¿œä¸é€‰
    }
    // =========================================================
    // 2. æ¡ä»¶å‹é™åˆ¶æŠ€èƒ½æ£€æŸ¥ (Context-based Restrictions)
    // ä½¿ç”¨ moves-data.js çš„æ•°æ®é©±åŠ¨åˆ¤æ–­
    // =========================================================
    // ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ move å‚æ•°ï¼ˆå·²ç»æ˜¯ getMergedMoveData å¤„ç†è¿‡çš„ï¼‰
    // åªæœ‰å½“ move æ²¡æœ‰ boosts/target æ—¶æ‰å›é€€åˆ° moveData
    const fullMoveData = {
        ...moveData,
        ...move,
        boosts: move.boosts || moveData.boosts || null,
        target: move.target || moveData.target || 'normal'
    };
    const moveFlags = fullMoveData.flags || {};
    // é¦–å›åˆé™åˆ¶æŠ€èƒ½ï¼šæ£€æŸ¥ flags.failinstruct æˆ–ç‰¹å®šæ¡ä»¶
    // Fake Out, First Impression, Mat Block ç­‰éƒ½æœ‰ onTry é™åˆ¶é¦–å›åˆ
    if (moveFlags.failinstruct || fullMoveData.condition?.duration === 1) {
        // ç®€åŒ–ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯å·²çŸ¥çš„é¦–å›åˆæŠ€èƒ½
        const firstTurnMoves = ['Fake Out', 'First Impression', 'Mat Block'];
        if (firstTurnMoves.includes(moveName) && attacker.turnsOnField > 0) {
            return -8888; // å·²è¿‡é¦–å›åˆï¼Œé€‰äº†ä¹Ÿä¼šå¤±è´¥
        }
    }
    // ç¡çœ çŠ¶æ€æ‰èƒ½ç”¨çš„æŠ€èƒ½ï¼šæ£€æŸ¥ flags.sleeptalk æˆ– sleepUsable
    if (moveFlags.nosleeptalk === undefined && (moveName === 'Sleep Talk' || moveName === 'Snore')) {
        if (attacker.status !== 'slp') {
            return -5000;
        }
    }
    // éœ€è¦å¯¹æ‰‹ç¡çœ çš„æŠ€èƒ½ï¼šæ£€æŸ¥ onTryImmunity æˆ– condition
    if (fullMoveData.sleepUsable || moveName === 'Dream Eater') {
        if (defender.status !== 'slp') {
            return -5000;
        }
    }
    // =========================================================
    // 3. æ ¸å¿ƒæˆ˜æœ¯å¼ºåˆ¶æ‰§è¡Œ (Force Setup Logic)
    // ä½¿ç”¨ moves-data.js æ•°æ®é©±åŠ¨åˆ¤æ–­æŠ€èƒ½ç±»å‹
    // =========================================================
    const itemName = (attacker.item || '').toLowerCase().replace(/[^a-z]/g, '');
    const hasFocusSash = itemName === 'focussash';
    const hpPercent = attacker.currHp / attacker.maxHp;
    // [A] åœºåœ°æŠ€èƒ½æ£€æµ‹ (pseudoWeather ç±»)
    // Trick Room, Magic Room, Wonder Room, Gravity ç­‰
    if (fullMoveData.pseudoWeather) {
        const fieldType = fullMoveData.pseudoWeather;
        // æ£€æŸ¥åœºåœ°æ˜¯å¦å·²å¼€å¯
        if (typeof battle !== 'undefined' && battle.field && battle.field[fieldType] > 1) {
            console.log(`[AI TACTIC] ${fieldType} å·²å¼€å¯ï¼Œä¸å†ä½¿ç”¨`);
            return -9999;
        }
        // Trick Room ç‰¹æ®Šå¤„ç†ï¼šç©ºé—´é˜Ÿæ ¸å¿ƒ
        if (fieldType === 'trickroom' && (hpPercent >= 0.4 || hasFocusSash)) {
            console.log(`[AI TACTIC] ${attacker.cnName} å¿…é¡»å¼€ Trick Roomï¼`);
            return 50000;
        }
        // å…¶ä»–åœºåœ°æŠ€èƒ½
        if (hpPercent >= 0.5) {
            return 25000;
        }
    }
    // [B] åœºåœ°æŠ€èƒ½ (sideCondition ç±»)
    // åˆ†ä¸¤ç±»ï¼šå·±æ–¹åœºåœ°ï¼ˆTailwind, Reflect, Light Screen, Aurora Veilï¼‰å’Œæ•Œæ–¹åœºåœ°ï¼ˆé’‰å­ç±»ï¼‰
    if (fullMoveData.sideCondition) {
        const sideType = fullMoveData.sideCondition;
        const target = fullMoveData.target || 'foeSide';
        const isAiAttacker = typeof battle !== 'undefined' && attacker !== battle.getPlayer?.();
        // æ ¹æ® target å­—æ®µåˆ¤æ–­ä½œç”¨äºå“ªä¸€æ–¹åœºåœ°
        let targetSide = null;
        if (target === 'foeSide') {
            // é’‰å­ç±»ï¼šAI æ’’é’‰å­ä½œç”¨äºç©å®¶åœºåœ°
            targetSide = isAiAttacker ? battle.playerSide : battle.enemySide;
        } else if (target === 'allySide' || target === 'self') {
            // å·±æ–¹å¢ç›Šï¼šAI ä½¿ç”¨ä½œç”¨äºå·±æ–¹åœºåœ°
            targetSide = isAiAttacker ? battle.enemySide : battle.playerSide;
        }
        // === é’‰å­ç±»æŠ€èƒ½ï¼šæ£€æŸ¥æ˜¯å¦å·²æ»¡å±‚ ===
        if (['stealthrock', 'spikes', 'toxicspikes', 'stickyweb'].includes(sideType) && targetSide) {
            // æ£€æŸ¥å„ç±»é’‰å­çš„ä¸Šé™
            if (sideType === 'spikes' && (targetSide.spikes || 0) >= 3) {
                console.log(`[AI BAN] Spikes å·²æ»¡3å±‚ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'toxicspikes' && (targetSide.toxicspikes || targetSide.toxicSpikes || 0) >= 2) {
                console.log(`[AI BAN] Toxic Spikes å·²æ»¡2å±‚ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'stealthrock' && targetSide.stealthRock) {
                console.log(`[AI BAN] Stealth Rock å·²å­˜åœ¨ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'stickyweb' && targetSide.stickyWeb) {
                console.log(`[AI BAN] Sticky Web å·²å­˜åœ¨ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            // === å…³é”®ä¿®å¤ï¼šå¯¹æ‰‹æ­£åœ¨å¼ºåŒ–æ—¶ï¼Œé™ä½æ’’é’‰å­çš„ä¼˜å…ˆçº§ ===
            // å¦‚æœå¯¹æ‰‹æ”»å‡»ç­‰çº§ >= 2ï¼Œæ’’é’‰å­å°±æ˜¯é€æ­»è¡Œä¸º
            const defenderBoosts = defender.boosts || {};
            const defenderAtkBoost = defenderBoosts.atk || 0;
            const defenderSpaBoost = defenderBoosts.spa || 0;
            if (defenderAtkBoost >= 2 || defenderSpaBoost >= 2) {
                console.log(`[AI TACTIC] å¯¹æ‰‹å·²å¼ºåŒ– (atk:${defenderAtkBoost}, spa:${defenderSpaBoost})ï¼Œæ”¾å¼ƒæ’’é’‰å­`);
                return -500; // å¤§å¹…é™ä½ä¼˜å…ˆçº§ï¼Œè½¬è€Œæ”»å‡»
            }
            // é¦–å‘æ’’é’‰ï¼šåªæœ‰è¡€é‡å¥åº·ä¸”å¯¹æ‰‹æ²¡å¼ºåŒ–æ—¶æ‰æ’’
            if (hpPercent >= 0.9) {
                console.log(`[AI TACTIC] ${attacker.cnName} é¦–å‘æ’’é’‰: ${moveName}`);
                return 2500 + Math.random() * 500;
            }
            // éé¦–å‘ä¸æ’’é’‰å­
            return -100;
        }
        // === å·±æ–¹å¢ç›Šç±»æŠ€èƒ½ ===
        if (targetSide) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆå·±æ–¹å¢ç›Šç±»ï¼‰
            const keyMap = {
                'tailwind': 'tailwind',
                'reflect': 'reflect', 
                'lightscreen': 'lightScreen',
                'auroraveil': 'auroraVeil'
            };
            const key = keyMap[sideType] || sideType;
            if (targetSide[key] > 0) {
                return -500; // å·²å­˜åœ¨ï¼Œä¸é‡å¤ä½¿ç”¨
            }
        }
        // é¡ºé£ï¼šé«˜ä¼˜å…ˆçº§
        if (sideType === 'tailwind' && hpPercent >= 0.5) {
            return 40000;
        }
        // åŒå¢™/æå…‰å¹•ï¼šé«˜ä¼˜å…ˆçº§
        if (['reflect', 'lightscreen', 'auroraveil'].includes(sideType) && hpPercent >= 0.6) {
            console.log(`[AI TACTIC] ${attacker.cnName} å¼€å¯é˜²æŠ¤å¢™: ${moveName}`);
            return 15000;
        }
    }
    // [C] å¤©æ°”æŠ€èƒ½æ£€æµ‹ (weather ç±»)
    if (fullMoveData.weather) {
        if (hpPercent >= 0.5) {
            return 30000;
        }
    }
    // [D] å‚¬çœ æŠ€èƒ½æ£€æµ‹ (status: 'slp')
    if (fullMoveData.status === 'slp') {
        if (!defender.status && (!defender.volatile || !defender.volatile.yawn)) {
            // æ ¹æ®å‘½ä¸­ç‡ç»™åˆ†ï¼š100% å‘½ä¸­çš„æ›´é«˜åˆ†
            const accuracy = fullMoveData.accuracy === true ? 100 : (fullMoveData.accuracy || 75);
            const sleepBonus = accuracy >= 100 ? 8000 : (accuracy >= 75 ? 6000 : 4000);
            console.log(`[AI TACTIC] ${attacker.cnName} å°è¯•å‚¬çœ : ${moveName} (å‘½ä¸­ç‡: ${accuracy})`);
            return sleepBonus;
        } else {
            return -500;
        }
    }
    // [E] å¼ºåŒ–æŠ€èƒ½æ£€æµ‹ (boosts ä¸” target: 'self')
    const isSelfBoost = fullMoveData.boosts && 
        ['self', 'allySide', 'adjacentAllyOrSelf'].includes(fullMoveData.target);
    // ã€è°ƒè¯•ã€‘è¾“å‡ºå¼ºåŒ–æŠ€æ£€æµ‹ä¿¡æ¯
    if (moveName === 'Iron Defense' || moveName === 'Swords Dance' || moveName === 'Calm Mind') {
        console.log(`[AI BOOST DEBUG] ${moveName}: boosts=`, fullMoveData.boosts, 'target=', fullMoveData.target, 'isSelfBoost=', isSelfBoost);
        console.log(`[AI BOOST DEBUG] attacker.boosts=`, attacker.boosts);
    }
    if (isSelfBoost) {
        const boosts = fullMoveData.boosts;
        // æ£€æŸ¥ä¸»è¦å¼ºåŒ–çš„èƒ½åŠ›
        const atkBoost = boosts.atk || 0;
        const spaBoost = boosts.spa || 0;
        const speBoost = boosts.spe || 0;
        const defBoost = boosts.def || 0;
        const spdBoost = boosts.spd || 0;
        // ã€ä¿®å¤ã€‘æ£€æŸ¥æ‰€æœ‰æ­£é¢å¼ºåŒ–æ˜¯å¦å·²æ»¡çº§ (+6)
        // å¦‚æœè¯¥æŠ€èƒ½å¼ºåŒ–çš„èƒ½åŠ›å·²ç»æ»¡çº§ï¼Œç›´æ¥è¿”å›è´Ÿåˆ†
        const currentBoosts = attacker.boosts || {};
        for (const stat of Object.keys(boosts)) {
            const boostValue = boosts[stat];
            if (boostValue > 0) { // åªæ£€æŸ¥æ­£é¢å¼ºåŒ–
                const currentValue = currentBoosts[stat] || 0;
                console.log(`[AI BOOST CHECK] ${moveName}: ${stat} boost=${boostValue}, current=${currentValue}`);
                if (currentValue >= 6) {
                    console.log(`[AI TACTIC] ${attacker.cnName} çš„ ${stat} å·²æ»¡çº§ (+6)ï¼Œç¦æ­¢ä½¿ç”¨ ${moveName}`);
                    return -9999; // æ»¡çº§åç»å¯¹ä¸èƒ½å†ç”¨
                }
            }
        }
        // ã€å…³é”®ä¿®å¤ã€‘å¨èƒæ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹é€Ÿåº¦æ›´å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½ï¼Œä¸è¦å¼ºåŒ–
        const mySpeed = getEffectiveSpeed(attacker);
        const oppSpeed = getEffectiveSpeed(defender);
        const playerFaster = oppSpeed > mySpeed;
        if (playerFaster) {
            // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æœ‰å…‹åˆ¶æŠ€èƒ½
            let hasSuper = false;
            for (const pMove of (defender.moves || [])) {
                const pMoveType = pMove.type || 'Normal';
                const eff = getTypeEffectivenessAI(pMoveType, attacker.types || ['Normal']);
                if (eff >= 2) {
                    hasSuper = true;
                    break;
                }
            }
            // å¦‚æœå¯¹æ–¹é€Ÿåº¦å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½ï¼Œå¼ºåŒ–æ˜¯è‡ªæ€è¡Œä¸º
            if (hasSuper) {
                console.log(`[AI TACTIC] ${attacker.cnName} æ”¾å¼ƒå¼ºåŒ–ï¼šå¯¹æ–¹é€Ÿåº¦å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½`);
                return -500;
            }
            // å³ä½¿æ²¡æœ‰å…‹åˆ¶ï¼Œæ£€æŸ¥æ˜¯å¦ä¼šè¢« 2HKO
            let maxIncoming = 0;
            for (const pMove of (defender.moves || [])) {
                const mergedMove = getMergedMoveData(pMove);
                const dmgResult = simulateDamage(defender, attacker, mergedMove);
                if (dmgResult.damage > maxIncoming) maxIncoming = dmgResult.damage;
            }
            if (maxIncoming * 2 >= attacker.currHp) {
                console.log(`[AI TACTIC] ${attacker.cnName} æ”¾å¼ƒå¼ºåŒ–ï¼šä¼šè¢« 2HKO (${maxIncoming}x2 >= ${attacker.currHp})`);
                return -500;
            }
        }
        // æ”»å‡»/ç‰¹æ”»å¼ºåŒ–
        if (atkBoost > 0 || spaBoost > 0) {
            const relevantStat = atkBoost > 0 ? 'atk' : 'spa';
            const currentBoost = (attacker.boosts && attacker.boosts[relevantStat]) || 0;
            // å·²ç» +2 æˆ–æ›´é«˜ï¼Œåœæ­¢å¼ºåŒ–
            if (currentBoost >= 2) {
                console.log(`[AI TACTIC] ${attacker.cnName} å·²å¼ºåŒ– ${currentBoost} çº§ï¼Œåœæ­¢å¼ºåŒ–`);
                return -100;
            }
            // è¡€é‡å¥åº·æ—¶å¼ºåŒ–
            if (hpPercent >= 0.8) {
                console.log(`[AI TACTIC] ${attacker.cnName} å®‰å…¨å¼ºåŒ–: ${moveName}`);
                return 3500;
            } else if (hpPercent >= 0.5) {
                return 1500;
            }
        }
        // é€Ÿåº¦å¼ºåŒ–ï¼ˆé¾™èˆã€è¶èˆç­‰ï¼‰
        if (speBoost > 0 && (atkBoost > 0 || spaBoost > 0)) {
            if (hpPercent >= 0.7) {
                return 4000; // é¾™èˆç±»æ›´æœ‰ä»·å€¼
            }
        }
    }
    const category = (move.cat || move.category || '').toLowerCase();
    const isStatus = category === 'status' || move.power === 0 || move.basePower === 0;
    const MC = (typeof MOVE_CONSTANTS !== 'undefined') ? MOVE_CONSTANTS : {};
    // =========================================================
    // ã€Anti-Spam ä¿®æ­£ã€‘æ›¿èº« (Substitute) ç‰¹æ®Šå¤„ç†
    // é˜²æ­¢ AI æ— é™å¾ªç¯ä½¿ç”¨æ›¿èº«
    // =========================================================
    if (moveName === 'Substitute') {
        // 1. è¡€é‡è¿‡ä½ç»å¯¹ä¸ç”¨ï¼ˆ< 30%ï¼‰
        if (hpPercent < 0.30) {
            console.log(`[AI BAN] ${attacker.cnName} è¡€é‡è¿‡ä½ (${Math.round(hpPercent * 100)}%)ï¼Œç¦æ­¢ä½¿ç”¨æ›¿èº«`);
            return -9999;
        }
        // 2. å·²æœ‰æ›¿èº«ç»å¯¹ä¸ç”¨
        if (attacker.volatile && attacker.volatile.substitute && attacker.volatile.substitute > 0) {
            console.log(`[AI BAN] ${attacker.cnName} å·²æœ‰æ›¿èº«ï¼Œç¦æ­¢é‡å¤ä½¿ç”¨`);
            return -9999;
        }
        // 3. è¿ç»­ä½¿ç”¨æƒ©ç½šï¼šå¦‚æœä¸Šå›åˆç”¨äº†æ›¿èº«ï¼Œå¤§å¹…é™åˆ†
        if (attacker.lastMoveUsed === 'Substitute') {
            console.log(`[AI PENALTY] ${attacker.cnName} ä¸Šå›åˆå·²ç”¨æ›¿èº«ï¼Œé™ä½ä¼˜å…ˆçº§`);
            return -500;
        }
        // 4. è¡€é‡ä¸­ç­‰æ—¶ï¼ˆ30%-50%ï¼‰ï¼Œæ›¿èº«ä»·å€¼é™ä½
        if (hpPercent < 0.50) {
            return 20; // ä½ä¼˜å…ˆçº§
        }
        // 5. å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œä¸è¦ç”¨æ›¿èº«ï¼Œåº”è¯¥è¿›æ”»
        const defenderHpPercent = defender.currHp / defender.maxHp;
        if (defenderHpPercent < 0.30) {
            console.log(`[AI TACTIC] å¯¹æ‰‹æ®‹è¡€ï¼Œ${attacker.cnName} åº”è¯¥è¿›æ”»è€Œéæ›¿èº«`);
            return -200;
        }
        // 6. æ­£å¸¸æƒ…å†µä¸‹æ›¿èº«æ˜¯ä¸­ç­‰ä¼˜å…ˆçº§
        return 50;
    }
    // === å˜åŒ–æŠ€è¯„åˆ† ===
    if (isStatus) {
        let statusScore = 10;
        // =========================================================
        // ã€Critical Fixã€‘è‡ªæˆ‘ç‰ºç‰²æŠ€èƒ½ (Memento, Healing Wish, Lunar Dance)
        // æ£€æŸ¥ selfdestruct å­—æ®µï¼Œé˜²æ­¢æ— æ•ˆä½¿ç”¨å¯¼è‡´æ­»å¾ªç¯
        // =========================================================
        if (fullMoveData.selfdestruct) {
            // Memento: é™ä½å¯¹æ‰‹æ”»å‡»å’Œç‰¹æ”»å„2çº§
            if (fullMoveData.boosts) {
                const targetBoosts = defender.boosts || {};
                let canLowerStats = false;
                // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½é™ä½ä»»ä½•å±æ€§
                for (const [stat, value] of Object.entries(fullMoveData.boosts)) {
                    const currentBoost = targetBoosts[stat] || 0;
                    // å¦‚æœå½“å‰ç­‰çº§ > -6ï¼Œè¯´æ˜è¿˜èƒ½é™ä½
                    if (value < 0 && currentBoost > -6) {
                        canLowerStats = true;
                        break;
                    }
                }
                // å¦‚æœæ‰€æœ‰ç›¸å…³å±æ€§éƒ½å·²ç»æ˜¯ -6ï¼Œç¦æ­¢ä½¿ç”¨
                if (!canLowerStats) {
                    console.log(`[AI BAN] ${moveName} æ— æ•ˆï¼šå¯¹æ‰‹å±æ€§å·²é™è‡³æœ€ä½ (atk:${targetBoosts.atk || 0}, spa:${targetBoosts.spa || 0})`);
                    return -99999;
                }
                // åªæœ‰åœ¨å¯¹æ‰‹å¨èƒå¾ˆå¤§ä¸”æˆ‘æ–¹å³å°†å€’ä¸‹æ—¶æ‰ä½¿ç”¨
                const defenderHpPercent = defender.currHp / defender.maxHp;
                const attackerHpPercent = attacker.currHp / attacker.maxHp;
                // å¯¹æ‰‹æ®‹è¡€æ—¶ä¸è¦ç”¨ï¼ˆæµªè´¹ï¼‰
                if (defenderHpPercent < 0.3) {
                    console.log(`[AI BAN] ${moveName}ï¼šå¯¹æ‰‹æ®‹è¡€ï¼Œä¸å€¼å¾—ç‰ºç‰²`);
                    return -9999;
                }
                // è‡ªå·±è¿˜å¥åº·æ—¶ä¸è¦ç”¨
                if (attackerHpPercent > 0.5) {
                    console.log(`[AI BAN] ${moveName}ï¼šè‡ªå·±è¿˜å¥åº·ï¼Œä¸åº”ç‰ºç‰²`);
                    return -9999;
                }
                // åªæœ‰åœ¨è‡ªå·±æ®‹è¡€ä¸”å¯¹æ‰‹å¼ºå¤§æ—¶æ‰è€ƒè™‘
                if (attackerHpPercent <= 0.3 && defenderHpPercent > 0.6) {
                    // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦å·²ç»è¢«å‰Šå¼±
                    const atkDebuff = targetBoosts.atk || 0;
                    const spaDebuff = targetBoosts.spa || 0;
                    if (atkDebuff <= -4 && spaDebuff <= -4) {
                        // å·²ç»å‰Šå¼±å¾—å¤Ÿå¤šäº†
                        console.log(`[AI BAN] ${moveName}ï¼šå¯¹æ‰‹å·²è¢«å……åˆ†å‰Šå¼± (atk:${atkDebuff}, spa:${spaDebuff})`);
                        return -9999;
                    }
                    // å¯ä»¥ä½¿ç”¨ï¼Œä½†ä¼˜å…ˆçº§ä¸é«˜
                    return 30;
                }
                // å…¶ä»–æƒ…å†µä¸ä½¿ç”¨
                return -9999;
            }
            // Healing Wish / Lunar Dance: åªåœ¨æœ‰åå¤‡ä¸”è‡ªå·±æ®‹è¡€æ—¶ä½¿ç”¨
            if (moveName === 'Healing Wish' || moveName === 'Lunar Dance') {
                if (hpPercent > 0.2) {
                    return -9999; // è¡€é‡è¿˜è¡Œï¼Œä¸ç‰ºç‰²
                }
                // éœ€è¦æ£€æŸ¥æ˜¯å¦æœ‰åå¤‡å®å¯æ¢¦ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
                return 20;
            }
        }
        // å¼ºåŒ–æŠ€èƒ½
        const boostMoves = MC.AI_BOOST_MOVES || ['Swords Dance', 'Calm Mind', 'Dragon Dance', 'Nasty Plot'];
        if (boostMoves.includes(moveName)) {
            const relevantBoost = attacker.spa > attacker.atk ? (attacker.boosts?.spa || 0) : (attacker.boosts?.atk || 0);
            if (relevantBoost < 2) statusScore = 80 + Math.random() * 20;
            else if (relevantBoost < 4) statusScore = 40 + Math.random() * 20;
            else statusScore = 5;
        }
        // çŠ¶æ€æŠ€èƒ½
        const statusInflict = MC.AI_STATUS_MOVES || ['Thunder Wave', 'Will-O-Wisp', 'Toxic', 'Spore'];
        const sleepMoves = MC.AI_SLEEP_MOVES || ['Spore', 'Sleep Powder', 'Hypnosis', 'Sing'];
        const paralyzeMoves = MC.AI_PARALYZE_MOVES || ['Thunder Wave', 'Glare', 'Stun Spore'];
        if (statusInflict.includes(moveName)) {
            if (!defender.status) {
                if (sleepMoves.includes(moveName)) {
                    statusScore = 70 + Math.random() * 30;
                } else if (paralyzeMoves.includes(moveName)) {
                    statusScore = defender.spe > attacker.spe ? 60 + Math.random() * 20 : 30 + Math.random() * 20;
                } else if (moveName === 'Will-O-Wisp') {
                    statusScore = defender.atk > defender.spa ? 65 + Math.random() * 20 : 25 + Math.random() * 15;
                } else if (moveName === 'Toxic') {
                    statusScore = 50 + Math.random() * 20;
                }
            } else {
                statusScore = -100;
            }
        }
        // å›å¤æŠ€èƒ½
        const healMoves = MC.AI_HEAL_MOVES || ['Recover', 'Roost', 'Soft-Boiled', 'Slack Off'];
        if (healMoves.includes(moveName)) {
            const hpPercent = attacker.currHp / attacker.maxHp;
            const defenderHpPercent = defender.currHp / defender.maxHp;
            // ã€ä¿®æ­£ã€‘å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œå¤§å¹…é™ä½å›è¡€æŠ€èƒ½ä¼˜å…ˆçº§
            if (defenderHpPercent < 0.25 && hpPercent > 0.4) {
                // å¯¹æ‰‹å¿«æ­»äº†ï¼Œæˆ‘è¿˜å¥åº·ï¼Œä¸è¦å›è¡€ï¼å»è¾“å‡ºï¼
                statusScore = -500;
            } else if (hpPercent < 0.3) {
                statusScore = 90 + Math.random() * 10;
            } else if (hpPercent < 0.5) {
                statusScore = 60 + Math.random() * 20;
            } else if (hpPercent < 0.7) {
                statusScore = 30 + Math.random() * 15;
            } else {
                statusScore = 5;
            }
        }
        // ã€æ–°å¢ã€‘åä¼¤æŠ€èƒ½é¢„æµ‹è¯„åˆ† (Mirror Coat / Counter / Metal Burst)
        const counterMoves = ['Mirror Coat', 'Counter', 'Metal Burst'];
        if (counterMoves.includes(moveName)) {
            const defenderHpPercent = defender.currHp / defender.maxHp;
            // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œåä¼¤æŠ€èƒ½æ¯«æ— æ„ä¹‰ï¼ˆå¯¹é¢å¯èƒ½ç›´æ¥æ¢äººæˆ–ç”¨å˜åŒ–æŠ€ï¼‰
            if (defenderHpPercent < 0.25) {
                return -9999;
            }
            // é¢„æµ‹å¯¹æ‰‹çš„æ”»å‡»ç±»å‹
            const defenderIsSpecialAttacker = (defender.baseStats?.spa || defender.spa || 0) > (defender.baseStats?.atk || defender.atk || 0);
            const defenderIsPhysicalAttacker = (defender.baseStats?.atk || defender.atk || 0) > (defender.baseStats?.spa || defender.spa || 0);
            // Mirror Coatï¼šåªå¯¹ç‰¹æ”»æ‰‹æœ‰æ•ˆ
            if (moveName === 'Mirror Coat') {
                if (defenderIsSpecialAttacker) {
                    // é¢„æµ‹å¯¹æ‰‹ä¼šç”¨ç‰¹æ®Šæ”»å‡»ï¼ŒMirror Coat æœ‰ä»·å€¼
                    const predictedDamage = attacker.maxHp * 0.35; // å‡è®¾å—åˆ° 35% HP ä¼¤å®³
                    const estimatedReturn = predictedDamage * 2;
                    statusScore = 40 + (estimatedReturn / defender.maxHp) * 100;
                } else if (defenderIsPhysicalAttacker) {
                    // å¯¹é¢æ˜¯ç‰©ç†æ‰‹ï¼ŒMirror Coat æ— ç”¨
                    return -9999;
                } else {
                    // ä¸ç¡®å®šï¼Œç»™ä¸ªä¸­ç­‰åˆ†æ•°
                    statusScore = 20;
                }
            }
            // Counterï¼šåªå¯¹ç‰©ç†æ‰‹æœ‰æ•ˆ
            if (moveName === 'Counter') {
                if (defenderIsPhysicalAttacker) {
                    const predictedDamage = attacker.maxHp * 0.35;
                    const estimatedReturn = predictedDamage * 2;
                    statusScore = 40 + (estimatedReturn / defender.maxHp) * 100;
                } else if (defenderIsSpecialAttacker) {
                    return -9999;
                } else {
                    statusScore = 20;
                }
            }
            // Metal Burstï¼šé€šç”¨åä¼¤ï¼Œä½†éœ€è¦åæ‰‹
            if (moveName === 'Metal Burst') {
                const attackerSpeed = attacker.spe || attacker.baseStats?.spe || 100;
                const defenderSpeed = defender.spe || defender.baseStats?.spe || 100;
                if (attackerSpeed < defenderSpeed) {
                    // æˆ‘æ¯”å¯¹æ‰‹æ…¢ï¼ŒMetal Burst æœ‰æ•ˆ
                    statusScore = 50;
                } else {
                    // æˆ‘æ¯”å¯¹æ‰‹å¿«ï¼ŒMetal Burst æ— æ•ˆ
                    return -5000;
                }
            }
        }
        // å®ˆä½ç±» - è€ƒè™‘è¿ç»­ä½¿ç”¨æƒ©ç½š
        const protectMoves = MC.AI_PROTECT_MOVES || ['Protect', 'Detect', 'King\'s Shield', 'Spiky Shield', 'Baneful Bunker', 'Obstruct', 'Silk Trap'];
        if (protectMoves.includes(moveName)) {
            // æ£€æŸ¥è¿ç»­ä½¿ç”¨æƒ©ç½š
            const protectCounter = attacker.protectCounter || 0;
            if (protectCounter > 0) {
                // è¿ç»­ä½¿ç”¨æˆåŠŸç‡å¾ˆä½ï¼ŒAI åº”è¯¥é¿å…
                const successChance = Math.pow(1/3, protectCounter);
                if (successChance < 0.34) {
                    // æˆåŠŸç‡ä½äº 34%ï¼Œä¸å€¼å¾—å†’é™©
                    return -100;
                }
            }
            if (defender.status === 'psn' || defender.status === 'tox' || defender.status === 'brn') {
                statusScore = 40 + Math.random() * 30;
            } else {
                statusScore = 15 + Math.random() * 15;
            }
        }
        // é¦–å›åˆé™åˆ¶æŠ€èƒ½æ£€æŸ¥
        const firstTurnMoves = ['Fake Out', 'First Impression', 'Mat Block'];
        if (firstTurnMoves.includes(moveName)) {
            if ((attacker.turnsOnField || 0) > 0) {
                return -9999; // éé¦–å›åˆï¼Œå¿…å®šå¤±è´¥
            }
        }
        // åŒå‘½è¿ç»­ä½¿ç”¨é™åˆ¶
        if (moveName === 'Destiny Bond' && attacker.lastMoveUsed === 'Destiny Bond') {
            return -9999; // è¿ç»­ä½¿ç”¨å¿…å¤±è´¥
        }
        // åƒµç›´çŠ¶æ€æ£€æŸ¥
        if (attacker.mustRecharge) {
            return -9999; // éœ€è¦ä¼‘æ¯ï¼Œæ— æ³•è¡ŒåŠ¨
        }
        return statusScore;
    }
    // === æ”»å‡»æŠ€èƒ½è¯„åˆ†ï¼ˆä½¿ç”¨è½¯ç¼–ç çš„ evaluateMoveImpactï¼‰===
    const impact = evaluateMoveImpact(attacker, defender, move);
    const eff = impact.effectiveness;
    // å…ç–«æ—¶ç›´æ¥è¿”å›æä½åˆ†
    if (eff === 0) return -9999;
    let score = impact.totalScore;
    // =========================================================
    // ã€AI æ™ºå•†è¡¥æ­£ã€‘Contrary (å”±åè°ƒ) ç‰¹æ€§ä¸“é—¨å¢å¼º
    // è‡ªé™èƒ½åŠ›çš„æŠ€èƒ½åœ¨å”±åè°ƒä¸‹å˜æˆè‡ªæˆ‘å¼ºåŒ–
    // =========================================================
    const attackerAbility = (attacker.ability || '').toLowerCase();
    const isContrary = attackerAbility === 'contrary';
    if (isContrary) {
        // è½¯ç¼–ç ï¼šä» fullMoveData.self.boosts ä¸­æ£€æµ‹è‡ªé™èƒ½åŠ›
        const selfBoosts = fullMoveData.self?.boosts || {};
        let hasSelfDebuff = false;
        let debuffValue = 0;
        // æ£€æŸ¥æ‰€æœ‰è‡ªé™èƒ½åŠ›
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            const boost = selfBoosts[stat] || 0;
            if (boost < 0) {
                hasSelfDebuff = true;
                debuffValue += Math.abs(boost);
            }
        }
        // å¦‚æœæœ‰è‡ªé™èƒ½åŠ›ï¼Œåœ¨å”±åè°ƒä¸‹å˜æˆå¼ºåŒ–
        if (hasSelfDebuff) {
            // æ¯çº§è‡ªé™å˜æˆ +1 å¼ºåŒ–ï¼Œä»·å€¼æé«˜
            const contraryBonus = debuffValue * 800; // æ¯çº§ +800 åˆ†
            score += contraryBonus;
            console.log(`[AI CONTRARY] ${attacker.cnName} çš„ ${moveName} å› å”±åè°ƒè·å¾— +${contraryBonus} åˆ† (è‡ªé™ ${debuffValue} çº§)`);
            // ç‰¹åˆ«åŠ æˆï¼šLeaf Storm / Overheat ç­‰ -2 ç‰¹æ”»çš„æŠ€èƒ½
            if (selfBoosts.spa === -2 || selfBoosts.atk === -2) {
                score += 500; // é¢å¤–åŠ æˆï¼Œå› ä¸ºè¿™ç±»æŠ€èƒ½å¨åŠ›æœ¬èº«å°±é«˜
                console.log(`[AI CONTRARY] ${moveName} æ˜¯é¡¶çº§å¼ºåŒ–æŠ€ï¼Œé¢å¤– +500 åˆ†`);
            }
        }
    }
    // ã€åå‘é€»è¾‘ã€‘éå”±åè°ƒæ—¶ï¼Œè‡ªé™èƒ½åŠ›æŠ€èƒ½åº”è¯¥é€‚å½“å‡åˆ†
    else {
        const selfBoosts = fullMoveData.self?.boosts || {};
        let debuffPenalty = 0;
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            const boost = selfBoosts[stat] || 0;
            if (boost < 0) {
                // é™æ”»å‡»/ç‰¹æ”»æƒ©ç½šæ›´é‡
                if (stat === 'atk' || stat === 'spa') {
                    debuffPenalty += Math.abs(boost) * 100;
                } else {
                    debuffPenalty += Math.abs(boost) * 50;
                }
            }
        }
        if (debuffPenalty > 0) {
            score -= debuffPenalty;
        }
    }
    // =========================================================
    // ã€Extension 1ã€‘æ¡ä»¶å¢ä¼¤æŠ€èƒ½é€»è¾‘ (Variable Power)
    // Hex, Venoshock, Foul Play, Body Press, Gyro Ball ç­‰
    // =========================================================
    let damageMultiplier = 1.0;
    // 1.1 çŠ¶æ€æ–½åŠ å¢ä¼¤ (Facade, Hex, Venoshock, Wake-Up Slap)
    if (moveName === 'Facade' && (attacker.status === 'brn' || attacker.status === 'par' || attacker.status === 'psn' || attacker.status === 'tox')) {
        damageMultiplier = 2.0;
        if (attacker.status === 'brn') score += 1000; // çƒ§ä¼¤æ—¶ç¡¬æ’‘æ— è§†å‡åŠ
    }
    if (moveName === 'Hex' && defender.status) {
        damageMultiplier = 2.0;
        console.log(`[AI VAR] Hex å¯¹å¼‚å¸¸çŠ¶æ€ç›®æ ‡å¨åŠ›ç¿»å€`);
    }
    if (moveName === 'Venoshock' && (defender.status === 'psn' || defender.status === 'tox')) {
        damageMultiplier = 2.0;
    }
    if (moveName === 'Wake-Up Slap' && defender.status === 'slp') {
        damageMultiplier = 2.0;
    }
    if (moveName === 'Brine' && defender.currHp <= defender.maxHp / 2) {
        damageMultiplier = 2.0;
    }
    // 1.2 åˆ©ç”¨å¯¹æ‰‹å±æ€§è®¡ç®— (Foul Play / Body Press / Power Trip / Stored Power)
    if (moveName === 'Foul Play') {
        const enemyAtk = defender.atk || defender.baseStats?.atk || 50;
        const myAtk = attacker.atk || 50;
        if (enemyAtk > myAtk) {
            damageMultiplier = enemyAtk / myAtk;
            console.log(`[AI VAR] Foul Play ä½¿ç”¨å¯¹æ‰‹æ”»å‡»åŠ›: x${damageMultiplier.toFixed(1)}`);
        }
    }
    if (moveName === 'Body Press') {
        const myDef = attacker.def || 50;
        const myAtk = attacker.atk || 50;
        if (myDef > myAtk) {
            damageMultiplier = myDef / myAtk;
            console.log(`[AI VAR] Body Press ä½¿ç”¨è‡ªèº«é˜²å¾¡: x${damageMultiplier.toFixed(1)}`);
        }
    }
    if (moveName === 'Power Trip' || moveName === 'Stored Power') {
        const boosts = attacker.boosts || {};
        let totalBoosts = 0;
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            totalBoosts += Math.max(0, boosts[stat] || 0);
        }
        if (totalBoosts > 0) {
            // æ¯çº§ +20 å¨åŠ›ï¼ŒåŸºç¡€ 20
            const power = 20 + totalBoosts * 20;
            damageMultiplier = power / 20;
            console.log(`[AI VAR] ${moveName} å¼ºåŒ–åŠ æˆ: ${totalBoosts}çº§ -> å¨åŠ›${power}`);
        }
    }
    // 1.3 é€Ÿåº¦ç±»æŠ€èƒ½ (Gyro Ball / Electro Ball)
    if (moveName === 'Gyro Ball') {
        const oppSpeed = getEffectiveSpeed(defender) || 1;
        const mySpeed = getEffectiveSpeed(attacker) || 1;
        const power = Math.min(150, Math.floor(25 * (oppSpeed / mySpeed)));
        if (power > (move.basePower || 80)) {
            damageMultiplier = power / (move.basePower || 80);
            console.log(`[AI VAR] Gyro Ball é€Ÿåº¦å·®è®¡ç®—: å¨åŠ›${power}`);
        }
    }
    if (moveName === 'Electro Ball') {
        const oppSpeed = getEffectiveSpeed(defender) || 1;
        const mySpeed = getEffectiveSpeed(attacker) || 1;
        const diff = mySpeed / oppSpeed;
        let power = 60;
        if (diff >= 4) power = 150;
        else if (diff >= 3) power = 120;
        else if (diff >= 2) power = 80;
        damageMultiplier = power / 60;
    }
    // 1.4 ä½“é‡ç±»æŠ€èƒ½ (Grass Knot / Low Kick / Heavy Slam / Heat Crash)
    if (moveName === 'Grass Knot' || moveName === 'Low Kick') {
        // ç®€åŒ–ï¼šå‡è®¾é‡å‹å®å¯æ¢¦å¨åŠ›æ›´é«˜
        const defenderWeight = defender.baseStats?.hp || 80; // ç”¨ HP è¿‘ä¼¼ä½“é‡
        if (defenderWeight > 100) damageMultiplier = 1.5;
        if (defenderWeight > 150) damageMultiplier = 2.0;
    }
    // 1.5 åº”ç”¨æ¡ä»¶å¢ä¼¤ä¿®æ­£
    if (damageMultiplier > 1.0) {
        const bonusDmg = impact.rawDamage * (damageMultiplier - 1);
        if ((impact.rawDamage + bonusDmg) >= defender.currHp) {
            score += 3000;
            console.log(`[AI CRITICAL] ${moveName} ç»è¿‡æ¡ä»¶ä¿®æ­£åå¯æ–©æ€!`);
        } else {
            score += Math.min(2000, bonusDmg / attacker.maxHp * 1000);
        }
    }
    // =========================================================
    // ã€Extension 2ã€‘å¤§çˆ†ç‚¸æˆ˜æœ¯é€»è¾‘ (Explosion / Self-Destruct)
    // =========================================================
    if (moveName === 'Explosion' || moveName === 'Self-Destruct' || moveName === 'Misty Explosion') {
        let enemyCount = 1;
        if (typeof battle !== 'undefined' && battle.playerParty) {
            enemyCount = battle.playerParty.filter(p => p && p.currHp > 0).length;
        }
        const canKill = impact.rawDamage >= defender.currHp;
        const myHpPct = attacker.currHp / attacker.maxHp;
        // Case A: è‡ªå·±æ®‹è¡€ï¼ˆ<15%ï¼‰ï¼ŒåºŸç‰©åˆ©ç”¨
        if (myHpPct < 0.15) {
            score += 5000;
            console.log(`[AI EXPLOSION] æ®‹è¡€è‡ªçˆ†: ${moveName} (+5000)`);
        }
        // Case B: èƒ½ç¡®æ€ä¸”å¯¹æ‰‹æ˜¯æœ€åä¸€åª -> ç»ˆç»“æ¯”èµ›
        else if (canKill && enemyCount === 1) {
            score += 10000;
            console.log(`[AI EXPLOSION] ç»ˆç»“æ¯”èµ›: ${moveName} (+10000)`);
        }
        // Case C: èƒ½æ€ä¸”å¯¹æ‰‹å¨èƒå¤§
        else if (canKill && myHpPct < 0.5) {
            score += 2000;
            console.log(`[AI EXPLOSION] ä¸€æ¢ä¸€: ${moveName} (+2000)`);
        }
        // Case D: æ»¡è¡€ä¸”æ€ä¸æ­»å¯¹æ‰‹ -> ä¸¥ç¦ä½¿ç”¨
        else {
            console.log(`[AI BAN] ${moveName} æ€ä¸æ­»äººäºèŠ‚å¥ï¼Œç¦ç”¨`);
            return -9999;
        }
    }
    // =========================================================
    // ã€Extension 3ã€‘çªè¢­é¢„åˆ¤é€»è¾‘ (Sucker Punch / Thunderclap)
    // =========================================================
    if (moveName === 'Sucker Punch' || moveName === 'Thunderclap') {
        // è¿ç»­ä½¿ç”¨æƒ©ç½š
        if (attacker.lastMoveUsed === moveName) {
            console.log(`[AI SMART] è¿ç»­çªè¢­æƒ©ç½š: ${moveName}`);
            score -= 500;
        }
        // é¢„æµ‹å¯¹æ‰‹è¡Œä¸ºï¼šå¦‚æœå¯¹æ‰‹å¨èƒå°ï¼Œå¯èƒ½ç”¨å˜åŒ–æŠ€ï¼Œçªè¢­ä¼šå¤±è´¥
        // ç®€åŒ–åˆ¤æ–­ï¼šå¯¹æ‰‹æ®‹è¡€æ—¶çªè¢­æœ‰æ•ˆï¼ˆæ”¶å‰²ï¼‰ï¼Œå¯¹æ‰‹å¥åº·ä¸”å¨èƒå°æ—¶é£é™©é«˜
        const defHpPct = defender.currHp / defender.maxHp;
        if (defHpPct < 0.2) {
            // å¯¹æ‰‹æ®‹è¡€ï¼Œçªè¢­æ”¶å‰²
            score += 1000;
            console.log(`[AI SMART] çªè¢­æ”¶å‰²æ®‹è¡€: ${moveName} (+1000)`);
        } else if (defHpPct > 0.7) {
            // å¯¹æ‰‹å¥åº·ï¼Œå¯èƒ½ä¼šç”¨å˜åŒ–æŠ€
            // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰å¼ºåŒ–/å›å¤æŠ€èƒ½å€¾å‘
            const defenderIsSetupType = (defender.spa || 0) > (defender.atk || 0) * 1.2 || 
                                        (defender.def || 0) > 100 || (defender.spd || 0) > 100;
            if (defenderIsSetupType) {
                score -= 800;
                console.log(`[AI SMART] å¯¹æ‰‹å¯èƒ½å¼ºåŒ–ï¼Œçªè¢­é£é™©é«˜: ${moveName} (-800)`);
            }
        }
    }
    // =========================================================
    // ã€Extension 4ã€‘ç¡¬ç›´/è“„åŠ›æŠ€èƒ½é£é™©è¯„ä¼°
    // =========================================================
    const rechargeMoves = ['Hyper Beam', 'Giga Impact', 'Hydro Cannon', 'Blast Burn', 'Frenzy Plant', 'Roar of Time', 'Eternabeam', 'Prismatic Laser', 'Meteor Assault'];
    const chargeMoves = ['Solar Beam', 'Solar Blade', 'Meteor Beam', 'Sky Attack', 'Skull Bash'];
    const weather = (typeof battle !== 'undefined' && battle.field) ? battle.field.weather : '';
    // 4.1 ç¡¬ç›´æŠ€èƒ½ (éœ€è¦ä¸‹å›åˆä¸èƒ½åŠ¨)
    if (rechargeMoves.includes(moveName)) {
        if (impact.rawDamage < defender.currHp) {
            // æ‰“ä¸æ­»äººï¼Œä¸‹å›åˆæ˜¯æ´»é¶å­
            score -= 8000;
            console.log(`[AI SMART] ${moveName} æ— æ³•æ–©æ€ï¼Œç¡¬ç›´é£é™©ï¼Œç¦ç”¨`);
        } else {
            // èƒ½æ‰“æ­»ï¼Œä½†ä»æœ‰é£é™©
            score -= 500;
            // ç”¨ç ´åæ­»å…‰æ€æ®‹è¡€æ˜¯æµªè´¹
            if (defender.currHp < 50) {
                score -= 5000;
                console.log(`[AI SMART] æ²¡å¿…è¦ç”¨ ${moveName} æ€æ®‹è¡€`);
            }
        }
    }
    // 4.2 è“„åŠ›æŠ€èƒ½ (Solar Beam ç­‰)
    if (chargeMoves.includes(moveName)) {
        const isSolar = moveName.includes('Solar');
        const hasSun = (weather === 'sunnyday' || weather === 'desolateland');
        const hasHerb = (attacker.item || '').toLowerCase().includes('power herb') || 
                        (attacker.item || '').includes('å¼ºåŠ›é¦™è‰');
        if (isSolar && !hasSun && !hasHerb) {
            // æ²¡æœ‰æ™´å¤©ä¹Ÿæ²¡æœ‰å¼ºåŠ›é¦™è‰ï¼Œè“„åŠ›å›åˆæ˜¯é€
            score -= 5000;
            console.log(`[AI SMART] æ™´å¤©/é¦™è‰ç¼ºå¤±ï¼Œç¦æ­¢è£¸æ‰“ ${moveName}`);
        } else if (hasSun || hasHerb) {
            // å³å‘çŠ¶æ€ï¼Œè¿™æ˜¯å¥½æŠ€èƒ½
            score += 500;
        }
        // Meteor Beam ç‰¹æ®Šå¤„ç†ï¼šè“„åŠ›æ—¶ +1 ç‰¹æ”»
        if (moveName === 'Meteor Beam' && !hasHerb) {
            // æ²¡æœ‰é¦™è‰ä½†èƒ½å¼ºåŒ–ï¼Œé£é™©é™ä½
            score -= 2000; // ä»æœ‰é£é™©ä½†ä¸æ˜¯å®Œå…¨ç¦ç”¨
        }
    }
    // æ–©æ€åŠ åˆ†
    if (impact.rawDamage >= defender.currHp) score += 5000;
    // å…ˆåˆ¶æŠ€æ–©æ€åŠ åˆ†
    const priority = move.priority || 0;
    if (priority > 0 && impact.rawDamage >= defender.currHp) score += 2000;
    // ä½è¡€é‡æ—¶ä¼˜å…ˆå…ˆåˆ¶æŠ€
    const myHpPercent = attacker.currHp / attacker.maxHp;
    if (priority > 0 && myHpPercent < 0.3) score += 500;
    // =========================================================
    // ã€æ–°å¢ã€‘æ–©æ€æ¿€åŠ± (Execution Incentive)
    // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼ŒAI åº”è¯¥ä¼˜å…ˆè¾“å‡ºè€Œä¸æ˜¯å›è¡€/è¾…åŠ©
    // =========================================================
    const defenderHpPercent = defender.currHp / defender.maxHp;
    const defenderIsLowHp = defenderHpPercent < 0.25 || (defender.currHp < 100 && myHpPercent > 0.4);
    if (defenderIsLowHp) {
        // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œæ”»å‡»æŠ€èƒ½å¤§å¹…åŠ åˆ†
        if (category !== 'status' && move.basePower > 0) {
            score += 300; // æ®‹è¡€å¿…æ€åŠ æˆ
            // å¦‚æœèƒ½æ–©æ€ï¼Œå†åŠ åˆ†
            if (impact.rawDamage >= defender.currHp) {
                score += 200; // ç¡®ä¿æ–©æ€ä¼˜å…ˆçº§æœ€é«˜
            }
        }
    }
    // å…‹åˆ¶åŠ åˆ†
    if (eff >= 2) score += 100;
    if (eff >= 4) score += 200;
    // ã€å¼ºåŒ–ã€‘æ•ˆæœä¸å¥½å‡åˆ† - æ›´ä¸¥å‰çš„æƒ©ç½š
    // AI ä¸åº”è¯¥ç”¨æ•ˆæœä¸å¥½çš„æŠ€èƒ½ï¼Œé™¤éæ²¡æœ‰æ›´å¥½çš„é€‰æ‹©
    if (eff <= 0.5 && eff > 0) score -= 200;  // ä» -50 æ”¹ä¸º -200
    if (eff <= 0.25) score -= 500;            // ä» -100 æ”¹ä¸º -500
    // ã€æ–°å¢ã€‘å¦‚æœæœ‰æ›´å¥½çš„å±æ€§å…‹åˆ¶é€‰æ‹©ï¼Œè¿›ä¸€æ­¥æƒ©ç½šæ•ˆæœä¸å¥½çš„æŠ€èƒ½
    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æŠ€èƒ½èƒ½æ‰“å‡ºæ›´å¥½çš„æ•ˆæœ
    if (eff <= 0.5 && attacker.moves && attacker.moves.length > 1) {
        for (const otherMove of attacker.moves) {
            if (otherMove === move) continue;
            const otherMerged = getMergedMoveData(otherMove);
            const otherEff = getTypeEffectivenessAI(otherMerged.type || 'Normal', defender.types || ['Normal']);
            // å¦‚æœæœ‰æ›´å¥½çš„å±æ€§å…‹åˆ¶æŠ€èƒ½ï¼Œå¤§å¹…æƒ©ç½šå½“å‰æŠ€èƒ½
            if (otherEff > eff && (otherMerged.basePower || otherMerged.power || 0) >= 60) {
                score -= 300;
                break;
            }
        }
    }
    // ========================================
    // ã€v2.1ã€‘åä¼¤æŠ€èƒ½æ™ºèƒ½è¯„ä¼° - ç¦æ­¢è‡ªæ€å¼è¢­å‡»
    // ========================================
    const recoilMoveNames = (typeof RECOIL_MOVES !== 'undefined') ? Object.keys(RECOIL_MOVES) : 
        ['Flare Blitz', 'Brave Bird', 'Double-Edge', 'Head Smash', 'Wood Hammer', 'Wild Charge', 'Take Down', 'Submission'];
    // åä¼¤æ¯”ä¾‹è¡¨ (æ‹›å¼å -> åä¼¤æ¯”ä¾‹)
    const RECOIL_RATIOS = {
        'Head Smash': 0.50,      // 50% åä¼¤
        'Light of Ruin': 0.50,   // 50% åä¼¤
        'Flare Blitz': 0.33,     // 33% åä¼¤
        'Brave Bird': 0.33,      // 33% åä¼¤
        'Double-Edge': 0.33,     // 33% åä¼¤
        'Wood Hammer': 0.33,     // 33% åä¼¤
        'Wild Charge': 0.25,     // 25% åä¼¤
        'Take Down': 0.25,       // 25% åä¼¤
        'Submission': 0.25,      // 25% åä¼¤
    };
    if (recoilMoveNames.includes(moveName)) {
        const recoilRatio = RECOIL_RATIOS[moveName] || 0.33;
        const moveDamage = impact.rawDamage || 0;
        const expectedRecoil = Math.floor(moveDamage * recoilRatio);
        // ã€æ ¸å¿ƒé€»è¾‘ã€‘å¦‚æœåä¼¤ä¼šè‡´æ­»
        if (expectedRecoil >= attacker.currHp) {
            // æ£€æŸ¥æ•Œæ–¹å‰©ä½™å­˜æ´»æ•°é‡
            let enemyAliveCount = 1; // è‡³å°‘æœ‰å½“å‰å¯¹æ‰‹
            if (typeof battle !== 'undefined' && battle.playerParty) {
                enemyAliveCount = battle.playerParty.filter(p => p && p.currHp > 0).length;
            }
            // æ£€æŸ¥è¿™ä¸€å‡»èƒ½å¦å‡»æ€å¯¹æ‰‹
            const canKill = moveDamage >= defender.currHp;
            if (canKill && enemyAliveCount <= 1) {
                // åŒå½’äºå°½ä¸”æ˜¯æœ€åä¸€åª -> å‹‡å¾€ç›´å‰ï¼
                score += 3000;
                console.log(`[AI RECOIL] åŒå½’äºå°½æ–©æ€æœ€åä¸€åª: ${moveName} (+3000)`);
            } else if (canKill && enemyAliveCount <= 2) {
                // èƒ½æ€ä½†å¯¹é¢è¿˜æœ‰2åª -> å‹‰å¼ºå¯ä»¥æ¥å—
                score -= 500;
                console.log(`[AI RECOIL] è‡ªæ€æ¢äººå¤´(å¯¹é¢å‰©${enemyAliveCount}): ${moveName} (-500)`);
            } else {
                // è‡ªæ€ä½†æ€ä¸æ‰ æˆ– å¯¹é¢è¿˜æœ‰å¾ˆå¤š -> æåˆ‘ç¦æ­¢
                score -= 8000;
                console.log(`[AI RECOIL] ç¦æ­¢è‡ªæ€å¼è¢­å‡»: ${moveName} (-8000)`);
            }
        } else if (expectedRecoil >= attacker.currHp * 0.5) {
            // åä¼¤ä¼šæ‰ä¸€åŠè¡€ä»¥ä¸Š -> è°¨æ…ä½¿ç”¨
            if (myHpPercent < 0.5) {
                score -= 400;
            }
        } else if (myHpPercent < 0.4) {
            // åŸæœ‰é€»è¾‘ï¼šä½è¡€é‡æ—¶å‡åˆ†
            score -= 200;
        }
    }
    // ========================================
    // v2.0ï¼šæŠ˜è¿”æŠ€èƒ½æˆ˜æœ¯è¯„åˆ†
    // ========================================
    if (PIVOT_MOVES.includes(moveName)) {
        // ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å­˜æ´»é˜Ÿå‹å¯ä»¥æ¢å…¥
        // å¦‚æœæ²¡æœ‰é˜Ÿå‹äº†ï¼ŒæŠ˜è¿”æ¯«æ— æ„ä¹‰ï¼Œåº”è¯¥é€‰æ‹©é«˜ä¼¤å®³æŠ€èƒ½å¯¹æ”»
        let aliveAllies = 0;
        if (aiParty && aiParty.length > 0) {
            for (const ally of aiParty) {
                if (ally && ally !== attacker && ally.isAlive && ally.isAlive()) {
                    aliveAllies++;
                }
            }
        }
        if (aliveAllies === 0) {
            // æ²¡æœ‰é˜Ÿå‹äº†ï¼ŒæŠ˜è¿”æŠ€èƒ½å¤§å¹…å‡åˆ†ï¼ˆåªä¿ç•™åŸºç¡€ä¼¤å®³ä»·å€¼ï¼‰
            console.log(`[AI PIVOT] ${attacker.name} æ²¡æœ‰å­˜æ´»é˜Ÿå‹ï¼Œ${moveName} æŠ˜è¿”æ— æ„ä¹‰ï¼Œå¤§å¹…å‡åˆ†`);
            score -= 500; // å‡åˆ†ï¼Œè®© AI é€‰æ‹©å…¶ä»–é«˜ä¼¤å®³æŠ€èƒ½
        } else {
            // æœ‰é˜Ÿå‹æ—¶ï¼Œæ­£å¸¸è®¡ç®—æŠ˜è¿”åŠ åˆ†
            // åŸºç¡€å¥–åŠ±ï¼šçµæ´»æ€§æ€»æ˜¯å¥½çš„
            score += 300;
            const attackerSpeed = getEffectiveSpeed(attacker);
            const defenderSpeed = getEffectiveSpeed(defender);
            const isFaster = attackerSpeed > defenderSpeed;
            const isSlower = attackerSpeed < defenderSpeed;
            // å…ˆæ‰‹æŠ˜è¿” (Fast Pivot)ï¼šæ”¶å‰²æ®‹è¡€åå®‰å…¨æ’¤é€€
            if (isFaster && defender.currHp < defender.maxHp * 0.15) {
                score += 1500; // ç™½å«–ä¼¤å®³åè·‘è·¯
            }
            // åæ‰‹æŠ˜è¿” (Slow Pivot)ï¼šè®©é˜Ÿå‹æ— ä¼¤ä¸Šåœºï¼Œè¿™æ˜¯ç¥æŠ€
            // å¦‚æœæˆ‘æ¯”è¾ƒè‚‰ä¸”æ¯”å¯¹æ‰‹æ…¢
            const myBulk = (attacker.def || 80) + (attacker.spd || 80);
            if (isSlower && myBulk >= 160) {
                score += 1200; // åæ‰‹å¸¦äººæ˜¯æˆ˜æœ¯æ ¸å¿ƒ
            }
            // å¦‚æœæˆ‘çŠ¶æ€ä¸å¥½ï¼ˆèƒ½åŠ›ä¸‹é™ï¼‰ï¼ŒæŠ˜è¿”æ¸…é™¤è´Ÿé¢çŠ¶æ€
            const boosts = attacker.boosts || {};
            if ((boosts.atk || 0) <= -1 || (boosts.spa || 0) <= -1 || (boosts.spe || 0) <= -1) {
                score += 800; // ç”¨æŠ˜è¿”é‡ç½®çŠ¶æ€
            }
            // Parting Shot ç‰¹æ®ŠåŠ åˆ†ï¼ˆé™å¯¹æ‰‹èƒ½åŠ›ï¼‰
            if (moveName === 'Parting Shot') {
                score += 500;
            }
        }
    }
    return score;
}
/* =============================================================
 *  Revenge Killer é€‰æ‹© - æ™ºèƒ½æ¢äººé€»è¾‘
 * ============================================================= */
/**
 * å½“ AI çš„å®å¯æ¢¦å€’ä¸‹æ—¶ï¼Œé€‰æ‹©æœ€ä½³çš„å¤ä»‡è€…ä¸Šåœº
 * @param {Pokemon[]} party - AI é˜Ÿä¼
 * @param {Pokemon} opp - ç©å®¶å½“å‰åœºä¸Šçš„å®å¯æ¢¦
 * @param {number} currentActive - å½“å‰ï¼ˆå·²å€’ä¸‹çš„ï¼‰å®å¯æ¢¦ç´¢å¼•
 * @returns {number} - æœ€ä½³é˜Ÿå‘˜çš„ indexï¼Œ-1 è¡¨ç¤ºæ²¡æœ‰å¯ç”¨çš„
 */
function getBestRevengeKiller(party, opp, currentActive = -1) {
    if (!party || !opp) return -1;
    let bestIdx = -1;
    let bestScore = -Infinity;
    party.forEach((p, i) => {
        // è·³è¿‡æ­»äº¡çš„ã€å½“å‰åœ¨åœºçš„
        if (!p || p.currHp <= 0 || !p.moves || i === currentActive) return;
        let score = 0;
        // 1. é€Ÿåº¦ä¼˜åŠ¿ (æœ€é‡è¦çš„å¤ä»‡å‡»æ€æŒ‡æ ‡)
        const mySpe = getEffectiveSpeed(p);
        const oppSpe = getEffectiveSpeed(opp);
        if (mySpe > oppSpe) score += 300;
        // 2. ä¼¤å®³æ½œåŠ› (èƒ½å¦ç§’æ€å¯¹é¢ï¼Ÿ)
        let maxDmg = 0;
        for (const m of p.moves) {
            const mergedMove = getMergedMoveData(m);
            const result = simulateDamage(p, opp, mergedMove);
            if (result.damage > maxDmg) maxDmg = result.damage;
        }
        const oppHp = opp.currHp || 1;
        const dmgPercent = maxDmg / oppHp;
        if (dmgPercent >= 1) {
            score += 500; // ç¡®ä¸€ï¼ˆç§’æ€ï¼‰ï¼æƒé‡æé«˜
        } else {
            score += dmgPercent * 200; // èƒ½æ‰“ç—›ä¹Ÿå¥½
        }
        // 3. æŠ—æ€§ (ä¼šä¸ä¼šè¢«å¯¹é¢æ‰“æ­»ï¼Ÿ)
        let incomingDmg = 0;
        let worstEff = 1;
        for (const m of opp.moves) {
            const mergedMove = getMergedMoveData(m);
            const result = simulateDamage(opp, p, mergedMove);
            if (result.damage > incomingDmg) {
                incomingDmg = result.damage;
                worstEff = result.effectiveness || 1;
            }
        }
        // ã€æ–°å¢ã€‘å±æ€§å…‹åˆ¶æ£€æŸ¥ï¼šè¢«å…‹åˆ¶çš„å®å¯æ¢¦å¤§å¹…å‡åˆ†
        if (worstEff >= 2) {
            score -= 400; // è¢«å…‹åˆ¶ï¼Œå°½é‡ä¸é€‰
            console.log(`[AI] ${p.cnName || p.name} è¢«å¯¹æ‰‹å…‹åˆ¶ (${worstEff}x)ï¼Œå‡åˆ†`);
        } else if (worstEff === 0) {
            score += 300; // å…ç–«å¯¹æ‰‹æœ€å¼ºæŠ€èƒ½ï¼ŒåŠ åˆ†
        } else if (worstEff <= 0.5) {
            score += 150; // æŠµæŠ—å¯¹æ‰‹æœ€å¼ºæŠ€èƒ½ï¼ŒåŠ åˆ†
        }
        // æˆ‘èƒ½æŒ¨å‡ ä¸‹ï¼Ÿ
        const mySurviveTurns = incomingDmg > 0 ? (p.currHp / incomingDmg) : 999;
        if (mySurviveTurns >= 2) {
            score += 200; // èƒ½åƒä¸¤å‘ï¼Œå¾ˆç¨³
        } else if (mySurviveTurns < 1) {
            score -= 300; // ä¸Šæ¥å°±æ­»ï¼Œå°½é‡ä¸é€‰
        }
        // 4. å…ˆåˆ¶æŠ€èƒ½åŠ åˆ†
        for (const m of p.moves) {
            const mergedMove = getMergedMoveData(m);
            if ((mergedMove.priority || 0) > 0 && (mergedMove.basePower || mergedMove.power || 0) > 0) {
                const result = simulateDamage(p, opp, mergedMove);
                if (result.damage >= oppHp) {
                    score += 400; // å…ˆåˆ¶æŠ€èƒ½èƒ½ç§’æ€ï¼Œæé«˜ä¼˜å…ˆçº§
                } else {
                    score += 100; // æœ‰å…ˆåˆ¶æŠ€èƒ½
                }
            }
        }
        if (score > bestScore) {
            bestScore = score;
            bestIdx = i;
        }
    });
    console.log(`[AI] getBestRevengeKiller: best index = ${bestIdx}, score = ${bestScore}`);
    return bestIdx;
}
/* =============================================================
 *  å¯¼å‡º
 * ============================================================= */
if (typeof window !== 'undefined') {
    window.AI_DIFFICULTY = AI_DIFFICULTY;
    window.AI_ACTION_TYPE = AI_ACTION_TYPE;
    window.getAiAction = getAiAction;
    window.getExpertAiAction = getExpertAiAction;
    window.getHardAiMove = getHardAiMove;
    window.getNormalAiMove = getNormalAiMove;
    window.getEasyAiMove = getEasyAiMove;
    window.getBestRevengeKiller = getBestRevengeKiller;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        AI_DIFFICULTY,
        AI_ACTION_TYPE,
        getAiAction,
        getExpertAiAction,
        getHardAiMove,
        getNormalAiMove,
        getEasyAiMove
    };
}
]]></file>
        <file name="battle-engine.js"><![CDATA[/**
 * =============================================
 * BATTLE ENGINE - æˆ˜æ–—æ ¸å¿ƒå¼•æ“
 * =============================================
 * 
 * è´Ÿè´£ï¼š
 * - å±æ€§å…‹åˆ¶è®¡ç®—
 * - Pokemon å®ä¾‹åˆ›å»º
 * - æˆ˜æ–—çŠ¶æ€ç®¡ç†
 */
// === è½¯ç¼–ç ï¼šæ™ºèƒ½æå–åŸºç¡€å½¢æ€å ===
// ç¡¬ç¼–ç æ•°æ®å·²ç§»è‡³ move-constants.js
/**
 * ä»å®å¯æ¢¦åç§°æå–åŸºç¡€å½¢æ€IDï¼ˆç”¨äºå›¾ç‰‡å›é€€ï¼‰
 * @param {string} name åŸå§‹åç§°
 * @returns {string} åŸºç¡€å½¢æ€ID
 */
function extractBaseFormId(name = '') {
    let id = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
    // ä» move-constants.js è·å–åç¼€åˆ—è¡¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨å†…ç½®åå¤‡
    const suffixes = (typeof FORM_SUFFIXES !== 'undefined') ? FORM_SUFFIXES : [
        'starter', 'gmax', 'megax', 'megay', 'mega',
        'alola', 'galar', 'hisui', 'paldea',
        'therian', 'incarnate', 'origin', 'altered',
        'crowned', 'hero', 'eternamax', 'primal', 'ultra', 'ash', 'totem'
    ];
    // å°è¯•ç§»é™¤åç¼€
    for (const suffix of suffixes) {
        if (id.endsWith(suffix)) {
            const base = id.slice(0, -suffix.length);
            if (base.length >= 3) {
                return base;
            }
        }
    }
    return id;
}
/**
 * è·å–ç²¾çµå›¾IDï¼ˆä¿ç•™æ¨ªæ ä»¥æ”¯æŒåœ°åŒºå½¢æ€å’Œç‰¹æ®Šåå­—ï¼‰
 * ä¾‹å¦‚: "Vulpix-Alola" -> "vulpix-alola", "Ho-Oh" -> "ho-oh"
 * Mega å½¢æ€ç‰¹æ®Šå¤„ç†: "Charizard-Mega-X" -> "charizardmegax" (ç´§å‡‘æ ¼å¼)
 */
function resolveSpriteId(name = '') {
    const normalized = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
    // ã€ä¿®å¤ã€‘Mega å½¢æ€ï¼šä¿ç•™æ¨ªæ ï¼ˆShowdown æ ¼å¼ï¼‰
    // Metagross-Mega -> metagross-mega
    // Charizard-Mega-X -> charizard-mega-x
    // ä¸å†ç§»é™¤æ¨ªæ ï¼Œç›´æ¥è¿”å›è§„èŒƒåŒ–åçš„åç§°
    // å…¶ä»–å½¢æ€ï¼šä¿ç•™æ¨ªæ ï¼ˆåœ°åŒºå½¢æ€ã€ç‰¹æ®Šåå­—ç­‰ï¼‰
    return normalized;
}
/**
 * è·å–å›é€€ç²¾çµå›¾IDï¼ˆæå–åŸºç¡€å½¢æ€ï¼‰
 */
function getFallbackSpriteId(name = '') {
    return extractBaseFormId(name);
}
if (typeof window !== 'undefined') {
    window.resolveSpriteId = resolveSpriteId;
    window.extractBaseFormId = extractBaseFormId;
    window.getFallbackSpriteId = getFallbackSpriteId;
}
// === æ€§æ ¼ä¿®æ­£è¡¨ ===
// æ€§æ ¼ -> { å¢ç›Šå±æ€§: 1.1, å‡ç›Šå±æ€§: 0.9 }
// æ— ä¿®æ­£æ€§æ ¼ï¼ˆè®¤çœŸã€åŠªåŠ›ç­‰ï¼‰ä¸åœ¨æ­¤è¡¨ä¸­
const NATURE_MODIFIERS = {
    // åŠ æ”»å‡»
    'Lonely':   { atk: 1.1, def: 0.9 },
    'Adamant':  { atk: 1.1, spa: 0.9 },
    'Naughty':  { atk: 1.1, spd: 0.9 },
    'Brave':    { atk: 1.1, spe: 0.9 },
    // åŠ é˜²å¾¡
    'Bold':     { def: 1.1, atk: 0.9 },
    'Impish':   { def: 1.1, spa: 0.9 },
    'Lax':      { def: 1.1, spd: 0.9 },
    'Relaxed':  { def: 1.1, spe: 0.9 },
    // åŠ ç‰¹æ”»
    'Modest':   { spa: 1.1, atk: 0.9 },
    'Mild':     { spa: 1.1, def: 0.9 },
    'Rash':     { spa: 1.1, spd: 0.9 },
    'Quiet':    { spa: 1.1, spe: 0.9 },
    // åŠ ç‰¹é˜²
    'Calm':     { spd: 1.1, atk: 0.9 },
    'Gentle':   { spd: 1.1, def: 0.9 },
    'Careful':  { spd: 1.1, spa: 0.9 },
    'Sassy':    { spd: 1.1, spe: 0.9 },
    // åŠ é€Ÿåº¦
    'Timid':    { spe: 1.1, atk: 0.9 },
    'Hasty':    { spe: 1.1, def: 0.9 },
    'Jolly':    { spe: 1.1, spa: 0.9 },
    'Naive':    { spe: 1.1, spd: 0.9 },
};
// === å±æ€§å…‹åˆ¶è¡¨ ===
// æ”»å‡»æ–¹å±æ€§ -> { è¢«å…‹åˆ¶å±æ€§: 2, æŠµæŠ—å±æ€§: 0.5, å…ç–«å±æ€§: 0 }
const TYPE_CHART = {
    'Normal':   { weak: [],                          resist: ['Rock', 'Steel'],      immune: ['Ghost'] },
    'Fire':     { weak: ['Grass', 'Ice', 'Bug', 'Steel'], resist: ['Fire', 'Water', 'Rock', 'Dragon'], immune: [] },
    'Water':    { weak: ['Fire', 'Ground', 'Rock'],  resist: ['Water', 'Grass', 'Dragon'], immune: [] },
    'Electric': { weak: ['Water', 'Flying'],         resist: ['Electric', 'Grass', 'Dragon'], immune: ['Ground'] },
    'Grass':    { weak: ['Water', 'Ground', 'Rock'], resist: ['Fire', 'Grass', 'Poison', 'Flying', 'Bug', 'Dragon', 'Steel'], immune: [] },
    'Ice':      { weak: ['Grass', 'Ground', 'Flying', 'Dragon'], resist: ['Fire', 'Water', 'Ice', 'Steel'], immune: [] },
    'Fighting': { weak: ['Normal', 'Ice', 'Rock', 'Dark', 'Steel'], resist: ['Poison', 'Flying', 'Psychic', 'Bug', 'Fairy'], immune: ['Ghost'] },
    'Poison':   { weak: ['Grass', 'Fairy'],          resist: ['Poison', 'Ground', 'Rock', 'Ghost'], immune: ['Steel'] },
    'Ground':   { weak: ['Fire', 'Electric', 'Poison', 'Rock', 'Steel'], resist: ['Grass', 'Bug'], immune: ['Flying'] },
    'Flying':   { weak: ['Grass', 'Fighting', 'Bug'], resist: ['Electric', 'Rock', 'Steel'], immune: [] },
    'Psychic':  { weak: ['Fighting', 'Poison'],      resist: ['Psychic', 'Steel'],   immune: ['Dark'] },
    'Bug':      { weak: ['Grass', 'Psychic', 'Dark'], resist: ['Fire', 'Fighting', 'Poison', 'Flying', 'Ghost', 'Steel', 'Fairy'], immune: [] },
    'Rock':     { weak: ['Fire', 'Ice', 'Flying', 'Bug'], resist: ['Fighting', 'Ground', 'Steel'], immune: [] },
    'Ghost':    { weak: ['Psychic', 'Ghost'],        resist: ['Dark'],               immune: ['Normal'] },
    'Dragon':   { weak: ['Dragon'],                  resist: ['Steel'],              immune: ['Fairy'] },
    'Dark':     { weak: ['Psychic', 'Ghost'],        resist: ['Fighting', 'Dark', 'Fairy'], immune: [] },
    'Steel':    { weak: ['Ice', 'Rock', 'Fairy'],    resist: ['Fire', 'Water', 'Electric', 'Steel'], immune: [] },
    'Fairy':    { weak: ['Fighting', 'Dark', 'Dragon'], resist: ['Fire', 'Poison', 'Steel'], immune: [] },
};
/**
 * è®¡ç®—å±æ€§å…‹åˆ¶å€ç‡
 * @param {string} atkType - æ”»å‡»æŠ€èƒ½å±æ€§
 * @param {string[]} defTypes - é˜²å¾¡æ–¹å±æ€§æ•°ç»„
 * @param {string} moveName - æŠ€èƒ½åç§°ï¼ˆç”¨äºç‰¹æ®Šå…‹åˆ¶è§„åˆ™ï¼‰
 * @returns {number} - å€ç‡ (0, 0.25, 0.5, 1, 2, 4)
 */
function getTypeEffectiveness(atkType, defTypes, moveName = '') {
    const chart = TYPE_CHART[atkType];
    if (!chart) return 1;
    let multiplier = 1;
    const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
    for (const defType of defTypes) {
        // === ç‰¹æ®Šå…‹åˆ¶è§„åˆ™ ===
        // Freeze-Dry (å†·å†»å¹²ç‡¥): å¯¹æ°´ç³»æ•ˆæœç»ä½³
        if (moveId === 'freezedry' && defType === 'Water') {
            multiplier *= 2;
            continue;
        }
        // Flying Press (é£èº«é‡å‹): åŒæ—¶å…·æœ‰æ ¼æ–—å’Œé£è¡Œå±æ€§
        // Thousand Arrows (åƒç®­): å¯¹é£è¡Œç³»ä¹Ÿæœ‰æ•ˆ
        if (moveId === 'thousandarrows' && defType === 'Flying') {
            // ä¸å…ç–«ï¼Œæ­£å¸¸è®¡ç®—
            continue;
        }
        if (chart.immune.includes(defType)) return 0;
        if (chart.weak.includes(defType)) multiplier *= 2;
        if (chart.resist.includes(defType)) multiplier *= 0.5;
    }
    return multiplier;
}
/**
 * å®å¯æ¢¦åç§°è§„èŒƒåŒ–å™¨ ("å®½è¿›"ç­–ç•¥)
 * å°† AI ç”Ÿæˆçš„è‡ªç„¶è¯­è¨€å½¢å®¹è¯è½¬æ¢ä¸ºæ ‡å‡†çš„ ID åç¼€
 * ä¾‹å¦‚: "Grimer-Alolan" -> "Grimer-Alola"
 * @param {string} rawName - åŸå§‹åç§°
 * @returns {string} è§„èŒƒåŒ–åçš„åç§°
 */
function normalizePokemonName(rawName) {
    if (!rawName) return '';
    let name = String(rawName).trim();
    // å¤„ç†å½¢å®¹è¯åç¼€ (Alolan -> Alola, Galarian -> Galar, etc.)
    const adjectiveMap = [
        { pattern: /-Alolan$/i, replacement: '-Alola' },
        { pattern: /\s+Alolan$/i, replacement: '-Alola' },
        { pattern: /-Galarian$/i, replacement: '-Galar' },
        { pattern: /\s+Galarian$/i, replacement: '-Galar' },
        { pattern: /-Hisuian$/i, replacement: '-Hisui' },
        { pattern: /\s+Hisuian$/i, replacement: '-Hisui' },
        { pattern: /-Paldean$/i, replacement: '-Paldea' },
        { pattern: /\s+Paldean$/i, replacement: '-Paldea' }
    ];
    for (const { pattern, replacement } of adjectiveMap) {
        if (pattern.test(name)) {
            const normalized = name.replace(pattern, replacement);
            console.log(`[PKM] [NORMALIZE] "${rawName}" -> "${normalized}"`);
            return normalized;
        }
    }
    return name;
}
/**
 * ä» Pokemon Showdown POKEDEX è·å–å®å¯æ¢¦æ•°æ® (å¸¦æ™ºèƒ½å›é€€æœºåˆ¶)
 * ç­–ç•¥: è§„èŒƒåŒ–åç§° -> ç›´æ¥æŸ¥æ‰¾ -> ä¿®æ­£åç¼€ -> å›é€€åˆ°åŸºç¡€å½¢æ€
 * @param {string} name - è‹±æ–‡å (å¦‚ 'Pikachu')
 * @returns {object|null}
 */
function getPokemonData(name) {
    if (typeof POKEDEX === 'undefined') return null;
    // === ç¬¬ä¸€æ­¥: è§„èŒƒåŒ–åç§° (å®½è¿›) ===
    const normalizedName = normalizePokemonName(name);
    let id = normalizedName.toLowerCase().replace(/[^a-z0-9]/g, '');
    // === ç¬¬äºŒæ­¥: ç›´æ¥æŸ¥æ‰¾ ===
    if (POKEDEX[id]) {
        const data = POKEDEX[id];
        return {
            name: data.name,
            types: data.types || ['Normal'],
            baseStats: data.baseStats
        };
    }
    // === ç¬¬ä¸‰æ­¥: ä¿®æ­£å¸¸è§çš„å½¢å®¹è¯åç¼€é”™è¯¯ ===
    const suffixFixes = [
        { from: 'alolan', to: 'alola' },
        { from: 'galarian', to: 'galar' },
        { from: 'hisuian', to: 'hisui' },
        { from: 'paldean', to: 'paldea' }
    ];
    for (const fix of suffixFixes) {
        if (id.endsWith(fix.from)) {
            const fixedId = id.slice(0, -fix.from.length) + fix.to;
            if (POKEDEX[fixedId]) {
                console.log(`[PKM] [SUFFIX FIX] "${id}" -> "${fixedId}"`);
                const data = POKEDEX[fixedId];
                return {
                    name: data.name,
                    types: data.types || ['Normal'],
                    baseStats: data.baseStats
                };
            }
        }
    }
    // === ç¬¬å››æ­¥: æ™ºèƒ½å›é€€åˆ°åŸºç¡€å½¢æ€ ===
    const splitChars = ['-', ' '];
    for (const splitChar of splitChars) {
        if (normalizedName.includes(splitChar)) {
            const potentialBaseName = normalizedName.split(splitChar)[0];
            if (potentialBaseName && potentialBaseName !== normalizedName) {
                const baseId = potentialBaseName.toLowerCase().replace(/[^a-z0-9]/g, '');
                if (POKEDEX[baseId]) {
                    console.log(`[PKM] [FALLBACK] Using base species "${potentialBaseName}" instead of "${normalizedName}"`);
                    const data = POKEDEX[baseId];
                    return {
                        name: data.name,
                        types: data.types || ['Normal'],
                        baseStats: data.baseStats
                    };
                }
            }
        }
    }
    // === ç¬¬äº”æ­¥: æ‰¾ä¸åˆ° ===
    console.warn(`[PKM] [NOT FOUND] Pokemon "${name}" not found in POKEDEX`);
    return null;
}
/**
 * ä» Pokemon Showdown MOVES è·å–æŠ€èƒ½æ•°æ®
 * @param {string} name - è‹±æ–‡å (å¦‚ 'Thunderbolt')
 * @returns {object} åŒ…å«æ‰€æœ‰åŸå§‹æ•°æ® + æ ‡å‡†åŒ–å­—æ®µ
 */
function getMoveData(name) {
    const id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const data = typeof MOVES !== 'undefined' ? MOVES[id] : null;
    if (!data) {
        return { name: name, type: 'Normal', power: 40, cat: 'phys', accuracy: 100 };
    }
    // === CRITICAL FIX ===
    // ä½¿ç”¨ spread operator ä¿ç•™æ‰€æœ‰åŸå§‹æ•°æ®ï¼ˆaccuracy, multihit, recoil, drain, secondary ç­‰ï¼‰
    // åŒæ—¶æ·»åŠ æ ‡å‡†åŒ–å­—æ®µä¾› API è°ƒç”¨
    // === åŠ¨æ€å¨åŠ›æŠ€èƒ½è¡¥ä¸ ===
    // è¿™äº›æŠ€èƒ½çš„ basePower åœ¨åŸæ•°æ®ä¸­æ˜¯ 0 æˆ– nullï¼ˆéœ€è¦è¿è¡Œæ—¶è®¡ç®—ï¼‰ï¼Œç»™å®ƒä»¬å›ºå®šå¨åŠ›
    const dynamicPowerPatches = {
        'gyroball': 80,         // é™€èºçƒï¼šé€Ÿåº¦å·®è®¡ç®—ï¼Œå¹³å‡çº¦80
        'electroball': 80,      // ç”µçƒï¼šé€Ÿåº¦å·®è®¡ç®—
        'grassknot': 80,        // æ‰“è‰ç»“ï¼šä½“é‡è®¡ç®—
        'lowkick': 80,          // è¸¢å€’ï¼šä½“é‡è®¡ç®—
        'heatcrash': 80,        // é«˜æ¸©é‡å‹ï¼šä½“é‡è®¡ç®—
        'heavyslam': 80,        // é‡ç£…å†²æ’ï¼šä½“é‡è®¡ç®—
        'fling': 50,            // æŠ•æ·ï¼šé“å…·å¨åŠ›
        'return': 102,          // æŠ¥æ©ï¼šæ»¡äº²å¯†åº¦
        'frustration': 102,     // è¿æ€’ï¼šæ»¡ä¸äº²å¯†
        'punishment': 70,       // æƒ©ç½šï¼šèƒ½åŠ›å˜åŒ–
        'storedpower': 80,      // è¾…åŠ©åŠ›é‡ï¼šèƒ½åŠ›å˜åŒ–
        'reversal': 100,        // ç»å¤„é€¢ç”Ÿï¼šä½è¡€é«˜å¨åŠ›
        'flail': 100,           // æŒ£æ‰ï¼šä½è¡€é«˜å¨åŠ›
        'eruption': 150,        // å–·ç«ï¼šæ»¡è¡€å¨åŠ›
        'waterspout': 150,      // å–·æ°´ï¼šæ»¡è¡€å¨åŠ›
        'crushgrip': 100,       // æ¡ç¢ï¼šå¯¹æ–¹è¡€é‡
        'wringout': 100,        // ç»ç´§ï¼šå¯¹æ–¹è¡€é‡
        'naturalgift': 80,      // è‡ªç„¶ä¹‹æ©ï¼šæ ‘æœ
        'trumpcard': 80,        // ç‹ç‰Œï¼šPP
        'spitup': 100,          // å–·å‡ºï¼šè“„åŠ›æ¬¡æ•°
        'present': 60,          // ç¤¼ç‰©ï¼šéšæœº
        'magnitude': 70,        // éœ‡çº§ï¼šéšæœº
    };
    let finalPower = data.basePower || 0;
    const moveId = id.toLowerCase();
    if (dynamicPowerPatches[moveId]) {
        finalPower = dynamicPowerPatches[moveId];
    }
    return {
        ...data, // ä¿ç•™æ‰€æœ‰é«˜çº§å±æ€§ï¼
        // æ ‡å‡†åŒ–å­—æ®µ
        name: data.name || name,
        type: data.type || 'Normal',
        power: finalPower,
        cat: data.category === 'Special' ? 'spec' : (data.category === 'Physical' ? 'phys' : 'status'),
        accuracy: (data.accuracy === true) ? true : (data.accuracy === undefined ? 100 : data.accuracy)
    };
}
/**
 * è®¡ç®—èƒ½åŠ›å€¼ (æ”¯æŒæ–°ç‰ˆ stats_meta æ ¼å¼)
 * 
 * @param {object} baseStats - { hp, atk, def, spa, spd, spe }
 * @param {number} level - ç­‰çº§
 * @param {object} options - å¯é€‰å‚æ•°
 * @param {object} options.ivs - ä¸ªä½“å€¼å¯¹è±¡ { hp, atk, def, spa, spd, spe }ï¼Œé»˜è®¤å…¨31
 * @param {number} options.ev_level - ç»Ÿä¸€åŠªåŠ›å€¼ç­‰çº§ (0~252)ï¼Œä¼šåŒæ—¶åŠ åˆ°å…­é¡¹
 * @param {string} options.nature - æ€§æ ¼åç§°ï¼Œç”¨äºä¿®æ­£èƒ½åŠ›å€¼
 * @returns {object} è®¡ç®—åçš„èƒ½åŠ›å€¼ { hp, atk, def, spa, spd, spe }
 */
function calcStats(baseStats, level, options = {}) {
    // å…¼å®¹æ—§ç‰ˆè°ƒç”¨: calcStats(baseStats, level, iv, ev)
    let ivs, evs, nature;
    if (typeof options === 'number') {
        // æ—§ç‰ˆè°ƒç”¨æ–¹å¼
        const oldIv = options;
        const oldEv = arguments[3] || 0;
        ivs = { hp: oldIv, atk: oldIv, def: oldIv, spa: oldIv, spd: oldIv, spe: oldIv };
        evs = { hp: oldEv, atk: oldEv, def: oldEv, spa: oldEv, spd: oldEv, spe: oldEv };
        nature = null;
    } else {
        // æ–°ç‰ˆè°ƒç”¨æ–¹å¼
        ivs = options.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
        // æ”¯æŒä¸‰ç§ ev_level æ ¼å¼ï¼š
        // 1. æ•°å­— (ç»Ÿä¸€å€¼): 252 -> æ‰€æœ‰é¡¹éƒ½æ˜¯ 252
        // 2. æ•°ç»„ [HP, Atk, Def, SpA, SpD, Spe]: [252, 0, 0, 252, 6, 0]
        // 3. å¯¹è±¡ { hp, atk, def, spa, spd, spe }
        const evInput = options.ev_level;
        if (Array.isArray(evInput)) {
            // æ•°ç»„æ ¼å¼: [HP, Atk, Def, SpA, SpD, Spe]
            evs = {
                hp: evInput[0] || 0,
                atk: evInput[1] || 0,
                def: evInput[2] || 0,
                spa: evInput[3] || 0,
                spd: evInput[4] || 0,
                spe: evInput[5] || 0
            };
        } else if (typeof evInput === 'object' && evInput !== null) {
            // å¯¹è±¡æ ¼å¼
            evs = evInput;
        } else {
            // æ•°å­—æ ¼å¼ (ç»Ÿä¸€å€¼)
            const evLevel = evInput !== undefined ? evInput : 0;
            evs = { hp: evLevel, atk: evLevel, def: evLevel, spa: evLevel, spd: evLevel, spe: evLevel };
        }
        nature = options.nature || null;
    }
    // è·å–æ€§æ ¼ä¿®æ­£
    const natureMod = nature ? (NATURE_MODIFIERS[nature] || {}) : {};
    // HP è®¡ç®—å…¬å¼ï¼ˆHP ä¸å—æ€§æ ¼å½±å“ï¼‰
    const calcHP = (base, iv, ev) => {
        return Math.floor((2 * base + iv + ev / 4) * level / 100) + level + 10;
    };
    // å…¶ä»–èƒ½åŠ›è®¡ç®—å…¬å¼ï¼ˆå—æ€§æ ¼å½±å“ï¼‰
    const calcOther = (base, iv, ev, statName) => {
        let val = Math.floor(((2 * base + iv + ev / 4) * level / 100 + 5));
        // åº”ç”¨æ€§æ ¼ä¿®æ­£
        if (natureMod[statName]) {
            val = Math.floor(val * natureMod[statName]);
        }
        return val;
    };
    return {
        hp: calcHP(baseStats.hp, ivs.hp || 31, evs.hp || 0),
        atk: calcOther(baseStats.atk, ivs.atk || 31, evs.atk || 0, 'atk'),
        def: calcOther(baseStats.def, ivs.def || 31, evs.def || 0, 'def'),
        spa: calcOther(baseStats.spa, ivs.spa || 31, evs.spa || 0, 'spa'),
        spd: calcOther(baseStats.spd, ivs.spd || 31, evs.spd || 0, 'spd'),
        spe: calcOther(baseStats.spe, ivs.spe || 31, evs.spe || 0, 'spe')
    };
}
/**
 * Pokemon æˆ˜æ–—å®ä¾‹
 * ä» Pokemon Showdown POKEDEX æŸ¥è¡¨åˆ›å»ºï¼Œè‡ªåŠ¨è®¡ç®—èƒ½åŠ›å€¼
 * 
 * æ”¯æŒä¸¤ç§æ„é€ æ–¹å¼ï¼š
 * 1. æ—§ç‰ˆï¼šnew Pokemon(name, level, moves)
 * 2. æ–°ç‰ˆï¼šnew Pokemon(config) å…¶ä¸­ config åŒ…å«å®Œæ•´çš„ stats_meta
 */
class Pokemon {
    constructor(nameOrConfig, level, moveNames = []) {
        // æ£€æµ‹æ˜¯å¦ä¸ºæ–°ç‰ˆé…ç½®å¯¹è±¡æ ¼å¼
        if (typeof nameOrConfig === 'object' && nameOrConfig !== null && nameOrConfig.name) {
            this._initFromConfig(nameOrConfig);
        } else {
            // æ—§ç‰ˆæ„é€ æ–¹å¼
            const name = nameOrConfig;
            const data = getPokemonData(name);
            if (!data) {
                console.warn(`Pokemon "${name}" not found in POKEDEX, using Pikachu`);
                const fallback = getPokemonData('Pikachu') || {
                    name: 'Pikachu', types: ['Electric'],
                    baseStats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 }
                };
                this._initLegacy('Pikachu', fallback.types, fallback.baseStats, level, moveNames);
            } else {
                this._initLegacy(name, data.types, data.baseStats, level, moveNames);
            }
        }
    }
    /**
     * æ–°ç‰ˆåˆå§‹åŒ–ï¼šä»å®Œæ•´é…ç½®å¯¹è±¡åˆ›å»º
     * @param {object} config - åŒ…å« name, lv, moves, gender, nature, ability, stats_meta ç­‰
     */
    _initFromConfig(config) {
        const name = config.name;
        const level = config.lv || config.level || 50;
        const moveNames = config.moves || [];
        const data = getPokemonData(name);
        if (!data) {
            console.warn(`Pokemon "${name}" not found in POKEDEX, using Pikachu`);
            const fallback = getPokemonData('Pikachu') || {
                name: 'Pikachu', types: ['Electric'],
                baseStats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 }
            };
            this._initCore('Pikachu', fallback.types, fallback.baseStats, level, moveNames, config);
        } else {
            this._initCore(name, data.types, data.baseStats, level, moveNames, config);
        }
    }
    /**
     * æ—§ç‰ˆåˆå§‹åŒ–ï¼šå…¼å®¹æ—§çš„æ„é€ æ–¹å¼
     */
    _initLegacy(name, types, baseStats, level, moveNames) {
        this._initCore(name, types, baseStats, level, moveNames, {});
    }
    /**
     * æ ¸å¿ƒåˆå§‹åŒ–é€»è¾‘
     * @param {string} name - å®å¯æ¢¦åç§°
     * @param {string[]} types - å±æ€§æ•°ç»„
     * @param {object} baseStats - ç§æ—å€¼
     * @param {number} level - ç­‰çº§
     * @param {string[]} moveNames - æŠ€èƒ½åç§°æ•°ç»„
     * @param {object} config - é¢å¤–é…ç½® (gender, nature, ability, stats_meta, shiny ç­‰)
     */
    _initCore(name, types, baseStats, level, moveNames, config = {}) {
        this.name = name;
        this.cnName = name; // æš‚æ—¶ä½¿ç”¨è‹±æ–‡åï¼Œå¯åç»­æ·»åŠ ä¸­æ–‡æ˜ å°„
        this.types = types;
        this.baseStats = baseStats;
        this.level = level;
        // === æ–°å¢å±æ€§ï¼šæ€§åˆ«ã€æ€§æ ¼ã€ç‰¹æ€§ã€é—ªå…‰ ===
        this.gender = config.gender || null; // 'M', 'F', or null
        this.nature = config.nature || null; // æ€§æ ¼åç§°
        this.shiny = config.shiny || false;  // æ˜¯å¦é—ªå…‰
        // ç‰¹æ€§å¤„ç†ï¼šä¼˜å…ˆä½¿ç”¨é…ç½®ä¸­çš„ç‰¹æ€§ï¼Œå¦åˆ™ä» POKEDEX è·å–é»˜è®¤ç‰¹æ€§
        if (config.ability) {
            this.ability = config.ability;
        } else {
            // ä» POKEDEX è·å–é»˜è®¤ç‰¹æ€§ (ä½¿ç”¨è§„èŒƒåŒ–åç§°)
            const normalizedId = normalizePokemonName(name).toLowerCase().replace(/[^a-z0-9]/g, '');
            const pokeData = typeof POKEDEX !== 'undefined' ? POKEDEX[normalizedId] : null;
            if (pokeData && pokeData.abilities) {
                this.ability = pokeData.abilities['0'] || null;
            } else {
                this.ability = null;
            }
        }
        // === èƒ½åŠ›å€¼è®¡ç®— ===
        // ä¼˜å…ˆä½¿ç”¨ stats_meta ä¸­çš„å®Œæ•´æ•°æ®
        const statsMeta = config.stats_meta || {};
        let ivs, evLevel;
        if (statsMeta.ivs || statsMeta.ev_level !== undefined) {
            // æ–°ç‰ˆæ ¼å¼ï¼šä½¿ç”¨ stats_meta
            ivs = statsMeta.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
            evLevel = statsMeta.ev_level !== undefined ? statsMeta.ev_level : 0;
        } else {
            // æ—§ç‰ˆå…¼å®¹ï¼šåŠ¨æ€ EV è®¡ç®—é€»è¾‘
            // ç­‰çº§è¶Šé«˜ï¼Œç»å†çš„æˆ˜æ–—è¶Šå¤šï¼Œç§¯ç´¯çš„åŠªåŠ›å€¼å°±è¶Šé«˜
            // å…¬å¼ï¼šæ¯çº§ç»™ 1.5 çš„å•é¡¹ EVï¼Œä¸Šé™ 85 (6é¡¹ x 85 = 510 æ€»é‡)
            ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
            evLevel = Math.min(85, Math.floor(level * 1.5));
        }
        // ä¿å­˜åŸå§‹æ•°æ®ä»¥ä¾¿åç»­æŸ¥çœ‹/å¯¼å‡º
        this.statsMeta = {
            ivs: ivs,
            ev_level: evLevel
        };
        // è®¡ç®—èƒ½åŠ›å€¼
        const stats = calcStats(baseStats, level, {
            ivs: ivs,
            ev_level: evLevel,
            nature: this.nature
        });
        this.maxHp = stats.hp;
        this.currHp = stats.hp;
        this.atk = stats.atk;
        this.def = stats.def;
        this.spa = stats.spa;
        this.spd = stats.spd;
        this.spe = stats.spe;
        // === æˆ˜åœºèƒ½åŠ›å¢ç›Šç­‰çº§ (Stages) ===
        // èŒƒå›´ -6 åˆ° +6, é»˜è®¤ 0
        this.boosts = {
            atk: 0, def: 0, spa: 0, spd: 0, spe: 0,
            accuracy: 0, evasion: 0
        };
        // === ä¸Šåœºå›åˆæ•° (ç”¨äº Fake Out ç­‰é¦–å›åˆé™åˆ¶æŠ€èƒ½) ===
        this.turnsOnField = 0;
        // === æŠ€èƒ½ä½¿ç”¨è¿½è¸ª (ç”¨äºè¿ç»­ä½¿ç”¨é™åˆ¶) ===
        this.lastMoveUsed = null;       // ä¸Šå›åˆä½¿ç”¨çš„æŠ€èƒ½åç§°
        this.protectCounter = 0;        // è¿ç»­ä½¿ç”¨å®ˆä½ç±»æŠ€èƒ½çš„æ¬¡æ•°
        this.mustRecharge = false;      // æ˜¯å¦éœ€è¦è“„åŠ›/åƒµç›´ï¼ˆç ´åå…‰çº¿ç­‰ï¼‰
        // === çŠ¶æ€å¼‚å¸¸ç³»ç»Ÿ ===
        this.status = null;      // ä¸»è¦çŠ¶æ€: 'slp', 'par', 'brn', 'psn', 'tox', 'frz'
        this.volatile = {};      // ä¸´æ—¶çŠ¶æ€: { flinch: true, confusion: true }
        this.sleepTurns = 0;     // ç¡çœ å‰©ä½™å›åˆæ•°
        // =====================================================
        // === æƒ…æ„ŸåŠªåŠ›å€¼ (Affective Values - AVs) ===
        // === æ´›è¿ªäºšç‰¹åŒº (Rhodia Region) ä¸“å±ç³»ç»Ÿ ===
        // =====================================================
        // å—ç¥é¦”ç²‰é›¾ (Ambrosia) å½±å“ï¼Œå®å¯æ¢¦ä¸è®­ç»ƒå®¶çš„çµé­‚é“¾æ¥äº§ç”Ÿçš„åŠ ç‚¹
        // æ¯ä¸ªç»´åº¦ 0~255ï¼Œç±»ä¼¼ä¼ ç»Ÿ EVs ä½†å½±å“æˆ˜æ–—æœºåˆ¶è€Œéæ•°å€¼
        // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
        // 1. æ‰å¹³æ ¼å¼: { avs: { trust, passion, insight, devotion } }
        // 2. åµŒå¥—æ ¼å¼: { friendship: { avs: { trust, passion, insight, devotion } } }
        let avsConfig = config.avs || {};
        if (config.friendship) {
            // åµŒå¥—æ ¼å¼: friendship.avs
            if (config.friendship.avs) {
                avsConfig = config.friendship.avs;
            } else {
                // æ—§æ‰å¹³æ ¼å¼: friendship ç›´æ¥åŒ…å« trust/passion ç­‰
                avsConfig = config.friendship;
            }
        }
        // ã€è§£é”ç³»ç»Ÿã€‘enable_insight æ§åˆ¶ AVs ä¸Šé™
        // æœªè§£é”ï¼šä¸Šé™ 155
        // å·²è§£é”ï¼šä¸Šé™ 255
        // æ³¨æ„ï¼šè¿™é‡Œåªå­˜å‚¨åŸå§‹å€¼ï¼Œå®é™…æ•ˆæœè®¡ç®—æ—¶ä¼šæ ¹æ® enable_insight åŠ¨æ€è°ƒæ•´
        this.avs = {
            trust: avsConfig.trust || 0,       // ä¿¡èµ–ï¼šé˜²å®ˆå‘ï¼Œè‡´å‘½ä¼¤å®³æ—¶é”è¡€
            passion: avsConfig.passion || 0,   // æ¿€æƒ…ï¼šè¿›æ”»å‘ï¼Œæš´å‡»ç‡æå‡
            insight: avsConfig.insight || 0,   // çµçŠ€ï¼šå›é¿å‘ï¼Œé—ªé¿ç‡æå‡
            devotion: avsConfig.devotion || 0  // çŒ®èº«ï¼šå›å¤å‘ï¼Œå›åˆæœ«æ²»æ„ˆå¼‚å¸¸
        };
        console.log(`[AVS] ${this.name} loaded AVs (raw):`, this.avs);
        // çµé­‚ä¼™ä¼´æ ‡è®° (isAce) å’Œ Second Wind æœºåˆ¶
        this.isAce = config.isAce || false;
        this.hasSecondWind = config.hasSecondWind || false;
        // === äº’æ–¥æœºåˆ¶ç³»ç»Ÿ (Mechanic Lock) ===
        // mechanic: 'mega' | 'dynamax' | 'zmove' | 'tera' | undefined
        this.mechanic = config.mechanic || null;
        // === æå·¨åŒ– (Dynamax) ç³»ç»Ÿ ===
        // canDynamax: æ˜¯å¦å¯ä»¥æå·¨åŒ–
        // å¦‚æœ mechanic === 'dynamax'ï¼Œè‡ªåŠ¨å¯ç”¨æå·¨åŒ–èƒ½åŠ›
        this.canDynamax = config.canDynamax || (this.mechanic === 'dynamax');
        this.isDynamaxed = false;      // å½“å‰æ˜¯å¦å¤„äºæå·¨åŒ–çŠ¶æ€
        this.dynamaxTurns = 0;         // æå·¨åŒ–å‰©ä½™å›åˆæ•°
        this.dynamax_moves = config.dynamax_moves || null; // æå·¨åŒ–æ—¶çš„æ‹›å¼åˆ—è¡¨
        // === Mega è¿›åŒ–ç›®æ ‡ ===
        // æ”¯æŒ mega_target æˆ– mega å­—æ®µï¼ˆç”¨äº G-Max å½¢æ€ç­‰ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œåªè®¾ç½® megaTargetIdï¼ŒcanMegaEvolve ç”± autoDetectMegaEligibility å¤„ç†
        const megaTarget = config.mega_target || config.mega;
        if (megaTarget) {
            this.megaTargetId = megaTarget;
            // ã€ä¿®å¤ã€‘åªæœ‰å½“ mechanic ä¸æ˜¯ 'mega' æ—¶ï¼Œæ‰æ ¹æ® gmax è®¾ç½® canDynamax
            // mechanic å­—æ®µæ˜¯æœ€é«˜æƒå¨ï¼Œä¸åº”è¢« mega_target åŠ«æŒ
            if (megaTarget.includes('gmax') && this.mechanic !== 'mega') {
                this.canDynamax = true;
            }
        }
        // === Z æ‹›å¼é…ç½® ===
        // z_move_config: { base_move, target_move, is_unique, trigger_text }
        this.z_move_config = config.z_move_config || null;
        // === å¤ªæ™¶åŒ– (Terastallization) ç³»ç»Ÿ ===
        // teraType: å¤ªæ™¶åŒ–åçš„å±æ€§ (é¢„è®¾å‹)
        // å¦‚æœæ²¡é…ç½®ï¼Œé»˜è®¤ fallback åˆ°ç¬¬ä¸€å±æ€§
        this.teraType = config.tera_type || config.teraType || this.types[0] || 'Normal';
        this.isTerastallized = false;       // å½“å‰æ˜¯å¦å¤„äºå¤ªæ™¶åŒ–çŠ¶æ€
        this.originalTypes = [...this.types]; // ä¿å­˜åŸå§‹å±æ€§ (ç”¨äº STAB å›æº¯)
        // canTera: æ˜¯å¦å¯ä»¥å¤ªæ™¶åŒ– (ç”± mechanic å†³å®š)
        this.canTera = (this.mechanic === 'tera');
        // === é“å…· ===
        this.item = config.item || null;
        // è°ƒè¯•æ—¥å¿—ï¼šç¡®è®¤æ–°å­—æ®µæ˜¯å¦æ­£ç¡®è§£æ
        if (this.mechanic || this.z_move_config || this.dynamax_moves || this.canDynamax || this.canTera) {
            console.log(`[MECHANIC] ${this.name} initialized with:`, {
                mechanic: this.mechanic,
                canDynamax: this.canDynamax,
                canTera: this.canTera,
                teraType: this.teraType,
                megaTargetId: this.megaTargetId,
                z_move_config: this.z_move_config,
                dynamax_moves: this.dynamax_moves,
                item: this.item
            });
        }
        // AVs è§¦å‘è®°å½•ï¼ˆæ¯åœºæˆ˜æ–—åªè§¦å‘ä¸€æ¬¡çš„æ•ˆæœï¼‰
        this.avsTriggered = {
            trustEndure: false,  // Trust é”è¡€æ˜¯å¦å·²è§¦å‘
            passionKill: false   // Passion å‡»æ€åŠ æˆæ˜¯å¦å·²è§¦å‘
        };
        const safeMoves = Array.isArray(moveNames) ? moveNames : [];
        this.moves = safeMoves.map(mn => {
            const id = (mn || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            const rawData = typeof MOVES !== 'undefined' ? MOVES[id] : null;
            let md = getMoveData(mn);
            if (!rawData) {
                const randomFallback = FALLBACK_MOVES[Math.floor(Math.random() * FALLBACK_MOVES.length)];
                md = getMoveData(randomFallback);
            }
            return { name: md.name, cn: md.name, type: md.type, power: md.power || 0, cat: md.cat || 'phys' };
        });
        // å¦‚æœæ²¡ç»™æŠ€èƒ½æˆ–è¿‡æ»¤åä¸ºç©ºï¼Œç»™ä¸ªé»˜è®¤çš„
        if (this.moves.length === 0) {
            this.moves = [{ name: 'Tackle', cn: 'Tackle', type: 'Normal', power: 40, cat: 'phys' }];
        }
    }
    /**
     * è·å–æœ‰æ•ˆ AVs å€¼ï¼ˆè€ƒè™‘ enable_insight / enable_styles è§£é”é™åˆ¶ï¼‰
     * @param {string} stat - AVs å±æ€§å: 'trust', 'passion', 'insight', 'devotion'
     * @returns {number} æœ‰æ•ˆçš„ AVs å€¼
     */
    getEffectiveAVs(stat) {
        if (!this.avs || !this.avs[stat]) return 0;
        const rawValue = this.avs[stat];
        // è·å–è§£é”çŠ¶æ€ï¼ˆåŒºåˆ†ç©å®¶å’Œæ•Œæ–¹ï¼‰
        // é€šè¿‡æ£€æŸ¥å½“å‰å®å¯æ¢¦æ˜¯å¦åœ¨ç©å®¶é˜Ÿä¼ä¸­æ¥åˆ¤æ–­
        let insightUnlocked = false;
        if (typeof battle !== 'undefined') {
            const isPlayerPokemon = battle.playerParty && battle.playerParty.includes(this);
            if (isPlayerPokemon) {
                // ç©å®¶å®å¯æ¢¦ï¼šæ£€æŸ¥ playerUnlocks
                const unlocks = battle.playerUnlocks || {};
                insightUnlocked = unlocks.enable_insight === true || unlocks.enable_styles === true;
            } else {
                // æ•Œæ–¹å®å¯æ¢¦ï¼šæ£€æŸ¥ enemyUnlocks
                const unlocks = battle.enemyUnlocks || {};
                insightUnlocked = unlocks.enable_insight === true || unlocks.enable_styles === true;
            }
        }
        // æœªè§£é”ï¼šä¸Šé™ 155
        // å·²è§£é”ï¼šä¸Šé™ 255ï¼Œä¸”åœ¨ 255 æ—¶æœ‰é¢å¤–åŠ æˆï¼ˆé€šè¿‡ avsEvolutionBoost æˆ–å…¶ä»–æœºåˆ¶ï¼‰
        const cap = insightUnlocked ? 255 : 155;
        const cappedValue = Math.min(rawValue, cap);
        // å¦‚æœå·²è§£é”ä¸”è¾¾åˆ°æ»¡å€¼ 255ï¼Œç»™äºˆ 1.1x åŠ æˆ
        if (insightUnlocked && rawValue >= 255) {
            return Math.floor(cappedValue * 1.1);
        }
        return cappedValue;
    }
    // è·å–ç²¾çµå›¾ URL
    getSprite(isBack = false) {
        // éå®˜æ–¹ Megaï¼šè¿”å›åŸºç¡€å½¢æ€çš„å›¾ç‰‡ URL
        if (this.isUnofficialMega && this.megaTargetId) {
            const baseSpecies = this.megaTargetId.replace(/mega.*$/i, '');
            const folder = isBack ? 'ani-back' : 'ani';
            return `https://play.pokemonshowdown.com/sprites/${folder}/${baseSpecies}.gif`;
        }
        const id = resolveSpriteId(this.name);
        let folder = isBack ? 'ani-back' : 'ani';
        // Mega å½¢æ€å¼ºåˆ¶ä½¿ç”¨æ™®é€šè‰²ï¼ˆé¿å…å¼‚è‰² Mega èµ„æºç¼ºå¤±ï¼‰
        const isMegaForm = /mega|primal/i.test(this.name);
        if (this.shiny && !isMegaForm) {
            folder += '-shiny';
        }
        return `https://play.pokemonshowdown.com/sprites/${folder}/${id}.gif`;
    }
    // è·å–å›é€€ç²¾çµå›¾ URLï¼ˆåŸºç¡€å½¢æ€ï¼‰
    getFallbackSprite(isBack = false) {
        const id = getFallbackSpriteId(this.name);
        let folder = isBack ? 'ani-back' : 'ani';
        // Mega å½¢æ€å¼ºåˆ¶ä½¿ç”¨æ™®é€šè‰²ï¼ˆé¿å…å¼‚è‰² Mega èµ„æºç¼ºå¤±ï¼‰
        const isMegaForm = /mega|primal/i.test(this.name);
        if (this.shiny && !isMegaForm) {
            folder += '-shiny';
        }
        return `https://play.pokemonshowdown.com/sprites/${folder}/${id}.gif`;
    }
    // æ˜¯å¦å­˜æ´»
    isAlive() {
        return this.currHp > 0;
    }
    // å—ä¼¤
    // @param {number} dmg - ä¼¤å®³å€¼
    // @param {string} category - ä¼¤å®³ç±»å‹ ('physical'/'special'/null)ï¼Œç”¨äº Counter/Mirror Coat
    takeDamage(dmg, category = null) {
        // === è®°å½•æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ï¼ˆç”¨äº Counter/Mirror Coatï¼‰===
        if (!this.turnData) this.turnData = {};
        if (dmg > 0 && category) {
            this.turnData.lastDamageTaken = {
                amount: dmg,
                category: category.toLowerCase()
            };
        }
        // Focus Sash (æ°”åŠ¿æŠ«å¸¦): æ»¡è¡€æ—¶ï¼Œè‡´å‘½ä¼¤å®³åªä¼šè®© HP å‰© 1
        // ä½¿ç”¨ items-data.js çš„ ItemEffects å¤„ç†å™¨
        if (typeof ItemEffects !== 'undefined' && ItemEffects.checkFocusSash) {
            if (ItemEffects.checkFocusSash(this, dmg)) {
                console.log(`[ITEM] ${this.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            }
        } else {
            // Fallback: å…¼å®¹æ—§é€»è¾‘
            const itemName = (this.item || '').toLowerCase().replace(/[^a-z]/g, '');
            if (itemName === 'focussash' && this.currHp === this.maxHp && dmg >= this.currHp) {
                this.currHp = 1;
                this.item = null;
                this.focusSashTriggered = true;
                console.log(`[ITEM] ${this.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼`);
                return;
            }
        }
        // =====================================================
        // === AVs: Trust (ä¿¡èµ–) - Sync Guard é”è¡€æ•ˆæœ ===
        // =====================================================
        // ã€å¹³è¡¡è°ƒæ•´ã€‘é™ä½æ¦‚ç‡ï¼Œæ¯åªå®å¯æ¢¦æ¯åœºæˆ˜æ–—åªèƒ½è§¦å‘ä¸€æ¬¡
        // Trust >= 200: 35% æ¦‚ç‡è§¦å‘ï¼ˆåŸ 50%ï¼‰
        // Trust >= 150: 20% æ¦‚ç‡è§¦å‘ï¼ˆåŸ 30%ï¼‰
        // Trust >= 100: 10% æ¦‚ç‡è§¦å‘ï¼ˆåŸ 15%ï¼‰
        // åªæœ‰ isAce=true çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
        if (this.isAce && this.avs && this.avs.trust > 0 && dmg >= this.currHp && !this.avsTriggered?.trustEndure) {
            let triggerChance = 0;
            const baseTrust = this.getEffectiveAVs('trust');
            const effectiveTrust = this.avsEvolutionBoost ? baseTrust * 2 : baseTrust;
            if (effectiveTrust >= 200) triggerChance = 0.35;      // å‰Šå¼±ï¼š50% -> 35%
            else if (effectiveTrust >= 150) triggerChance = 0.20; // å‰Šå¼±ï¼š30% -> 20%
            else if (effectiveTrust >= 100) triggerChance = 0.10; // å‰Šå¼±ï¼š15% -> 10%
            if (triggerChance > 0 && Math.random() < triggerChance) {
                this.currHp = 1;
                this.avsTriggered.trustEndure = true; // æ¯åœºæˆ˜æ–—åªèƒ½è§¦å‘ä¸€æ¬¡
                this.trustEndureTriggered = true; // æ ‡è®°ç”¨äºæ—¥å¿—
                console.log(`[AVs] ${this.cnName} çš„ Trust å®ˆæŠ¤å‘åŠ¨ï¼(Chance: ${Math.round(triggerChance * 100)}%, Trust: ${baseTrust}${this.avsEvolutionBoost ? ' x2' : ''})`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            }
        }
        // =====================================================
        // === Second Wind (ç¬¬äºŒæ°”æ¯) - æè¯£åŒº Boss ä¸“å± ===
        // =====================================================
        // ç‹ç‰Œå®å¯æ¢¦é¦–æ¬¡è¡€æ¡å½’é›¶æ—¶ï¼šé” 1 HP + å…¨å±æ€§ +1
        // åªæœ‰æ ‡è®°äº† hasSecondWind çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘
        if (this.hasSecondWind && dmg >= this.currHp && !this.secondWindTriggered) {
            this.currHp = 1;
            this.secondWindTriggered = true;
            this.secondWindActivated = true; // æ ‡è®°ç”¨äºæ—¥å¿—å’ŒåŠ¨ç”»
            // å…¨å±æ€§ +1
            this.applyBoost('atk', 1);
            this.applyBoost('def', 1);
            this.applyBoost('spa', 1);
            this.applyBoost('spd', 1);
            this.applyBoost('spe', 1);
            console.log(`[Second Wind] ${this.cnName} çš„ç¬¬äºŒæ°”æ¯å‘åŠ¨äº†ï¼å…¨å±æ€§ +1ï¼`);
            return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
        }
        this.currHp = Math.max(0, this.currHp - dmg);
    }
    // å›å¤
    heal(amount) {
        this.currHp = Math.min(this.maxHp, this.currHp + amount);
    }
    // === é‡ç½®èƒ½åŠ›å˜åŒ– (æ¢äººæ—¶è°ƒç”¨) ===
    resetBoosts() {
        this.boosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
        this.turnsOnField = 0;      // é‡ç½®ä¸Šåœºå›åˆæ•°
        this.lastMoveUsed = null;   // é‡ç½®ä¸Šå›åˆæŠ€èƒ½
        this.protectCounter = 0;    // é‡ç½®å®ˆä½è®¡æ•°å™¨
        this.mustRecharge = false;  // é‡ç½®åƒµç›´çŠ¶æ€
        // ã€ä¿®å¤ã€‘æ¢äººæ—¶æ¸…é™¤æå·¨åŒ–çŠ¶æ€
        // æ­£ä½œè§„åˆ™ï¼šæå·¨åŒ–å®å¯æ¢¦ä¸€æ—¦é€€åœºï¼Œæå·¨åŒ–ç«‹åˆ»è§£é™¤
        if (this.isDynamaxed) {
            console.log(`[SWITCH] Clearing Dynamax for ${this.name}`);
            this.isDynamaxed = false;
            this.dynamaxTurns = 0;
            // æ¢å¤åŸå§‹åç§°ï¼ˆG-Max å½¢æ€åç§° -> åŸºç¡€åç§°ï¼‰
            if (this.originalName) {
                console.log(`[SWITCH] Restoring name: ${this.name} -> ${this.originalName}`);
                this.name = this.originalName;
                delete this.originalName;
            }
            // æ¢å¤ HPï¼ˆå¦‚æœä¹‹å‰ä¹˜äº† 1.5 å€ï¼‰
            if (this.preDynamaxMaxHp) {
                // æŒ‰æ¯”ä¾‹æ¢å¤ HP
                const hpRatio = this.currHp / this.maxHp;
                this.maxHp = this.preDynamaxMaxHp;
                this.currHp = Math.max(1, Math.floor(this.maxHp * hpRatio));
                this.preDynamaxMaxHp = null;
                this.preDynamaxCurrHp = null;
            }
        }
        // æ¸…é™¤è“„åŠ›çŠ¶æ€ (Solar Beam, Skull Bash, etc.)
        this.isCharging = false;
        this.chargingMove = null;
        // æ¸…é™¤å…¶ä»– volatile çŠ¶æ€
        if (this.volatiles) {
            this.volatiles = {};
        }
    }
    // === åº”ç”¨èƒ½åŠ›ç­‰çº§å˜åŒ– ===
    applyBoost(statName, stage) {
        if (!this.boosts.hasOwnProperty(statName)) return 0;
        // Contrary (å”±åè°ƒ): èƒ½åŠ›å˜åŒ–åè½¬
        if (this.ability && this.ability.toLowerCase().replace(/\s/g, '') === 'contrary') {
            stage = -stage;
        }
        const oldVal = this.boosts[statName];
        this.boosts[statName] = Math.min(6, Math.max(-6, oldVal + stage));
        return this.boosts[statName] - oldVal;
    }
    // === è·å–ç»è¿‡èƒ½åŠ›ä¿®æ­£åçš„å®æˆ˜æ•°å€¼ ===
    getStat(statName) {
        // åŸºç¡€å…­å›´ (é™¤äº† HP, accuracy, evasion)
        if (['atk', 'def', 'spa', 'spd', 'spe'].includes(statName)) {
            const base = this[statName];
            const stage = this.boosts[statName];
            // æ ¸å¿ƒå…¬å¼ï¼š stage >= 0: (2 + stage) / 2; stage < 0: 2 / (2 + |stage|)
            let multiplier = 1.0;
            if (stage >= 0) multiplier = (2 + stage) / 2;
            else multiplier = 2 / (2 + Math.abs(stage));
            let val = Math.floor(base * multiplier);
            // === ç‰¹æ€§åŠ æˆ Hook (å¤§åŠ›å£«ã€æ¯›çš®å¤§è¡£ã€å¤©æ°”åŠ é€Ÿç­‰) ===
            if (typeof AbilityHandlers !== 'undefined' && this.ability && AbilityHandlers[this.ability]) {
                const ah = AbilityHandlers[this.ability];
                if (ah.onModifyStat) {
                    const shell = { atk: this.atk, def: this.def, spa: this.spa, spd: this.spd, spe: this.spe };
                    shell[statName] = val;
                    // ä¼ é€’ battle å¯¹è±¡ä»¥æ”¯æŒå¤©æ°”ç‰¹æ€§ (å¶ç»¿ç´ ã€æ‚ æ¸¸è‡ªå¦‚ç­‰)
                    const battleRef = (typeof battle !== 'undefined') ? battle : (typeof window !== 'undefined' ? window.battle : null);
                    ah.onModifyStat(shell, this, battleRef);
                    val = shell[statName];
                }
            }
            return Math.max(1, val);
        }
        // å‘½ä¸­/é—ªé¿è¿”å›ç­‰çº§å€¼ï¼Œç”±å¼•æ“è®¡ç®—æœ€ç»ˆå‘½ä¸­ç‡
        if (statName === 'accuracy' || statName === 'evasion') {
            return this.boosts[statName];
        }
        return 0;
    }
}
/**
 * ä¼¤å®³è®¡ç®— (å«èƒ½åŠ›ç­‰çº§ä¿®æ­£ã€å‘½ä¸­åˆ¤å®šã€å¤šæ®µæ”»å‡»ã€æš´å‡»ç‡)
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move - { type, power, cat, accuracy }
 * @returns {object} - { damage, effectiveness, isCrit, miss, hitCount, blocked }
 */
function calcDamage(attacker, defender, move) {
    // è·å–å®Œæ•´æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    const accuracy = move.accuracy ?? fullMoveData.accuracy;
    let category = fullMoveData.category || (move.cat === 'spec' ? 'Special' : (move.cat === 'phys' ? 'Physical' : 'Status'));
    let basePower = move.power ?? fullMoveData.basePower ?? 0;
    // =====================================================
    // === ã€æå·¨åŒ–/Zæ‹›å¼å¨åŠ›ä¿®æ­£è¡¥ä¸ã€‘ ===
    // =====================================================
    // æ•°æ®åº“ä¸­ G-Max ä¸“å±æ‹›å¼å’Œéƒ¨åˆ†é€šç”¨ Max æ‹›å¼çš„ basePower è¢«è®¾ä¸º 10
    // è¿™ä¼šå¯¼è‡´åˆ®ç—§ï¼ˆè¶…ä½ä¼¤å®³ï¼‰ï¼Œéœ€è¦å¼ºåˆ¶ä¿®æ­£
    const moveName = move.name || '';
    const isMaxMoveName = moveName.startsWith('Max ') || moveName.startsWith('G-Max ');
    const isZMoveName = moveName.includes('10,000,000') || 
                        moveName.includes('Catastropika') || 
                        moveName.includes('Stoked Sparksurfer') ||
                        moveName.includes('Pulverizing Pancake') ||
                        (fullMoveData.isZ && basePower < 100);
    if (isMaxMoveName && basePower < 100) {
        // G-Max ä¸“å±æ‹›å¼é€šå¸¸ 130-160ï¼Œé€šç”¨ Max æ‹›å¼ 90-140
        // æ ¹æ®åŸæŠ€èƒ½å¨åŠ›æ¨ç®—ï¼Œè¿™é‡Œç»Ÿä¸€ç»™ 130 ä½œä¸ºåˆç†é»˜è®¤å€¼
        const oldPower = basePower;
        basePower = 130;
        console.warn(`[ENGINE FIX] Max/G-Max å¨åŠ›ä¿®æ­£: ${moveName} (${oldPower} -> ${basePower})`);
    }
    if (isZMoveName && basePower < 100) {
        // Z æ‹›å¼å¨åŠ›é€šå¸¸ 160-200
        const oldPower = basePower;
        basePower = 180;
        console.warn(`[ENGINE FIX] Z-Move å¨åŠ›ä¿®æ­£: ${moveName} (${oldPower} -> ${basePower})`);
    }
    // =====================================================
    // === ã€Tera Blast ç‰¹åˆ¤ã€‘ ===
    // =====================================================
    // Tera Blast é»˜è®¤æ˜¯æ™®é€šç³» 80 å¨åŠ›ç‰¹æ®Šæ‹›å¼
    // å¤ªæ™¶åŒ–åï¼š
    // 1. å±æ€§å˜ä¸ºå¤ªæ™¶å±æ€§
    // 2. åˆ†ç±»æ ¹æ®æ”»å‡»è€…çš„ Atk vs SpA å†³å®š
    if (moveName === 'Tera Blast' && attacker.isTerastallized) {
        // æ”¹å±æ€§ï¼šå˜ä¸ºå¤ªæ™¶å±æ€§
        move.type = attacker.teraType;
        // æ”¹åˆ†ç±»ï¼šæ¯”è¾ƒç‰©æ”»å’Œç‰¹æ”»ï¼Œé«˜è€…å†³å®šåˆ†ç±»
        const atkStat = attacker.getStat ? attacker.getStat('atk') : attacker.atk;
        const spaStat = attacker.getStat ? attacker.getStat('spa') : attacker.spa;
        if (atkStat > spaStat) {
            move.cat = 'phys';
            category = 'Physical';
        } else {
            move.cat = 'spec';
            category = 'Special';
        }
        console.log(`[TERA BLAST] ${attacker.name} ä½¿ç”¨ Tera Blast: å±æ€§=${move.type}, åˆ†ç±»=${category} (Atk=${atkStat}, SpA=${spaStat})`);
    }
    // === ç­–ç•¥æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç‰¹æ®Šå¤„ç†å™¨ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    // === å›ºå®šä¼¤å®³æŠ€èƒ½ (damageCallback) ===
    if (handler && handler.damageCallback) {
        const fixedDamage = handler.damageCallback(attacker, defender);
        return { 
            damage: fixedDamage, 
            effectiveness: 1, 
            isCrit: false, 
            miss: false, 
            hitCount: 1,
            fixedDamage: true
        };
    }
    // === åŠ¨æ€å¨åŠ›æŠ€èƒ½ (basePowerCallback) ===
    if (handler && handler.basePowerCallback) {
        basePower = handler.basePowerCallback(attacker, defender);
    }
    // === ç‰¹æ€§å¨åŠ›åŠ æˆ Hook (æŠ€å¸ˆã€çŒ›ç«ã€æ¿€æµç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && attacker.ability && AbilityHandlers[attacker.ability]) {
        const ah = AbilityHandlers[attacker.ability];
        if (ah.onBasePower) {
            basePower = ah.onBasePower(basePower, attacker, defender, move);
        }
    }
    // === Mirror Coat / Counter ç®€åŒ–å¤„ç†ï¼šè½¬ä¸ºæ™®é€šæ”»å‡» ===
    if (move.name === 'Mirror Coat') {
        basePower = 100;
        move.cat = 'spec';
    } else if (move.name === 'Counter') {
        basePower = 80;
        move.cat = 'phys';
    }
    // === Protect/Detect å®ˆä½åˆ¤å®š ===
    // å¦‚æœé˜²å¾¡æ–¹å¤„äºå®ˆä½çŠ¶æ€ï¼Œä¸”è¿™æ˜¯ä¸€ä¸ªé’ˆå¯¹æ€§æ”»å‡»ï¼ˆéå˜åŒ–æŠ€ï¼‰
    if (defender.volatile && defender.volatile.protect && basePower > 0) {
        // æŸäº›æŠ€èƒ½å¯ä»¥è´¯ç©¿å®ˆä½ (Feint, Phantom Force ç­‰)ï¼Œè¿™é‡Œæš‚ä¸å¤„ç†
        return { damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true };
    }
    // === ç‰¹æ€§å…ç–«åˆ¤å®š Hook (æ¼‚æµ®ã€é¿é›·é’ˆã€å¼•ç«ç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onImmunity && ahDef.onImmunity(move.type)) {
            return { damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true, abilityImmune: defender.ability };
        }
    }
    // å˜åŒ–æŠ€ä¸é€ æˆä¼¤å®³ï¼Œä½†éœ€è¦å‘½ä¸­åˆ¤å®š
    if (basePower === 0 || category === 'Status') {
        // å˜åŒ–æŠ€å‘½ä¸­åˆ¤å®š
        let statusAcc = (accuracy === true || accuracy === undefined) ? 100 : accuracy;
        const accStage = attacker.boosts.accuracy;
        const evaStage = defender.boosts.evasion;
        const finalStage = Math.min(6, Math.max(-6, accStage - evaStage));
        let accMult = 1.0;
        if (finalStage >= 0) accMult = (3 + finalStage) / 3;
        else accMult = 3 / (3 + Math.abs(finalStage));
        const finalAcc = statusAcc * accMult;
        // å¿…ä¸­æŠ€èƒ½ (accuracy === true æˆ– undefined) è·³è¿‡åˆ¤å®š
        if (statusAcc < 100 && Math.random() * 100 >= finalAcc) {
            return { damage: 0, effectiveness: 1, isCrit: false, miss: true, hitCount: 0 };
        }
        return { damage: 0, effectiveness: 1, isCrit: false, miss: false, hitCount: 0 };
    }
    // === å‘½ä¸­åˆ¤å®š ===
    let moveAcc = (accuracy === true || accuracy === undefined) ? 100 : accuracy;
    // å‘½ä¸­/é—ªé¿ä¿®æ­£å…¬å¼ï¼šä»¥ 3 ä¸ºåŸºå‡†
    const accStage = attacker.boosts.accuracy;
    const evaStage = defender.boosts.evasion;
    const finalStage = Math.min(6, Math.max(-6, accStage - evaStage));
    let accMult = 1.0;
    if (finalStage >= 0) accMult = (3 + finalStage) / 3;
    else accMult = 3 / (3 + Math.abs(finalStage));
    let hitRate = moveAcc * accMult;
    // =====================================================
    // === å¿…ä¸­åˆ¤å®šï¼šZ æ‹›å¼å’Œæå·¨æ‹›å¼è±å… ===
    // =====================================================
    // Z æ‹›å¼å’Œæå·¨æ‹›å¼æ˜¯å¿…ä¸­çš„ï¼Œæ— è§†å›é¿ç‡æå‡
    const isZMove = move.isZ || (move.name && (
        move.name.includes('10,000,000') ||
        move.name.includes('Catastropika') ||
        move.name.includes('Breakneck Blitz') ||
        move.name.includes('Inferno Overdrive') ||
        move.name.includes('Hydro Vortex') ||
        move.name.includes('Gigavolt Havoc')
    ));
    const isMaxMove = move.isMax || (move.name && (
        move.name.startsWith('Max ') ||
        move.name.startsWith('G-Max ')
    ));
    const isSureHit = isZMove || isMaxMove || accuracy === true;
    // =====================================================
    // === Insight å¥‡è¿¹é—ªé¿ (Miracle Dodge) ===
    // =====================================================
    // æé«˜ Insight (250+) å¯ä»¥æœ‰å°æ¦‚ç‡é—ªé¿å¿…ä¸­æ‹›å¼
    // è¿™æ˜¯ RP å™äº‹çš„"è§„åˆ™çº§é—ªé¿"ï¼Œä»£è¡¨æè‡´çš„ç¬¬å…­æ„Ÿ
    if (isSureHit && defender.isAce && defender.avs && defender.avs.insight >= 250) {
        const baseInsight = defender.getEffectiveAVs('insight');
        const effectiveInsight = defender.avsEvolutionBoost ? baseInsight * 2 : baseInsight;
        // 255 æ»¡å€¼ = 10% å¥‡è¿¹é—ªé¿ï¼Œ250-254 = 5%
        const miracleChance = effectiveInsight >= 255 ? 10 : 5;
        if (Math.random() * 100 < miracleChance) {
            console.log(`[Insight] MIRACLE DODGE TRIGGERED! Bypassed Sure-Hit.`);
            return {
                damage: 0,
                effectiveness: 0,
                isCrit: false,
                miss: true,
                hitCount: 0,
                insightMiracle: true // æ ‡è®°ä¸ºå¥‡è¿¹é—ªé¿
            };
        }
    }
    // =====================================================
    // === AVs: Insight (çµçŠ€) - Sixth Sense é—ªé¿åŠ æˆ ===
    // =====================================================
    // ã€å¹³è¡¡è°ƒæ•´ v2ã€‘è¿›ä¸€æ­¥å‰Šå¼±é—ªé¿åŠ æˆï¼Œè®¾ç½®ä¸Šé™
    // Insight >= 200: å‘½ä¸­ç‡ -8%ï¼ˆåŸ -10%ï¼‰
    // Insight >= 150: å‘½ä¸­ç‡ -5%ï¼ˆåŸ -7%ï¼‰
    // Insight >= 100: å‘½ä¸­ç‡ -2%ï¼ˆåŸ -3%ï¼‰
    // ã€ä¸Šé™ã€‘æœ€ç»ˆå‘½ä¸­ç‡ä¸ä½äº 70%ï¼ˆé˜²æ­¢é—ªé¿æµè¿‡äºå˜æ€ï¼‰
    // åªæœ‰ isAce=true çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
    // ã€ä¿®å¤ã€‘Z æ‹›å¼å’Œæå·¨æ‹›å¼æ˜¯å¿…ä¸­çš„ï¼Œä¸å— Insight å½±å“
    if (defender.isAce && defender.avs && defender.avs.insight > 0 && !isSureHit) {
        let evasionBonus = 0;
        const baseInsight = defender.getEffectiveAVs('insight');
        const effectiveInsight = defender.avsEvolutionBoost ? baseInsight * 2 : baseInsight;
        if (effectiveInsight >= 200) evasionBonus = 8;      // å‰Šå¼±ï¼š10% -> 8%
        else if (effectiveInsight >= 150) evasionBonus = 5; // å‰Šå¼±ï¼š7% -> 5%
        else if (effectiveInsight >= 100) evasionBonus = 2; // å‰Šå¼±ï¼š3% -> 2%
        // ã€ä¸Šé™ã€‘æœ€ç»ˆå‘½ä¸­ç‡ä¸ä½äº 70%ï¼Œé˜²æ­¢é—ªé¿æµè¿‡äºå˜æ€
        hitRate = Math.max(70, hitRate - evasionBonus);
    }
    // æ£€æµ‹æ˜¯å¦ Miss (å¿…ä¸­ç±»ä¸éœ€è¦æ£€å®š)
    if (typeof accuracy === 'number' && !isSureHit) {
        if (Math.random() * 100 > hitRate) {
            return { damage: 0, effectiveness: 0, isCrit: false, miss: true, hitCount: 0, insightDodge: defender.avs?.insight >= 100 };
        }
    }
    // === å¤šæ®µæ”»å‡» (Multi-Hit) ===
    let hitCount = 1;
    const multihit = fullMoveData.multihit;
    if (multihit) {
        if (Array.isArray(multihit)) {
            // éšæœºæ¬¡æ•° [min, max]ï¼Œå¦‚ [2, 5]
            // æ¦‚ç‡åˆ†å¸ƒï¼š2æ¬¡=1/3, 3æ¬¡=1/3, 4æ¬¡=1/6, 5æ¬¡=1/6 (ç®€åŒ–ä¸ºå‡åŒ€åˆ†å¸ƒ)
            const [min, max] = multihit;
            hitCount = Math.floor(Math.random() * (max - min + 1)) + min;
        } else {
            // å›ºå®šæ¬¡æ•°ï¼Œå¦‚ multihit: 2 (åŒé‡åŠˆ) æˆ– 3 (æ°´æµè¿æ‰“)
            hitCount = multihit;
        }
    }
    // === é€‰æ‹©æ”»å‡»/é˜²å¾¡èƒ½åŠ› (ä½¿ç”¨ getStat è·å–ä¿®æ­£åæ•°å€¼) ===
    const isSpecial = (move.cat === 'spec' || category === 'Special');
    let atkStat = isSpecial ? attacker.getStat('spa') : attacker.getStat('atk');
    let defStat = isSpecial ? defender.getStat('spd') : defender.getStat('def');
    // === ç­–ç•¥æ¨¡å¼ï¼šç‰¹æ®Šæ”»é˜²è®¡ç®— (Foul Play, Body Press, Psyshock ç­‰) ===
    if (handler && handler.modifyAtk) {
        atkStat = handler.modifyAtk(attacker, defender, isSpecial);
    }
    if (handler && handler.modifyDef) {
        defStat = handler.modifyDef(attacker, defender, isSpecial);
    }
    // === ç¼ä¼¤å‡åŠç‰©æ”» (Burn halves physical attack) ===
    if (!isSpecial && attacker.status === 'brn') {
        atkStat = Math.floor(atkStat * 0.5);
    }
    // === é˜²å¾¡æ–¹å±æ€§åˆ¤å®šä¿®æ­£ ===
    // å¸¸è§„å¤ªæ™¶ï¼šé˜²å¾¡å±æ€§ = teraType
    // æ˜Ÿæ™¶å¤ªæ™¶ï¼šé˜²å¾¡å±æ€§ = åŸå§‹å±æ€§ (ä¸æ”¹å˜é˜²å¾¡å±æ€§)
    let defensiveTypes = defender.types || ['Normal'];
    if (defender.isTerastallized) {
        if (defender.teraType === 'Stellar') {
            // æ˜Ÿæ™¶é˜²å¾¡ç‰¹æ®ŠåŒ–ï¼šç”¨å›åŸå±æ€§
            defensiveTypes = defender.originalTypes || defender.types;
            console.log(`[STELLAR] ${defender.name} æ˜¯æ˜Ÿæ™¶çŠ¶æ€ï¼Œé˜²å¾¡å±æ€§å›å½’ä¸º: ${defensiveTypes.join('/')}`);
        } else {
            // å¸¸è§„å¤ªæ™¶ï¼šç”¨å¤ªæ™¶å±æ€§
            defensiveTypes = [defender.teraType];
        }
    }
    // å±æ€§å…‹åˆ¶ï¼ˆä¼ å…¥æŠ€èƒ½åç”¨äºç‰¹æ®Šå…‹åˆ¶è§„åˆ™å¦‚ Freeze-Dryï¼‰
    let effectiveness = getTypeEffectiveness(move.type, defensiveTypes, move.name);
    // =====================================================
    // === æœ¬ç³»åŠ æˆ (STAB) - æ”¯æŒå¤ªæ™¶åŒ–åŒè½¨åˆ¶ + æ˜Ÿæ™¶ç‰¹æ®Šé€»è¾‘ ===
    // =====================================================
    let stab = 1;
    if (attacker.isTerastallized) {
        const teraType = attacker.teraType;
        const originalTypes = attacker.originalTypes || [];
        const moveType = move.type;
        // --- â˜… æ˜Ÿæ™¶ (Stellar) ç‰¹æ®Šé€»è¾‘ ---
        if (teraType === 'Stellar') {
            // æ˜Ÿæ™¶é€»è¾‘1ï¼šåŸå§‹æœ¬ç³»æ‹›å¼ï¼ŒåŠ æˆæå‡åˆ° 2.0x (åŸ1.5 -> 2.0)
            if (originalTypes.includes(moveType)) {
                stab = 2.0; 
                console.log(`[STELLAR STAB] ${attacker.name} åŸç”Ÿæœ¬ç³»å¼ºåŒ– (${moveType}) -> 2.0x`);
            } 
            // æ˜Ÿæ™¶é€»è¾‘2ï¼šéæœ¬ç³»æ‹›å¼ï¼Œè·å¾— 1.2x åŠ æˆ
            else {
                stab = 1.2;
                console.log(`[STELLAR STAB] ${attacker.name} æ˜Ÿæ™¶å…¨èƒ½å¼ºåŒ– (${moveType}) -> 1.2x`);
            }
            // æ˜Ÿæ™¶é€»è¾‘3ï¼šå¤ªæ™¶çˆ†å‘ (Tera Blast) æ°¸è¿œæ˜¯ 2.0x
            if (move.name === 'Tera Blast') {
                stab = 2.0; 
            }
        } 
        // --- å¸¸è§„å¤ªæ™¶é€»è¾‘ (åŒè½¨åˆ¶) ---
        else {
            // è½¨é“1 (Tera Track): æŠ€èƒ½å±æ€§ == å¤ªæ™¶å±æ€§
            let teraTrackBonus = 0;
            if (moveType === teraType) {
                teraTrackBonus = 1.5;
                // é€‚åº”åŠ›çˆ†å‘ï¼šå¤ªæ™¶å±æ€§ == åŸå§‹å±æ€§ä¹‹ä¸€ -> 2.0å€
                if (originalTypes.includes(teraType)) {
                    teraTrackBonus = 2.0;
                }
            }
            // è½¨é“2 (Recall Track): æŠ€èƒ½å±æ€§ == åŸå§‹å±æ€§ä¹‹ä¸€ï¼ˆå›æº¯ STABï¼‰
            let recallTrackBonus = 0;
            if (originalTypes.includes(moveType)) {
                recallTrackBonus = 1.5;
            }
            // å–ä¸¤ä¸ªè½¨é“çš„æœ€é«˜å€¼
            stab = Math.max(teraTrackBonus, recallTrackBonus, 1);
            if (stab > 1) {
                console.log(`[TERA STAB] ${attacker.name} (Tera: ${teraType}, Original: ${originalTypes.join('/')}) ä½¿ç”¨ ${moveType} æ‹›å¼, STAB: ${stab}x`);
            }
        }
    } else {
        // æ™®é€šçŠ¶æ€ï¼šæ ‡å‡† STAB
        stab = attacker.types.includes(move.type) ? 1.5 : 1;
    }
    // === é€‚åº”åŠ›ç‰¹æ€§ Hook (STAB 1.5 -> 2.0) ===
    // æ³¨æ„ï¼šå¤ªæ™¶åŒ–çš„é€‚åº”åŠ›çˆ†å‘å·²åœ¨ä¸Šé¢å¤„ç†ï¼Œè¿™é‡Œåªå¤„ç†éå¤ªæ™¶çŠ¶æ€
    if (!attacker.isTerastallized && stab > 1 && attacker.ability === 'Adaptability') {
        stab = 2;
    }
    // ============================================
    // â˜… æ˜Ÿæ™¶å¤ªæ™¶çˆ†å‘ (Tera Blast - Stellar) ç‰¹åˆ¤
    // ============================================
    if (attacker.isTerastallized && attacker.teraType === 'Stellar' && move.name === 'Tera Blast') {
        // æ•ˆæœ1: å¯¹ã€å·²å¤ªæ™¶åŒ–ã€‘çš„æ•Œäººï¼Œæ— è§†å±æ€§ï¼Œæ’å®šé€ æˆå…‹åˆ¶ä¼¤å®³
        if (defender.isTerastallized) {
            console.log(`[STELLAR KILLER] æ˜Ÿæ™¶çˆ†å‘å‡»ä¸­äº†å¤ªæ™¶åŒ–çš„å¯¹æ‰‹ï¼å¼ºåˆ¶æ•ˆæœæ‹”ç¾¤ã€‚`);
            // è¦†ç›–ä¹‹å‰çš„å±æ€§å…‹åˆ¶è®¡ç®—ç»“æœï¼Œå¼ºåˆ¶ 2.0x
            effectiveness = 2.0; 
        } else {
            // å¯¹æœªå¤ªæ™¶åŒ–çš„æ•Œäººï¼šä¼¤å®³å˜ä¸ºä¸­æ€§ (1.0)ï¼Œä½†ä¼šé™ä½è‡ªèº«æ”»é˜²ï¼ˆåœ¨ move-handlers å¤„ç†ï¼‰
            if (effectiveness < 1 && effectiveness > 0) {
                effectiveness = 1;
            }
        }
    }
    // === ä¼šå¿ƒä¸€å‡»åˆ¤å®š ===
    let isCrit = false;
    // å¿…å®šæš´å‡»æŠ€èƒ½ï¼šä» MOVES æ•°æ®çš„ willCrit å­—æ®µåˆ¤æ–­ï¼ˆæ•°æ®é©±åŠ¨ï¼‰
    if (fullMoveData.willCrit) {
        isCrit = true;
    } else {
        // æ ¹æ® critRatio è®¡ç®—æš´å‡»ç‡
        // critRatio: 1 = 1/24 (~4.17%), 2 = 1/8 (12.5%), 3 = 1/2 (50%), 4+ = 100%
        let critRatio = fullMoveData.critRatio || 1;
        // =====================================================
        // === AVs: Passion (æ¿€æƒ…) - Adrenaline Rush æš´å‡»åŠ æˆ ===
        // =====================================================
        // ã€å¹³è¡¡è°ƒæ•´ã€‘é™ä½æš´å‡»ç­‰çº§åŠ æˆ
        // Passion >= 200: critRatio +1ï¼ˆåŸ +2ï¼Œçº¦ 50% æš´å‡»ç‡ï¼‰
        // Passion >= 150: critRatio +0.5ï¼ˆåŸ +1ï¼Œçº¦ 25% æš´å‡»ç‡ï¼‰
        // Passion >= 100: critRatio +0ï¼ˆåŸ +0.5ï¼Œä»…ä¿ç•™åŸºç¡€æ¦‚ç‡ï¼‰
        // åªæœ‰ isAce=true çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
        if (attacker.isAce && attacker.avs && attacker.avs.passion > 0) {
            const basePassion = attacker.getEffectiveAVs('passion');
            const effectivePassion = attacker.avsEvolutionBoost ? basePassion * 2 : basePassion;
            if (effectivePassion >= 200) critRatio += 1;       // å‰Šå¼±ï¼š+2 -> +1
            else if (effectivePassion >= 150) critRatio += 0.5; // å‰Šå¼±ï¼š+1 -> +0.5
            // 100+ ä¸å†æœ‰åŠ æˆ
        }
        let critChance = 1 / 24; // é»˜è®¤ ~4.17%
        if (critRatio >= 2 && critRatio < 3) critChance = 1 / 8;
        else if (critRatio >= 3 && critRatio < 4) critChance = 1 / 2;
        else if (critRatio >= 4) critChance = 1;
        if (Math.random() < critChance) isCrit = true;
    }
    const critMod = isCrit ? 1.5 : 1;
    // ä¹±æ•° (0.85 ~ 1.0)
    const random = 0.85 + Math.random() * 0.15;
    // é˜²æ­¢é™¤ä»¥0
    const finalDef = Math.max(1, defStat);
    // ä¼¤å®³å…¬å¼ (å•æ¬¡ä¼¤å®³)
    // Damage = ((2*Level/5 + 2) * Power * A/D / 50 + 2) * Modifiers
    let singleHitDamage = Math.floor(
        ((2 * attacker.level / 5 + 2) * basePower * (atkStat / finalDef) / 50 + 2)
        * stab * effectiveness * critMod * random
    );
    // æœ€ä½ä¼¤å®³ 1 (é™¤éå…ç–«)
    if (effectiveness > 0 && singleHitDamage < 1) singleHitDamage = 1;
    // å…ç–«æ—¶ä¼¤å®³ä¸º 0
    if (effectiveness === 0) singleHitDamage = 0;
    // === é˜²å¾¡æ–¹ç‰¹æ€§ä¼¤å®³ä¿®æ­£ Hook (åšè„‚è‚ªã€å¤šé‡é³ç‰‡ã€æ»¤é•œç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onDefenderModifyDamage) {
            singleHitDamage = ahDef.onDefenderModifyDamage(singleHitDamage, attacker, defender, move, effectiveness);
        }
    }
    // === åŒå¢™/æå…‰å¹•å‡ä¼¤ (Screens) ===
    // éœ€è¦ä»å…¨å±€ battle å¯¹è±¡è·å–åœºåœ°çŠ¶æ€
    if (typeof battle !== 'undefined' && battle) {
        // åˆ¤æ–­é˜²å¾¡æ–¹æ˜¯ç©å®¶è¿˜æ˜¯æ•Œæ–¹
        const defenderSide = (defender === battle.getPlayer?.()) ? battle.playerSide : battle.enemySide;
        if (defenderSide) {
            // æå…‰å¹•ï¼šç‰©ç†å’Œç‰¹æ®Šéƒ½å‡åŠ
            if (defenderSide.auroraVeil > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
            // åå°„å£ï¼šç‰©ç†å‡åŠ
            else if (!isSpecial && defenderSide.reflect > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
            // å…‰å¢™ï¼šç‰¹æ®Šå‡åŠ
            else if (isSpecial && defenderSide.lightScreen > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
        }
    }
    // === ç»“å®ç‰¹æ€§ Hook (æ»¡è¡€é”1è¡€) ===
    if (typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onDamageHack) {
            singleHitDamage = ahDef.onDamageHack(singleHitDamage * hitCount, defender);
            // å¦‚æœè¢«é”è¡€ï¼Œç›´æ¥è¿”å›
            return { 
                damage: singleHitDamage, 
                singleHitDamage,
                effectiveness, 
                isCrit, 
                miss: false, 
                hitCount,
                sturdyActivated: singleHitDamage === defender.currHp - 1
            };
        }
    }
    // æ€»ä¼¤å®³ = å•æ¬¡ä¼¤å®³ Ã— å‘½ä¸­æ¬¡æ•°
    const totalDamage = singleHitDamage * hitCount;
    return { 
        damage: totalDamage, 
        singleHitDamage,
        effectiveness, 
        isCrit, 
        miss: false, 
        hitCount 
    };
}
/**
 * å¤„ç†æŠ€èƒ½å¸¦æ¥çš„å‰¯ä½œç”¨ï¼ˆèƒ½åŠ›å‡é™ã€åä¼¤ã€å¸è¡€ï¼‰
 * @param {Pokemon} user æ”»å‡»æ–¹
 * @param {Pokemon} target å—å‡»æ–¹
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @param {number} damageDealt å®é™…é€ æˆçš„ä¼¤å®³ï¼ˆç”¨äºè®¡ç®—åä¼¤/å¸è¡€ï¼‰
 * @returns {Array} äº§ç”Ÿçš„æ—¥å¿—æ–‡æœ¬æ•°ç»„
 */
function applyMoveSecondaryEffects(user, target, move, damageDealt = 0, battle = null, isPlayer = false) {
    let logs = [];
    // è·å–å®Œæ•´æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // === ç­–ç•¥æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç‰¹æ®Šå¤„ç†å™¨ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    console.log(`[MOVE HANDLER] Looking for handler: "${move.name}", found:`, handler ? 'YES' : 'NO', handler?.onUse ? '(has onUse)' : '');
    // === onUse é’©å­ (å˜åŒ–æŠ€/å¤©æ°”/åœºåœ°ç­‰ï¼Œä»¥åŠæŠ€èƒ½å‰ç½®æ£€æŸ¥å¦‚ Fake Out) ===
    if (handler && handler.onUse) {
        console.log(`[MOVE HANDLER] Calling onUse for "${move.name}", battle:`, battle, 'isPlayer:', isPlayer);
        const result = handler.onUse(user, target, logs, battle, isPlayer);
        console.log(`[MOVE HANDLER] onUse returned, logs now:`, logs);
        if (result) {
            // å¤„ç†ç‰¹æ®Šè¿”å›å€¼
            if (result.failed) {
                // æŠ€èƒ½å¤±è´¥ï¼ˆå¦‚ Fake Out éé¦–å›åˆä½¿ç”¨ï¼‰
                return { logs, pivot: false };
            }
            if (result.selfDestruct) {
                // è‡ªçˆ†ç±»æŠ€èƒ½å·²åœ¨ handler ä¸­å¤„ç† HP
            }
        }
    }
    // === onHit é’©å­ (å‘½ä¸­åæ•ˆæœ) ===
    // æ³¨æ„ï¼šå˜åŒ–æŠ€ï¼ˆå¦‚ Recover, Hazeï¼‰ä¹Ÿéœ€è¦è§¦å‘ onHitï¼Œå³ä½¿ damageDealt === 0
    let pivotTriggered = false;
    if (handler && handler.onHit) {
        const hitResult = handler.onHit(user, target, damageDealt, logs, battle);
        if (hitResult && hitResult.pivot) {
            pivotTriggered = true;
        }
    }
    // === åœºåœ°çŠ¶æ€æŠ€èƒ½å¤„ç† (sideCondition) ===
    // åŒ…æ‹¬ï¼šéšå½¢å²©ã€æ’’è±ã€æ¯’è±ã€é»é»ç½‘ã€é¡ºé£ã€åŒå¢™ç­‰
    if (fullMoveData.sideCondition && battle) {
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applySideCondition) {
            const sideLogs = MoveEffects.applySideCondition(user, move, battle);
            logs.push(...sideLogs);
        }
    }
    // èƒ½åŠ›åç§°æ˜ å°„
    const statMap = {
        atk: "æ”»å‡»", def: "é˜²å¾¡", spa: "ç‰¹æ”»", spd: "ç‰¹é˜²", spe: "é€Ÿåº¦",
        accuracy: "å‘½ä¸­ç‡", evasion: "é—ªé¿ç‡"
    };
    // å˜åŒ–å¹…åº¦æ–‡æ¡ˆ
    const getChangeText = (val) => {
        if (Math.abs(val) >= 3) return "æå¤§å¹…";
        if (Math.abs(val) === 2) return "å¤§å¹…";
        return "";
    };
    // helperï¼šä¿®æ”¹æŒ‡å®šå¯¹è±¡çš„èƒ½åŠ›
    const changeStats = (subject, boostsObj) => {
        if (!boostsObj) return;
        for (const [stat, val] of Object.entries(boostsObj)) {
            if (typeof val !== 'number') continue;
            const diff = subject.applyBoost(stat, val);
            if (diff === 0) {
                // å…³é”®ä¿®å¤ï¼šæ ¹æ®å½“å‰èƒ½åŠ›ç­‰çº§åˆ¤æ–­æ˜¯ä¸Šé™è¿˜æ˜¯ä¸‹é™
                // Contrary ç‰¹æ€§ä¼šå¯¼è‡´ val å’Œå®é™…æ–¹å‘ç›¸åï¼Œæ‰€ä»¥è¦çœ‹å½“å‰ boost å€¼
                const currentBoost = subject.boosts[stat] || 0;
                if (currentBoost >= 6) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}å·²ç»æ— æ³•å†æå‡äº†!`);
                } else if (currentBoost <= -6) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}å·²ç»æ— æ³•å†é™ä½äº†!`);
                } else {
                    // ç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™é‡Œï¼Œä½†ä¿é™©èµ·è§
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}æ— æ³•æ”¹å˜!`);
                }
            } else {
                // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ diffï¼ˆå®é™…å˜åŒ–å€¼ï¼‰è€Œä¸æ˜¯ valï¼ˆåŸå§‹å€¼ï¼‰æ¥ç”Ÿæˆæ—¥å¿—
                // è¿™æ · Contrary ç‰¹æ€§çš„åè½¬æ•ˆæœä¼šæ­£ç¡®æ˜¾ç¤º
                const changeText = getChangeText(diff);
                if (diff > 0) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}${changeText}æå‡äº†!`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
                } else {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}${changeText}ä¸‹é™äº†!`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
                }
            }
        }
    };
    // ========== 1. èƒ½åŠ›å˜åŒ– (Boosts) ==========
    // === å…³é”®ä¿®å¤ï¼šåˆ¤æ–­æŠ€èƒ½ç›®æ ‡æ˜¯è‡ªå·±è¿˜æ˜¯æ•Œäºº ===
    // target: 'self', 'allySide', 'adjacentAlly' -> ä½œç”¨äºè‡ªå·± (å¦‚ Swords Dance, Agility)
    // target: 'normal', 'allAdjacentFoes', 'any' -> ä½œç”¨äºæ•Œäºº (å¦‚ Sand Attack, Growl, Tail Whip)
    const selfTargets = ['self', 'allySide', 'adjacentAlly', 'adjacentAllyOrSelf', 'allies'];
    const isTargetSelf = selfTargets.includes(fullMoveData.target);
    // 1.1 Status æ‹›å¼çš„ boosts
    if (fullMoveData.category === 'Status' && fullMoveData.boosts) {
        if (isTargetSelf) {
            // å¦‚ Swords Dance, Agility, Calm Mind -> Buff è‡ªå·±
            changeStats(user, fullMoveData.boosts);
        } else {
            // å¦‚ Sand Attack, Growl, Tail Whip, String Shot -> Debuff æ•Œäºº
            changeStats(target, fullMoveData.boosts);
        }
    }
    // 1.2 self.boostsï¼ˆå¯¹è‡ªå·±ç”Ÿæ•ˆçš„å‰¯ä½œç”¨ï¼‰
    if (fullMoveData.self && fullMoveData.self.boosts) {
        changeStats(user, fullMoveData.self.boosts);
    }
    // 1.3 Secondary Effectsï¼ˆå‡ ç‡è§¦å‘ï¼Œé€šå¸¸å¯¹æ•Œäººï¼‰
    if (fullMoveData.secondary) {
        const chance = fullMoveData.secondary.chance || 100;
        if (Math.random() * 100 < chance) {
            if (fullMoveData.secondary.boosts) {
                changeStats(target, fullMoveData.secondary.boosts);
            }
            if (fullMoveData.secondary.self && fullMoveData.secondary.self.boosts) {
                changeStats(user, fullMoveData.secondary.self.boosts);
            }
            // === çŠ¶æ€å¼‚å¸¸ï¼šå†™å…¥çœŸå®æ•°æ® + æ—¥å¿— ===
            if (fullMoveData.secondary.status) {
                const s = fullMoveData.secondary.status;
                // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å·²æœ‰ä¸»è¦çŠ¶æ€ï¼ˆä¸»è¦çŠ¶æ€äº’æ–¥ï¼‰
                if (!target.status) {
                    target.status = s;
                    if (s === 'slp') {
                        target.sleepTurns = Math.floor(Math.random() * 3) + 2; // ç¡2-4å›åˆ
                    }
                    const statusMap = {
                        brn: "è¢«ç¼ä¼¤äº†!", psn: "ä¸­æ¯’äº†!", par: "éº»ç—¹äº†!",
                        tox: "ä¸­äº†å‰§æ¯’!", slp: "ç¡ç€äº†!", frz: "è¢«å†»ç»“äº†!"
                    };
                    const statusText = statusMap[s];
                    if (statusText) {
                        logs.push(`${target.cnName} ${statusText}`);
                    }
                }
            }
            // ç•ç¼©æ•ˆæœï¼šå†™å…¥ volatile çŠ¶æ€
            if (fullMoveData.secondary.volatileStatus === 'flinch') {
                target.volatile = target.volatile || {};
                target.volatile.flinch = true;
                logs.push(`${target.cnName} ç•ç¼©äº†!`);
            }
        }
    }
    // 1.4 Status æ‹›å¼ç›´æ¥æ–½åŠ çŠ¶æ€ï¼ˆå¦‚ç”µç£æ³¢ã€é¬¼ç«ã€å‚¬çœ ç²‰ï¼‰
    if (fullMoveData.status) {
        const s = fullMoveData.status;
        if (!target.status) {
            target.status = s;
            if (s === 'slp') {
                target.sleepTurns = Math.floor(Math.random() * 3) + 2;
            }
            const statusMap = {
                brn: "è¢«ç¼ä¼¤äº†!", psn: "ä¸­æ¯’äº†!", par: "éº»ç—¹äº†!",
                tox: "ä¸­äº†å‰§æ¯’!", slp: "ç¡ç€äº†!", frz: "è¢«å†»ç»“äº†!"
            };
            const statusText = statusMap[s];
            if (statusText) {
                logs.push(`${target.cnName} ${statusText}`);
            }
        }
    }
    // 1.4 è‡ªé™èƒ½åŠ›å‰¯ä½œç”¨ - æ•°æ®é©±åŠ¨ï¼šä» MOVES çš„ self.boosts è¯»å–
    // ä¸å†éœ€è¦ boostPatches ç¡¬ç¼–ç è¡¥ä¸ï¼
    // ç¤ºä¾‹ï¼šClose Combat ä¼šä» moves-data.js è¯»å– self: { boosts: { def: -1, spd: -1 } }
    // === 1.5 Protect/Detect å®ˆä½ç±»æŠ€èƒ½ï¼šè®¾ç½® volatile çŠ¶æ€ ===
    // æ•°æ®é©±åŠ¨ï¼šæ£€æŸ¥ MOVES çš„ stallingMove å­—æ®µæˆ– volatileStatus åŒ…å« protect
    const isProtectMove = fullMoveData.stallingMove || 
        (fullMoveData.volatileStatus && ['protect', 'banefulbunker', 'spikyshield', 'kingsshield', 'obstruct', 'silktrap', 'burningbulwark'].includes(fullMoveData.volatileStatus));
    if (isProtectMove) {
        user.volatile = user.volatile || {};
        user.volatile.protect = true;
        logs.push(`${user.cnName} å®ˆä½äº†è‡ªå·±!`);
    }
    // ========== 2. åä¼¤ (Recoil) ==========
    // æ ¼å¼: recoil: [num, den] è¡¨ç¤ºåä¼¤ num/den çš„é€ æˆä¼¤å®³
    // === çŸ³å¤´è„‘è¢‹ / é­”æ³•é˜²å®ˆ å…ç–«åä¼¤ ===
    const noRecoilAbility = (typeof AbilityHandlers !== 'undefined' && user.ability && AbilityHandlers[user.ability]) 
        ? (AbilityHandlers[user.ability].noRecoil || AbilityHandlers[user.ability].noIndirectDamage) 
        : false;
    if (!noRecoilAbility) {
        if (fullMoveData.recoil && damageDealt > 0) {
            const [num, den] = fullMoveData.recoil;
            const recoilDmg = Math.max(1, Math.floor(damageDealt * num / den));
            user.takeDamage(recoilDmg);
            logs.push(`${user.cnName} å—åˆ°äº† ${recoilDmg} ç‚¹åä½œç”¨åŠ›ä¼¤å®³!`);
        } else if (damageDealt > 0) {
            // ä» move-constants.js è·å–åä¼¤æ•°æ®
            const recoilPatches = (typeof RECOIL_MOVES !== 'undefined') ? RECOIL_MOVES : {};
            if (recoilPatches[move.name]) {
                const [num, den] = recoilPatches[move.name];
                const recoilDmg = Math.max(1, Math.floor(damageDealt * num / den));
                user.takeDamage(recoilDmg);
                logs.push(`${user.cnName} å—åˆ°äº† ${recoilDmg} ç‚¹åä½œç”¨åŠ›ä¼¤å®³!`);
            }
        }
    }
    // ========== 3. å¸è¡€ (Drain) ==========
    // æ ¼å¼: drain: [num, den] è¡¨ç¤ºæ¢å¤ num/den çš„é€ æˆä¼¤å®³
    if (fullMoveData.drain && damageDealt > 0) {
        const [num, den] = fullMoveData.drain;
        const healAmt = Math.max(1, Math.floor(damageDealt * num / den));
        const actualHeal = Math.min(healAmt, user.maxHp - user.currHp);
        if (actualHeal > 0) {
            user.heal(healAmt);
            logs.push(`${user.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
        }
    } else if (damageDealt > 0) {
        // ä» move-constants.js è·å–å¸è¡€æ•°æ®
        const drainPatches = (typeof DRAIN_MOVES !== 'undefined') ? DRAIN_MOVES : {};
        if (drainPatches[move.name]) {
            const [num, den] = drainPatches[move.name];
            const healAmt = Math.max(1, Math.floor(damageDealt * num / den));
            const actualHeal = Math.min(healAmt, user.maxHp - user.currHp);
            if (actualHeal > 0) {
                user.heal(healAmt);
                logs.push(`${user.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
        }
    }
    // ========== 4. ç‰¹æ®ŠæŠ€èƒ½æ•ˆæœç¡¬ç¼–ç  ==========
    // å¯„ç”Ÿç§å­ (Leech Seed)
    if (move.name === 'Leech Seed') {
        // è‰ç³»å…ç–«å¯„ç”Ÿç§å­
        if (!target.types.includes('Grass')) {
            target.volatile = target.volatile || {};
            target.volatile['leechseed'] = true;
            logs.push(`å¯„ç”Ÿç§å­ç§åœ¨äº† ${target.cnName} èº«ä¸Š!`);
        } else {
            logs.push(`å¯¹è‰ç³»å®å¯æ¢¦æ²¡æœ‰æ•ˆæœ!`);
        }
    }
    // å“ˆæ¬  (Yawn)
    if (move.name === 'Yawn') {
        if (!target.status && !(target.volatile && target.volatile['yawn'])) {
            target.volatile = target.volatile || {};
            target.volatile['yawn'] = 2; // 2å›åˆåç¡ç€
            logs.push(`${target.cnName} æ‰“äº†ä¸ªå¤§å¤§çš„å“ˆæ¬ ...`);
        }
    }
    // è¯…å’’ (Curse) - é¬¼ç³»ç‰ˆæœ¬
    if (move.name === 'Curse' && user.types.includes('Ghost')) {
        const selfDmg = Math.floor(user.maxHp / 2);
        user.takeDamage(selfDmg);
        target.volatile = target.volatile || {};
        target.volatile['curse'] = true;
        logs.push(`${user.cnName} å‰Šå‡äº†è‡ªå·±çš„ä½“åŠ›ï¼Œå¯¹ ${target.cnName} æ–½åŠ äº†è¯…å’’!`);
    }
    // æŸç¼šç±»æŠ€èƒ½ - æ•°æ®é©±åŠ¨ï¼šæ£€æŸ¥ MOVES çš„ volatileStatus === 'partiallytrapped'
    if (fullMoveData.volatileStatus === 'partiallytrapped') {
        target.volatile = target.volatile || {};
        target.volatile['partiallytrapped'] = true;
        logs.push(`${target.cnName} è¢«å›°ä½äº†!`);
    }
    // ========== 5. è‡ªæˆ‘ç‰ºç‰²æŠ€èƒ½ (Self-Destruct) ==========
    // å¤„ç† selfdestruct å­—æ®µï¼šMemento, Healing Wish, Lunar Dance ç­‰
    // selfdestruct: "always" - æ— è®ºå‘½ä¸­ä¸å¦éƒ½æ¿’æ­»
    // selfdestruct: "ifHit" - å‘½ä¸­åæ‰æ¿’æ­»
    if (fullMoveData.selfdestruct) {
        const shouldFaint = fullMoveData.selfdestruct === 'always' || 
                           (fullMoveData.selfdestruct === 'ifHit' && damageDealt >= 0);
        if (shouldFaint) {
            user.currHp = 0;
            logs.push(`${user.cnName} å€’ä¸‹äº†!`);
            console.log(`[SELFDESTRUCT] ${user.cnName} used ${move.name} with selfdestruct: ${fullMoveData.selfdestruct}`);
        }
    }
    // è¿”å›åŒ…å«æ—¥å¿—å’Œ pivot æ ‡è®°çš„å¯¹è±¡
    return { logs, pivot: pivotTriggered };
}
/**
 * æ ¸å¿ƒï¼šåˆ¤æ–­å½“å‰å®å¯æ¢¦èƒ½å¦è¡ŒåŠ¨
 * @param {Pokemon} pokemon
 * @returns {{ can: boolean, msg: string }}
 */
function checkCanMove(pokemon) {
    // 1. ç•ç¼© (Flinch) - æœ¬å›åˆæ— æ³•è¡ŒåŠ¨ï¼Œç”¨å®Œå³æ¸…
    if (pokemon.volatile && pokemon.volatile.flinch) {
        pokemon.volatile.flinch = false;
        return { can: false, msg: `${pokemon.cnName} å› ä¸ºç•ç¼©è€Œæ— æ³•åŠ¨å¼¹!` };
    }
    // 2. ç¡çœ  (Sleep) - æ¯å›åˆå‡å°‘è®¡æ•°ï¼Œåˆ°0é†’æ¥
    if (pokemon.status === 'slp') {
        pokemon.sleepTurns--;
        if (pokemon.sleepTurns <= 0) {
            pokemon.status = null;
            return { can: true, msg: `${pokemon.cnName} é†’è¿‡æ¥äº†!` };
        }
        return { can: false, msg: `${pokemon.cnName} æ­£åœ¨ç†Ÿç¡ä¸­...` };
    }
    // 3. éº»ç—¹ (Paralysis) - 25% å‡ ç‡æ— æ³•è¡ŒåŠ¨
    if (pokemon.status === 'par') {
        if (Math.random() < 0.25) {
            return { can: false, msg: `${pokemon.cnName} å› èº«ä½“éº»ç—¹è€Œæ— æ³•è¡ŒåŠ¨!` };
        }
    }
    // 4. å†°å†» (Frozen) - 20% å‡ ç‡è§£å†»ï¼Œå¦åˆ™æ— æ³•è¡ŒåŠ¨
    if (pokemon.status === 'frz') {
        if (Math.random() < 0.2) {
            pokemon.status = null;
            return { can: true, msg: `${pokemon.cnName} çš„å†°å†»è§£é™¤äº†!` };
        }
        return { can: false, msg: `${pokemon.cnName} è¢«å†»å¾—åŠ¨å¼¹ä¸å¾—!` };
    }
    return { can: true, msg: '' };
}
/**
 * æ¸…é™¤å›åˆç»“æŸæ—¶çš„ä¸´æ—¶çŠ¶æ€ï¼ˆå¦‚ç•ç¼©ï¼‰
 */
function clearVolatileStatus(pokemon) {
    if (pokemon.volatile) {
        pokemon.volatile.flinch = false;
    }
}
/**
 * å›åˆç»“æŸçš„ç»“ç®— (End Phase)
 * å¤„ç† å¼‚å¸¸æ‰£è¡€ã€å¯„ç”Ÿç§å­å¸è¡€ã€Yawnç»“ç®—ç­‰
 * @param {Pokemon} poke ç»“ç®—çš„ç›®æ ‡
 * @param {Pokemon} opponent å¯¹æ‰‹ (ç”¨äºå¸è¡€é€»è¾‘)
 * @param {boolean} isPlayerPoke æ˜¯å¦ä¸ºç©å®¶æ–¹çš„å®å¯æ¢¦ï¼ˆAVs æ•ˆæœåªå¯¹ç©å®¶æ–¹ç”Ÿæ•ˆï¼‰
 * @returns {Array} logs
 */
function getEndTurnStatusLogs(poke, opponent, isPlayerPoke = false) {
    let logs = [];
    if (!poke || !poke.isAlive()) return logs;
    // ----------------------------------------
    // 1. ç¼ä¼¤ (Burn): æ‰£ 1/16 HP
    // ----------------------------------------
    if (poke.status === 'brn') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 16));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°ç¼ä¼¤çš„ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 2. ä¸­æ¯’ (Poison): æ‰£ 1/8 HP
    // ----------------------------------------
    if (poke.status === 'psn') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°æ¯’ç´ çš„ä¼¤å®³! (-${dmg})`);
    }
    // å‰§æ¯’ (Toxic): ç´¯åŠ ä¼¤å®³ (ç®€åŒ–ä¸º 1/8)
    if (poke.status === 'tox') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°å‰§æ¯’çš„ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 3. å¯„ç”Ÿç§å­ (Leech Seed): è¢«å¯¹æ–¹å¸è¡€ 1/8
    // ----------------------------------------
    if (poke.volatile && poke.volatile['leechseed'] && opponent && opponent.isAlive()) {
        const drain = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(drain);
        opponent.heal(drain);
        logs.push(`${poke.cnName} çš„ä½“åŠ›è¢«å¯„ç”Ÿç§å­å¸å–äº†! (-${drain})`);
    }
    // ----------------------------------------
    // 4. æŸç¼šçŠ¶æ€ (Bind / Whirlpool / Fire Spin) -> æ‰£ 1/8
    // ----------------------------------------
    if (poke.volatile && poke.volatile['partiallytrapped']) {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å› æŸç¼šè€Œå—åˆ°ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 5. è¯…å’’ (Curse - Ghostä½¿ç”¨): æ¯å›åˆæ‰£ 1/4
    // ----------------------------------------
    if (poke.volatile && poke.volatile['curse']) {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 4));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°äº†è¯…å’’! (-${dmg})`);
    }
    // ----------------------------------------
    // 6. å“ˆæ¬  (Yawn): å€’è®¡æ—¶ï¼Œæ—¶é—´åˆ°ç¡ç€
    // ----------------------------------------
    if (poke.volatile && poke.volatile['yawn']) {
        poke.volatile['yawn'] -= 1;
        if (poke.volatile['yawn'] <= 0) {
            if (!poke.status) {
                poke.status = 'slp';
                poke.sleepTurns = Math.floor(Math.random() * 3) + 2;
                delete poke.volatile['yawn'];
                logs.push(`${poke.cnName} çš„ç¡æ„è¢­æ¥äº†! -> ç¡ç€äº†!`);
            } else {
                delete poke.volatile['yawn'];
            }
        } else {
            logs.push(`${poke.cnName} æ›´åŠ å›°å€¦äº†...`);
        }
    }
    // =====================================================
    // === AVs: Devotion (çŒ®èº«) - çŠ¶æ€æ²»æ„ˆ + æ®‹è¡€å›å¤ ===
    // ã€v3.4 é‡å†™ã€‘ä¸¤ä¸ªç‹¬ç«‹è§¦å‘æ¡ä»¶ï¼š
    //   1. æœ‰å¼‚å¸¸çŠ¶æ€ â†’ æ¸…é™¤å¼‚å¸¸ + å›å¤ 10% HP
    //   2. æ®‹è¡€ï¼ˆâ‰¤30%ï¼‰â†’ å›å¤ 40% HP
    // =====================================================
    // ã€è°ƒè¯•ã€‘æ£€æŸ¥ Devotion è§¦å‘æ¡ä»¶
    console.log(`[AVs Devotion] æ£€æŸ¥: ${poke.cnName}, isPlayerPoke=${isPlayerPoke}, isAce=${poke.isAce}, avs=`, poke.avs);
    // åªæœ‰ã€ç©å®¶æ–¹ã€‘çš„ isAce=true å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
    if (isPlayerPoke && poke.isAce && poke.avs && poke.avs.devotion > 0) {
        const baseDevotion = poke.getEffectiveAVs ? poke.getEffectiveAVs('devotion') : poke.avs.devotion;
        const effectiveDevotion = poke.avsEvolutionBoost ? baseDevotion * 2 : baseDevotion;
        const hpRatio = poke.currHp / poke.maxHp;
        const isCritical = hpRatio <= 0.30;
        console.log(`[AVs Devotion] ${poke.cnName}: baseDevotion=${baseDevotion}, effective=${effectiveDevotion}, hpRatio=${hpRatio.toFixed(2)}, isCritical=${isCritical}, status=${poke.status}`);
        // ã€ä¿®å¤ã€‘ä½¿ç”¨çº¿æ€§æ¦‚ç‡è®¡ç®—ï¼ˆåŸºäº 0-255 æ•°å€¼ï¼‰
        // 255 æ»¡å€¼ = 15% åŸºç¡€æ¦‚ç‡
        // 0 = 0% æ¦‚ç‡
        // çº¿æ€§æ’å€¼ï¼šbaseChance = (effectiveDevotion / 255) * 0.15
        const baseChance = Math.min(0.15, (effectiveDevotion / 255) * 0.15);
        // åˆå§‹åŒ–å…¨å±€è§¦å‘æ ‡è®°ï¼ˆæ¯åªå®å¯æ¢¦åªèƒ½è§¦å‘ä¸€æ¬¡æ®‹è¡€å›å¤ï¼‰
        if (!poke.avsTriggered) poke.avsTriggered = {};
        if (poke.devotionStatusTriggered === undefined) poke.devotionStatusTriggered = -1;
        const currentTurn = (typeof battle !== 'undefined' && battle.turn) ? battle.turn : 0;
        console.log(`[AVs Devotion] baseChance=${(baseChance * 100).toFixed(1)}%, currentTurn=${currentTurn}`);
        // ã€è§¦å‘æ¡ä»¶ 1ã€‘æœ‰å¼‚å¸¸çŠ¶æ€ â†’ æ¸…é™¤å¼‚å¸¸ + å›å¤ 10% HP
        if (poke.status && poke.devotionStatusTriggered !== currentTurn && baseChance > 0) {
            const roll = Math.random();
            console.log(`[AVs Devotion] çŠ¶æ€æ²»æ„ˆæ£€æŸ¥: status=${poke.status}, roll=${roll.toFixed(3)}, chance=${baseChance.toFixed(3)}`);
            if (roll < baseChance) {
                const oldStatus = poke.status;
                poke.status = null;
                poke.sleepTurns = 0;
                // æ¸…é™¤å¼‚å¸¸åå›å¤ 10% HP
                const healAmount = Math.floor(poke.maxHp * 0.10);
                poke.heal(healAmount);
                logs.push(`<b style="color:#e91e63">ğŸ’• ${poke.cnName} ä¸ºäº†ä¸è®©è®­ç»ƒå®¶æ‹…å¿ƒï¼Œæ²»å¥½äº†è‡ªå·±çš„${oldStatus}ï¼å›å¤äº† ${healAmount} HPï¼(Devotion${poke.avsEvolutionBoost ? ' x2' : ''})</b>`);
                poke.devotionStatusTriggered = currentTurn;
            }
        }
        // ã€è§¦å‘æ¡ä»¶ 2ã€‘æ®‹è¡€ï¼ˆâ‰¤30%ï¼‰â†’ å›å¤ 40% HPï¼ˆç‹¬ç«‹è§¦å‘ï¼Œä¸ä¸çŠ¶æ€æ²»æ„ˆå†²çªï¼‰
        // ã€ä¿®å¤ã€‘æ¯åªå®å¯æ¢¦åªèƒ½è§¦å‘ä¸€æ¬¡æ®‹è¡€å›å¤ï¼ˆå…¨å±€é™åˆ¶ï¼‰
        if (isCritical && !poke.avsTriggered.devotionCritical && baseChance > 0) {
            // æ®‹è¡€æ—¶æ¦‚ç‡æå‡ +8%
            const criticalChance = Math.min(1.0, baseChance + 0.08);
            const roll = Math.random();
            console.log(`[AVs Devotion] æ®‹è¡€å›å¤æ£€æŸ¥: roll=${roll.toFixed(3)}, chance=${criticalChance.toFixed(3)}, triggered=${poke.avsTriggered.devotionCritical}`);
            if (roll < criticalChance) {
                const healAmount = Math.floor(poke.maxHp * 0.40);
                poke.heal(healAmount);
                logs.push(`<b style="color:#e91e63">ğŸ’• ${poke.cnName} çš„çŒ®èº«ä¹‹å¿ƒæ¿€å‘äº†ç”Ÿå‘½åŠ›ï¼å›å¤äº† ${healAmount} HPï¼[å±æœºçˆ†å‘] (Devotion${poke.avsEvolutionBoost ? ' x2' : ''})</b>`);
                poke.avsTriggered.devotionCritical = true; // æ ‡è®°å·²è§¦å‘ï¼Œå…¨å±€åªèƒ½è§¦å‘ä¸€æ¬¡
            }
        }
    }
    return logs;
}
/**
 * è·å–æ‹›å¼çš„ä¼˜å…ˆçº§ (Priority)
 * @param {object} move - æ‹›å¼å¯¹è±¡
 * @returns {number} ä¼˜å…ˆçº§å€¼ (-7 åˆ° +5)
 */
function getMovePriority(move) {
    if (!move || !move.name) return 0;
    // ã€å¤æ­¦ç³»ç»Ÿã€‘å¦‚æœæ‹›å¼å¯¹è±¡å·²æœ‰ priority å±æ€§ï¼ˆè¢« style ä¿®æ”¹è¿‡ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
    if (typeof move.priority === 'number') {
        return move.priority;
    }
    const moveId = move.name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // ä¼˜å…ˆä» MOVES æ•°æ®è·å–
    if (fullMoveData.priority !== undefined) {
        return fullMoveData.priority;
    }
    // ä» move-constants.js è·å–ä¼˜å…ˆçº§æ˜ å°„ (ä½œä¸ºåå¤‡)
    const priorityMap = (typeof PRIORITY_MAP !== 'undefined') ? PRIORITY_MAP : {};
    return priorityMap[move.name] || 0;
}
if (typeof window !== 'undefined') {
    window.checkCanMove = checkCanMove;
    window.clearVolatileStatus = clearVolatileStatus;
    window.getEndTurnStatusLogs = getEndTurnStatusLogs;
    window.getMovePriority = getMovePriority;
}
/**
 * =============================================
 * MEGA EVOLUTION SYSTEM
 * =============================================
 */
/**
 * è‡ªåŠ¨æ£€æµ‹å®å¯æ¢¦çš„å½¢æ€å˜åŒ–èµ„æ ¼ï¼ˆMega/Ultra/Primal/Dynamax ç­‰ï¼‰
 * ä¿®å¤ç‰ˆ V2ï¼š
 * 1. ä¿®å¤è·¯å¡åˆ©æ¬§æ˜¾ç¤ºåŒ Mega é—®é¢˜ï¼ˆå¢åŠ  X/Y ç™½åå•ï¼‰
 * 2. ä¿®å¤æ€ªåŠ›æ— æ³•æå·¨åŒ–é—®é¢˜ï¼ˆå¼ºåˆ¶ä¿¡ä»» explicitFormFlag ä¸­çš„ gmaxï¼‰
 * 
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {string|null} explicitFormFlag - JSON ä¸­æ˜¾å¼æŒ‡å®šçš„å½¢æ€ ('x', 'y', 'primal', 'ultra', 'crowned', 'machampgmax' ç­‰)
 */
/* ==========================================================
 *  æ™ºèƒ½å½¢æ€æ¢æµ‹å™¨ v3 : Zero-Config, Database-Driven
 *  åŸºäº mechanic å­—æ®µå’Œæ•°æ®åº“è‡ªåŠ¨æ£€æµ‹å¯ç”¨å½¢æ€
 * ========================================================== */ 
function autoDetectFormChangeEligibility(pokemon, explicitFormFlag = null) {
    // ä½¿ç”¨è§„èŒƒåŒ–åç§°æŸ¥æ‰¾ POKEDEX
    const normalizedName = normalizePokemonName(pokemon.name);
    const baseId = normalizedName.toLowerCase().replace(/[^a-z0-9]/g, '');
    const data = typeof POKEDEX !== 'undefined' ? POKEDEX[baseId] : null;
    // è·å–ç©å®¶åœ¨ JSON é…ç½®é‡ŒæŒ‡å®šçš„"æ„æ„¿" (Mechanic Lock)
    const desiredMechanic = pokemon.mechanic || 'any'; // 'mega', 'dynamax', 'zmove', 'any'(Auto)
    console.log(`[FORM] Auto-Scan for ${pokemon.name} (baseId: ${baseId}), mechanic: ${desiredMechanic}, hasData: ${!!data}`);
    // ========================================
    // æ­¥éª¤ 1ï¼šæ‰«ææ•°æ®åº“çš„æ‰€æœ‰å½¢æ€æ ‘
    // ========================================
    let avail = {
        mega: [],
        gmax: [],
        primal: null,
        ultra: null,
        crowned: null
    };
    // ä» otherFormes æ”¶é›†
    if (data && data.otherFormes) {
        for (const formeName of data.otherFormes) {
            const formeId = formeName.toLowerCase().replace(/[^a-z0-9]/g, '');
            if (formeId.includes('gmax') || formeId.includes('gigantamax')) {
                avail.gmax.push(formeId);
            } else if (formeName.includes('Mega') && formeId.match(/mega[xy]?$/)) {
                avail.mega.push(formeId);
            } else if (formeName.includes('Primal')) {
                avail.primal = formeId;
            } else if (formeName.includes('Ultra')) {
                avail.ultra = formeId;
            } else if (formeName.includes('Crowned')) {
                avail.crowned = formeId;
            }
        }
    }
    // æ¿€è¿›æ¢æµ‹ï¼šå°è¯•æ‹¼æ¥ IDï¼ˆæ•°æ®åº“å¯èƒ½æ²¡æœ‰ otherFormes ä½†æœ‰å®é™…æ•°æ®ï¼‰
    const guessedGmaxId = baseId + 'gmax';
    const guessedMegaId = baseId + 'mega';
    if (avail.gmax.length === 0 && typeof POKEDEX !== 'undefined' && POKEDEX[guessedGmaxId]) {
        avail.gmax.push(guessedGmaxId);
    }
    if (avail.mega.length === 0 && typeof POKEDEX !== 'undefined' && POKEDEX[guessedMegaId]) {
        avail.mega.push(guessedMegaId);
    }
    // åŒ Mega ç™½åå•
    const KNOWN_DUAL_MEGAS = ['charizard', 'mewtwo'];
    const hasDualMega = (avail.mega.length >= 2) && KNOWN_DUAL_MEGAS.includes(baseId);
    console.log(`[FORM] Available forms:`, avail);
    // ========================================
    // æ­¥éª¤ 2ï¼šåŸå§‹å›å½’ / Crowned - ç«‹å³å›ºåŒ–
    // ========================================
    if (avail.primal && typeof POKEDEX !== 'undefined' && POKEDEX[avail.primal]) {
        pokemon.isPrimal = true;
        pokemon.primalTargetId = avail.primal;
        pokemon.needsInitTransform = true;
        pokemon.initTransformTarget = avail.primal;
        pokemon.initTransformType = 'primal';
    }
    if (avail.crowned && typeof POKEDEX !== 'undefined' && POKEDEX[avail.crowned]) {
        pokemon.isCrowned = true;
        pokemon.crownedTargetId = avail.crowned;
        pokemon.needsInitTransform = true;
        pokemon.initTransformTarget = avail.crowned;
        pokemon.initTransformType = 'crowned';
    }
    // ===================================
    //  å†³ç­–åŒº: æ ¹æ® mechanic å†³å®š Target
    // ===================================
    // ğŸ‘‰ åœºæ™¯ A: æ˜ç¡®æƒ³è¦æå·¨åŒ– (mechanic='dynamax')
    if (desiredMechanic === 'dynamax') {
        // ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·åœ¨ JSON ä¸­æ˜¾å¼æŒ‡å®šçš„ mega/mega_target å­—æ®µ
        if (pokemon.megaTargetId && pokemon.megaTargetId.includes('gmax')) {
            // ç”¨æˆ·å·²ç»æŒ‡å®šäº† G-Max å½¢æ€ï¼Œç›´æ¥ä½¿ç”¨
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            console.log(`[FORM] Using explicit G-Max target: ${pokemon.megaTargetId}`);
        } else if (avail.gmax.length > 0) {
            // æ‰¾åˆ°æ­£ç‰ˆ Gmax æ•°æ®
            pokemon.megaTargetId = avail.gmax[0];
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            console.log(`[FORM] Locked Dynamax target: ${pokemon.megaTargetId}`);
        } else {
            // æ²¡æœ‰ GMax æ•°æ®ï¼Œèµ°é€šç”¨æå·¨åŒ– (Non-GMax Dynamax)
            // æ¯ä¸ªå®å¯æ¢¦éƒ½å¯ä»¥é€šç”¨å˜å¤§ï¼Œåªæ˜¯æ²¡æœ‰ä¸“å± G-Max æ‹›å¼
            pokemon.megaTargetId = guessedGmaxId; // è™šæ‹Ÿ IDï¼Œä¾›å›¾ç‰‡åŠ è½½å°è¯•
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            pokemon.isGenericDynamax = true; // æ ‡è®°ä¸ºé€šç”¨æå·¨åŒ–
            console.log(`[FORM] Generic Dynamax (No G-Form in DB) target: ${pokemon.megaTargetId}`);
        }
        return;
    }
    // ğŸ‘‰ åœºæ™¯ B: æ˜ç¡®æƒ³è¦ Mega (mechanic='mega')
    if (desiredMechanic === 'mega') {
        if (avail.mega.length > 0) {
            const validMegaForms = avail.mega.filter(f => typeof POKEDEX !== 'undefined' && POKEDEX[f]);
            if (validMegaForms.length > 0) {
                if (hasDualMega && validMegaForms.length >= 2) {
                    pokemon.hasDualMega = true;
                    pokemon.megaFormsAvailable = validMegaForms;
                    pokemon.megaTargetId = validMegaForms.find(f => f.endsWith('x')) || validMegaForms[0];
                } else {
                    pokemon.megaTargetId = validMegaForms[0];
                }
                pokemon.canMegaEvolve = true;
                pokemon.evolutionType = 'mega';
                console.log(`[FORM] Locked Mega target: ${pokemon.megaTargetId}`);
                return;
            }
        }
        // æ²¡æœ‰ Mega æ•°æ®ï¼Œç¦ç”¨
        pokemon.canMegaEvolve = false;
        console.log(`[FORM] ${pokemon.name} has no Mega form - Mega DISABLED`);
        return;
    }
    // ğŸ‘‰ åœºæ™¯ C: Z æ‹›å¼æ¨¡å¼ (mechanic='zmove')
    if (desiredMechanic === 'zmove') {
        // Z æ‹›å¼ä¸éœ€è¦å½¢æ€å˜åŒ–ï¼Œä½†ç¦æ­¢ Mega/Dynamax
        pokemon.canMegaEvolve = false;
        pokemon.canDynamax = false;
        console.log(`[FORM] ${pokemon.name} locked to Z-Move - form changes DISABLED`);
        return;
    }
    if (desiredMechanic === 'tera') {
        // å¤ªæ™¶åŒ–ä¸éœ€è¦å½¢æ€å˜åŒ–ï¼Œç¦æ­¢è‡ªåŠ¨æ£€æµ‹ Mega/Dynamax
        pokemon.canMegaEvolve = false;
        pokemon.canDynamax = false;
        console.log(`[FORM] ${pokemon.name} locked to Tera - form changes DISABLED`);
        return;
    }
    // ğŸ‘‰ åœºæ™¯ D: è‡ªåŠ¨æŒ¡ (mechanic ä¸å¡«æˆ– 'any')
    // ä¼˜å…ˆ Megaï¼ˆå› ä¸º Mega æ”¹å˜ç§æ—ç‰¹æ€§æ›´æ˜æ˜¾ï¼‰ï¼Œæ²¡ Mega çœ‹èƒ½ä¸èƒ½ GMax
    if (avail.ultra && typeof POKEDEX !== 'undefined' && POKEDEX[avail.ultra]) {
        pokemon.megaTargetId = avail.ultra;
        pokemon.canMegaEvolve = true;
        pokemon.evolutionType = 'ultra';
        console.log(`[FORM] Auto-detected Ultra: ${pokemon.megaTargetId}`);
    } else if (avail.mega.length > 0) {
        const validMegaForms = avail.mega.filter(f => typeof POKEDEX !== 'undefined' && POKEDEX[f]);
        if (validMegaForms.length > 0) {
            if (hasDualMega && validMegaForms.length >= 2) {
                pokemon.hasDualMega = true;
                pokemon.megaFormsAvailable = validMegaForms;
            }
            pokemon.megaTargetId = validMegaForms.find(f => f.endsWith('x')) || validMegaForms[0];
            pokemon.canMegaEvolve = true;
            pokemon.evolutionType = 'mega';
            console.log(`[FORM] Auto-detected Mega: ${pokemon.megaTargetId}`);
        }
    } else if (avail.gmax.length > 0) {
        // åªæœ‰ä¸“å± GMax çš„æ‰è‡ªåŠ¨æ¿€æ´»ï¼Œé€šç”¨æå·¨åŒ–éœ€è¦æ‰‹åŠ¨æŒ‡å®š mechanic
        pokemon.megaTargetId = avail.gmax[0];
        pokemon.canMegaEvolve = true;
        pokemon.canDynamax = true;
        pokemon.evolutionType = 'dynamax';
        console.log(`[FORM] Auto-detected GMax: ${pokemon.megaTargetId}`);
    } else {
        pokemon.canMegaEvolve = false;
        pokemon.canFormChange = false;
        console.log(`[FORM] ${pokemon.name} has NO form changes available`);
    }
}
// å‘åå…¼å®¹åˆ«å
const autoDetectMegaEligibility = autoDetectFormChangeEligibility;
/**
 * æ£€æŸ¥æ˜¯å¦ä¸ºéå®˜æ–¹ Megaï¼ˆåŠ¨æ€æ£€æµ‹ï¼‰
 * ä¸å†ä½¿ç”¨ç¡¬ç¼–ç åˆ—è¡¨ï¼
 * å®é™…æ£€æµ‹åœ¨ smartLoadSprite ä¸­è¿›è¡Œï¼šå½“æ‰€æœ‰ç²¾çµå›¾å›é€€éƒ½å¤±è´¥æ—¶ï¼Œè‡ªåŠ¨åˆ¤æ–­ä¸ºéå®˜æ–¹ Mega
 * è¿™ä¸ªå‡½æ•°ç°åœ¨åªè¿”å› falseï¼Œè®©ç²¾çµå›¾åŠ è½½ç³»ç»Ÿæ¥å†³å®š
 */
function isUnofficialMega(megaTargetId) {
    // ä¸å†é¢„åˆ¤ï¼Œè®© smartLoadSprite çš„å›é€€æœºåˆ¶æ¥åŠ¨æ€æ£€æµ‹
    // å¦‚æœæ‰€æœ‰ Mega ç²¾çµå›¾ URL éƒ½å¤±è´¥ï¼ŒsmartLoadSprite ä¼šè‡ªåŠ¨åŠ è½½åŸºç¡€å½¢æ€
    return false;
}
/**
 * æ‰§è¡Œ Mega è¿›åŒ– (å¼•æ“å±‚é¢)
 * @param {Pokemon} pokemon - è¦è¿›åŒ–çš„å®å¯æ¢¦
 * @returns {object|null} - è¿›åŒ–ç»“æœä¿¡æ¯ï¼Œæˆ– null å¦‚æœå¤±è´¥
 */
function performMegaEvolution(pokemon) {
    if (!pokemon.canMegaEvolve || pokemon.isMega || !pokemon.megaTargetId) {
        return null;
    }
    const megaData = getPokemonData(pokemon.megaTargetId);
    if (!megaData) {
        console.warn(`[MEGA] Mega form data not found: ${pokemon.megaTargetId}`);
        return null;
    }
    // æ£€æµ‹æ˜¯å¦ä¸ºéå®˜æ–¹ Mega
    const isUnofficial = isUnofficialMega(pokemon.megaTargetId);
    if (isUnofficial) {
        console.log(`[MEGA] Detected unofficial Mega: ${pokemon.megaTargetId} (Radical Red / ROM Hack)`);
        pokemon.isUnofficialMega = true;
    }
    // ä¿å­˜æ—§æ•°æ®ç”¨äºæ—¥å¿—
    const oldName = pokemon.cnName;
    const oldTypes = [...pokemon.types];
    const oldAbility = pokemon.ability;
    // æ›´æ–°åŸºç¡€æ•°æ®
    pokemon.name = megaData.name;
    pokemon.cnName = megaData.name;
    pokemon.types = megaData.types || pokemon.types;
    pokemon.baseStats = megaData.baseStats;
    // è·å– Mega å½¢æ€çš„ç‰¹æ€§
    const megaPokedexData = typeof POKEDEX !== 'undefined' ? POKEDEX[pokemon.megaTargetId] : null;
    if (megaPokedexData && megaPokedexData.abilities) {
        pokemon.ability = megaPokedexData.abilities['0'] || megaPokedexData.abilities['H'] || pokemon.ability;
    }
    // é‡æ–°è®¡ç®—èƒ½åŠ›å€¼ (HP ä¸å˜!)
    const oldHp = pokemon.currHp;
    const oldMaxHp = pokemon.maxHp;
    let autoEv = Math.floor(pokemon.level * 1.5);
    if (autoEv > 85) autoEv = 85;
    const newStats = calcStats(megaData.baseStats, pokemon.level, 31, autoEv);
    // HP ä¿æŒä¸å˜ (Mega è¿›åŒ–çš„æ ¸å¿ƒè§„åˆ™)
    // pokemon.maxHp = oldMaxHp; // ä¸å˜
    // pokemon.currHp = oldHp;   // ä¸å˜
    // æ›´æ–°å…¶ä»–èƒ½åŠ›å€¼
    pokemon.atk = newStats.atk;
    pokemon.def = newStats.def;
    pokemon.spa = newStats.spa;
    pokemon.spd = newStats.spd;
    pokemon.spe = newStats.spe;
    // æ ‡è®°å·² Mega è¿›åŒ–
    pokemon.isMega = true;
    pokemon.canMegaEvolve = false;
    // === æ’­æ”¾ Mega è¿›åŒ–å«å£° ===
    if (typeof window.playPokemonCry === 'function') {
        window.playPokemonCry(pokemon.name);
    }
    return {
        oldName,
        newName: pokemon.cnName,
        oldTypes,
        newTypes: pokemon.types,
        oldAbility,
        newAbility: pokemon.ability,
        typeChanged: JSON.stringify(oldTypes) !== JSON.stringify(pokemon.types),
        abilityChanged: oldAbility !== pokemon.ability
    };
}
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥ Mega è¿›åŒ–
 * @param {Pokemon} pokemon
 * @returns {boolean}
 */
function canMegaEvolve(pokemon) {
    return pokemon && pokemon.canMegaEvolve && !pokemon.isMega && pokemon.megaTargetId;
}
// å¯¼å‡º Mega ç›¸å…³å‡½æ•°
if (typeof window !== 'undefined') {
    window.autoDetectMegaEligibility = autoDetectMegaEligibility;
    window.performMegaEvolution = performMegaEvolution;
    window.canMegaEvolve = canMegaEvolve;
}
/**
 * æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨
 */
class BattleState {
    constructor() {
        this.playerParty = [];
        this.enemyParty = [];
        this.playerActive = 0;
        this.enemyActive = 0;
        this.phase = 'intro';
        this.trainer = null;
        this.locked = false;
        this.scriptedResult = null;
        this.aiDifficulty = 'normal';
        // Mega Evolution çŠ¶æ€
        this.playerMegaUsed = false;    // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Mega
        this.enemyMegaUsed = false;     // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Mega
        this.playerMegaArmed = false;   // ç©å®¶æ˜¯å¦å·²é¢„å¤‡ Mega (ç‚¹å‡»äº†æŒ‰é’®)
        // Z-Move / Max Move çŠ¶æ€ (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
        this.playerZUsed = false;       // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Z æ‹›å¼
        this.enemyZUsed = false;        // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Z æ‹›å¼
        this.playerMaxUsed = false;     // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨æå·¨åŒ–
        this.enemyMaxUsed = false;      // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨æå·¨åŒ–
        // å¤ªæ™¶åŒ– (Terastallization) çŠ¶æ€ (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡ï¼Œç”±ç”Ÿåˆ°æ­»)
        this.playerTeraUsed = false;    // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨å¤ªæ™¶åŒ–
        this.enemyTeraUsed = false;     // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨å¤ªæ™¶åŒ–
        // =========================================================
        // å…¨å±€æˆ˜åœºçŠ¶æ€ (Field Conditions)
        // =========================================================
        this.field = {
            trickRoom: 0,   // æˆæ³•ç©ºé—´å‰©ä½™å›åˆ (0=æœªå¼€å¯)
            gravity: 0,     // é‡åŠ›å‰©ä½™å›åˆ
            magicRoom: 0,   // é­”æ³•ç©ºé—´å‰©ä½™å›åˆ
            wonderRoom: 0   // å¥‡å¦™ç©ºé—´å‰©ä½™å›åˆ
        };
        // ç©å®¶ä¾§çŠ¶æ€ (Player Side)
        this.playerSide = {
            tailwind: 0,      // é¡ºé£å‰©ä½™å›åˆ
            reflect: 0,       // åå°„å£å‰©ä½™å›åˆ
            lightScreen: 0,   // å…‰å¢™å‰©ä½™å›åˆ
            auroraVeil: 0,    // æå…‰å¹•å‰©ä½™å›åˆ
            stealthRock: false,  // éšå½¢å²©
            spikes: 0,        // æ’’è±å±‚æ•° (0-3)
            toxicSpikes: 0,   // æ¯’è±å±‚æ•° (0-2)
            stickyWeb: false  // é»é»ç½‘
        };
        // æ•Œæ–¹ä¾§çŠ¶æ€ (Enemy Side)
        this.enemySide = {
            tailwind: 0,
            reflect: 0,
            lightScreen: 0,
            auroraVeil: 0,
            stealthRock: false,
            spikes: 0,
            toxicSpikes: 0,
            stickyWeb: false
        };
    }
    // å›åˆç»“æŸæ—¶é€’å‡åœºåœ°çŠ¶æ€
    tickFieldConditions() {
        const logs = [];
        // å…¨å±€åœºåœ°
        if (this.field.trickRoom > 0) {
            this.field.trickRoom--;
            if (this.field.trickRoom === 0) {
                logs.push("æ‰­æ›²çš„æ—¶ç©ºæ¢å¤äº†æ­£å¸¸ï¼");
            }
        }
        if (this.field.gravity > 0) {
            this.field.gravity--;
            if (this.field.gravity === 0) {
                logs.push("é‡åŠ›æ¢å¤äº†æ­£å¸¸ï¼");
            }
        }
        // ç©å®¶ä¾§
        if (this.playerSide.tailwind > 0) {
            this.playerSide.tailwind--;
            if (this.playerSide.tailwind === 0) {
                logs.push("æˆ‘æ–¹çš„é¡ºé£åœæ­¢äº†ï¼");
            }
        }
        if (this.playerSide.reflect > 0) {
            this.playerSide.reflect--;
            if (this.playerSide.reflect === 0) {
                logs.push("æˆ‘æ–¹çš„åå°„å£æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.playerSide.lightScreen > 0) {
            this.playerSide.lightScreen--;
            if (this.playerSide.lightScreen === 0) {
                logs.push("æˆ‘æ–¹çš„å…‰å¢™æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.playerSide.auroraVeil > 0) {
            this.playerSide.auroraVeil--;
            if (this.playerSide.auroraVeil === 0) {
                logs.push("æˆ‘æ–¹çš„æå…‰å¹•æ¶ˆå¤±äº†ï¼");
            }
        }
        // æ•Œæ–¹ä¾§
        if (this.enemySide.tailwind > 0) {
            this.enemySide.tailwind--;
            if (this.enemySide.tailwind === 0) {
                logs.push("æ•Œæ–¹çš„é¡ºé£åœæ­¢äº†ï¼");
            }
        }
        if (this.enemySide.reflect > 0) {
            this.enemySide.reflect--;
            if (this.enemySide.reflect === 0) {
                logs.push("æ•Œæ–¹çš„åå°„å£æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.enemySide.lightScreen > 0) {
            this.enemySide.lightScreen--;
            if (this.enemySide.lightScreen === 0) {
                logs.push("æ•Œæ–¹çš„å…‰å¢™æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.enemySide.auroraVeil > 0) {
            this.enemySide.auroraVeil--;
            if (this.enemySide.auroraVeil === 0) {
                logs.push("æ•Œæ–¹çš„æå…‰å¹•æ¶ˆå¤±äº†ï¼");
            }
        }
        return logs;
    }
    // ä» AI JSON åˆå§‹åŒ–æ•Œæ–¹
    loadFromJSON(json) {
        const enemyObj = json.enemy || json.trainer || {};
        const typeLabel = typeof enemyObj.type === 'string' ? enemyObj.type.trim() : '';
        const nameId = typeof enemyObj.name === 'string' ? enemyObj.name.trim() : '';
        const isWild = (typeLabel.toLowerCase() === 'wild') || (!nameId && !enemyObj.type);
        let imgId = 'wild';
        if (!isWild) {
            imgId = enemyObj.id || nameId || 'wild';
        }
        let displayName = nameId;
        if (isWild && !displayName) displayName = "Wild Pokemon";
        if (!displayName) displayName = "Unknown";
        const lines = enemyObj.lines || {};
        this.trainer = {
            name: displayName,
            title: typeLabel || '',
            id: imgId,
            lines: {
                start: lines.start || enemyObj.line || "",
                win: lines.win || "",
                lose: lines.lose || "",
                escape: lines.escape || ""
            }
        };
        this.scriptedResult = json.script || null;
        const rawDiff = (json.ai || json.difficulty || enemyObj.difficulty || '').toString().toLowerCase();
        if (rawDiff) {
            this.aiDifficulty = rawDiff;
        } else {
            this.aiDifficulty = isWild ? 'easy' : 'normal';
        }
        const trainerNameLower = (displayName || '').toLowerCase();
        if (/cynthia|red|steven|champion/.test(trainerNameLower)) {
            this.aiDifficulty = 'hard';
        }
        let rawParty = [];
        if (Array.isArray(json.party)) {
            rawParty.push(...json.party);
        }
        if (Array.isArray(enemyObj.party)) {
            rawParty.push(...enemyObj.party);
        }
        if (rawParty.length === 0 && Array.isArray(json.enemyParty)) {
            rawParty.push(...json.enemyParty);
        }
        if (rawParty.length > 6) {
            rawParty = rawParty.slice(0, 6);
        }
        const validPartyData = [];
        for (const p of rawParty) {
            const seed = (p?.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            if (!seed) continue;
            validPartyData.push(p);
        }
        if (validPartyData.length === 0) {
            console.warn("[PKM] Warn: No valid pokemon found in enemy party. Adding fallback.");
            validPartyData.push({ name: 'Magikarp', lv: 5, moves: ['Splash'] });
        }
        // === æ•Œæ–¹è§£é”ç³»ç»Ÿ (Enemy Unlock System) ===
        // è§£æ unlocks å¯¹è±¡ï¼Œå†³å®š NPC æ˜¯å¦æœ‰èµ„æ ¼ä½¿ç”¨å„æœºåˆ¶
        // unlocks å¯ä»¥åœ¨ json.unlocks æˆ– enemyObj.unlocks ä¸­
        const enemyUnlocksRaw = json.unlocks || enemyObj.unlocks || {};
        this.enemyUnlocks = {
            enable_bond: enemyUnlocksRaw.enable_bond === true,        // ç¾ç»Šå…±é¸£ (é»˜è®¤å…³é—­)
            enable_styles: enemyUnlocksRaw.enable_styles === true,    // åˆšçŒ›/è¿…ç–¾ (é»˜è®¤å…³é—­)
            enable_insight: enemyUnlocksRaw.enable_insight === true,  // å¿ƒçœ¼/AVsçªç ´155ä¸Šé™ (é»˜è®¤å…³é—­)
            enable_mega: enemyUnlocksRaw.enable_mega === true,        // Megaè¿›åŒ– (é»˜è®¤å…³é—­)
            enable_z_move: enemyUnlocksRaw.enable_z_move === true,    // Zæ‹›å¼ (é»˜è®¤å…³é—­)
            enable_dynamax: enemyUnlocksRaw.enable_dynamax === true,  // æå·¨åŒ– (é»˜è®¤å…³é—­)
            enable_tera: enemyUnlocksRaw.enable_tera === true         // å¤ªæ™¶åŒ– (é»˜è®¤å…³é—­)
        };
        console.log('[UNLOCK] æ•Œæ–¹è§£é”çŠ¶æ€:', this.enemyUnlocks);
        // æ£€æŸ¥æ•Œæ–¹è®­ç»ƒå®¶æ˜¯å¦æœ‰ Mega æƒé™
        // ä¼˜å…ˆä½¿ç”¨ unlocks.enable_megaï¼Œå…¶æ¬¡æ£€æŸ¥ canMega å­—æ®µæˆ– Boss åç§°
        // (trainerNameLower å·²åœ¨ä¸Šé¢å®šä¹‰)
        const isBossTrainer = /cynthia|red|steven|champion|elite|leader|boss/.test(trainerNameLower);
        const enemyCanMega = this.enemyUnlocks.enable_mega || 
            (enemyObj.canMega !== false && (enemyObj.canMega === true || isBossTrainer));
        this.enemyParty = validPartyData.map(p => {
            // ä½¿ç”¨æ–°ç‰ˆæ„é€ æ–¹å¼ï¼šä¼ å…¥å®Œæ•´é…ç½®å¯¹è±¡
            const poke = new Pokemon(p);
            // ã€ä¿®å¤ã€‘å³ä½¿ enemyCanMega=falseï¼Œå¦‚æœå®å¯æ¢¦æœ‰ mechanic='dynamax'ï¼Œä¹Ÿéœ€è¦æ£€æµ‹å½¢æ€
            // autoDetectMegaEligibility ä¸ä»…å¤„ç† Megaï¼Œè¿˜å¤„ç† Dynamax/GMax å½¢æ€
            const needsFormDetection = (enemyCanMega && !isWild) || 
                poke.mechanic === 'dynamax' || 
                poke.mechanic === 'tera' ||
                poke.canDynamax;
            if (needsFormDetection) {
                console.log('[FORM] Enemy: Calling autoDetectMegaEligibility for', poke.name, 'mechanic:', poke.mechanic);
                autoDetectMegaEligibility(poke, p.mega || null);
                console.log('[FORM] Enemy after detection:', poke.name, 'canMegaEvolve:', poke.canMegaEvolve, 'canDynamax:', poke.canDynamax, 'megaTargetId:', poke.megaTargetId);
            }
            return poke;
        });
        // ã€è°ƒè¯•ã€‘æ‰“å°æ•Œæ–¹é˜Ÿä¼åˆå§‹åŒ–çŠ¶æ€
        console.log('[ENEMY PARTY] Loaded', this.enemyParty.length, 'Pokemon:');
        this.enemyParty.forEach((p, i) => {
            console.log(`  [${i}] ${p.cnName} (${p.name}) - HP: ${p.currHp}/${p.maxHp}, isAlive: ${p.isAlive()}`);
        });
        this.enemyActive = 0;
        this.enemyMegaUsed = false;
        if (isWild && this.enemyParty.length > 0) {
            this.trainer.name = this.enemyParty[0].cnName;
        }
        this.phase = 'battle';
    }
    // è®¾ç½®ç©å®¶é˜Ÿä¼
    // ã€ä¿®å¤ã€‘canMega åªæ§åˆ¶ Mega è¿›åŒ–ï¼Œä½†æå·¨åŒ–/å¤ªæ™¶åŒ–ç­‰éœ€è¦å•ç‹¬æ£€æŸ¥
    setPlayerParty(partyData, canMega = true) {
        console.log('[MEGA] setPlayerParty called, canMega:', canMega, 'partyData:', partyData);
        this.playerParty = partyData.map(p => {
            // ä½¿ç”¨æ–°ç‰ˆæ„é€ æ–¹å¼ï¼šä¼ å…¥å®Œæ•´é…ç½®å¯¹è±¡
            // AVs åº”è¯¥åœ¨ pkm-tavern-plugin.js ä¸­å¤„ç† (AVl/AVup æ ¼å¼)
            const poke = new Pokemon(p);
            // ã€ä¿®å¤ã€‘å³ä½¿ canMega=falseï¼Œå¦‚æœå®å¯æ¢¦æœ‰ mechanic='dynamax'ï¼Œä¹Ÿéœ€è¦æ£€æµ‹å½¢æ€
            // autoDetectMegaEligibility ä¸ä»…å¤„ç† Megaï¼Œè¿˜å¤„ç† Dynamax/GMax å½¢æ€
            const needsFormDetection = canMega || 
                poke.mechanic === 'dynamax' || 
                poke.mechanic === 'tera' ||
                poke.canDynamax;
            if (needsFormDetection) {
                console.log('[FORM] Calling autoDetectMegaEligibility for', poke.name, 'with mega flag:', p.mega, 'mechanic:', poke.mechanic);
                autoDetectMegaEligibility(poke, p.mega || null);
                console.log('[FORM] After detection:', poke.name, 'canMegaEvolve:', poke.canMegaEvolve, 'canDynamax:', poke.canDynamax, 'megaTargetId:', poke.megaTargetId);
            }
            return poke;
        });
        this.playerActive = 0;
        this.playerMegaUsed = false;
    }
    // è·å–å½“å‰å‡ºæˆ˜
    getPlayer() { return this.playerParty[this.playerActive]; }
    getEnemy() { return this.enemyParty[this.enemyActive]; }
    // æ£€æŸ¥èƒœè´Ÿ
    checkBattleEnd() {
        const playerAlive = this.playerParty.some(p => p.isAlive());
        const enemyAlive = this.enemyParty.some(p => p.isAlive());
        if (!playerAlive) return 'loss';
        if (!enemyAlive) return 'win';
        return null;
    }
    // æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„æ•Œæ–¹
    nextAliveEnemy() {
        // é‡ç½®å½“å‰æ•Œæ–¹çš„èƒ½åŠ›ç­‰çº§
        const currentEnemy = this.enemyParty[this.enemyActive];
        if (currentEnemy && typeof currentEnemy.resetBoosts === 'function') {
            currentEnemy.resetBoosts();
        }
        // è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰æ•Œæ–¹å®å¯æ¢¦çš„çŠ¶æ€
        console.log('[nextAliveEnemy] Current active:', this.enemyActive);
        this.enemyParty.forEach((p, i) => {
            console.log(`[nextAliveEnemy] Enemy ${i}: ${p.cnName}, HP: ${p.currHp}/${p.maxHp}, isAlive: ${p.isAlive()}`);
        });
        // ============================================
        // æ™ºèƒ½æ¢äººï¼šExpert/Hard éš¾åº¦ä½¿ç”¨ Revenge Killer é€»è¾‘
        // ============================================
        const difficulty = this.aiDifficulty || 'hard';
        if ((difficulty === 'expert' || difficulty === 'hard') && 
            typeof window !== 'undefined' && typeof window.getBestRevengeKiller === 'function') {
            const playerPoke = this.getPlayer();
            if (playerPoke && playerPoke.isAlive()) {
                const smartIdx = window.getBestRevengeKiller(this.enemyParty, playerPoke, this.enemyActive);
                if (smartIdx !== -1 && smartIdx !== this.enemyActive && 
                    this.enemyParty[smartIdx] && this.enemyParty[smartIdx].isAlive()) {
                    console.log(`[nextAliveEnemy] Smart switch: choosing index ${smartIdx} (Revenge Killer)`);
                    this.enemyActive = smartIdx;
                    return true;
                }
            }
        }
        // Fallback: çº¿æ€§æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„
        const idx = this.enemyParty.findIndex((p, i) => i !== this.enemyActive && p.isAlive());
        console.log('[nextAliveEnemy] Found next alive at index:', idx);
        if (idx !== -1) this.enemyActive = idx;
        return idx !== -1;
    }
    // æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„ç©å®¶
    nextAlivePlayer() {
        const idx = this.playerParty.findIndex((p, i) => i !== this.playerActive && p.isAlive());
        if (idx !== -1) this.playerActive = idx;
        this.phase = 'battle';
    }
}
/* =============================================================
 *  BATTLE AI - å·²è¿ç§»åˆ° ai-engine.js
 *  ä¿ç•™æ­¤æ³¨é‡Šä»¥æ ‡è®° AI é€»è¾‘çš„æ–°ä½ç½®
 * ============================================================= */
// å¯¼å‡º
window.TYPE_CHART = TYPE_CHART;
window.NATURE_MODIFIERS = NATURE_MODIFIERS;
window.getTypeEffectiveness = getTypeEffectiveness;
window.getPokemonData = getPokemonData;
window.getMoveData = getMoveData;
window.calcStats = calcStats;
window.Pokemon = Pokemon;
window.calcDamage = calcDamage;
window.applyMoveSecondaryEffects = applyMoveSecondaryEffects;
window.BattleState = BattleState;
// window.getAiMove - å·²è¿ç§»åˆ° ai-engine.js
]]></file>
        <file name="items-data.js"><![CDATA[/**
 * ===========================================
 * ITEMS-DATA.JS - é“å…·æ•°æ®åº“
 * ===========================================
 * 
 * é›†ä¸­ç®¡ç†æ‰€æœ‰é“å…·æ•°æ®ï¼Œæ¶ˆé™¤ç¡¬ç¼–ç 
 * å‚è€ƒ Showdown çš„ items.ts ç»“æ„
 * 
 * èŒè´£:
 * - é“å…·åŸºç¡€æ•°æ® (åç§°ã€ç±»å‹ã€æ•ˆæœ)
 * - é“å…·åˆ†ç±»å¸¸é‡
 * - é“å…·æ•ˆæœå¤„ç†å™¨
 */
// ============================================
// é“å…·æ•°æ®åº“
// ============================================
const ITEMS = {
    // ========== æˆ˜æ–—é“å…· (Battle Items) ==========
    // --- æ°”åŠ¿æŠ«å¸¦ (Focus Sash) ---
    focussash: {
        id: 'focussash',
        name: 'Focus Sash',
        cnName: 'æ°”åŠ¿æŠ«å¸¦',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        // æ•ˆæœ: æ»¡è¡€æ—¶ï¼Œè‡´å‘½ä¼¤å®³åªä¼šè®© HP å‰© 1
        effect: 'surviveLethal',
        description: 'å½“æŒæœ‰è€…HPæ»¡æ—¶ï¼Œå—åˆ°è‡´å‘½ä¼¤å®³ä¼šä¿ç•™1ç‚¹HPï¼ˆä¸€æ¬¡æ€§ï¼‰',
    },
    // --- è®²ç©¶ç³»åˆ— (Choice Items) ---
    choiceband: {
        id: 'choiceband',
        name: 'Choice Band',
        cnName: 'è®²ç©¶å¤´å¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { atk: 1.5 },
        isChoice: true,
        description: 'ç‰©æ”»x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    choicescarf: {
        id: 'choicescarf',
        name: 'Choice Scarf',
        cnName: 'è®²ç©¶å›´å·¾',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { spe: 1.5 },
        isChoice: true,
        description: 'é€Ÿåº¦x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    choicespecs: {
        id: 'choicespecs',
        name: 'Choice Specs',
        cnName: 'è®²ç©¶çœ¼é•œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { spa: 1.5 },
        isChoice: true,
        description: 'ç‰¹æ”»x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    // --- ç”Ÿå‘½å®ç  (Life Orb) ---
    lifeorb: {
        id: 'lifeorb',
        name: 'Life Orb',
        cnName: 'ç”Ÿå‘½å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'lifeOrb',
        damageBoost: 1.3,
        recoilPercent: 0.1, // 10% æœ€å¤§HP
        description: 'æ”»å‡»ä¼¤å®³x1.3ï¼Œä½†æ¯æ¬¡æ”»å‡»æŸå¤±10%æœ€å¤§HP',
    },
    // --- å‰©é¥­ (Leftovers) ---
    leftovers: {
        id: 'leftovers',
        name: 'Leftovers',
        cnName: 'å‰©é¥­',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'endOfTurnHeal',
        healPercent: 1/16, // æ¯å›åˆæ¢å¤ 1/16 æœ€å¤§HP
        description: 'æ¯å›åˆç»“æŸæ—¶æ¢å¤1/16æœ€å¤§HP',
    },
    // --- é»‘è‰²æ·¤æ³¥ (Black Sludge) ---
    blacksludge: {
        id: 'blacksludge',
        name: 'Black Sludge',
        cnName: 'é»‘è‰²æ·¤æ³¥',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'blackSludge',
        healPercent: 1/16, // æ¯’ç³»æ¢å¤
        damagePercent: 1/8, // éæ¯’ç³»å—ä¼¤
        description: 'æ¯’å±æ€§æ¯å›åˆæ¢å¤1/16HPï¼Œéæ¯’å±æ€§æ¯å›åˆæŸå¤±1/8HP',
    },
    // --- è¿›åŒ–å¥‡çŸ³ (Eviolite) ---
    eviolite: {
        id: 'eviolite',
        name: 'Eviolite',
        cnName: 'è¿›åŒ–å¥‡çŸ³',
        category: 'held',
        consumable: false,
        fling: { basePower: 40 },
        effect: 'eviolite',
        defBoost: 1.5,
        spdBoost: 1.5,
        requiresNFE: true, // åªå¯¹æœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦æœ‰æ•ˆ
        description: 'æœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦é˜²å¾¡å’Œç‰¹é˜²x1.5',
    },
    // --- çªå‡»èƒŒå¿ƒ (Assault Vest) ---
    assaultvest: {
        id: 'assaultvest',
        name: 'Assault Vest',
        cnName: 'çªå‡»èƒŒå¿ƒ',
        category: 'held',
        consumable: false,
        fling: { basePower: 80 },
        effect: 'assaultVest',
        spdBoost: 1.5,
        disableStatus: true, // ç¦æ­¢ä½¿ç”¨å˜åŒ–æŠ€
        description: 'ç‰¹é˜²x1.5ï¼Œä½†æ— æ³•ä½¿ç”¨å˜åŒ–æŠ€',
    },
    // --- æ°”çƒ (Air Balloon) ---
    airballoon: {
        id: 'airballoon',
        name: 'Air Balloon',
        cnName: 'æ°”çƒ',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        effect: 'airBalloon',
        immunity: ['Ground'], // å…ç–«åœ°é¢
        popOnHit: true, // è¢«æ”»å‡»åç ´è£‚
        description: 'å…ç–«åœ°é¢ç³»æ‹›å¼ï¼Œè¢«æ”»å‡»åç ´è£‚',
    },
    // --- å…‰ä¹‹é»åœŸ (Light Clay) ---
    lightclay: {
        id: 'lightclay',
        name: 'Light Clay',
        cnName: 'å…‰ä¹‹é»åœŸ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'extendScreens',
        screenDuration: 8, // å£ç±»æ‹›å¼æŒç»­8å›åˆï¼ˆé»˜è®¤5ï¼‰
        description: 'åå°„å£ã€å…‰å¢™ã€æå…‰å¹•æŒç»­8å›åˆ',
    },
    // --- å‡¸å‡¸å¤´ç›” (Rocky Helmet) ---
    rockyhelmet: {
        id: 'rockyhelmet',
        name: 'Rocky Helmet',
        cnName: 'å‡¸å‡¸å¤´ç›”',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'rockyHelmet',
        contactDamage: 1/6, // æ¥è§¦æ”»å‡»è€…æŸå¤± 1/6 HP
        description: 'è¢«æ¥è§¦ç±»æ‹›å¼æ”»å‡»æ—¶ï¼Œæ”»å‡»è€…æŸå¤±1/6æœ€å¤§HP',
    },
    // --- è¾¾äººå¸¦ (Expert Belt) ---
    expertbelt: {
        id: 'expertbelt',
        name: 'Expert Belt',
        cnName: 'è¾¾äººå¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'expertBelt',
        superEffectiveBoost: 1.2, // æ•ˆæœæ‹”ç¾¤æ—¶ä¼¤å®³x1.2
        description: 'æ•ˆæœæ‹”ç¾¤çš„æ‹›å¼ä¼¤å®³x1.2',
    },
    // --- å¼±ç‚¹ä¿é™© (Weakness Policy) ---
    weaknesspolicy: {
        id: 'weaknesspolicy',
        name: 'Weakness Policy',
        cnName: 'å¼±ç‚¹ä¿é™©',
        category: 'held',
        consumable: true,
        fling: { basePower: 80 },
        effect: 'weaknessPolicy',
        boosts: { atk: 2, spa: 2 }, // è¢«å¼±ç‚¹æ”»å‡»åæ”»å‡»ç‰¹æ”»+2
        description: 'è¢«æ•ˆæœæ‹”ç¾¤çš„æ‹›å¼æ”»å‡»åï¼Œæ”»å‡»å’Œç‰¹æ”»å„+2çº§',
    },
    // --- ç«ç„°å®ç  (Flame Orb) ---
    flameorb: {
        id: 'flameorb',
        name: 'Flame Orb',
        cnName: 'ç«ç„°å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'brn' },
        effect: 'flameOrb',
        selfStatus: 'brn', // å›åˆç»“æŸæ—¶è‡ªå·±çƒ§ä¼¤
        description: 'å›åˆç»“æŸæ—¶ä½¿è‡ªå·±é™·å…¥ç¼ä¼¤çŠ¶æ€',
    },
    // --- å‰§æ¯’å®ç  (Toxic Orb) ---
    toxicorb: {
        id: 'toxicorb',
        name: 'Toxic Orb',
        cnName: 'å‰§æ¯’å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'tox' },
        effect: 'toxicOrb',
        selfStatus: 'tox', // å›åˆç»“æŸæ—¶è‡ªå·±å‰§æ¯’
        description: 'å›åˆç»“æŸæ—¶ä½¿è‡ªå·±é™·å…¥å‰§æ¯’çŠ¶æ€',
    },
    // --- çº¢ç‰Œ (Red Card) ---
    redcard: {
        id: 'redcard',
        name: 'Red Card',
        cnName: 'çº¢ç‰Œ',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        effect: 'redCard',
        forceSwitch: true, // è¢«æ”»å‡»åå¼ºåˆ¶å¯¹æ–¹æ¢äºº
        description: 'è¢«æ”»å‡»åå¼ºåˆ¶å¯¹æ–¹æ›´æ¢å®å¯æ¢¦',
    },
    // --- é€ƒè„±æŒ‰é”® (Eject Button) ---
    ejectbutton: {
        id: 'ejectbutton',
        name: 'Eject Button',
        cnName: 'é€ƒè„±æŒ‰é”®',
        category: 'held',
        consumable: true,
        fling: { basePower: 30 },
        effect: 'ejectButton',
        selfSwitch: true, // è¢«æ”»å‡»åè‡ªå·±æ¢äºº
        description: 'è¢«æ”»å‡»åå¯ä»¥æ›´æ¢è‡ªå·±çš„å®å¯æ¢¦',
    },
    // --- æºå¸¦é€ƒè·‘åŒ… (Eject Pack) ---
    ejectpack: {
        id: 'ejectpack',
        name: 'Eject Pack',
        cnName: 'æºå¸¦é€ƒè·‘åŒ…',
        category: 'held',
        consumable: true,
        fling: { basePower: 50 },
        effect: 'ejectPack',
        switchOnStatDrop: true, // èƒ½åŠ›ä¸‹é™æ—¶æ¢äºº
        description: 'èƒ½åŠ›ä¸‹é™æ—¶å¯ä»¥æ›´æ¢å®å¯æ¢¦',
    },
    // ========== å±æ€§å¼ºåŒ–é“å…· (Type-Boosting Items) ==========
    charcoal: {
        id: 'charcoal',
        name: 'Charcoal',
        cnName: 'æœ¨ç‚­',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Fire',
        boost: 1.2,
        description: 'ç«å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    mysticwater: {
        id: 'mysticwater',
        name: 'Mystic Water',
        cnName: 'ç¥ç§˜æ°´æ»´',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Water',
        boost: 1.2,
        description: 'æ°´å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    miracleseed: {
        id: 'miracleseed',
        name: 'Miracle Seed',
        cnName: 'å¥‡è¿¹ç§å­',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Grass',
        boost: 1.2,
        description: 'è‰å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    magnet: {
        id: 'magnet',
        name: 'Magnet',
        cnName: 'ç£é“',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Electric',
        boost: 1.2,
        description: 'ç”µå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    nevermeltice: {
        id: 'nevermeltice',
        name: 'Never-Melt Ice',
        cnName: 'ä¸èå†°',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Ice',
        boost: 1.2,
        description: 'å†°å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    blackbelt: {
        id: 'blackbelt',
        name: 'Black Belt',
        cnName: 'é»‘å¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Fighting',
        boost: 1.2,
        description: 'æ ¼æ–—å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    poisonbarb: {
        id: 'poisonbarb',
        name: 'Poison Barb',
        cnName: 'æ¯’é’ˆ',
        category: 'held',
        consumable: false,
        fling: { basePower: 70, status: 'psn' },
        effect: 'typeBoost',
        boostedType: 'Poison',
        boost: 1.2,
        description: 'æ¯’å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    softsand: {
        id: 'softsand',
        name: 'Soft Sand',
        cnName: 'æŸ”è½¯æ²™å­',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Ground',
        boost: 1.2,
        description: 'åœ°é¢å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    sharpbeak: {
        id: 'sharpbeak',
        name: 'Sharp Beak',
        cnName: 'é”åˆ©é¸Ÿå˜´',
        category: 'held',
        consumable: false,
        fling: { basePower: 50 },
        effect: 'typeBoost',
        boostedType: 'Flying',
        boost: 1.2,
        description: 'é£è¡Œå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    twistedspoon: {
        id: 'twistedspoon',
        name: 'Twisted Spoon',
        cnName: 'å¼¯æ›²çš„æ±¤åŒ™',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Psychic',
        boost: 1.2,
        description: 'è¶…èƒ½åŠ›å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    silverpowder: {
        id: 'silverpowder',
        name: 'Silver Powder',
        cnName: 'é“¶ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Bug',
        boost: 1.2,
        description: 'è™«å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    hardstone: {
        id: 'hardstone',
        name: 'Hard Stone',
        cnName: 'ç¡¬çŸ³å¤´',
        category: 'held',
        consumable: false,
        fling: { basePower: 100 },
        effect: 'typeBoost',
        boostedType: 'Rock',
        boost: 1.2,
        description: 'å²©çŸ³å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    spelltag: {
        id: 'spelltag',
        name: 'Spell Tag',
        cnName: 'è¯…å’’ä¹‹ç¬¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Ghost',
        boost: 1.2,
        description: 'å¹½çµå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    dragonfang: {
        id: 'dragonfang',
        name: 'Dragon Fang',
        cnName: 'é¾™ä¹‹ç‰™',
        category: 'held',
        consumable: false,
        fling: { basePower: 70 },
        effect: 'typeBoost',
        boostedType: 'Dragon',
        boost: 1.2,
        description: 'é¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    blackglasses: {
        id: 'blackglasses',
        name: 'Black Glasses',
        cnName: 'é»‘è‰²çœ¼é•œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Dark',
        boost: 1.2,
        description: 'æ¶å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    metalcoat: {
        id: 'metalcoat',
        name: 'Metal Coat',
        cnName: 'é‡‘å±è†œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Steel',
        boost: 1.2,
        description: 'é’¢å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    silkscarf: {
        id: 'silkscarf',
        name: 'Silk Scarf',
        cnName: 'ä¸ç»¸å›´å·¾',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Normal',
        boost: 1.2,
        description: 'ä¸€èˆ¬å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    fairyfeather: {
        id: 'fairyfeather',
        name: 'Fairy Feather',
        cnName: 'å¦–ç²¾ä¹‹ç¾½',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Fairy',
        boost: 1.2,
        description: 'å¦–ç²¾å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    // ========== å¤ªæ™¶ç  (Tera Orbs) ==========
    teraorb: {
        id: 'teraorb',
        name: 'Tera Orb',
        cnName: 'å¤ªæ™¶ç ',
        category: 'key',
        consumable: false,
        effect: 'enableTera',
        description: 'å…è®¸å®å¯æ¢¦è¿›è¡Œå¤ªæ™¶åŒ–',
    },
    stellarteraorb: {
        id: 'stellarteraorb',
        name: 'Stellar Tera Orb',
        cnName: 'æ˜Ÿæ™¶å¤ªæ™¶ç ',
        category: 'key',
        consumable: false,
        effect: 'enableStellarTera',
        teraType: 'Stellar',
        description: 'ç‰¹æ®Šçš„å¤ªæ™¶ç ï¼Œå…è®¸å®å¯æ¢¦è¿›è¡Œæ˜Ÿæ™¶å¤ªæ™¶åŒ–ã€‚æ˜Ÿæ™¶çŠ¶æ€ä¸‹ï¼šåŸç”Ÿæœ¬ç³»æ‹›å¼2.0xåŠ æˆï¼Œéæœ¬ç³»æ‹›å¼1.2xåŠ æˆï¼Œå¤ªæ™¶çˆ†å‘å¯¹å¤ªæ™¶åŒ–ç›®æ ‡æ’å®šæ•ˆæœæ‹”ç¾¤',
    },
    // ========== ç²¾çµçƒ (PokÃ© Balls) ==========
    pokeball: {
        id: 'pokeball',
        name: 'PokÃ© Ball',
        cnName: 'ç²¾çµçƒ',
        category: 'ball',
        catchRate: 1,
        isPokeball: true,
        description: 'ç”¨äºæ•æ‰é‡ç”Ÿå®å¯æ¢¦çš„é“å…·',
    },
    greatball: {
        id: 'greatball',
        name: 'Great Ball',
        cnName: 'è¶…çº§çƒ',
        category: 'ball',
        catchRate: 1.5,
        isPokeball: true,
        description: 'æ€§èƒ½æ¯”ç²¾çµçƒå¥½ä¸€äº›çš„çƒ',
    },
    ultraball: {
        id: 'ultraball',
        name: 'Ultra Ball',
        cnName: 'é«˜çº§çƒ',
        category: 'ball',
        catchRate: 2,
        isPokeball: true,
        description: 'æ€§èƒ½éå¸¸å¥½çš„çƒ',
    },
    masterball: {
        id: 'masterball',
        name: 'Master Ball',
        cnName: 'å¤§å¸ˆçƒ',
        category: 'ball',
        catchRate: 255, // å¿…å®šæ•è·
        isPokeball: true,
        description: 'å¿…å®šèƒ½æ•æ‰åˆ°é‡ç”Ÿå®å¯æ¢¦çš„æœ€é«˜æ€§èƒ½çƒ',
    },
    premierball: {
        id: 'premierball',
        name: 'Premier Ball',
        cnName: 'çºªå¿µçƒ',
        category: 'ball',
        catchRate: 1,
        isPokeball: true,
        description: 'æŸç§çºªå¿µç”¨çš„ç¨€æœ‰çƒ',
    },
    quickball: {
        id: 'quickball',
        name: 'Quick Ball',
        cnName: 'é€Ÿåº¦çƒ',
        category: 'ball',
        catchRate: 5, // ç¬¬ä¸€å›åˆ
        catchRateLater: 1, // ä¹‹å
        isPokeball: true,
        description: 'æˆ˜æ–—å¼€å§‹æ—¶ä½¿ç”¨æ•ˆæœæ‹”ç¾¤çš„çƒ',
    },
    timerball: {
        id: 'timerball',
        name: 'Timer Ball',
        cnName: 'è®¡æ—¶çƒ',
        category: 'ball',
        // æ•è·ç‡éšå›åˆå¢åŠ 
        isPokeball: true,
        description: 'å›åˆæ•°è¶Šå¤šæ•ˆæœè¶Šå¥½çš„çƒ',
    },
    duskball: {
        id: 'duskball',
        name: 'Dusk Ball',
        cnName: 'é»‘æš—çƒ',
        category: 'ball',
        catchRate: 3, // å¤œæ™šæˆ–æ´ç©´
        catchRateDay: 1,
        isPokeball: true,
        description: 'åœ¨é»‘æš—çš„åœ°æ–¹å®¹æ˜“æ•æ‰çš„çƒ',
    },
    healball: {
        id: 'healball',
        name: 'Heal Ball',
        cnName: 'æ²»æ„ˆçƒ',
        category: 'ball',
        catchRate: 1,
        healOnCatch: true,
        isPokeball: true,
        description: 'æ•æ‰åä¼šç«‹å³æ¢å¤HPå’ŒçŠ¶æ€çš„çƒ',
    },
    netball: {
        id: 'netball',
        name: 'Net Ball',
        cnName: 'æ•ç½‘çƒ',
        category: 'ball',
        catchRate: 3.5, // æ°´/è™«å±æ€§
        catchRateOther: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰æ°´å±æ€§å’Œè™«å±æ€§å®å¯æ¢¦çš„çƒ',
    },
    diveball: {
        id: 'diveball',
        name: 'Dive Ball',
        cnName: 'æ½œæ°´çƒ',
        category: 'ball',
        catchRate: 3.5, // æ°´ä¸­
        catchRateLand: 1,
        isPokeball: true,
        description: 'åœ¨æ°´ä¸­å®¹æ˜“æ•æ‰çš„çƒ',
    },
    luxuryball: {
        id: 'luxuryball',
        name: 'Luxury Ball',
        cnName: 'è±ªåçƒ',
        category: 'ball',
        catchRate: 1,
        friendshipBoost: true,
        isPokeball: true,
        description: 'æ•æ‰åäº²å¯†åº¦æ›´å®¹æ˜“ä¸Šå‡çš„çƒ',
    },
    repeatball: {
        id: 'repeatball',
        name: 'Repeat Ball',
        cnName: 'é‡å¤çƒ',
        category: 'ball',
        catchRate: 3.5, // å·²æ•è·è¿‡çš„ç§ç±»
        catchRateNew: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰æ›¾ç»æ•æ‰è¿‡çš„å®å¯æ¢¦çš„çƒ',
    },
    beastball: {
        id: 'beastball',
        name: 'Beast Ball',
        cnName: 'ç©¶æçƒ',
        category: 'ball',
        catchRate: 5, // ç©¶æå¼‚å…½
        catchRateOther: 0.1,
        isPokeball: true,
        description: 'ç”¨äºæ•æ‰ç©¶æå¼‚å…½çš„ç‰¹æ®Šçƒ',
    },
    dreamball: {
        id: 'dreamball',
        name: 'Dream Ball',
        cnName: 'æ¢¦å¢ƒçƒ',
        category: 'ball',
        catchRate: 4, // ç¡çœ çŠ¶æ€
        catchRateAwake: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰ç¡çœ çŠ¶æ€å®å¯æ¢¦çš„çƒ',
    },
    // ========== æ ‘æœ (Berries) ==========
    // --- å›å¤æ ‘æœ ---
    oranberry: {
        id: 'oranberry',
        name: 'Oran Berry',
        cnName: 'æ©™æ©™æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healAmount: 10,
        triggerHP: 0.5, // HP <= 50% æ—¶è§¦å‘
        naturalGift: { basePower: 80, type: 'Poison' },
        description: 'HPé™åˆ°ä¸€åŠä»¥ä¸‹æ—¶æ¢å¤10ç‚¹HP',
    },
    sitrusberry: {
        id: 'sitrusberry',
        name: 'Sitrus Berry',
        cnName: 'æ–‡æŸšæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 0.25, // æ¢å¤ 25% æœ€å¤§HP
        triggerHP: 0.5,
        naturalGift: { basePower: 80, type: 'Psychic' },
        description: 'HPé™åˆ°ä¸€åŠä»¥ä¸‹æ—¶æ¢å¤25%æœ€å¤§HP',
    },
    // --- 1/3 HP å›å¤æ ‘æœ (æ··ä¹±æ ‘æœ) ---
    figyberry: {
        id: 'figyberry',
        name: 'Figy Berry',
        cnName: 'å‹¿èŠ±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'atk', // å‡æ”»å‡»æ€§æ ¼ä¼šæ··ä¹±
        naturalGift: { basePower: 80, type: 'Bug' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡æ”»å‡»æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    wikiberry: {
        id: 'wikiberry',
        name: 'Wiki Berry',
        cnName: 'å¼‚å¥‡æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spa',
        naturalGift: { basePower: 80, type: 'Rock' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡ç‰¹æ”»æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    magoberry: {
        id: 'magoberry',
        name: 'Mago Berry',
        cnName: 'èŠ’èŠ’æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spe',
        naturalGift: { basePower: 80, type: 'Ghost' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡é€Ÿåº¦æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    aguavberry: {
        id: 'aguavberry',
        name: 'Aguav Berry',
        cnName: 'èŠ­äºšæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spd',
        naturalGift: { basePower: 80, type: 'Dragon' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡ç‰¹é˜²æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    iapapaberry: {
        id: 'iapapaberry',
        name: 'Iapapa Berry',
        cnName: 'ä¹èŠ­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'def',
        naturalGift: { basePower: 80, type: 'Dark' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡é˜²å¾¡æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    // --- çŠ¶æ€å›å¤æ ‘æœ ---
    cheriberry: {
        id: 'cheriberry',
        name: 'Cheri Berry',
        cnName: 'æ¨±å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'par',
        naturalGift: { basePower: 80, type: 'Fire' },
        description: 'æ²»æ„ˆéº»ç—¹çŠ¶æ€',
    },
    chestoberry: {
        id: 'chestoberry',
        name: 'Chesto Berry',
        cnName: 'é›¶ä½™æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'slp',
        naturalGift: { basePower: 80, type: 'Water' },
        description: 'æ²»æ„ˆç¡çœ çŠ¶æ€',
    },
    pechaberry: {
        id: 'pechaberry',
        name: 'Pecha Berry',
        cnName: 'æ¡ƒæ¡ƒæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'psn',
        naturalGift: { basePower: 80, type: 'Electric' },
        description: 'æ²»æ„ˆä¸­æ¯’çŠ¶æ€',
    },
    rawstberry: {
        id: 'rawstberry',
        name: 'Rawst Berry',
        cnName: 'è“è“æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'brn',
        naturalGift: { basePower: 80, type: 'Grass' },
        description: 'æ²»æ„ˆç¼ä¼¤çŠ¶æ€',
    },
    aspearberry: {
        id: 'aspearberry',
        name: 'Aspear Berry',
        cnName: 'åˆ©æœ¨æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'frz',
        naturalGift: { basePower: 80, type: 'Ice' },
        description: 'æ²»æ„ˆå†°å†»çŠ¶æ€',
    },
    persimberry: {
        id: 'persimberry',
        name: 'Persim Berry',
        cnName: 'æŸ¿ä»”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureConfusion',
        naturalGift: { basePower: 80, type: 'Ground' },
        description: 'æ²»æ„ˆæ··ä¹±çŠ¶æ€',
    },
    lumberry: {
        id: 'lumberry',
        name: 'Lum Berry',
        cnName: 'æœ¨å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureAll',
        naturalGift: { basePower: 80, type: 'Flying' },
        description: 'æ²»æ„ˆæ‰€æœ‰å¼‚å¸¸çŠ¶æ€',
    },
    // --- åŠä¼¤æ ‘æœ (æŠ—æ€§æ ‘æœ) ---
    occaberry: {
        id: 'occaberry',
        name: 'Occa Berry',
        cnName: 'æè”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fire',
        naturalGift: { basePower: 80, type: 'Fire' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„ç«å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    passhoberry: {
        id: 'passhoberry',
        name: 'Passho Berry',
        cnName: 'ç•ªè”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Water',
        naturalGift: { basePower: 80, type: 'Water' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ°´å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    wacanberry: {
        id: 'wacanberry',
        name: 'Wacan Berry',
        cnName: 'è²è’²æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Electric',
        naturalGift: { basePower: 80, type: 'Electric' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„ç”µå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    rindoberry: {
        id: 'rindoberry',
        name: 'Rindo Berry',
        cnName: 'é¾™ç›æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Grass',
        naturalGift: { basePower: 80, type: 'Grass' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è‰å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    yacheberry: {
        id: 'yacheberry',
        name: 'Yache Berry',
        cnName: 'é›ªè²æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ice',
        naturalGift: { basePower: 80, type: 'Ice' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å†°å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chopleberry: {
        id: 'chopleberry',
        name: 'Chople Berry',
        cnName: 'ç½—å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fighting',
        naturalGift: { basePower: 80, type: 'Fighting' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ ¼æ–—å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    kebiaberry: {
        id: 'kebiaberry',
        name: 'Kebia Berry',
        cnName: 'è‰èš•æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Poison',
        naturalGift: { basePower: 80, type: 'Poison' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ¯’å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    shucaberry: {
        id: 'shucaberry',
        name: 'Shuca Berry',
        cnName: 'æ²™é³æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ground',
        naturalGift: { basePower: 80, type: 'Ground' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„åœ°é¢å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    cobaberry: {
        id: 'cobaberry',
        name: 'Coba Berry',
        cnName: 'å‹¿èŠ±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Flying',
        naturalGift: { basePower: 80, type: 'Flying' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é£è¡Œå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    payapaberry: {
        id: 'payapaberry',
        name: 'Payapa Berry',
        cnName: 'èŠ­ä¹æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Psychic',
        naturalGift: { basePower: 80, type: 'Psychic' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è¶…èƒ½åŠ›å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    tangaberry: {
        id: 'tangaberry',
        name: 'Tanga Berry',
        cnName: 'æ‰æ¨±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Bug',
        naturalGift: { basePower: 80, type: 'Bug' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è™«å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chartiberry: {
        id: 'chartiberry',
        name: 'Charti Berry',
        cnName: 'å²©è”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Rock',
        naturalGift: { basePower: 80, type: 'Rock' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å²©çŸ³å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    kasibberry: {
        id: 'kasibberry',
        name: 'Kasib Berry',
        cnName: 'å¹½çµæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ghost',
        naturalGift: { basePower: 80, type: 'Ghost' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å¹½çµå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    habanberry: {
        id: 'habanberry',
        name: 'Haban Berry',
        cnName: 'å“ˆå¯†æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Dragon',
        naturalGift: { basePower: 80, type: 'Dragon' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é¾™å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    colburberry: {
        id: 'colburberry',
        name: 'Colbur Berry',
        cnName: 'éœ¹éœ¹æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Dark',
        naturalGift: { basePower: 80, type: 'Dark' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ¶å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    babiriberry: {
        id: 'babiriberry',
        name: 'Babiri Berry',
        cnName: 'éœ¸æ¯”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Steel',
        naturalGift: { basePower: 80, type: 'Steel' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é’¢å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chilanberry: {
        id: 'chilanberry',
        name: 'Chilan Berry',
        cnName: 'å¥‡æœ—æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Normal',
        naturalGift: { basePower: 80, type: 'Normal' },
        description: 'å—åˆ°ä¸€èˆ¬å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    roseliberry: {
        id: 'roseliberry',
        name: 'Roseli Berry',
        cnName: 'è”·è–‡æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fairy',
        naturalGift: { basePower: 80, type: 'Fairy' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å¦–ç²¾å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    // ========== ç¥å…½ä¸“å±é“å…· ==========
    adamantorb: {
        id: 'adamantorb',
        name: 'Adamant Orb',
        cnName: 'é‡‘åˆšç‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Dialga'],
        boostedTypes: ['Steel', 'Dragon'],
        boost: 1.2,
        description: 'å¸ç‰™å¢å¡æŒæœ‰æ—¶é’¢å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    lustrousorb: {
        id: 'lustrousorb',
        name: 'Lustrous Orb',
        cnName: 'ç™½ç‰å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Palkia'],
        boostedTypes: ['Water', 'Dragon'],
        boost: 1.2,
        description: 'å¸•è·¯å¥‡äºšæŒæœ‰æ—¶æ°´å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    griseousorb: {
        id: 'griseousorb',
        name: 'Griseous Orb',
        cnName: 'ç™½é‡‘ç‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Giratina'],
        boostedTypes: ['Ghost', 'Dragon'],
        boost: 1.2,
        forcedForme: 'Giratina-Origin',
        description: 'éª‘æ‹‰å¸çº³æŒæœ‰æ—¶å¹½çµå’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2ï¼Œå¹¶å˜ä¸ºèµ·æºå½¢æ€',
    },
    souldew: {
        id: 'souldew',
        name: 'Soul Dew',
        cnName: 'å¿ƒä¹‹æ°´æ»´',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoostSpecies',
        itemUser: ['Latios', 'Latias'],
        boostedTypes: ['Psychic', 'Dragon'],
        boost: 1.2,
        description: 'æ‹‰å¸æ¬§æ–¯/æ‹‰å¸äºšæ–¯æŒæœ‰æ—¶è¶…èƒ½åŠ›å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    // --- åŸå§‹å›å½’å®ç  ---
    redorb: {
        id: 'redorb',
        name: 'Red Orb',
        cnName: 'çº¢è‰²å®ç ',
        category: 'held',
        consumable: false,
        effect: 'primalReversion',
        itemUser: ['Groudon'],
        forcedForme: 'Groudon-Primal',
        isPrimalOrb: true,
        description: 'å›ºæ‹‰å¤šæŒæœ‰æ—¶ä¼šè¿›è¡ŒåŸå§‹å›å½’',
    },
    blueorb: {
        id: 'blueorb',
        name: 'Blue Orb',
        cnName: 'è“è‰²å®ç ',
        category: 'held',
        consumable: false,
        effect: 'primalReversion',
        itemUser: ['Kyogre'],
        forcedForme: 'Kyogre-Primal',
        isPrimalOrb: true,
        description: 'ç›–æ¬§å¡æŒæœ‰æ—¶ä¼šè¿›è¡ŒåŸå§‹å›å½’',
    },
    // --- è‹å“/è—ç›ç„¶ç‰¹ä¸“å± ---
    rustedsword: {
        id: 'rustedsword',
        name: 'Rusted Sword',
        cnName: 'è…æœ½çš„å‰‘',
        category: 'held',
        consumable: false,
        effect: 'formeChange',
        itemUser: ['Zacian'],
        forcedForme: 'Zacian-Crowned',
        description: 'è‹å“æŒæœ‰æ—¶ä¼šå˜ä¸ºå‰‘ä¹‹ç‹å½¢æ€',
    },
    rustedshield: {
        id: 'rustedshield',
        name: 'Rusted Shield',
        cnName: 'è…æœ½çš„ç›¾',
        category: 'held',
        consumable: false,
        effect: 'formeChange',
        itemUser: ['Zamazenta'],
        forcedForme: 'Zamazenta-Crowned',
        description: 'è—ç›ç„¶ç‰¹æŒæœ‰æ—¶ä¼šå˜ä¸ºç›¾ä¹‹ç‹å½¢æ€',
    },
    // ========== ä¸“å±å¼ºåŒ–é“å…· ==========
    lightball: {
        id: 'lightball',
        name: 'Light Ball',
        cnName: 'ç”µæ°”çƒ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'par' },
        effect: 'speciesBoost',
        itemUser: ['Pikachu'],
        statBoost: { atk: 2, spa: 2 },
        description: 'çš®å¡ä¸˜æŒæœ‰æ—¶æ”»å‡»å’Œç‰¹æ”»ç¿»å€',
    },
    thickclub: {
        id: 'thickclub',
        name: 'Thick Club',
        cnName: 'ç²—éª¨å¤´',
        category: 'held',
        consumable: false,
        fling: { basePower: 90 },
        effect: 'speciesBoost',
        itemUser: ['Cubone', 'Marowak', 'Marowak-Alola'],
        statBoost: { atk: 2 },
        description: 'å¡æ‹‰å¡æ‹‰/å˜å•¦å˜å•¦æŒæœ‰æ—¶æ”»å‡»ç¿»å€',
    },
    leek: {
        id: 'leek',
        name: 'Leek',
        cnName: 'å¤§è‘±',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'critBoost',
        itemUser: ['Farfetchd', 'Farfetchd-Galar', 'Sirfetchd'],
        critBoost: 2,
        description: "å¤§è‘±é¸­/è‘±æ¸¸å…µæŒæœ‰æ—¶å®¹æ˜“å‡»ä¸­è¦å®³",
    },
    luckypunch: {
        id: 'luckypunch',
        name: 'Lucky Punch',
        cnName: 'å¹¸è¿æ‹³å¥—',
        category: 'held',
        consumable: false,
        fling: { basePower: 40 },
        effect: 'critBoost',
        itemUser: ['Chansey'],
        critBoost: 2,
        description: 'å‰åˆ©è›‹æŒæœ‰æ—¶å®¹æ˜“å‡»ä¸­è¦å®³',
    },
    metalpowder: {
        id: 'metalpowder',
        name: 'Metal Powder',
        cnName: 'é‡‘å±ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'speciesBoost',
        itemUser: ['Ditto'],
        statBoost: { def: 2 },
        requiresUntransformed: true,
        description: 'ç™¾å˜æ€ªï¼ˆæœªå˜èº«æ—¶ï¼‰æŒæœ‰æ—¶é˜²å¾¡ç¿»å€',
    },
    quickpowder: {
        id: 'quickpowder',
        name: 'Quick Powder',
        cnName: 'é€Ÿåº¦ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'speciesBoost',
        itemUser: ['Ditto'],
        statBoost: { spe: 2 },
        requiresUntransformed: true,
        description: 'ç™¾å˜æ€ªï¼ˆæœªå˜èº«æ—¶ï¼‰æŒæœ‰æ—¶é€Ÿåº¦ç¿»å€',
    },
};
// ============================================
// é“å…·åˆ†ç±»å¸¸é‡
// ============================================
// ä¸å¯äº¤æ¢çš„é“å…· (Trick/Switcheroo æ— æ•ˆ)
const UNSWAPPABLE_ITEMS = [
    // ç¥å…½ä¸“å±
    'rustedsword', 'rustedshield',
    'griseousorb', 'adamantorb', 'lustrousorb',
    'adamantcrystal', 'lustrousglobe', 'griseouscore',
    // ä¸“å±å¼ºåŒ–
    'souldew', 'lightball', 'thickclub', 'luckypunch', 'leek', 'stick',
    // é‚®ä»¶
    'mail',
    // åŸå§‹å›å½’
    'redorb', 'blueorb',
];
// Mega çŸ³åˆ¤å®š (ä»¥ 'ite' ç»“å°¾ä½†ä¸æ˜¯ 'eviolite')
function isMegaStone(itemId) {
    return itemId.endsWith('ite') && itemId !== 'eviolite';
}
// Z æ°´æ™¶åˆ¤å®š
function isZCrystal(itemId) {
    return itemId.endsWith('iumz') || itemId.endsWith('iniumz');
}
// æ£€æŸ¥é“å…·æ˜¯å¦å¯äº¤æ¢
function isSwappable(itemId) {
    if (!itemId) return true;
    const id = itemId.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (UNSWAPPABLE_ITEMS.includes(id)) return false;
    if (isMegaStone(id)) return false;
    if (isZCrystal(id)) return false;
    return true;
}
// ============================================
// é“å…·æ•ˆæœå¤„ç†å™¨
// ============================================
const ItemEffects = {
    /**
     * æ£€æŸ¥ Focus Sash æ•ˆæœ
     * @returns {boolean} æ˜¯å¦è§¦å‘äº†æ°”åŠ¿æŠ«å¸¦
     */
    checkFocusSash(pokemon, damage) {
        const itemId = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (itemId !== 'focussash') return false;
        if (pokemon.currHp !== pokemon.maxHp) return false;
        if (damage < pokemon.currHp) return false;
        // è§¦å‘æ•ˆæœ
        pokemon.currHp = 1;
        pokemon.item = null;
        pokemon.focusSashTriggered = true;
        return true;
    },
    /**
     * æ£€æŸ¥ Choice é“å…·é”æ‹›
     */
    isChoiceLocked(pokemon) {
        const item = pokemon.item || '';
        const itemData = getItem(item);
        return itemData && itemData.isChoice;
    },
    /**
     * è·å– Light Clay çš„å£æŒç»­å›åˆæ•°
     */
    getScreenDuration(pokemon) {
        const itemId = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (itemId === 'lightclay') return 8;
        return 5;
    },
    /**
     * è·å–ç²¾çµçƒæ•è·ç‡
     */
    getBallCatchRate(ballId, context = {}) {
        const ball = ITEMS[ballId];
        if (!ball || !ball.isPokeball) return 1;
        // ç‰¹æ®Šçƒçš„æ¡ä»¶åˆ¤æ–­
        if (ballId === 'quickball' && context.turn === 1) {
            return ball.catchRate;
        }
        if (ballId === 'quickball' && context.turn > 1) {
            return ball.catchRateLater || 1;
        }
        return ball.catchRate || 1;
    },
};
// ============================================
// å·¥å…·å‡½æ•°
// ============================================
/**
 * æ ¹æ® ID è·å–é“å…·æ•°æ®
 * @param {string} itemName - é“å…·åç§°æˆ– ID
 * @returns {Object|null} é“å…·æ•°æ®å¯¹è±¡
 */
function getItem(itemName) {
    if (!itemName) return null;
    const id = itemName.toLowerCase().replace(/[^a-z0-9]/g, '');
    return ITEMS[id] || null;
}
/**
 * æ ¹æ®é“å…·åç§°è·å– ID
 */
function getItemId(itemName) {
    if (!itemName) return null;
    return itemName.toLowerCase().replace(/[^a-z0-9]/g, '');
}
/**
 * è·å–æ‰€æœ‰ç²¾çµçƒ
 */
function getAllPokeballs() {
    return Object.values(ITEMS).filter(item => item.isPokeball);
}
/**
 * è·å–æ‰€æœ‰æ ‘æœ
 */
function getAllBerries() {
    return Object.values(ITEMS).filter(item => item.isBerry);
}
/**
 * æ£€æŸ¥æ˜¯å¦ä¸º Choice é“å…·
 */
function isChoiceItem(itemName) {
    const item = getItem(itemName);
    return item && item.isChoice;
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.ITEMS = ITEMS;
    window.UNSWAPPABLE_ITEMS = UNSWAPPABLE_ITEMS;
    window.ItemEffects = ItemEffects;
    window.getItem = getItem;
    window.getItemId = getItemId;
    window.getAllPokeballs = getAllPokeballs;
    window.getAllBerries = getAllBerries;
    window.isChoiceItem = isChoiceItem;
    window.isMegaStone = isMegaStone;
    window.isZCrystal = isZCrystal;
    window.isSwappable = isSwappable;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        ITEMS,
        UNSWAPPABLE_ITEMS,
        ItemEffects,
        getItem,
        getItemId,
        getAllPokeballs,
        getAllBerries,
        isChoiceItem,
        isMegaStone,
        isZCrystal,
        isSwappable,
    };
}
]]></file>
        <file name="move-effects.js"><![CDATA[/**
 * =============================================
 * MOVE EFFECTS - æŠ€èƒ½æ•ˆæœæ‰©å±•æ¨¡å—
 * =============================================
 * 
 * å¤„ç† moves-data.js ä¸­çš„é€šç”¨å­—æ®µï¼Œå®ç°é«˜çº§æˆ˜æ–—æœºåˆ¶ï¼š
 * - ä¼˜å…ˆçº§ (Priority)
 * - çŠ¶æ€å¼‚å¸¸ (Status Conditions)
 * - å¤©æ°”æ•ˆæœ (Weather)
 * - åœºåœ°æ•ˆæœ (Terrain)
 * - ç‰¹æ®ŠæŠ€èƒ½æ ‡è®° (Flags)
 * - å›ºå®šä¼¤å®³æŠ€èƒ½
 * - ä¸€å‡»å¿…æ€æŠ€èƒ½
 */
// ========== ä¼˜å…ˆçº§ç³»ç»Ÿ (Priority) ==========
// å†³å®šå›åˆå†…çš„è¡ŒåŠ¨é¡ºåº
/**
 * è·å–æŠ€èƒ½ä¼˜å…ˆçº§
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {number} ä¼˜å…ˆçº§ (-7 ~ +5)
 */
function getMovePriority(move) {
    // ã€å¤æ­¦ç³»ç»Ÿã€‘å¦‚æœæ‹›å¼å¯¹è±¡å·²æœ‰ priority å±æ€§ï¼ˆè¢« style ä¿®æ”¹è¿‡ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
    if (typeof move.priority === 'number') {
        return move.priority;
    }
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // ä»æ•°æ®ä¸­è¯»å–ä¼˜å…ˆçº§
    if (typeof fullMoveData.priority === 'number') {
        return fullMoveData.priority;
    }
    // ç¡¬ç¼–ç å¸¸è§ä¼˜å…ˆçº§æŠ€èƒ½
    const priorityMap = {
        // +5
        'Helping Hand': 5,
        // +4
        'Protect': 4, 'Detect': 4, 'Endure': 4, 'Magic Coat': 4, 'Snatch': 4,
        'Baneful Bunker': 4, 'Spiky Shield': 4, "King's Shield": 4, 'Obstruct': 4,
        'Silk Trap': 4, 'Burning Bulwark': 4,
        // +3
        'Fake Out': 3, 'Quick Guard': 3, 'Wide Guard': 3, 'Crafty Shield': 3,
        // +2
        'Extreme Speed': 2, 'Feint': 2, 'First Impression': 2, 'Accelerock': 2,
        // +1
        'Aqua Jet': 1, 'Baby-Doll Eyes': 1, 'Bullet Punch': 1, 'Ice Shard': 1,
        'Mach Punch': 1, 'Quick Attack': 1, 'Shadow Sneak': 1, 'Sucker Punch': 1,
        'Vacuum Wave': 1, 'Water Shuriken': 1, 'Grassy Glide': 1, 'Jet Punch': 1,
        // -1
        'Vital Throw': -1,
        // -3
        'Focus Punch': -3,
        // -4
        'Avalanche': -4, 'Revenge': -4,
        // -5
        'Counter': -5, 'Mirror Coat': -5,
        // -6
        'Circle Throw': -6, 'Dragon Tail': -6, 'Roar': -6, 'Whirlwind': -6, 'Teleport': -6,
        // -7
        'Trick Room': -7
    };
    return priorityMap[move.name] || 0;
}
/**
 * æ¯”è¾ƒä¸¤ä¸ªè¡ŒåŠ¨çš„å…ˆåé¡ºåº
 * @param {object} action1 { pokemon, move, isPlayer }
 * @param {object} action2 { pokemon, move, isPlayer }
 * @returns {number} è´Ÿæ•°=action1å…ˆï¼Œæ­£æ•°=action2å…ˆï¼Œ0=åŒé€Ÿ
 */
function compareActionOrder(action1, action2) {
    const pri1 = getMovePriority(action1.move);
    const pri2 = getMovePriority(action2.move);
    // ä¼˜å…ˆçº§é«˜çš„å…ˆåŠ¨
    if (pri1 !== pri2) {
        return pri2 - pri1;
    }
    // åŒä¼˜å…ˆçº§æ¯”é€Ÿåº¦
    const spe1 = action1.pokemon.getStat('spe');
    const spe2 = action2.pokemon.getStat('spe');
    if (spe1 !== spe2) {
        return spe2 - spe1; // é€Ÿåº¦é«˜çš„å…ˆåŠ¨
    }
    // åŒé€Ÿéšæœº
    return Math.random() < 0.5 ? -1 : 1;
}
// ========== çŠ¶æ€å¼‚å¸¸ç³»ç»Ÿ (Status Conditions) ==========
const STATUS_CONDITIONS = {
    // ä¸»è¦çŠ¶æ€ï¼ˆäº’æ–¥ï¼‰
    par: { name: 'éº»ç—¹', color: '#f1c40f', speedMod: 0.5, skipChance: 0.25 },
    brn: { name: 'ç¼ä¼¤', color: '#e74c3c', atkMod: 0.5, dotPercent: 1/16 },
    psn: { name: 'ä¸­æ¯’', color: '#9b59b6', dotPercent: 1/8 },
    tox: { name: 'å‰§æ¯’', color: '#8e44ad', dotBase: 1/16, dotIncrement: true },
    slp: { name: 'ç¡çœ ', color: '#95a5a6', skipChance: 1, duration: [1, 3] },
    frz: { name: 'å†°å†»', color: '#3498db', skipChance: 1, thawChance: 0.2 }
};
/**
 * å°è¯•ç»™ç›®æ ‡æ–½åŠ çŠ¶æ€å¼‚å¸¸
 * @param {Pokemon} target ç›®æ ‡
 * @param {string} status çŠ¶æ€ID (par/brn/psn/tox/slp/frz)
 * @returns {object} { success, message }
 */
function tryInflictStatus(target, status) {
    // å·²æœ‰ä¸»è¦çŠ¶æ€åˆ™æ— æ³•æ–½åŠ 
    if (target.status) {
        return { success: false, message: `${target.cnName} å·²ç»å¤„äºå¼‚å¸¸çŠ¶æ€!` };
    }
    // å±æ€§å…ç–«æ£€æŸ¥
    const immunities = {
        par: ['Electric'], // ç”µç³»å…ç–«éº»ç—¹
        brn: ['Fire'],     // ç«ç³»å…ç–«ç¼ä¼¤
        psn: ['Poison', 'Steel'], // æ¯’/é’¢ç³»å…ç–«ä¸­æ¯’
        tox: ['Poison', 'Steel'],
        frz: ['Ice']       // å†°ç³»å…ç–«å†°å†»
    };
    if (immunities[status]) {
        for (const type of target.types) {
            if (immunities[status].includes(type)) {
                return { success: false, message: `${target.cnName} çš„${type}å±æ€§å…ç–«äº†è¯¥çŠ¶æ€!` };
            }
        }
    }
    // æ–½åŠ çŠ¶æ€
    target.status = status;
    target.statusTurns = 0;
    const statusInfo = STATUS_CONDITIONS[status];
    return { 
        success: true, 
        message: `${target.cnName} ${statusInfo.name}äº†!` 
    };
}
/**
 * å¤„ç†å›åˆå¼€å§‹æ—¶çš„çŠ¶æ€æ•ˆæœ
 * @param {Pokemon} pokemon 
 * @returns {object} { canMove, damage, message }
 */
function processStatusEffects(pokemon) {
    if (!pokemon.status) {
        return { canMove: true, damage: 0, message: null };
    }
    const status = pokemon.status;
    const info = STATUS_CONDITIONS[status];
    let result = { canMove: true, damage: 0, message: null };
    switch (status) {
        case 'par':
            // 25% æ¦‚ç‡æ— æ³•è¡ŒåŠ¨
            if (Math.random() < info.skipChance) {
                result.canMove = false;
                result.message = `${pokemon.cnName} å› éº»ç—¹è€Œæ— æ³•è¡ŒåŠ¨!`;
            }
            break;
        case 'slp':
            pokemon.statusTurns++;
            const sleepDuration = pokemon.sleepDuration || (Math.floor(Math.random() * 3) + 1);
            pokemon.sleepDuration = sleepDuration;
            if (pokemon.statusTurns >= sleepDuration) {
                pokemon.status = null;
                pokemon.statusTurns = 0;
                pokemon.sleepDuration = 0;
                result.message = `${pokemon.cnName} é†’æ¥äº†!`;
            } else {
                result.canMove = false;
                result.message = `${pokemon.cnName} æ­£åœ¨ç¡è§‰...`;
            }
            break;
        case 'frz':
            // 20% æ¦‚ç‡è§£å†»
            if (Math.random() < info.thawChance) {
                pokemon.status = null;
                result.message = `${pokemon.cnName} è§£å†»äº†!`;
            } else {
                result.canMove = false;
                result.message = `${pokemon.cnName} è¢«å†»ä½äº†!`;
            }
            break;
    }
    return result;
}
/**
 * å¤„ç†å›åˆç»“æŸæ—¶çš„çŠ¶æ€ä¼¤å®³
 * @param {Pokemon} pokemon 
 * @returns {object} { damage, message }
 */
function processStatusDamage(pokemon) {
    if (!pokemon.status) {
        return { damage: 0, message: null };
    }
    const status = pokemon.status;
    let damage = 0;
    let message = null;
    switch (status) {
        case 'brn':
            damage = Math.max(1, Math.floor(pokemon.maxHp / 16));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› ç¼ä¼¤å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
        case 'psn':
            damage = Math.max(1, Math.floor(pokemon.maxHp / 8));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› ä¸­æ¯’å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
        case 'tox':
            pokemon.statusTurns = (pokemon.statusTurns || 0) + 1;
            damage = Math.max(1, Math.floor(pokemon.maxHp * pokemon.statusTurns / 16));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› å‰§æ¯’å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
    }
    return { damage, message };
}
// ========== æŠ€èƒ½é™„åŠ çŠ¶æ€æ•ˆæœ ==========
/**
 * å¤„ç†æŠ€èƒ½çš„çŠ¶æ€å¼‚å¸¸é™„åŠ æ•ˆæœ
 * @param {Pokemon} user æ”»å‡»æ–¹
 * @param {Pokemon} target é˜²å¾¡æ–¹
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function processMoveStatusEffects(user, target, move) {
    const logs = [];
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æŸ¥ secondary ä¸­çš„çŠ¶æ€æ•ˆæœ
    if (fullMoveData.secondary && fullMoveData.secondary.status) {
        const chance = fullMoveData.secondary.chance || 100;
        if (Math.random() * 100 < chance) {
            const result = tryInflictStatus(target, fullMoveData.secondary.status);
            if (result.message) logs.push(result.message);
        }
    }
    // æ£€æŸ¥å¿…å®šè§¦å‘çš„çŠ¶æ€æ•ˆæœ
    if (fullMoveData.status) {
        const result = tryInflictStatus(target, fullMoveData.status);
        if (result.message) logs.push(result.message);
    }
    // ç¡¬ç¼–ç å¸¸è§çŠ¶æ€æŠ€èƒ½
    const statusMoves = {
        'Thunder Wave': { status: 'par', chance: 100 },
        'Stun Spore': { status: 'par', chance: 100 },
        'Glare': { status: 'par', chance: 100 },
        'Nuzzle': { status: 'par', chance: 100 },
        'Will-O-Wisp': { status: 'brn', chance: 100 },
        'Toxic': { status: 'tox', chance: 100 },
        'Poison Powder': { status: 'psn', chance: 100 },
        'Poison Gas': { status: 'psn', chance: 100 },
        'Spore': { status: 'slp', chance: 100 },
        'Sleep Powder': { status: 'slp', chance: 75 },
        'Hypnosis': { status: 'slp', chance: 60 },
        'Sing': { status: 'slp', chance: 55 },
        // æ”»å‡»æŠ€èƒ½é™„å¸¦æ•ˆæœ
        'Thunderbolt': { status: 'par', chance: 10 },
        'Thunder': { status: 'par', chance: 30 },
        'Discharge': { status: 'par', chance: 30 },
        'Body Slam': { status: 'par', chance: 30 },
        'Flamethrower': { status: 'brn', chance: 10 },
        'Fire Blast': { status: 'brn', chance: 10 },
        'Scald': { status: 'brn', chance: 30 },
        'Lava Plume': { status: 'brn', chance: 30 },
        'Ice Beam': { status: 'frz', chance: 10 },
        'Blizzard': { status: 'frz', chance: 10 },
        'Sludge Bomb': { status: 'psn', chance: 30 },
        'Poison Jab': { status: 'psn', chance: 30 }
    };
    if (statusMoves[move.name] && !fullMoveData.secondary?.status) {
        const { status, chance } = statusMoves[move.name];
        if (Math.random() * 100 < chance) {
            const result = tryInflictStatus(target, status);
            if (result.success && result.message) logs.push(result.message);
        }
    }
    return logs;
}
// ========== å›ºå®šä¼¤å®³æŠ€èƒ½ ==========
/**
 * æ£€æŸ¥å¹¶è®¡ç®—å›ºå®šä¼¤å®³æŠ€èƒ½
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move 
 * @returns {object|null} { damage, message } æˆ– nullï¼ˆéå›ºå®šä¼¤å®³æŠ€èƒ½ï¼‰
 */
function checkFixedDamageMove(attacker, defender, move) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // damage å­—æ®µè¡¨ç¤ºå›ºå®šä¼¤å®³
    if (fullMoveData.damage) {
        if (fullMoveData.damage === 'level') {
            return { damage: attacker.level, message: null };
        }
        if (typeof fullMoveData.damage === 'number') {
            return { damage: fullMoveData.damage, message: null };
        }
    }
    // ç‰¹æ®Šå›ºå®šä¼¤å®³æŠ€èƒ½
    const fixedDamageMoves = {
        'Sonic Boom': 20,
        'Dragon Rage': 40,
        'Seismic Toss': 'level',
        'Night Shade': 'level',
        'Psywave': 'random', // 0.5x ~ 1.5x level
        'Super Fang': 'half', // å½“å‰HPçš„ä¸€åŠ
        'Nature\'s Madness': 'half',
        'Guardian of Alola': 'threequarters',
        'Endeavor': 'endeavor' // å°†å¯¹æ–¹HPé™åˆ°ä¸è‡ªå·±ç›¸åŒ
    };
    const fixedType = fixedDamageMoves[move.name];
    if (!fixedType) return null;
    let damage = 0;
    switch (fixedType) {
        case 'level':
            damage = attacker.level;
            break;
        case 'random':
            damage = Math.floor(attacker.level * (0.5 + Math.random()));
            break;
        case 'half':
            damage = Math.floor(defender.currHp / 2);
            break;
        case 'threequarters':
            damage = Math.floor(defender.currHp * 3 / 4);
            break;
        case 'endeavor':
            damage = Math.max(0, defender.currHp - attacker.currHp);
            break;
        default:
            if (typeof fixedType === 'number') {
                damage = fixedType;
            }
    }
    return { damage: Math.max(1, damage), message: null };
}
// ========== ä¸€å‡»å¿…æ€æŠ€èƒ½ (OHKO) ==========
/**
 * æ£€æŸ¥ä¸€å‡»å¿…æ€æŠ€èƒ½
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move 
 * @returns {object|null} { success, damage, message } æˆ– null
 */
function checkOHKOMove(attacker, defender, move) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // ohko å­—æ®µæ ‡è®°ä¸€å‡»å¿…æ€
    if (!fullMoveData.ohko) {
        const ohkoMoves = ['Fissure', 'Horn Drill', 'Guillotine', 'Sheer Cold'];
        if (!ohkoMoves.includes(move.name)) return null;
    }
    // ç­‰çº§ä½äºå¯¹æ–¹åˆ™æ— æ•ˆ
    if (attacker.level < defender.level) {
        return { success: false, damage: 0, message: `${defender.cnName} çš„ç­‰çº§å¤ªé«˜äº†!` };
    }
    // å‘½ä¸­ç‡ = 30 + (æ”»å‡»æ–¹ç­‰çº§ - é˜²å¾¡æ–¹ç­‰çº§)
    const hitChance = 30 + (attacker.level - defender.level);
    if (Math.random() * 100 < hitChance) {
        return { 
            success: true, 
            damage: defender.currHp, 
            message: `ä¸€å‡»å¿…æ€!` 
        };
    } else {
        return { success: false, damage: 0, message: null };
    }
}
// ========== å¤©æ°”ç³»ç»Ÿ (Weather) ==========
const WEATHER_TYPES = {
    sunnyday: { name: 'å¤§æ™´å¤©', fireBoost: 1.5, waterNerf: 0.5, solarBeamCharge: false },
    raindance: { name: 'ä¸‹é›¨', waterBoost: 1.5, fireNerf: 0.5, thunderAccuracy: true },
    sandstorm: { name: 'æ²™æš´', dotTypes: ['Rock', 'Ground', 'Steel'], spDefBoost: ['Rock'] },
    hail: { name: 'å†°é›¹', dotExcept: ['Ice'], blizzardAccuracy: true },
    snow: { name: 'ä¸‹é›ª', defBoost: ['Ice'] }
};
/**
 * è·å–å¤©æ°”å¯¹æŠ€èƒ½å¨åŠ›çš„ä¿®æ­£
 * @param {string} weather å½“å‰å¤©æ°”
 * @param {string} moveType æŠ€èƒ½å±æ€§
 * @returns {number} å¨åŠ›å€ç‡
 */
function getWeatherModifier(weather, moveType) {
    if (!weather || !WEATHER_TYPES[weather]) return 1;
    const w = WEATHER_TYPES[weather];
    if (moveType === 'Fire') {
        if (w.fireBoost) return w.fireBoost;
        if (w.fireNerf) return w.fireNerf;
    }
    if (moveType === 'Water') {
        if (w.waterBoost) return w.waterBoost;
        if (w.waterNerf) return w.waterNerf;
    }
    return 1;
}
// ========== åœºåœ°ç³»ç»Ÿ (Terrain) ==========
const TERRAIN_TYPES = {
    electricterrain: { name: 'ç”µæ°”åœºåœ°', boost: 'Electric', preventSleep: true },
    grassyterrain: { name: 'é’è‰åœºåœ°', boost: 'Grass', healPercent: 1/16 },
    psychicterrain: { name: 'ç²¾ç¥åœºåœ°', boost: 'Psychic', blockPriority: true },
    mistyterrain: { name: 'è–„é›¾åœºåœ°', dragonNerf: 0.5, preventStatus: true }
};
/**
 * è·å–åœºåœ°å¯¹æŠ€èƒ½å¨åŠ›çš„ä¿®æ­£
 * @param {string} terrain å½“å‰åœºåœ°
 * @param {string} moveType æŠ€èƒ½å±æ€§
 * @param {boolean} isGrounded æ˜¯å¦æ¥åœ°
 * @returns {number} å¨åŠ›å€ç‡
 */
function getTerrainModifier(terrain, moveType, isGrounded = true) {
    if (!terrain || !isGrounded || !TERRAIN_TYPES[terrain]) return 1;
    const t = TERRAIN_TYPES[terrain];
    if (t.boost === moveType) return 1.3;
    if (moveType === 'Dragon' && t.dragonNerf) return t.dragonNerf;
    return 1;
}
// ========== æŠ€èƒ½æ ‡è®°ç³»ç»Ÿ (Flags) ==========
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦æœ‰ç‰¹å®šæ ‡è®°
 * @param {object} move 
 * @param {string} flag æ ‡è®°å
 * @returns {boolean}
 */
function hasMoveFlag(move, flag) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    return !!(fullMoveData.flags && fullMoveData.flags[flag]);
}
// å¸¸ç”¨æ ‡è®°è¯´æ˜
const MOVE_FLAGS = {
    contact: 'æ¥è§¦ç±»æŠ€èƒ½ï¼Œè§¦å‘æ¥è§¦ç‰¹æ€§ï¼ˆå¦‚é“åˆºã€é™ç”µï¼‰',
    protect: 'å¯è¢«å®ˆä½ç±»æŠ€èƒ½æŒ¡ä¸‹',
    mirror: 'å¯è¢«é­”æ³•åå°„åå¼¹',
    sound: 'å£°éŸ³ç±»æŠ€èƒ½ï¼Œç©¿é€æ›¿èº«',
    punch: 'æ‹³ç±»æŠ€èƒ½ï¼Œé“æ‹³ç‰¹æ€§åŠ æˆ',
    bite: 'å’¬ç±»æŠ€èƒ½ï¼Œå¼ºå£®ä¹‹é¢šç‰¹æ€§åŠ æˆ',
    bullet: 'å­å¼¹/çƒç±»æŠ€èƒ½ï¼Œé˜²å¼¹ç‰¹æ€§å…ç–«',
    pulse: 'æ³¢åŠ¨ç±»æŠ€èƒ½ï¼Œè¶…çº§å‘å°„å™¨ç‰¹æ€§åŠ æˆ',
    slicing: 'æ–©åˆ‡ç±»æŠ€èƒ½ï¼Œé”‹é”ç‰¹æ€§åŠ æˆ',
    wind: 'é£ç±»æŠ€èƒ½ï¼Œé£åŠ›å‘ç”µç‰¹æ€§è§¦å‘'
};
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦ä¸ºæ¥è§¦ç±»
 */
function isContactMove(move) {
    return hasMoveFlag(move, 'contact');
}
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å¯è¢«å®ˆä½
 */
function isProtectable(move) {
    return hasMoveFlag(move, 'protect');
}
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦ä¸ºå£°éŸ³ç±»
 */
function isSoundMove(move) {
    return hasMoveFlag(move, 'sound');
}
// ========== åœºåœ°é’‰å­ç³»ç»Ÿ (Entry Hazards) ==========
/**
 * å¤„ç†åœºåœ°çŠ¶æ€æŠ€èƒ½ (sideCondition)
 * åŒ…æ‹¬ï¼šéšå½¢å²©ã€æ’’è±ã€æ¯’è±ã€é»é»ç½‘ã€é¡ºé£ã€åŒå¢™ç­‰
 * @param {Pokemon} user ä½¿ç”¨è€…
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function applySideCondition(user, move, battle) {
    const logs = [];
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    if (!fullMoveData.sideCondition) return logs;
    const conditionId = fullMoveData.sideCondition;
    const target = fullMoveData.target || 'foeSide';
    // åˆ¤æ–­æ–½æ³•è€…æ˜¯å¦ä¸ºç©å®¶
    const isPlayerUser = battle && battle.getPlayer && (user === battle.getPlayer());
    // è·å–å—å½±å“çš„åœºåœ°ï¼ˆå®Œå…¨åŸºäº target å­—æ®µï¼Œæ— ç¡¬ç¼–ç ï¼‰
    let targetSide = null;
    let sideNameCN = "æˆ‘æ–¹";
    if (target === 'foeSide') {
        targetSide = isPlayerUser ? battle.enemySide : battle.playerSide;
        sideNameCN = isPlayerUser ? "æ•Œæ–¹" : "æˆ‘æ–¹";
    } else if (target === 'allySide' || target === 'self') {
        targetSide = isPlayerUser ? battle.playerSide : battle.enemySide;
        sideNameCN = isPlayerUser ? "æˆ‘æ–¹" : "æ•Œæ–¹";
    }
    if (!targetSide) return logs;
    // === åœºåœ°çŠ¶æ€é…ç½®ï¼ˆæ•°æ®é©±åŠ¨ï¼Œæ˜“äºæ‰©å±•ï¼‰ ===
    const SIDE_CONDITION_CONFIG = {
        // å¯å åŠ çš„é’‰å­
        'spikes': {
            type: 'stackable',
            maxLayers: 3,
            key: 'spikes',
            messages: {
                success: (layers) => `æ’’è±æ•£å¸ƒåœ¨${sideNameCN}åœºåœ°ä¸Š! (å½“å‰${layers}å±‚)`,
                failed: () => `ä½†æ˜¯æ²¡ä»€ä¹ˆæ•ˆæœ... (å·²ç»æ’’ä¸ä¸‹äº†)`
            }
        },
        'toxicspikes': {
            type: 'stackable',
            maxLayers: 2,
            key: 'toxicspikes',
            altKey: 'toxicSpikes', // æ”¯æŒé©¼å³°å‘½å
            messages: {
                success: () => `æ¯’è±æ•£å¸ƒåœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯æ²¡ä»€ä¹ˆæ•ˆæœ... (å·²ç»æ’’ä¸ä¸‹äº†)`
            }
        },
        // å¸ƒå°”å‹é’‰å­
        'stealthrock': {
            type: 'boolean',
            key: 'stealthRock',
            messages: {
                success: () => `å°–é”çš„å²©çŸ³æ‚¬æµ®åœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'stickyweb': {
            type: 'boolean',
            key: 'stickyWeb',
            messages: {
                success: () => `é»é»ç½‘é“ºè®¾åœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        // æœ‰æ—¶é™çš„åœºåœ°çŠ¶æ€
        'tailwind': {
            type: 'timed',
            duration: 4, // å®é™…æ˜¯5å›åˆï¼ˆè®¾ç½®åç«‹å³-1ï¼‰
            key: 'tailwind',
            messages: {
                success: () => `${sideNameCN}åˆ®èµ·äº†é¡ºé£!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'reflect': {
            type: 'timed',
            duration: 5,
            key: 'reflect',
            messages: {
                success: () => `${sideNameCN}ç«–èµ·äº†åå°„å£!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'lightscreen': {
            type: 'timed',
            duration: 5,
            key: 'lightScreen',
            messages: {
                success: () => `${sideNameCN}ç«–èµ·äº†å…‰å¢™!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'auroraveil': {
            type: 'timed',
            duration: 5,
            key: 'auroraVeil',
            messages: {
                success: () => `${sideNameCN}è¢«æå…‰å¹•åŒ…å›´äº†!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        }
    };
    const config = SIDE_CONDITION_CONFIG[conditionId];
    if (!config) {
        // æœªé…ç½®çš„ sideConditionï¼Œä½¿ç”¨é€šç”¨å¤„ç†
        console.warn(`[SIDE CONDITION] æœªé…ç½®çš„åœºåœ°çŠ¶æ€: ${conditionId}`);
        return logs;
    }
    // æ ¹æ®ç±»å‹å¤„ç†
    if (config.type === 'stackable') {
        // å¯å åŠ ç±»å‹
        const key = config.key;
        const altKey = config.altKey;
        if (!targetSide[key]) targetSide[key] = 0;
        if (altKey && !targetSide[altKey]) targetSide[altKey] = 0;
        const currentLayers = targetSide[key] || targetSide[altKey] || 0;
        if (currentLayers < config.maxLayers) {
            targetSide[key] = currentLayers + 1;
            if (altKey) targetSide[altKey] = currentLayers + 1;
            logs.push(config.messages.success(currentLayers + 1));
        } else {
            logs.push(config.messages.failed());
        }
    } else if (config.type === 'boolean') {
        // å¸ƒå°”ç±»å‹
        const key = config.key;
        if (!targetSide[key]) {
            targetSide[key] = true;
            logs.push(config.messages.success());
        } else {
            logs.push(config.messages.failed());
        }
    } else if (config.type === 'timed') {
        // æœ‰æ—¶é™ç±»å‹
        const key = config.key;
        if (!targetSide[key] || targetSide[key] <= 0) {
            targetSide[key] = config.duration;
            logs.push(config.messages.success());
        } else {
            logs.push(config.messages.failed());
        }
    }
    return logs;
}
/**
 * å®å¯æ¢¦ä¸Šåœºæ—¶ç»“ç®—åœºåœ°é’‰å­ä¼¤å®³
 * @param {Pokemon} pokemon ä¸Šåœºçš„å®å¯æ¢¦
 * @param {boolean} isPlayer æ˜¯å¦ä¸ºç©å®¶æ–¹
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function applyEntryHazards(pokemon, isPlayer, battle) {
    const logs = [];
    if (!pokemon || !battle) return logs;
    // è·å–å¯¹åº”çš„åœºåœ°çŠ¶æ€
    const side = isPlayer ? battle.playerSide : battle.enemySide;
    if (!side) return logs;
    const types = pokemon.types || [];
    const isFlying = types.includes('Flying');
    const hasLevitate = (pokemon.ability || '').toLowerCase() === 'levitate';
    const isGrounded = !isFlying && !hasLevitate;
    const isPoison = types.includes('Poison');
    const isSteel = types.includes('Steel');
    // === éšå½¢å²© (Stealth Rock) ===
    // å²©çŸ³ç³»ä¼¤å®³ï¼Œæ ¹æ®å±æ€§å…‹åˆ¶è®¡ç®—
    if (side.stealthRock) {
        let effectiveness = 1;
        const rockChart = { 
            weak: ['Fire', 'Ice', 'Flying', 'Bug'], 
            resist: ['Fighting', 'Ground', 'Steel'] 
        };
        for (const type of types) {
            if (rockChart.weak.includes(type)) effectiveness *= 2;
            if (rockChart.resist.includes(type)) effectiveness *= 0.5;
        }
        const damage = Math.max(1, Math.floor(pokemon.maxHp * effectiveness / 8));
        pokemon.takeDamage(damage);
        logs.push(`å°–é”çš„å²©çŸ³æ‰è¿›äº† ${pokemon.cnName}! (-${damage})`);
    }
    // === æ’’è± (Spikes) ===
    // åœ°é¢ç³»ä¼¤å®³ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    if (side.spikes && side.spikes > 0 && isGrounded) {
        const layers = side.spikes;
        const damagePercent = [0, 1/8, 1/6, 1/4][layers] || 1/4;
        const damage = Math.max(1, Math.floor(pokemon.maxHp * damagePercent));
        pokemon.takeDamage(damage);
        logs.push(`${pokemon.cnName} è¢«æ’’è±æ‰ä¼¤äº†! (-${damage})`);
    }
    // === æ¯’è± (Toxic Spikes) ===
    // æ¯’ç³»å®å¯æ¢¦è¸©ä¸Šå»ä¼šæ¸…é™¤ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    // æ³¨æ„ï¼šæ”¯æŒä¸¤ç§å‘½åæ ¼å¼ toxicspikes å’Œ toxicSpikes
    const toxicLayers = side.toxicspikes || side.toxicSpikes || 0;
    if (toxicLayers > 0 && isGrounded) {
        if (isPoison) {
            // æ¯’ç³»å®å¯æ¢¦æ¸…é™¤æ¯’è±
            side.toxicspikes = 0;
            side.toxicSpikes = 0;
            logs.push(`${pokemon.cnName} å¸æ”¶äº†æ¯’è±!`);
        } else if (!isSteel && !pokemon.status) {
            // é’¢ç³»å…ç–«ä¸­æ¯’
            if (toxicLayers >= 2) {
                pokemon.status = 'tox';
                logs.push(`${pokemon.cnName} ä¸­äº†å‰§æ¯’!`);
            } else {
                pokemon.status = 'psn';
                logs.push(`${pokemon.cnName} ä¸­æ¯’äº†!`);
            }
        }
    }
    // === é»é»ç½‘ (Sticky Web) ===
    // é€Ÿåº¦-1ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    if (side.stickyWeb && isGrounded) {
        if (typeof pokemon.applyBoost === 'function') {
            pokemon.applyBoost('spe', -1);
            logs.push(`${pokemon.cnName} è¢«é»é»ç½‘ç¼ ä½äº†! é€Ÿåº¦ä¸‹é™!`);
            if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
        }
    }
    return logs;
}
/**
 * æ¸…é™¤åœºåœ°é’‰å­ï¼ˆé«˜é€Ÿæ—‹è½¬ã€æ¸…é™¤æµ“é›¾ï¼‰
 * @param {boolean} isPlayer æ¸…é™¤å“ªä¸€æ–¹çš„åœºåœ°
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function clearEntryHazards(isPlayer, battle) {
    const logs = [];
    if (!battle) return logs;
    const side = isPlayer ? battle.playerSide : battle.enemySide;
    if (!side) return logs;
    let cleared = false;
    if (side.stealthRock) {
        side.stealthRock = false;
        cleared = true;
    }
    if (side.spikes) {
        side.spikes = 0;
        cleared = true;
    }
    if (side.toxicspikes) {
        side.toxicspikes = 0;
        cleared = true;
    }
    if (side.stickyWeb) {
        side.stickyWeb = false;
        cleared = true;
    }
    if (cleared) {
        logs.push(`åœºåœ°ä¸Šçš„éšœç¢ç‰©è¢«æ¸…é™¤äº†!`);
    }
    return logs;
}
// ========== Volatile çŠ¶æ€ç³»ç»Ÿ (Taunt, Substitute ç­‰) ==========
/**
 * å¤„ç† Volatile çŠ¶æ€æŠ€èƒ½
 * @param {Pokemon} user ä½¿ç”¨è€…
 * @param {Pokemon} target ç›®æ ‡
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {object} { success, logs }
 */
function applyVolatileStatus(user, target, move) {
    const logs = [];
    const moveName = move.name || '';
    // åˆå§‹åŒ– volatile å¯¹è±¡
    if (!target.volatile) target.volatile = {};
    if (!user.volatile) user.volatile = {};
    switch (moveName) {
        case 'Taunt':
            // æŒ‘è¡…ï¼š3å›åˆå†…æ— æ³•ä½¿ç”¨å˜åŒ–æŠ€
            if (target.volatile.taunt && target.volatile.taunt > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»å¤„äºæŒ‘è¡…çŠ¶æ€)`);
                return { success: false, logs };
            }
            target.volatile.taunt = 3;
            logs.push(`${target.cnName} é™·å…¥äº†æŒ‘è¡…çŠ¶æ€!`);
            return { success: true, logs };
        case 'Substitute':
            // æ›¿èº«ï¼šæ¶ˆè€— 1/4 HP ç”ŸæˆæŠ¤ç›¾
            const subHp = Math.floor(user.maxHp / 4);
            if (user.currHp <= subHp) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥åˆ¶é€ æ›¿èº«)`);
                return { success: false, logs };
            }
            if (user.volatile.substitute && user.volatile.substitute > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (å·²ç»æœ‰æ›¿èº«äº†)`);
                return { success: false, logs };
            }
            user.currHp -= subHp;
            user.volatile.substitute = subHp;
            logs.push(`${user.cnName} åˆ¶é€ äº†ä¸€ä¸ªæ›¿èº«! (æ¶ˆè€— ${subHp} HP)`);
            return { success: true, logs };
        case 'Encore':
            // å†æ¥ä¸€æ¬¡ï¼šå¼ºåˆ¶ä½¿ç”¨ä¸Šä¸€ä¸ªæŠ€èƒ½
            if (!target.lastMoveUsed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.encore = 3;
            target.volatile.encoreMove = target.lastMoveUsed;
            logs.push(`${target.cnName} è¢«å¼ºåˆ¶å†æ¥ä¸€æ¬¡!`);
            return { success: true, logs };
        case 'Disable':
            // å®šèº«æ³•ï¼šå°å°ä¸Šä¸€ä¸ªæŠ€èƒ½
            if (!target.lastMoveUsed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.disable = 4;
            target.volatile.disabledMove = target.lastMoveUsed;
            logs.push(`${target.cnName} çš„ ${target.lastMoveUsed} è¢«å°å°äº†!`);
            return { success: true, logs };
        case 'Torment':
            // æ— ç†å–é—¹ï¼šæ— æ³•è¿ç»­ä½¿ç”¨åŒä¸€æŠ€èƒ½
            target.volatile.torment = true;
            logs.push(`${target.cnName} é™·å…¥äº†æ— ç†å–é—¹çŠ¶æ€!`);
            return { success: true, logs };
        case 'Heal Block':
            // å›å¤å°é”
            target.volatile.healBlock = 5;
            logs.push(`${target.cnName} è¢«å°é”äº†å›å¤!`);
            return { success: true, logs };
        // ===================== æŒç»­ä¼¤å®³/å¹²æ‰°ç±» =====================
        case 'Leech Seed':
            // å¯„ç”Ÿç§å­ï¼šæ¯å›åˆå¸å– 1/8 HP
            if (target.types && target.types.includes('Grass')) {
                logs.push(`å¯¹è‰å±æ€§å®å¯æ¢¦æ— æ•ˆ!`);
                return { success: false, logs };
            }
            if (target.volatile.leechseed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»è¢«ç§ä¸‹ç§å­äº†)`);
                return { success: false, logs };
            }
            target.volatile.leechseed = true;
            logs.push(`å¯„ç”Ÿç§å­ç§åœ¨äº† ${target.cnName} èº«ä¸Š!`);
            return { success: true, logs };
        case 'Curse':
            // è¯…å’’ï¼šåŒºåˆ†å¹½çµç³»å’Œéå¹½çµç³»
            if (user.types && user.types.includes('Ghost')) {
                // å¹½çµç³»ï¼šæ‰£ 50% HPï¼Œå¯¹æ–¹æ¯å›åˆæ‰ 1/4
                const curseCost = Math.floor(user.maxHp / 2);
                if (user.currHp <= curseCost) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥æ–½å±•è¯…å’’)`);
                    return { success: false, logs };
                }
                user.currHp -= curseCost;
                target.volatile.curse = true;
                logs.push(`${user.cnName} å‰Šå‡äº†è‡ªå·±çš„ä½“åŠ›ï¼Œå¯¹ ${target.cnName} æ–½åŠ äº†è¯…å’’!`);
                return { success: true, logs };
            } else {
                // éå¹½çµç³»ï¼šé€Ÿåº¦-1ï¼Œæ”»é˜²+1ï¼ˆç”± boosts å¤„ç†ï¼Œè¿™é‡Œåªè¿”å›æˆåŠŸï¼‰
                return { success: false, logs }; // è®©é»˜è®¤çš„ boosts å¤„ç†
            }
        case 'Yawn':
            // å“ˆæ¬ ï¼šä¸‹å›åˆç»“æŸæ—¶ç¡ç€
            if (target.status) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»æœ‰å¼‚å¸¸çŠ¶æ€äº†)`);
                return { success: false, logs };
            }
            if (target.volatile.yawn) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.yawn = 2; // 2å›åˆåç¡ç€
            logs.push(`${target.cnName} æ‰“äº†ä¸ªå“ˆæ¬ ...`);
            return { success: true, logs };
        case 'Perish Song':
            // ç­äº¡ä¹‹æ­Œï¼š3å›åˆååŒæ–¹å€’ä¸‹
            if (user.volatile.perishsong || target.volatile.perishsong) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            user.volatile.perishsong = 3;
            target.volatile.perishsong = 3;
            logs.push(`æ‰€æœ‰å¬åˆ°æ­Œå£°çš„å®å¯æ¢¦å°†åœ¨ 3 å›åˆåå€’ä¸‹!`);
            return { success: true, logs };
        case 'Destiny Bond':
            // åŒå‘½ï¼šå¦‚æœè‡ªå·±å€’ä¸‹ï¼Œå¯¹æ–¹ä¹Ÿå€’ä¸‹
            user.volatile.destinybond = true;
            logs.push(`${user.cnName} æƒ³è¦å’Œå¯¹æ‰‹åŒå½’äºå°½!`);
            return { success: true, logs };
        // ===================== æŸç¼šç±» =====================
        case 'Bind':
        case 'Wrap':
        case 'Fire Spin':
        case 'Clamp':
        case 'Whirlpool':
        case 'Sand Tomb':
        case 'Magma Storm':
        case 'Infestation':
        case 'Snap Trap':
            // æŸç¼šï¼šæ¯å›åˆæ‰£ 1/8 HPï¼ŒæŒç»­ 4-5 å›åˆ
            if (target.volatile.partiallytrapped) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»è¢«æŸç¼šäº†)`);
                return { success: false, logs };
            }
            target.volatile.partiallytrapped = 4 + Math.floor(Math.random() * 2); // 4-5 å›åˆ
            logs.push(`${target.cnName} è¢« ${moveName} æŸç¼šä½äº†!`);
            return { success: true, logs };
        // ===================== æ··ä¹±ç±» =====================
        case 'Confuse Ray':
        case 'Supersonic':
        case 'Sweet Kiss':
        case 'Teeter Dance':
        case 'Flatter':
        case 'Swagger':
            // æ··ä¹±
            if (target.volatile.confusion) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»æ··ä¹±äº†)`);
                return { success: false, logs };
            }
            target.volatile.confusion = 2 + Math.floor(Math.random() * 4); // 2-5 å›åˆ
            logs.push(`${target.cnName} æ··ä¹±äº†!`);
            return { success: true, logs };
        // ===================== æ¥åŠ›ç±» =====================
        case 'Shed Tail':
            // æ–­å°¾ï¼šæ¶ˆè€— 50% HP åˆ¶é€ æ›¿èº«å¹¶æ¢äºº
            const shedCost = Math.ceil(user.maxHp / 2);
            if (user.currHp <= shedCost) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥æ–­å°¾)`);
                return { success: false, logs };
            }
            user.currHp -= shedCost;
            // åˆ¶é€ ä¸€ä¸ª 1/4 HP çš„æ›¿èº«ç»™ä¸‹ä¸€åª
            user.volatile.shedTailSub = Math.floor(user.maxHp / 4);
            logs.push(`${user.cnName} åˆ¶é€ äº†ä¸€ä¸ªæ›¿èº«å¹¶å‡†å¤‡æ’¤é€€!`);
            return { success: true, logs, pivot: true, passSub: true };
        // ===================== å…¶ä»–å¸¸ç”¨çŠ¶æ€æŠ€ =====================
        case 'Attract':
            // ç€è¿·
            if (target.volatile.attract) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.attract = true;
            logs.push(`${target.cnName} ç€è¿·äº†!`);
            return { success: true, logs };
        case 'Focus Energy':
            // èšæ°”ï¼šæš´å‡»ç‡ +2
            user.volatile.focusenergy = true;
            logs.push(`${user.cnName} æ·±å‘¼å¸ï¼Œé›†ä¸­ç²¾ç¥!`);
            return { success: true, logs };
        case 'Imprison':
            // å°å°ï¼šå¯¹æ‰‹ä¸èƒ½ä½¿ç”¨ä¸è‡ªå·±ç›¸åŒçš„æ‹›å¼
            user.volatile.imprison = true;
            logs.push(`${user.cnName} å°å°äº†å¯¹æ‰‹çš„æ‹›å¼!`);
            return { success: true, logs };
        case 'Embargo':
            // æŸ¥å°ï¼šæ— æ³•ä½¿ç”¨é“å…·
            target.volatile.embargo = 5;
            logs.push(`${target.cnName} æ— æ³•ä½¿ç”¨é“å…·äº†!`);
            return { success: true, logs };
        case 'Aqua Ring':
            // æ°´æµç¯ï¼šæ¯å›åˆå›å¤ 1/16 HP
            user.volatile.aquaring = true;
            logs.push(`${user.cnName} ç”¨æ°´æµç¯åŒ…è£¹ä½äº†è‡ªå·±!`);
            return { success: true, logs };
        case 'Ingrain':
            // æ‰æ ¹ï¼šæ¯å›åˆå›å¤ 1/16 HPï¼Œæ— æ³•æ¢äºº
            user.volatile.ingrain = true;
            logs.push(`${user.cnName} æ‰ä¸‹äº†æ ¹!`);
            return { success: true, logs };
        default:
            return { success: false, logs };
    }
}
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥ä½¿ç”¨æŒ‡å®šæŠ€èƒ½
 * @param {Pokemon} pokemon 
 * @param {object} move 
 * @returns {object} { canUse, reason }
 */
function canUseMove(pokemon, move) {
    if (!pokemon.volatile) return { canUse: true, reason: null };
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    const category = fullMoveData.category || move.category || move.cat || 'Physical';
    // æŒ‘è¡…æ£€æŸ¥ï¼šæ— æ³•ä½¿ç”¨å˜åŒ–æŠ€
    if (pokemon.volatile.taunt && pokemon.volatile.taunt > 0) {
        if (category === 'Status' || category === 'status') {
            return { canUse: false, reason: `${pokemon.cnName} è¢«æŒ‘è¡…äº†ï¼Œæ— æ³•ä½¿ç”¨å˜åŒ–æŠ€!` };
        }
    }
    // å®šèº«æ³•æ£€æŸ¥
    if (pokemon.volatile.disable && pokemon.volatile.disable > 0) {
        if (pokemon.volatile.disabledMove === move.name) {
            return { canUse: false, reason: `${move.name} è¢«å°å°äº†!` };
        }
    }
    // å†æ¥ä¸€æ¬¡æ£€æŸ¥
    if (pokemon.volatile.encore && pokemon.volatile.encore > 0) {
        if (pokemon.volatile.encoreMove && move.name !== pokemon.volatile.encoreMove) {
            return { canUse: false, reason: `è¢«å¼ºåˆ¶ä½¿ç”¨ ${pokemon.volatile.encoreMove}!` };
        }
    }
    // æ— ç†å–é—¹æ£€æŸ¥
    if (pokemon.volatile.torment && pokemon.lastMoveUsed === move.name) {
        return { canUse: false, reason: `${pokemon.cnName} æ— æ³•è¿ç»­ä½¿ç”¨åŒä¸€æŠ€èƒ½!` };
    }
    // å°å°æ£€æŸ¥ (Imprison)ï¼šå¯¹æ‰‹ä¸èƒ½ä½¿ç”¨ä¸è‡ªå·±ç›¸åŒçš„æ‹›å¼
    // æ³¨æ„ï¼šè¿™éœ€è¦åœ¨æˆ˜æ–—ä¸­æ£€æŸ¥å¯¹æ‰‹çš„æ‹›å¼ï¼Œè¿™é‡Œåªåšæ ‡è®°æ£€æŸ¥
    if (pokemon.volatile.imprisonBlocked && pokemon.volatile.imprisonBlocked.includes(move.name)) {
        return { canUse: false, reason: `${move.name} è¢«å°å°äº†!` };
    }
    return { canUse: true, reason: null };
}
/**
 * æ£€æŸ¥æ··ä¹±çŠ¶æ€æ˜¯å¦å¯¼è‡´è‡ªä¼¤
 * @param {Pokemon} pokemon 
 * @returns {object} { confused, selfHit, damage, logs }
 */
function checkConfusion(pokemon) {
    const logs = [];
    if (!pokemon.volatile || !pokemon.volatile.confusion || pokemon.volatile.confusion <= 0) {
        return { confused: false, selfHit: false, damage: 0, logs };
    }
    logs.push(`${pokemon.cnName} æ­£å¤„äºæ··ä¹±ä¸­!`);
    // 33% æ¦‚ç‡è‡ªä¼¤
    if (Math.random() < 0.33) {
        // è‡ªä¼¤ä¼¤å®³ï¼š40 å¨åŠ›ç‰©ç†æ”»å‡»
        const selfDamage = Math.max(1, Math.floor(pokemon.atk * 40 / pokemon.def / 50 * 2));
        pokemon.currHp = Math.max(0, pokemon.currHp - selfDamage);
        logs.push(`${pokemon.cnName} åœ¨æ··ä¹±ä¸­æ”»å‡»äº†è‡ªå·±! (-${selfDamage})`);
        return { confused: true, selfHit: true, damage: selfDamage, logs };
    }
    return { confused: true, selfHit: false, damage: 0, logs };
}
/**
 * æ£€æŸ¥ç€è¿·çŠ¶æ€æ˜¯å¦é˜»æ­¢è¡ŒåŠ¨
 * @param {Pokemon} pokemon 
 * @returns {object} { attracted, immobilized, logs }
 */
function checkAttract(pokemon) {
    const logs = [];
    if (!pokemon.volatile || !pokemon.volatile.attract) {
        return { attracted: false, immobilized: false, logs };
    }
    logs.push(`${pokemon.cnName} å¯¹å¯¹æ‰‹ç€è¿·äº†!`);
    // 50% æ¦‚ç‡æ— æ³•è¡ŒåŠ¨
    if (Math.random() < 0.5) {
        logs.push(`${pokemon.cnName} å› ä¸ºç€è¿·è€Œæ— æ³•è¡ŒåŠ¨!`);
        return { attracted: true, immobilized: true, logs };
    }
    return { attracted: true, immobilized: false, logs };
}
/**
 * æ£€æŸ¥æ›¿èº«æ˜¯å¦å¸æ”¶ä¼¤å®³
 * @param {Pokemon} defender é˜²å¾¡æ–¹
 * @param {number} damage åŸå§‹ä¼¤å®³
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {object} { absorbed, remainingDamage, logs }
 */
function checkSubstitute(defender, damage, move) {
    const logs = [];
    if (!defender.volatile || !defender.volatile.substitute || defender.volatile.substitute <= 0) {
        return { absorbed: false, remainingDamage: damage, logs };
    }
    // å£°éŸ³ç±»æŠ€èƒ½ç©¿é€æ›¿èº«
    if (isSoundMove(move)) {
        return { absorbed: false, remainingDamage: damage, logs };
    }
    const subHp = defender.volatile.substitute;
    if (damage >= subHp) {
        // æ›¿èº«è¢«æ‰“ç ´
        defender.volatile.substitute = 0;
        logs.push(`${defender.cnName} çš„æ›¿èº«æ¶ˆå¤±äº†!`);
        // å‰©ä½™ä¼¤å®³ä¸ä¼ é€’ç»™æœ¬ä½“ï¼ˆæ›¿èº«å¸æ”¶æ‰€æœ‰ä¼¤å®³ï¼‰
        return { absorbed: true, remainingDamage: 0, logs };
    } else {
        // æ›¿èº«å¸æ”¶ä¼¤å®³
        defender.volatile.substitute -= damage;
        logs.push(`æ›¿èº«ä»£æ›¿ ${defender.cnName} æ‰¿å—äº†ä¼¤å®³! (æ›¿èº«å‰©ä½™: ${defender.volatile.substitute})`);
        return { absorbed: true, remainingDamage: 0, logs };
    }
}
/**
 * å›åˆç»“æŸæ—¶é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨
 * @param {Pokemon} pokemon 
 * @param {Pokemon} opponent - å¯¹æ‰‹ï¼ˆç”¨äºç­äº¡ä¹‹æ­Œç­‰ï¼‰
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯
 */
function tickVolatileStatus(pokemon, opponent = null) {
    const logs = [];
    if (!pokemon.volatile) return logs;
    // æŒ‘è¡…
    if (pokemon.volatile.taunt && pokemon.volatile.taunt > 0) {
        pokemon.volatile.taunt--;
        if (pokemon.volatile.taunt === 0) {
            logs.push(`${pokemon.cnName} çš„æŒ‘è¡…çŠ¶æ€è§£é™¤äº†!`);
        }
    }
    // å®šèº«æ³•
    if (pokemon.volatile.disable && pokemon.volatile.disable > 0) {
        pokemon.volatile.disable--;
        if (pokemon.volatile.disable === 0) {
            pokemon.volatile.disabledMove = null;
            logs.push(`${pokemon.cnName} çš„æŠ€èƒ½å°å°è§£é™¤äº†!`);
        }
    }
    // å†æ¥ä¸€æ¬¡
    if (pokemon.volatile.encore && pokemon.volatile.encore > 0) {
        pokemon.volatile.encore--;
        if (pokemon.volatile.encore === 0) {
            pokemon.volatile.encoreMove = null;
            logs.push(`${pokemon.cnName} çš„å†æ¥ä¸€æ¬¡çŠ¶æ€è§£é™¤äº†!`);
        }
    }
    // å›å¤å°é”
    if (pokemon.volatile.healBlock && pokemon.volatile.healBlock > 0) {
        pokemon.volatile.healBlock--;
        if (pokemon.volatile.healBlock === 0) {
            logs.push(`${pokemon.cnName} çš„å›å¤å°é”è§£é™¤äº†!`);
        }
    }
    // å“ˆæ¬  -> ç¡çœ 
    if (pokemon.volatile.yawn && pokemon.volatile.yawn > 0) {
        pokemon.volatile.yawn--;
        if (pokemon.volatile.yawn === 0) {
            if (!pokemon.status) {
                pokemon.status = 'slp';
                pokemon.sleepTurns = 0;
                logs.push(`${pokemon.cnName} ç¡ç€äº†!`);
            }
            delete pokemon.volatile.yawn;
        }
    }
    // ç­äº¡ä¹‹æ­Œ
    if (pokemon.volatile.perishsong && pokemon.volatile.perishsong > 0) {
        pokemon.volatile.perishsong--;
        logs.push(`${pokemon.cnName} çš„ç­äº¡å€’è®¡æ—¶: ${pokemon.volatile.perishsong}!`);
        if (pokemon.volatile.perishsong === 0) {
            pokemon.currHp = 0;
            logs.push(`${pokemon.cnName} å› ç­äº¡ä¹‹æ­Œå€’ä¸‹äº†!`);
        }
    }
    // æ··ä¹±
    if (pokemon.volatile.confusion && pokemon.volatile.confusion > 0) {
        pokemon.volatile.confusion--;
        if (pokemon.volatile.confusion === 0) {
            logs.push(`${pokemon.cnName} çš„æ··ä¹±è§£é™¤äº†!`);
        }
    }
    // æŸç¼š
    if (pokemon.volatile.partiallytrapped && typeof pokemon.volatile.partiallytrapped === 'number') {
        pokemon.volatile.partiallytrapped--;
        if (pokemon.volatile.partiallytrapped === 0) {
            delete pokemon.volatile.partiallytrapped;
            logs.push(`${pokemon.cnName} ä»æŸç¼šä¸­è§£è„±äº†!`);
        }
    }
    // æŸ¥å°
    if (pokemon.volatile.embargo && pokemon.volatile.embargo > 0) {
        pokemon.volatile.embargo--;
        if (pokemon.volatile.embargo === 0) {
            logs.push(`${pokemon.cnName} å¯ä»¥ä½¿ç”¨é“å…·äº†!`);
        }
    }
    // åŒå‘½ï¼ˆæ¯å›åˆé‡ç½®ï¼‰
    if (pokemon.volatile.destinybond) {
        delete pokemon.volatile.destinybond;
    }
    return logs;
}
// ========== å¯¼å‡º ==========
window.MoveEffects = {
    // ä¼˜å…ˆçº§
    getMovePriority,
    compareActionOrder,
    // çŠ¶æ€å¼‚å¸¸
    STATUS_CONDITIONS,
    tryInflictStatus,
    processStatusEffects,
    processStatusDamage,
    processMoveStatusEffects,
    // ç‰¹æ®Šä¼¤å®³
    checkFixedDamageMove,
    checkOHKOMove,
    // å¤©æ°”/åœºåœ°
    WEATHER_TYPES,
    TERRAIN_TYPES,
    getWeatherModifier,
    getTerrainModifier,
    // æŠ€èƒ½æ ‡è®°
    MOVE_FLAGS,
    hasMoveFlag,
    isContactMove,
    isProtectable,
    isSoundMove,
    // åœºåœ°é’‰å­
    applySideCondition,
    applyEntryHazards,
    clearEntryHazards,
    // Volatile çŠ¶æ€ (Taunt, Substitute ç­‰)
    applyVolatileStatus,
    canUseMove,
    checkConfusion,
    checkAttract,
    checkSubstitute,
    tickVolatileStatus
};
console.log('[PKM] MoveEffects æ¨¡å—å·²åŠ è½½');
]]></file>
        <file name="move-handlers.js"><![CDATA[/**
 * =============================================
 * MOVE HANDLERS - æŠ€èƒ½å¤„ç†å™¨ (ç­–ç•¥æ¨¡å¼)
 * =============================================
 * 
 * æœ¬æ–‡ä»¶ä½¿ç”¨ç­–ç•¥æ¨¡å¼å¤„ç†ç‰¹æ®ŠæŠ€èƒ½é€»è¾‘ï¼Œ
 * é¿å…åœ¨ battle-engine.js ä¸­å †ç§¯å¤§é‡ if-elseã€‚
 * 
 * æ¯ä¸ªæŠ€èƒ½å¯ä»¥æ³¨å†Œä»¥ä¸‹é’©å­ï¼š
 * - basePowerCallback: åŠ¨æ€è®¡ç®—å¨åŠ›
 * - damageCallback: å®Œå…¨è‡ªå®šä¹‰ä¼¤å®³è®¡ç®—
 * - onHit: å‘½ä¸­åçš„é¢å¤–æ•ˆæœ
 * - onMiss: æœªå‘½ä¸­æ—¶çš„æ•ˆæœ
 * - onUse: ä½¿ç”¨æ—¶çš„æ•ˆæœï¼ˆè“„åŠ›ç­‰ï¼‰
 * - modifyAtk: ä¿®æ”¹æ”»å‡»åŠ›è®¡ç®—
 * - modifyDef: ä¿®æ”¹é˜²å¾¡åŠ›è®¡ç®—
 */
const MoveHandlers = {
    // ============================================
    // 1. å›ºå®šä¼¤å®³æŠ€èƒ½ (Fixed Damage Moves)
    // ============================================
    'Night Shade': {
        damageCallback: (attacker, defender) => {
            return attacker.level;
        },
        description: 'é€ æˆç­‰äºä½¿ç”¨è€…ç­‰çº§çš„å›ºå®šä¼¤å®³'
    },
    'Seismic Toss': {
        damageCallback: (attacker, defender) => {
            return attacker.level;
        },
        description: 'é€ æˆç­‰äºä½¿ç”¨è€…ç­‰çº§çš„å›ºå®šä¼¤å®³'
    },
    'Psywave': {
        damageCallback: (attacker, defender) => {
            // ä¼¤å®³ = ç­‰çº§ Ã— (0.5 ~ 1.5) éšæœº
            const multiplier = 0.5 + Math.random();
            return Math.floor(attacker.level * multiplier);
        },
        description: 'é€ æˆç­‰çº§ç›¸å…³çš„éšæœºä¼¤å®³'
    },
    'Dragon Rage': {
        damageCallback: (attacker, defender) => {
            return 40; // å›ºå®š 40 ç‚¹ä¼¤å®³
        },
        description: 'å›ºå®šé€ æˆ 40 ç‚¹ä¼¤å®³'
    },
    'Sonic Boom': {
        damageCallback: (attacker, defender) => {
            return 20; // å›ºå®š 20 ç‚¹ä¼¤å®³
        },
        description: 'å›ºå®šé€ æˆ 20 ç‚¹ä¼¤å®³'
    },
    'Super Fang': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp / 2));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP ä¸€åŠçš„ä¼¤å®³'
    },
    'Nature\'s Madness': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp / 2));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP ä¸€åŠçš„ä¼¤å®³'
    },
    'Guardian of Alola': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp * 0.75));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP 75% çš„ä¼¤å®³'
    },
    // ============================================
    // 2. åŠ¨æ€å¨åŠ›æŠ€èƒ½ (Dynamic Power Moves)
    // ============================================
    'Gyro Ball': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 25 Ã— (ç›®æ ‡é€Ÿåº¦ / è‡ªå·±é€Ÿåº¦) + 1ï¼Œæœ€é«˜ 150
            const userSpeed = Math.max(1, attacker.getStat('spe'));
            const targetSpeed = Math.max(1, defender.getStat('spe'));
            const power = Math.floor(25 * targetSpeed / userSpeed) + 1;
            return Math.min(150, power);
        },
        description: 'é€Ÿåº¦è¶Šæ…¢å¨åŠ›è¶Šé«˜'
    },
    'Electro Ball': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ›æ ¹æ®é€Ÿåº¦æ¯”å€¼
            const userSpeed = Math.max(1, attacker.getStat('spe'));
            const targetSpeed = Math.max(1, defender.getStat('spe'));
            const ratio = userSpeed / targetSpeed;
            if (ratio >= 4) return 150;
            if (ratio >= 3) return 120;
            if (ratio >= 2) return 80;
            if (ratio >= 1) return 60;
            return 40;
        },
        description: 'é€Ÿåº¦è¶Šå¿«å¨åŠ›è¶Šé«˜'
    },
    'Grass Knot': {
        basePowerCallback: (attacker, defender) => {
            // æ ¹æ®ç›®æ ‡ä½“é‡ï¼ˆç®€åŒ–ï¼šç”¨ HP åŸºç¡€å€¼æ¨¡æ‹Ÿï¼‰
            const weight = defender.maxHp; // ç®€åŒ–å¤„ç†
            if (weight >= 200) return 120;
            if (weight >= 150) return 100;
            if (weight >= 100) return 80;
            if (weight >= 50) return 60;
            if (weight >= 25) return 40;
            return 20;
        },
        description: 'ç›®æ ‡è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Low Kick': {
        basePowerCallback: (attacker, defender) => {
            const weight = defender.maxHp;
            if (weight >= 200) return 120;
            if (weight >= 150) return 100;
            if (weight >= 100) return 80;
            if (weight >= 50) return 60;
            if (weight >= 25) return 40;
            return 20;
        },
        description: 'ç›®æ ‡è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Heavy Slam': {
        basePowerCallback: (attacker, defender) => {
            // æ ¹æ®ä½“é‡æ¯”
            const userWeight = attacker.maxHp;
            const targetWeight = Math.max(1, defender.maxHp);
            const ratio = userWeight / targetWeight;
            if (ratio >= 5) return 120;
            if (ratio >= 4) return 100;
            if (ratio >= 3) return 80;
            if (ratio >= 2) return 60;
            return 40;
        },
        description: 'è‡ªå·±è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Heat Crash': {
        basePowerCallback: (attacker, defender) => {
            const userWeight = attacker.maxHp;
            const targetWeight = Math.max(1, defender.maxHp);
            const ratio = userWeight / targetWeight;
            if (ratio >= 5) return 120;
            if (ratio >= 4) return 100;
            if (ratio >= 3) return 80;
            if (ratio >= 2) return 60;
            return 40;
        },
        description: 'è‡ªå·±è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Stored Power': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 20 + 20 Ã— èƒ½åŠ›æå‡æ€»ç­‰çº§
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (attacker.boosts[stat] > 0) {
                    totalBoosts += attacker.boosts[stat];
                }
            }
            return 20 + 20 * totalBoosts;
        },
        description: 'èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Power Trip': {
        basePowerCallback: (attacker, defender) => {
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (attacker.boosts[stat] > 0) {
                    totalBoosts += attacker.boosts[stat];
                }
            }
            return 20 + 20 * totalBoosts;
        },
        description: 'èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Punishment': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 60 + 20 Ã— ç›®æ ‡èƒ½åŠ›æå‡æ€»ç­‰çº§ï¼Œæœ€é«˜ 200
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (defender.boosts[stat] > 0) {
                    totalBoosts += defender.boosts[stat];
                }
            }
            return Math.min(200, 60 + 20 * totalBoosts);
        },
        description: 'ç›®æ ‡èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Reversal': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ›æ ¹æ®å‰©ä½™ HP ç™¾åˆ†æ¯”
            const hpPercent = attacker.currHp / attacker.maxHp;
            if (hpPercent <= 0.0417) return 200;
            if (hpPercent <= 0.1042) return 150;
            if (hpPercent <= 0.2083) return 100;
            if (hpPercent <= 0.3542) return 80;
            if (hpPercent <= 0.6875) return 40;
            return 20;
        },
        description: 'HP è¶Šä½å¨åŠ›è¶Šé«˜'
    },
    'Flail': {
        basePowerCallback: (attacker, defender) => {
            const hpPercent = attacker.currHp / attacker.maxHp;
            if (hpPercent <= 0.0417) return 200;
            if (hpPercent <= 0.1042) return 150;
            if (hpPercent <= 0.2083) return 100;
            if (hpPercent <= 0.3542) return 80;
            if (hpPercent <= 0.6875) return 40;
            return 20;
        },
        description: 'HP è¶Šä½å¨åŠ›è¶Šé«˜'
    },
    'Eruption': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 150 Ã— (å½“å‰HP / æœ€å¤§HP)
            return Math.max(1, Math.floor(150 * attacker.currHp / attacker.maxHp));
        },
        description: 'HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Water Spout': {
        basePowerCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(150 * attacker.currHp / attacker.maxHp));
        },
        description: 'HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Crush Grip': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 120 Ã— (ç›®æ ‡å½“å‰HP / ç›®æ ‡æœ€å¤§HP)
            return Math.max(1, Math.floor(120 * defender.currHp / defender.maxHp));
        },
        description: 'ç›®æ ‡ HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Wring Out': {
        basePowerCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(120 * defender.currHp / defender.maxHp));
        },
        description: 'ç›®æ ‡ HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    // ============================================
    // 3. ç‰¹æ®Šæ”»é˜²è®¡ç®— (Modified Stat Moves)
    // ============================================
    'Foul Play': {
        modifyAtk: (attacker, defender, isSpecial) => {
            // ä½¿ç”¨ç›®æ ‡çš„æ”»å‡»åŠ›
            return defender.getStat('atk');
        },
        description: 'ä½¿ç”¨ç›®æ ‡çš„æ”»å‡»åŠ›è®¡ç®—ä¼¤å®³'
    },
    'Body Press': {
        modifyAtk: (attacker, defender, isSpecial) => {
            // ä½¿ç”¨è‡ªå·±çš„é˜²å¾¡åŠ›ä»£æ›¿æ”»å‡»åŠ›
            return attacker.getStat('def');
        },
        description: 'ä½¿ç”¨è‡ªå·±çš„é˜²å¾¡åŠ›è®¡ç®—ä¼¤å®³'
    },
    'Psyshock': {
        modifyDef: (attacker, defender, isSpecial) => {
            // ç‰¹æ®Šæ”»å‡»ä½†æ‰“ç‰©é˜²
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    'Psystrike': {
        modifyDef: (attacker, defender, isSpecial) => {
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    'Secret Sword': {
        modifyDef: (attacker, defender, isSpecial) => {
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    // ============================================
    // 4. æ¢äººæŠ€èƒ½ (Pivot Moves) - ä»…æ—¥å¿—è¾“å‡º
    // ============================================
    'U-turn': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äººï¼ˆå…ç–«/æœªå‘½ä¸­ä¸è§¦å‘ï¼‰
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Volt Switch': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äººï¼ˆåœ°é¢ç³»å…ç–«ç”µç³»ï¼‰
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Flip Turn': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äºº
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Parting Shot': {
        onHit: (attacker, defender, damage, logs) => {
            // Parting Shot æ˜¯å˜åŒ–æŠ€ï¼Œåªè¦æˆåŠŸä½¿ç”¨å°±è§¦å‘ï¼ˆé™¤éè¢«æŒ‘è¡…ç­‰é˜»æ­¢ï¼‰
            logs.push(`${attacker.cnName} ç•™ä¸‹ç‹ è¯åæ’¤é€€äº†!`);
            return { pivot: true };
        },
        description: 'é™ä½å¯¹æ‰‹èƒ½åŠ›åæ¢äºº'
    },
    'Fake Out': {
        onUse: (attacker, defender, logs) => {
            // å…³é”®ä¿®å¤ï¼šFake Out åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[Fake Out] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            // 100% ç•ç¼©æ•ˆæœ
            if (damage > 0 && defender.volatile) {
                defender.volatile.flinch = true;
                logs.push(`${defender.cnName} ç•ç¼©äº†!`);
            }
            return {};
        },
        description: 'å…ˆåˆ¶æŠ€ï¼Œä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆï¼Œ100%ç•ç¼©'
    },
    'First Impression': {
        onUse: (attacker, defender, logs) => {
            // First Impression åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[First Impression] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            return {};
        },
        description: 'è™«ç³»å…ˆåˆ¶å¤§æ‹›ï¼Œä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆ'
    },
    'Mat Block': {
        onUse: (attacker, defender, logs) => {
            // Mat Block åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[Mat Block] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            logs.push(`${attacker.cnName} æ€èµ·äº†æ¦»æ¦»ç±³è¿›è¡Œé˜²å¾¡!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'ä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆï¼Œé˜²å¾¡ç‰©ç†å’Œç‰¹æ®Šæ”»å‡»'
    },
    // ============================================
    // å®ˆä½ç±»æŠ€èƒ½ (Protect Family) - è¿ç»­ä½¿ç”¨æƒ©ç½š
    // ============================================
    'Protect': {
        onUse: (attacker, defender, logs) => {
            // è¿ç»­ä½¿ç”¨æˆåŠŸç‡è¡°å‡ï¼š1 -> 1/3 -> 1/9 -> ...
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è¿ç»­ä½¿ç”¨å®ˆä½æˆåŠŸç‡é™ä½)`);
                    return { failed: true };
                }
            }
            // æˆåŠŸä½¿ç”¨
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} å®ˆä½äº†è‡ªå·±!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'å®ˆä½æ‰€æœ‰æ”»å‡»ï¼Œè¿ç»­ä½¿ç”¨æˆåŠŸç‡é™ä½'
    },
    'Detect': {
        onUse: (attacker, defender, logs) => {
            // ä¸ Protect å…±äº«è®¡æ•°å™¨
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è¿ç»­ä½¿ç”¨è§åˆ‡æˆåŠŸç‡é™ä½)`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†è§åˆ‡!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'ä¸å®ˆä½æ•ˆæœç›¸åŒï¼Œå…±äº«è¿ç»­ä½¿ç”¨è®¡æ•°å™¨'
    },
    'King\'s Shield': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†ç‹è€…ç›¾ç‰Œ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.kingsShield = true; // æ¥è§¦æ”»å‡»é™æ”»
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„æ”»å‡»'
    },
    'Spiky Shield': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†å°–åˆºé˜²å®ˆ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.spikyShield = true; // æ¥è§¦æ”»å‡»åä¼¤
            }
            return {};
        },
        description: 'å®ˆä½å¹¶å¯¹æ¥è§¦æ”»å‡»è€…é€ æˆä¼¤å®³'
    },
    'Baneful Bunker': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} èº²è¿›äº†ç¢‰å ¡!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.banefulBunker = true; // æ¥è§¦æ”»å‡»ä¸­æ¯’
            }
            return {};
        },
        description: 'å®ˆä½å¹¶ä½¿æ¥è§¦æ”»å‡»è€…ä¸­æ¯’'
    },
    'Obstruct': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†æ‹¦å µ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.obstruct = true; // æ¥è§¦æ”»å‡»é™é˜²
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„é˜²å¾¡'
    },
    'Silk Trap': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†çº¿é˜±!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.silkTrap = true; // æ¥è§¦æ”»å‡»é™é€Ÿ
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„é€Ÿåº¦'
    },
    'Endure': {
        onUse: (attacker, defender, logs) => {
            // æŒºä½ï¼šä¸å®ˆä½å…±äº«è®¡æ•°å™¨
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} æ‘†å‡ºäº†æŒºä½çš„æ¶åŠ¿!`);
            if (attacker.volatile) attacker.volatile.endure = true;
            return {};
        },
        description: 'æœ¬å›åˆè‡³å°‘ä¿ç•™1HPï¼Œä¸å®ˆä½å…±äº«è®¡æ•°å™¨'
    },
    'Destiny Bond': {
        onUse: (attacker, defender, logs) => {
            // Gen 7+ï¼šè¿ç»­ä½¿ç”¨å¿…å¤±è´¥
            if (attacker.lastMoveUsed === 'Destiny Bond') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (åŒå‘½ä¸èƒ½è¿ç»­ä½¿ç”¨)`);
                return { failed: true };
            }
            logs.push(`${attacker.cnName} æƒ³è¦å’Œå¯¹æ‰‹åŒå½’äºå°½!`);
            if (attacker.volatile) attacker.volatile.destinyBond = true;
            return {};
        },
        description: 'æœ¬å›åˆè¢«å‡»å€’æ—¶å¯¹æ‰‹ä¹Ÿä¼šå€’ä¸‹ï¼Œä¸èƒ½è¿ç»­ä½¿ç”¨'
    },
    // ============================================
    // åƒµç›´ç±»æŠ€èƒ½ (Recharge Moves)
    // ============================================
    'Hyper Beam': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'å¼ºåŠ›æ”»å‡»ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Giga Impact': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'å¼ºåŠ›ç‰©ç†æ”»å‡»ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Frenzy Plant': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'è‰ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Blast Burn': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'ç«ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Hydro Cannon': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'æ°´ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Prismatic Laser': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'è¶…èƒ½åŠ›ç³»å¤§æ‹›ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Meteor Assault': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'æ ¼æ–—ç³»å¤§æ‹›ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Eternabeam': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'é¾™ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Baton Pass': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†æ¥åŠ›æ£’!`);
            return { pivot: true, passBoosts: true };
        },
        description: 'æ¢äººå¹¶ä¼ é€’èƒ½åŠ›å˜åŒ–'
    },
    'Teleport': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} ä½¿ç”¨ç¬é—´ç§»åŠ¨æ’¤é€€äº†!`);
            return { pivot: true };
        },
        description: 'æ’¤é€€æ¢äºº'
    },
    // ============================================
    // 5. å¼ºåˆ¶æ¢äººæŠ€èƒ½ (Phazing Moves)
    // ============================================
    'Roar': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«å“è·‘äº†!`);
            return { phaze: true };
        },
        description: 'å¼ºåˆ¶å¯¹æ‰‹æ¢äºº'
    },
    'Whirlwind': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«å¹èµ°äº†!`);
            return { phaze: true };
        },
        description: 'å¼ºåˆ¶å¯¹æ‰‹æ¢äºº'
    },
    'Dragon Tail': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«ç”©é£äº†!`);
            return { phaze: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¼ºåˆ¶æ¢äºº'
    },
    'Circle Throw': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«æ‘”å‡ºå»äº†!`);
            return { phaze: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¼ºåˆ¶æ¢äºº'
    },
    // ============================================
    // 6. å¤©æ°”æŠ€èƒ½ (Weather Moves)
    // ============================================
    'Rain Dance': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'rain';
            logs.push('å¤©ç©ºä¸‹èµ·äº†å¤§é›¨!');
            logs.push('<span style="color:#3498db">æ°´ç³»æŠ€èƒ½å¨åŠ›æå‡ï¼Œç«ç³»æŠ€èƒ½å¨åŠ›ä¸‹é™!</span>');
            return { weather: 'rain' };
        },
        description: 'å¬å”¤é›¨å¤©'
    },
    'Sunny Day': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'sun';
            logs.push('é˜³å…‰å˜å¾—å¼ºçƒˆäº†!');
            logs.push('<span style="color:#e67e22">ç«ç³»æŠ€èƒ½å¨åŠ›æå‡ï¼Œæ°´ç³»æŠ€èƒ½å¨åŠ›ä¸‹é™!</span>');
            return { weather: 'sun' };
        },
        description: 'å¬å”¤æ™´å¤©'
    },
    'Sandstorm': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'sand';
            logs.push('æ²™æš´åˆ®èµ·æ¥äº†!');
            logs.push('<span style="color:#d4ac0d">å²©çŸ³ç³»ç‰¹é˜²æå‡ï¼Œéå²©/åœ°/é’¢ç³»æ¯å›åˆå—ä¼¤!</span>');
            return { weather: 'sand' };
        },
        description: 'å¬å”¤æ²™æš´'
    },
    'Hail': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'hail';
            logs.push('å¼€å§‹ä¸‹å†°é›¹äº†!');
            logs.push('<span style="color:#5dade2">éå†°ç³»æ¯å›åˆå—ä¼¤!</span>');
            return { weather: 'hail' };
        },
        description: 'å¬å”¤å†°é›¹'
    },
    'Snowscape': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'snow';
            logs.push('ä¸‹èµ·äº†é›ª!');
            logs.push('<span style="color:#85c1e9">å†°ç³»é˜²å¾¡æå‡!</span>');
            return { weather: 'snow' };
        },
        description: 'å¬å”¤é›ªå¤©'
    },
    // ============================================
    // 7. åœºåœ°æŠ€èƒ½ (Terrain/Hazard Moves) - ç®€åŒ–ç‰ˆ
    // ============================================
    'Stealth Rock': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('å°–é”çš„å²©çŸ³æ¼‚æµ®åœ¨å¯¹æ–¹åœºåœ°å‘¨å›´!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.stealthRock = true;
            }
            return { hazard: 'stealthRock' };
        },
        description: 'è®¾ç½®éšå½¢å²©'
    },
    'Spikes': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('æ’’è±æ•£å¸ƒåœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.spikes = (battle.hazards.spikes || 0) + 1;
            }
            return { hazard: 'spikes' };
        },
        description: 'è®¾ç½®æ’’è±'
    },
    'Toxic Spikes': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('æ¯’è±æ•£å¸ƒåœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.toxicSpikes = (battle.hazards.toxicSpikes || 0) + 1;
            }
            return { hazard: 'toxicSpikes' };
        },
        description: 'è®¾ç½®æ¯’è±'
    },
    'Sticky Web': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('é»é»ç½‘é“ºè®¾åœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.stickyWeb = true;
            }
            return { hazard: 'stickyWeb' };
        },
        description: 'è®¾ç½®é»é»ç½‘'
    },
    'Rapid Spin': {
        onHit: (attacker, defender, damage, logs, battle) => {
            logs.push(`${attacker.cnName} æ€¥é€Ÿæ—‹è½¬ï¼Œæ‰«é™¤äº†åœºä¸Šçš„éšœç¢!`);
            if (battle && battle.hazards) {
                battle.hazards = {};
            }
            // æ¸…é™¤è‡ªèº«çš„æŸç¼šçŠ¶æ€
            if (attacker.volatile) {
                delete attacker.volatile.partiallytrapped;
                delete attacker.volatile.leechseed;
            }
            return { clearHazards: true };
        },
        description: 'æ¸…é™¤å·±æ–¹åœºåœ°éšœç¢'
    },
    'Defog': {
        onHit: (attacker, defender, damage, logs, battle) => {
            logs.push('åœºåœ°ä¸Šçš„éšœç¢ç‰©è¢«å¹æ•£äº†!');
            if (battle) {
                battle.hazards = {};
            }
            return { clearHazards: true };
        },
        description: 'æ¸…é™¤åŒæ–¹åœºåœ°éšœç¢'
    },
    // ============================================
    // 8. è“„åŠ›æŠ€èƒ½ (Two-Turn Moves) - ç®€åŒ–ä¸ºå•å›åˆ
    // ============================================
    'Solar Beam': {
        onUse: (attacker, defender, logs, battle) => {
            // ç®€åŒ–ï¼šç›´æ¥å‘å°„ï¼Œä¸éœ€è¦è“„åŠ›
            if (battle && battle.weather === 'sun') {
                logs.push(`${attacker.cnName} å€ŸåŠ©å¼ºçƒˆçš„é˜³å…‰ï¼Œç¬é—´å‘å°„äº†æ—¥å…‰æŸ!`);
            } else {
                logs.push(`${attacker.cnName} è¿…é€Ÿèšé›†èƒ½é‡å‘å°„äº†æ—¥å…‰æŸ!`);
            }
            return { skipCharge: true };
        },
        description: 'æ™´å¤©ä¸‹æ— éœ€è“„åŠ›'
    },
    'Solar Blade': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle && battle.weather === 'sun') {
                logs.push(`${attacker.cnName} å€ŸåŠ©é˜³å…‰çš„åŠ›é‡æŒ¥å‡ºäº†æ—¥å…‰åˆƒ!`);
            } else {
                logs.push(`${attacker.cnName} èšé›†å…‰èŠ’æŒ¥å‡ºäº†æ—¥å…‰åˆƒ!`);
            }
            return { skipCharge: true };
        },
        description: 'æ™´å¤©ä¸‹æ— éœ€è“„åŠ›'
    },
    'Hyper Beam': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`<span style="color:#e74c3c">${attacker.cnName} éœ€è¦ä¼‘æ¯æ¢å¤!</span>`);
            // ç®€åŒ–ï¼šä¸å®é™…è·³è¿‡å›åˆï¼Œåªæ˜¯æç¤º
            return { recharge: true };
        },
        description: 'ä½¿ç”¨åéœ€è¦ä¼‘æ¯'
    },
    'Giga Impact': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`<span style="color:#e74c3c">${attacker.cnName} éœ€è¦ä¼‘æ¯æ¢å¤!</span>`);
            return { recharge: true };
        },
        description: 'ä½¿ç”¨åéœ€è¦ä¼‘æ¯'
    },
    // ============================================
    // 9. å…¶ä»–ç‰¹æ®ŠæŠ€èƒ½
    // ============================================
    'Explosion': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} å¼•çˆ†äº†è‡ªå·±!`);
            // è‡ªçˆ†ï¼šä½¿ç”¨è€…å€’ä¸‹
            attacker.currHp = 0;
            return { selfDestruct: true };
        },
        description: 'ä½¿ç”¨è€…å€’ä¸‹'
    },
    'Self-Destruct': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} è‡ªçˆ†äº†!`);
            attacker.currHp = 0;
            return { selfDestruct: true };
        },
        description: 'ä½¿ç”¨è€…å€’ä¸‹'
    },
    'Final Gambit': {
        damageCallback: (attacker, defender) => {
            const damage = attacker.currHp;
            attacker.currHp = 0; // ä½¿ç”¨è€…å€’ä¸‹
            return damage;
        },
        description: 'é€ æˆç­‰äºè‡ªèº«å‰©ä½™ HP çš„ä¼¤å®³ï¼Œä½¿ç”¨è€…å€’ä¸‹'
    },
    'Endeavor': {
        damageCallback: (attacker, defender) => {
            // å°†ç›®æ ‡ HP é™åˆ°ä¸è‡ªå·±ç›¸åŒ
            if (defender.currHp > attacker.currHp) {
                return defender.currHp - attacker.currHp;
            }
            return 0;
        },
        description: 'å°†ç›®æ ‡ HP é™åˆ°ä¸è‡ªå·±ç›¸åŒ'
    },
    'Pain Split': {
        onUse: (attacker, defender, logs) => {
            const avgHp = Math.floor((attacker.currHp + defender.currHp) / 2);
            attacker.currHp = Math.min(avgHp, attacker.maxHp);
            defender.currHp = Math.min(avgHp, defender.maxHp);
            logs.push(`${attacker.cnName} å’Œ ${defender.cnName} å¹³åˆ†äº†ç—›è‹¦!`);
            return { hpShared: true };
        },
        description: 'å¹³åˆ†åŒæ–¹ HP'
    },
    'Destiny Bond': {
        onUse: (attacker, defender, logs) => {
            attacker.volatile = attacker.volatile || {};
            attacker.volatile.destinyBond = true;
            logs.push(`${attacker.cnName} æƒ³è¦åŒå½’äºå°½!`);
            return { destinyBond: true };
        },
        description: 'å¦‚æœå€’ä¸‹åˆ™å¸¦èµ°å¯¹æ‰‹'
    },
    'Perish Song': {
        onUse: (attacker, defender, logs) => {
            logs.push('ç­äº¡ä¹‹æ­Œå“èµ·äº†! 3 å›åˆååœºä¸Šçš„å®å¯æ¢¦éƒ½ä¼šå€’ä¸‹!');
            // ç®€åŒ–ï¼šåªæ˜¯æç¤ºï¼Œä¸å®é™…å®ç°è®¡æ•°å™¨
            return { perishSong: true };
        },
        description: '3 å›åˆååŒæ–¹å€’ä¸‹'
    },
    'Metronome': {
        onUse: (attacker, defender, logs) => {
            // ç®€åŒ–ï¼šéšæœºé€‰æ‹©ä¸€ä¸ªå¸¸è§æ”»å‡»æŠ€èƒ½
            const randomMoves = ['Flamethrower', 'Thunderbolt', 'Ice Beam', 'Psychic', 
                                'Shadow Ball', 'Energy Ball', 'Earthquake', 'Surf'];
            const chosen = randomMoves[Math.floor(Math.random() * randomMoves.length)];
            logs.push(`${attacker.cnName} æŒ¥åŠ¨æ‰‹æŒ‡... ä½¿å‡ºäº† ${chosen}!`);
            return { metronome: chosen };
        },
        description: 'éšæœºä½¿ç”¨ä¸€ä¸ªæŠ€èƒ½'
    },
    // ============================================
    // 10. å±æ€§å˜åŒ–ç±»æŠ€èƒ½ (Type Changing Moves)
    // ============================================
    // ã€çº¹ç†ã€‘ï¼šå˜æˆè‡ªå·±ç¬¬ä¸€æ‹›çš„å±æ€§
    'Conversion': {
        onUse: (attacker, defender, logs) => {
            // è·å–ç¬¬ä¸€æ‹›
            const firstMove = attacker.moves[0];
            if (!firstMove) return;
            const targetType = firstMove.type;
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯è¯¥å±æ€§ï¼ˆå¦‚æœæ˜¯ï¼Œåˆ™æ‹›å¼å¤±è´¥ï¼‰
            // æ³¨æ„ï¼šattacker.types æ˜¯æ•°ç»„ï¼Œæ¯”å¦‚ ['Normal', 'Flying']
            if (attacker.types.length === 1 && attacker.types[0] === targetType) {
                logs.push(`ä½†æ˜¯åœ¨ ${targetType} å±æ€§ä¸‹æ— æ³•å†å˜åŒ–äº†!`);
                return;
            }
            // ä¿®æ”¹å±æ€§
            attacker.types = [targetType];
            logs.push(`${attacker.cnName} çš„çº¹ç†å˜å¾—å’Œ ${firstMove.name} ä¸€æ ·äº†!`);
            logs.push(`<span style="color:#a855f7">âœ¦ å˜æˆäº† ${targetType} å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†è‡ªèº«å±æ€§å˜ä¸ºç¬¬ä¸€æ‹›å¼çš„å±æ€§'
    },
    // ã€é•œé¢å±æ€§ã€‘ï¼šå¤åˆ¶å¯¹æ‰‹çš„å±æ€§
    'Reflect Type': {
        onUse: (attacker, defender, logs) => {
            if (!defender.types || defender.types.length === 0) return;
            // å¤åˆ¶å±æ€§æ•°ç»„ï¼ˆä½¿ç”¨æ‰©å±•è¿ç®—ç¬¦ ... é˜²æ­¢å¼•ç”¨ä¼ é€’ï¼‰
            attacker.types = [...defender.types];
            const typeStr = attacker.types.join('/');
            logs.push(`${attacker.cnName} å¤åˆ¶äº†å¯¹æ‰‹çš„å±æ€§!`);
            logs.push(`<span style="color:#a855f7">âœ¦ å˜æˆäº† ${typeStr} å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†è‡ªèº«å±æ€§å˜ä¸ºå’Œç›®æ ‡ç›¸åŒ'
    },
    // ã€æµ¸æ°´ã€‘ï¼šæŠŠå¯¹æ‰‹å˜æˆçº¯æ°´ç³»
    'Soak': {
        onHit: (attacker, defender, damage, logs) => {
            // æ— æ³•å¯¹æ›¿èº«ç”Ÿæ•ˆï¼ˆç®€åŒ–å¤„ç†å¿½ç•¥æ›¿èº«ï¼‰ï¼Œæ— æ³•å¯¹é˜¿å°”å®™æ–¯/é“¶ä¼´æˆ˜å…½ç”Ÿæ•ˆ
            if (defender.ability === 'Multitype' || defender.ability === 'RKS System') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            defender.types = ['Water'];
            logs.push(`${attacker.cnName} å‘å¯¹æ‰‹å–·å°„äº†ç‰¹æ®Šçš„æ°´!`);
            logs.push(`<span style="color:#3498db">âœ¦ ${defender.cnName} å˜æˆäº† æ°´ å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†ç›®æ ‡å˜ä¸ºæ°´å±æ€§'
    },
    // ============================================
    // 11. ç©¶ææŠ€èƒ½ï¼šå˜èº« (Transform)
    // ============================================
    'Transform': {
        onUse: (attacker, defender, logs) => {
            if (attacker.isTransformed) {
                logs.push(`ä½†æ˜¯ ${attacker.cnName} å·²ç»å˜èº«è¿‡äº†!`);
                return;
            }
            // 1. å¤åˆ¶å±æ€§
            attacker.types = [...defender.types];
            // 2. å¤åˆ¶èƒ½åŠ›å€¼ (é™¤HPå¤–)
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ç›´æ¥è¦†ç›– current statsã€‚
            // æ­£è§„é€»è¾‘åº”è¯¥å¤åˆ¶ baseStats ç„¶åé‡æ–°è®¡ç®—ï¼Œä½†ä¸ºäº†ç®€åŒ– RP æ•ˆæœï¼Œç›´æ¥å¤åˆ¶æ•°å€¼å³å¯ã€‚
            attacker.atk = defender.atk;
            attacker.def = defender.def;
            attacker.spa = defender.spa;
            attacker.spd = defender.spd;
            attacker.spe = defender.spe;
            // å¤åˆ¶èƒ½åŠ›ç­‰çº§ (Boosts)
            attacker.boosts = { ...defender.boosts };
            // 3. å¤åˆ¶æŠ€èƒ½ (ç®€åŒ–ï¼šç›´æ¥å¼•ç”¨å¯¹è±¡çš„æŠ€èƒ½æ•°ç»„ï¼ŒåŸæœ¬åº”è¯¥åªæœ‰5PPï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ— é™)
            // å¿…é¡»æ·±æ‹·è´æŠ€èƒ½æ•°ç»„ï¼Œå¦åˆ™ä¸€æ–¹æ¶ˆè€—PPä¼šå½±å“å¦ä¸€æ–¹ï¼ˆè™½ç„¶ç›®å‰æ²¡åšPPç³»ç»Ÿï¼‰
            attacker.moves = defender.moves.map(m => ({...m}));
            // 4. å¤åˆ¶ç‰¹æ€§
            attacker.ability = defender.ability;
            // 5. æ ‡è®°å˜èº«çŠ¶æ€ (é˜²æ­¢å¥—å¨ƒ)
            attacker.isTransformed = true;
            attacker.dittoOriginalName = attacker.cnName; // è®°ä½åŸå
            attacker.cnName = defender.cnName; // æ”¹å
            logs.push(`${attacker.dittoOriginalName} å˜èº«æˆäº† ${defender.cnName}!`);
            // å°è¯•æ›´æ–°å›¾ç‰‡ä¸ºå¯¹æ‰‹çš„å›¾ç‰‡ (è¿™æ˜¯ä¸€ä¸ªé«˜çº§è§†è§‰æ•ˆæœ)
            // æ³¨æ„ï¼šè¿™éœ€è¦å‰ç«¯ index.js æ”¯æŒï¼Œé€šè¿‡ id æŸ¥æ‰¾ DOM æ›´æ–° src
            if (typeof document !== 'undefined') {
                const playerSprite = document.getElementById('player-sprite');
                const enemySprite = document.getElementById('enemy-sprite');
                // ç®€å•çš„å›¾ç‰‡äº¤æ¢é€»è¾‘ï¼ˆä»…è§†è§‰ï¼‰
                if (playerSprite && enemySprite) {
                    // å¦‚æœæˆ‘æ˜¯ç©å®¶ï¼Œæˆ‘å˜èº«æˆæ•Œäºº
                    // è¿™ç§ç®€å•çš„ src å¤åˆ¶åœ¨ Showdown å›¾åº“ä¸‹æ˜¯æœ‰æ•ˆçš„ï¼ˆæ­£åé¢å¯èƒ½ä¸ä¸€è‡´ï¼Œä½†èƒ½çœ‹ï¼‰
                    // æ›´å¥½çš„åšæ³•æ˜¯å»è·å–å¯¹æ‰‹çš„æ­£åé¢ ID
                    /* è¿™é‡Œä¸åšå¤æ‚ DOM æ“ä½œï¼Œä»¥å…æŠ¥é”™ï¼Œä»…æ–‡å­—æç¤º */
                }
            }
            return { transform: true };
        },
        description: 'å˜èº«æˆå¯¹æ‰‹çš„æ ·å­'
    },
    // ============================================
    // å›å¤æŠ€èƒ½ (Recovery Moves)
    // ============================================
    'Recover': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Soft-Boiled': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Slack Off': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å·æ‡’æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Roost': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é™è½ä¼‘æ¯æ¢å¤äº†ä½“åŠ›!`);
                // ç¾½æ –æ•ˆæœï¼šæœ¬å›åˆå¤±å»é£è¡Œå±æ€§ï¼ˆç®€åŒ–å¤„ç†ï¼Œä¸å®ç°ï¼‰
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%ï¼Œæœ¬å›åˆå¤±å»é£è¡Œå±æ€§'
    },
    'Synthesis': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            // å¤©æ°”å½±å“
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é€šè¿‡å…‰åˆä½œç”¨æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    'Morning Sun': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ²æµ´æ™¨å…‰æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    'Moonlight': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ²æµ´æœˆå…‰æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    // ============================================
    // èƒ½åŠ›å˜åŒ–æ¸…é™¤æŠ€èƒ½ (Stat Reset Moves)
    // ============================================
    'Haze': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // é‡ç½®åŒæ–¹æ‰€æœ‰èƒ½åŠ›å˜åŒ–
            const resetBoosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
            if (attacker.boosts) {
                attacker.boosts = { ...resetBoosts };
            }
            if (defender.boosts) {
                defender.boosts = { ...resetBoosts };
            }
            logs.push(`åœºä¸Šæ‰€æœ‰çš„èƒ½åŠ›å˜åŒ–ç”±äºé»‘é›¾éƒ½æ¶ˆå¤±äº†!`);
            return { haze: true };
        },
        description: 'æ¸…é™¤åœºä¸Šæ‰€æœ‰å®å¯æ¢¦çš„èƒ½åŠ›å˜åŒ–'
    },
    'Clear Smog': {
        onHit: (attacker, defender, damage, logs) => {
            // åªé‡ç½®å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–
            const resetBoosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
            if (defender.boosts) {
                defender.boosts = { ...resetBoosts };
            }
            logs.push(`${defender.cnName} çš„å¼ºåŒ–è¢«æ¸…é™¤ä¹‹çƒŸæŠµæ¶ˆäº†!`);
            return { clearSmog: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶æ¸…é™¤å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–'
    },
    // ============================================
    // èƒ½åŠ›å˜åŒ–æ“æ§æŠ€èƒ½ (Stat Manipulation Moves)
    // ============================================
    'Topsy-Turvy': {
        onHit: (attacker, defender, damage, logs) => {
            // é¢ å€’å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–ï¼ˆ+3 å˜ -3ï¼Œ-1 å˜ +1ï¼‰
            const stats = ['atk', 'def', 'spa', 'spd', 'spe', 'accuracy', 'evasion'];
            let reversed = false;
            if (defender.boosts) {
                stats.forEach(key => {
                    if (defender.boosts[key] && defender.boosts[key] !== 0) {
                        defender.boosts[key] *= -1;
                        reversed = true;
                    }
                });
            }
            if (reversed) {
                logs.push(`${defender.cnName} çš„èƒ½åŠ›å˜åŒ–è¢«å®Œå…¨é¢ å€’äº†!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { topsyTurvy: true };
        },
        description: 'å°†å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–æ•°å€¼åè½¬'
    },
    'Spectral Thief': {
        onHit: (attacker, defender, damage, logs) => {
            // å·å–å¯¹æ‰‹çš„æ­£é¢èƒ½åŠ›å˜åŒ–
            const stats = ['atk', 'def', 'spa', 'spd', 'spe', 'accuracy', 'evasion'];
            let stolen = false;
            if (defender.boosts && attacker.boosts) {
                stats.forEach(key => {
                    if (defender.boosts[key] && defender.boosts[key] > 0) {
                        // è‡ªå·±åŠ ä¸Šå¯¹æ‰‹çš„å¢ç›Š
                        attacker.boosts[key] = Math.min(6, (attacker.boosts[key] || 0) + defender.boosts[key]);
                        // å¯¹æ‰‹æ¸…é›¶
                        defender.boosts[key] = 0;
                        stolen = true;
                    }
                });
            }
            if (stolen) {
                logs.push(`${attacker.cnName} å¤ºå–äº†å¯¹æ‰‹çš„å¼ºåŒ–èƒ½åŠ›!`);
            }
            return { spectralThief: true };
        },
        description: 'å·å–å¯¹æ‰‹çš„æ­£é¢èƒ½åŠ›å˜åŒ–åé€ æˆä¼¤å®³'
    },
    'Psych Up': {
        onHit: (attacker, defender, damage, logs) => {
            // å¤åˆ¶å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–
            if (defender.boosts) {
                attacker.boosts = { ...defender.boosts };
                logs.push(`${attacker.cnName} å¤åˆ¶äº† ${defender.cnName} çš„èƒ½åŠ›å˜åŒ–!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { psychUp: true };
        },
        description: 'å¤åˆ¶å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–è¦†ç›–è‡ªå·±'
    },
    'Heart Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const temp = { ...attacker.boosts };
                attacker.boosts = { ...defender.boosts };
                defender.boosts = temp;
                logs.push(`${attacker.cnName} å’Œ ${defender.cnName} çš„èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { heartSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„èƒ½åŠ›å˜åŒ–'
    },
    'Power Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const tempAtk = attacker.boosts.atk || 0;
                const tempSpa = attacker.boosts.spa || 0;
                attacker.boosts.atk = defender.boosts.atk || 0;
                attacker.boosts.spa = defender.boosts.spa || 0;
                defender.boosts.atk = tempAtk;
                defender.boosts.spa = tempSpa;
                logs.push(`åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { powerSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–'
    },
    'Guard Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const tempDef = attacker.boosts.def || 0;
                const tempSpd = attacker.boosts.spd || 0;
                attacker.boosts.def = defender.boosts.def || 0;
                attacker.boosts.spd = defender.boosts.spd || 0;
                defender.boosts.def = tempDef;
                defender.boosts.spd = tempSpd;
                logs.push(`åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { guardSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–'
    },
    'Speed Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„å®é™…é€Ÿåº¦å€¼
            const tempSpe = attacker.spe;
            attacker.spe = defender.spe;
            defender.spe = tempSpe;
            logs.push(`${attacker.cnName} å’Œ ${defender.cnName} çš„é€Ÿåº¦äº’æ¢äº†!`);
            return { speedSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„å®é™…é€Ÿåº¦å€¼'
    },
    // ============================================
    // çŠ¶æ€æ²»ç–—æŠ€èƒ½ (Status Healing Moves)
    // ============================================
    'Aromatherapy': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€ï¼ˆç®€åŒ–ï¼šåªæ²»æ„ˆè‡ªå·±ï¼‰
            let cured = false;
            if (attacker.status) {
                attacker.status = null;
                attacker.statusTurns = 0;
                cured = true;
            }
            // å°è¯•æ²»æ„ˆé˜Ÿå‹ï¼ˆå¦‚æœæœ‰ battle å¯¹è±¡ï¼‰
            if (battle && battle.playerParty) {
                battle.playerParty.forEach(pm => {
                    if (pm && pm.status && pm.isAlive && pm.isAlive()) {
                        pm.status = null;
                        pm.statusTurns = 0;
                        cured = true;
                    }
                });
            }
            if (cured) {
                logs.push(`èŠ³é¦™æ²»ç–—çš„é¦™æ°”æ²»æ„ˆäº†å¼‚å¸¸çŠ¶æ€!`);
            } else {
                logs.push(`èŠ³é¦™å››æº¢... ä½†å¥½åƒæ²¡ä»€ä¹ˆæ•ˆæœã€‚`);
            }
            return { aromatherapy: true };
        },
        description: 'æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€'
    },
    'Heal Bell': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€ï¼ˆç®€åŒ–ï¼šåªæ²»æ„ˆè‡ªå·±ï¼‰
            let cured = false;
            if (attacker.status) {
                attacker.status = null;
                attacker.statusTurns = 0;
                cured = true;
            }
            // å°è¯•æ²»æ„ˆé˜Ÿå‹
            if (battle && battle.playerParty) {
                battle.playerParty.forEach(pm => {
                    if (pm && pm.status && pm.isAlive && pm.isAlive()) {
                        pm.status = null;
                        pm.statusTurns = 0;
                        cured = true;
                    }
                });
            }
            if (cured) {
                logs.push(`æ²»æ„ˆé“ƒå£°å›è¡ï¼Œå¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
            } else {
                logs.push(`é“ƒå£°å›è¡... ä½†å¥½åƒæ²¡ä»€ä¹ˆæ•ˆæœã€‚`);
            }
            return { healBell: true };
        },
        description: 'æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€'
    },
    'Refresh': {
        onHit: (attacker, defender, damage, logs) => {
            // æ²»æ„ˆè‡ªå·±çš„ä¸­æ¯’ã€éº»ç—¹ã€ç¼ä¼¤
            const curableStatus = ['psn', 'tox', 'par', 'brn'];
            if (attacker.status && curableStatus.includes(attacker.status)) {
                attacker.status = null;
                attacker.statusTurns = 0;
                logs.push(`${attacker.cnName} çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { refresh: true };
        },
        description: 'æ²»æ„ˆè‡ªå·±çš„ä¸­æ¯’ã€éº»ç—¹ã€ç¼ä¼¤'
    },
    'Purify': {
        onHit: (attacker, defender, damage, logs) => {
            // æ²»æ„ˆå¯¹æ‰‹çš„å¼‚å¸¸çŠ¶æ€ï¼Œè‡ªå·±å›å¤50%HP
            if (defender.status) {
                defender.status = null;
                defender.statusTurns = 0;
                logs.push(`${defender.cnName} çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
                // è‡ªå·±å›å¤HP
                const healAmount = Math.floor(attacker.maxHp / 2);
                const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
                if (actualHeal > 0) {
                    attacker.currHp += actualHeal;
                    logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
                }
            } else {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
            }
            return { purify: true };
        },
        description: 'æ²»æ„ˆå¯¹æ‰‹çš„å¼‚å¸¸çŠ¶æ€ï¼Œè‡ªå·±å›å¤50%HP'
    },
    // ============================================
    // ç‰¹æ®Šå›å¤æŠ€èƒ½ (Special Recovery Moves)
    // ============================================
    'Rest': {
        onHit: (attacker, defender, damage, logs) => {
            // å®Œå…¨å›å¤HPï¼Œä½†é™·å…¥ç¡çœ 2å›åˆ
            if (attacker.currHp >= attacker.maxHp) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { rest: false };
            }
            attacker.currHp = attacker.maxHp;
            attacker.status = 'slp';
            attacker.statusTurns = 0;
            // ç¡çœ å›åˆæ•°ï¼ˆRest å›ºå®šç¡2å›åˆï¼Œç¬¬3å›åˆé†’æ¥ï¼‰
            attacker.sleepTurns = 3;
            logs.push(`${attacker.cnName} ç¡ç€äº†å¹¶æ¢å¤äº†å…¨éƒ¨ä½“åŠ›!`);
            return { rest: true };
        },
        description: 'å®Œå…¨å›å¤HPï¼Œä½†é™·å…¥ç¡çœ 2å›åˆ'
    },
    'Wish': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // ä¸‹å›åˆç»“æŸæ—¶å›å¤50%HPï¼ˆç®€åŒ–ï¼šç«‹å³å›å¤ï¼‰
            // å®Œæ•´å®ç°éœ€è¦å»¶è¿Ÿæ•ˆæœç³»ç»Ÿ
            if (battle) {
                battle.wishPending = {
                    target: 'player',
                    amount: Math.floor(attacker.maxHp / 2),
                    turnsLeft: 1
                };
            }
            logs.push(`${attacker.cnName} è®¸ä¸‹äº†æ„¿æœ›!`);
            return { wish: true };
        },
        description: 'ä¸‹å›åˆç»“æŸæ—¶å›å¤50%HP'
    },
    'Healing Wish': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦
            attacker.currHp = 0;
            if (battle) {
                battle.healingWishPending = true;
            }
            logs.push(`${attacker.cnName} ç‰ºç‰²è‡ªå·±è®¸ä¸‹äº†æ²»æ„ˆä¹‹æ„¿!`);
            return { healingWish: true, selfKO: true };
        },
        description: 'è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦'
    },
    'Lunar Dance': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦ï¼ˆåŒ…æ‹¬PPï¼‰
            attacker.currHp = 0;
            if (battle) {
                battle.lunarDancePending = true;
            }
            logs.push(`${attacker.cnName} è·³èµ·äº†æ–°æœˆä¹‹èˆ!`);
            return { lunarDance: true, selfKO: true };
        },
        description: 'è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦'
    },
    'Shore Up': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²™æš´å¤©æ°”ä¸‹å›å¤2/3ï¼Œå¦åˆ™å›å¤1/2
            let healRatio = 0.5;
            if (battle && battle.weather === 'sandstorm') {
                healRatio = 2/3;
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é›†æ²™æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ²™æš´å¤©æ°”ä¸‹æ¢å¤æ›´å¤š'
    },
    'Strength Sap': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ç­‰äºå¯¹æ‰‹æ”»å‡»åŠ›çš„HPï¼Œå¹¶é™ä½å¯¹æ‰‹æ”»å‡»
            const healAmount = defender.atk;
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº† ${defender.cnName} çš„åŠ›é‡!`);
            }
            // é™ä½å¯¹æ‰‹æ”»å‡»
            if (defender.boosts) {
                const oldAtk = defender.boosts.atk || 0;
                defender.boosts.atk = Math.max(-6, oldAtk - 1);
                if (oldAtk > -6) {
                    logs.push(`${defender.cnName} çš„æ”»å‡»ä¸‹é™äº†!`);
                }
            }
            return { strengthSap: true };
        },
        description: 'å›å¤ç­‰äºå¯¹æ‰‹æ”»å‡»åŠ›çš„HPï¼Œå¹¶é™ä½å¯¹æ‰‹æ”»å‡»'
    },
    'Leech Seed': {
        onHit: (attacker, defender, damage, logs) => {
            // ç§ä¸‹å¯„ç”Ÿç§å­
            if (defender.types && defender.types.includes('Grass')) {
                logs.push(`å¯¹è‰å±æ€§å®å¯æ¢¦æ²¡æœ‰æ•ˆæœ!`);
                return { leechSeed: false };
            }
            if (!defender.volatile) defender.volatile = {};
            defender.volatile.leechSeed = true;
            logs.push(`${defender.cnName} è¢«ç§ä¸‹äº†å¯„ç”Ÿç§å­!`);
            return { leechSeed: true };
        },
        description: 'æ¯å›åˆå¸å–å¯¹æ‰‹1/8HP'
    },
    'Pain Split': {
        onHit: (attacker, defender, damage, logs) => {
            // å¹³åˆ†åŒæ–¹HP
            const totalHp = attacker.currHp + defender.currHp;
            const splitHp = Math.floor(totalHp / 2);
            attacker.currHp = Math.min(splitHp, attacker.maxHp);
            defender.currHp = Math.min(splitHp, defender.maxHp);
            logs.push(`åŒæ–¹å¹³åˆ†äº†ç—›è‹¦!`);
            return { painSplit: true };
        },
        description: 'å¹³åˆ†åŒæ–¹å½“å‰HP'
    },
    // ============================================
    // å¸è¡€/åä¼¤æŠ€èƒ½è¡¥å…… (Drain/Recoil Moves)
    // ============================================
    'Giga Drain': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Drain Punch': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Horn Leech': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Leech Life': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Oblivion Wing': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ä¼¤å®³çš„75%
            const drainAmount = Math.floor(damage * 0.75);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„75%'
    },
    'Draining Kiss': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ä¼¤å®³çš„75%
            const drainAmount = Math.floor(damage * 0.75);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„75%'
    },
    'Absorb': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Mega Drain': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Dream Eater': {
        onHit: (attacker, defender, damage, logs) => {
            // åªå¯¹ç¡çœ çŠ¶æ€çš„å¯¹æ‰‹æœ‰æ•ˆï¼ˆä¼¤å®³è®¡ç®—å·²åœ¨åˆ«å¤„å¤„ç†ï¼‰
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} åƒæ‰äº†å¯¹æ‰‹çš„æ¢¦!`);
            }
            return { drain: actualHeal };
        },
        description: 'åƒæ‰ç¡çœ ä¸­å¯¹æ‰‹çš„æ¢¦ï¼Œå›å¤ä¼¤å®³çš„50%'
    },
    // ============================================
    // é“å…·äº¤æ¢æŠ€èƒ½ (Item Swap Moves)
    // ============================================
    'Trick': {
        onUse: (user, target, logs, battle) => {
            // æ£€æŸ¥åŒæ–¹é“å…·
            const userItem = user.item || null;
            const targetItem = target.item || null;
            // å¦‚æœåŒæ–¹éƒ½æ²¡æœ‰é“å…·ï¼ŒæŠ€èƒ½å¤±è´¥
            if (!userItem && !targetItem) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            const userItemId = userItem ? userItem.toLowerCase().replace(/[^a-z0-9]/g, '') : '';
            const targetItemId = targetItem ? targetItem.toLowerCase().replace(/[^a-z0-9]/g, '') : '';
            // ä½¿ç”¨ items-data.js çš„ isSwappable å‡½æ•°æ£€æŸ¥
            const checkSwappable = typeof isSwappable === 'function' ? isSwappable : (id) => {
                // Fallback: ç¡¬ç¼–ç æ£€æŸ¥
                const unswappableItems = [
                    'rustedsword', 'rustedshield', 'griseousorb', 'adamantorb', 'lustrousorb',
                    'souldew', 'lightball', 'thickclub', 'luckypunch', 'leek', 'stick', 'mail'
                ];
                if (unswappableItems.includes(id)) return false;
                if (id.endsWith('ite') && id !== 'eviolite') return false; // Mega çŸ³
                if (id.endsWith('iumz') || id.endsWith('iniumz')) return false; // Z æ°´æ™¶
                return true;
            };
            if (!checkSwappable(userItemId) || !checkSwappable(targetItemId)) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            // æ£€æŸ¥é»ç€ç‰¹æ€§
            if (target.ability === 'Sticky Hold') {
                logs.push(`${target.cnName} çš„é»ç€ç‰¹æ€§é˜»æ­¢äº†é“å…·äº¤æ¢ï¼`);
                return { failed: true };
            }
            // æ‰§è¡Œäº¤æ¢
            user.item = targetItem;
            target.item = userItem;
            // è®°å½•äº¤æ¢ï¼ˆç”¨äº AI åˆ¤æ–­é”æ‹›ï¼‰- ä½¿ç”¨ items-data.js çš„ isChoiceItem
            const checkChoice = typeof isChoiceItem === 'function' ? isChoiceItem : 
                (item) => item && (item.includes('Choice') || item.includes('è®²ç©¶'));
            if (checkChoice(targetItem)) {
                target.choiceLocked = true;
                target.choiceLockedMove = null;
            }
            if (checkChoice(userItem)) {
                user.choiceLocked = true;
                user.choiceLockedMove = null;
            }
            // ç”Ÿæˆæ—¥å¿— - å°è¯•è·å–ä¸­æ–‡å
            const getItemCnName = (item) => {
                if (!item) return 'æ— ';
                if (typeof getItem === 'function') {
                    const data = getItem(item);
                    if (data && data.cnName) return data.cnName;
                }
                return item;
            };
            const userItemName = getItemCnName(userItem);
            const targetItemName = getItemCnName(targetItem);
            logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} å’Œ ${target.cnName} äº¤æ¢äº†é“å…·ï¼</b>`);
            logs.push(`${user.cnName} è·å¾—äº† ${targetItemName}ï¼`);
            logs.push(`${target.cnName} è·å¾—äº† ${userItemName}ï¼`);
            console.log(`[TRICK] ${user.name}: ${userItem} -> ${targetItem}, ${target.name}: ${targetItem} -> ${userItem}`);
        },
        description: 'å’Œå¯¹æ‰‹äº¤æ¢æŒæœ‰çš„é“å…·'
    },
    'Switcheroo': {
        onUse: (user, target, logs, battle) => {
            // Switcheroo å’Œ Trick æ•ˆæœå®Œå…¨ç›¸åŒ
            const trickHandler = MoveHandlers['Trick'];
            if (trickHandler && trickHandler.onUse) {
                return trickHandler.onUse(user, target, logs, battle);
            }
        },
        description: 'å’Œå¯¹æ‰‹äº¤æ¢æŒæœ‰çš„é“å…·'
    },
    // ============================================
    // åœºåœ°çŠ¶æ€æŠ€èƒ½ (Field Condition Moves)
    // ============================================
    'Trick Room': {
        onUse: (user, target, logs, battle) => {
            console.log('[TRICK ROOM] onUse called, battle:', battle, 'field:', battle?.field);
            // å¦‚æœ battle æˆ– field ä¸å­˜åœ¨ï¼Œå°è¯•ä»å…¨å±€è·å–
            if (!battle) {
                battle = (typeof window !== 'undefined' && window.battle) ? window.battle : null;
                console.log('[TRICK ROOM] Using global battle:', battle);
            }
            if (!battle) {
                console.warn('[TRICK ROOM] No battle object available!');
                logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} æ‰­æ›²äº†æ—¶ç©ºï¼</b>`);
                logs.push(`<span style="color:#c084fc">æˆæ³•ç©ºé—´å±•å¼€ï¼é€Ÿåº¦æ…¢çš„å®å¯æ¢¦å°†å…ˆè¡ŒåŠ¨ï¼</span>`);
                return;
            }
            // ç¡®ä¿ field å¯¹è±¡å­˜åœ¨
            if (!battle.field) {
                battle.field = { trickRoom: 0 };
            }
            if (battle.field.trickRoom > 0) {
                // å·²ç»æœ‰ç©ºé—´ï¼Œå†ç”¨ä¼šå…³é—­
                battle.field.trickRoom = 0;
                logs.push(`${user.cnName} è®©æ‰­æ›²çš„æ—¶ç©ºæ¢å¤äº†æ­£å¸¸ï¼`);
                console.log('[TRICK ROOM] Closed! trickRoom =', battle.field.trickRoom);
            } else {
                // å¼€å¯ç©ºé—´ï¼ŒæŒç»­5å›åˆ
                battle.field.trickRoom = 5;
                logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} æ‰­æ›²äº†æ—¶ç©ºï¼</b>`);
                logs.push(`<span style="color:#c084fc">æˆæ³•ç©ºé—´å±•å¼€ï¼é€Ÿåº¦æ…¢çš„å®å¯æ¢¦å°†å…ˆè¡ŒåŠ¨ï¼</span>`);
                console.log('[TRICK ROOM] Opened! trickRoom =', battle.field.trickRoom);
            }
        },
        priority: -7,
        description: '5å›åˆå†…é€Ÿåº¦æ…¢çš„å…ˆåŠ¨'
    },
    'Tailwind': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            if (side.tailwind > 0) {
                logs.push(`é¡ºé£å·²ç»åœ¨å¹äº†ï¼`);
                return { failed: true };
            }
            side.tailwind = 4; // æŒç»­4å›åˆ
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#38bdf8">ğŸŒ¬ï¸ ${sideText}åˆ®èµ·äº†é¡ºé£ï¼</b>`);
        },
        description: '4å›åˆå†…æˆ‘æ–¹é€Ÿåº¦ç¿»å€'
    },
    'Reflect': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            if (side.reflect > 0) {
                logs.push(`åå°„å£å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.reflect = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#f97316">ğŸ›¡ï¸ ${sideText}å»ºèµ·äº†åå°„å£ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰©ç†ä¼¤å®³å‡åŠ'
    },
    'Light Screen': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            if (side.lightScreen > 0) {
                logs.push(`å…‰å¢™å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.lightScreen = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#facc15">âœ¨ ${sideText}å»ºèµ·äº†å…‰å¢™ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰¹æ®Šä¼¤å®³å‡åŠ'
    },
    'Aurora Veil': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            // æå…‰å¹•éœ€è¦å†°é›¹/é›ªå¤©æ°”
            // ç®€åŒ–ï¼šæš‚æ—¶ä¸æ£€æŸ¥å¤©æ°”ï¼Œç›´æ¥å…è®¸ä½¿ç”¨
            if (side.auroraVeil > 0) {
                logs.push(`æå…‰å¹•å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.auroraVeil = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#22d3ee">â„ï¸ ${sideText}å±•å¼€äº†æå…‰å¹•ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰©ç†å’Œç‰¹æ®Šä¼¤å®³éƒ½å‡åŠ'
    },
    // ============================================
    // åå¼¹æŠ€èƒ½ (Counter / Mirror Coat)
    // ============================================
    // è¿™ä¸¤ä¸ªæŠ€èƒ½éœ€è¦æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ç±»å‹
    // Counter: åå¼¹ç‰©ç†ä¼¤å®³çš„ä¸¤å€
    // Mirror Coat: åå¼¹ç‰¹æ®Šä¼¤å®³çš„ä¸¤å€
    'Counter': {
        // æ ‡è®°ä¸ºåå¼¹æŠ€èƒ½ï¼Œä¸æ˜¯æ™®é€šå˜åŒ–æŠ€
        isReflectMove: true,
        reflectCategory: 'physical',
        damageCallback: (attacker, defender) => {
            // æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0; // æ²¡å—ä¼¤ï¼Œåå¼¹å¤±è´¥
            }
            // å¿…é¡»æ˜¯ç‰©ç†ä¼¤å®³
            const cat = takenDamage.category || '';
            if (cat !== 'physical' && cat !== 'phys') {
                return 0; // ç±»å‹ä¸å¯¹
            }
            // åŒå€è¿”è¿˜
            return takenDamage.amount * 2;
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            const cat = takenDamage.category || '';
            if (cat !== 'physical' && cat !== 'phys') {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æ²¡æœ‰å—åˆ°ç‰©ç†æ”»å‡»)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#c0392b">ğŸ’¥ ${user.cnName} å°†ç‰©ç†ä¼¤å®³åŒå€å¥‰è¿˜ï¼</b>`);
            return { damage: takenDamage.amount * 2 };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ç‰©ç†ä¼¤å®³åŒå€è¿”è¿˜'
    },
    'Mirror Coat': {
        // æ ‡è®°ä¸ºåå¼¹æŠ€èƒ½ï¼Œä¸æ˜¯æ™®é€šå˜åŒ–æŠ€
        isReflectMove: true,
        reflectCategory: 'special',
        damageCallback: (attacker, defender) => {
            // æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0; // æ²¡å—ä¼¤ï¼Œåå¼¹å¤±è´¥
            }
            // å¿…é¡»æ˜¯ç‰¹æ®Šä¼¤å®³
            const cat = takenDamage.category || '';
            if (cat !== 'special' && cat !== 'spec') {
                return 0; // ç±»å‹ä¸å¯¹
            }
            // åŒå€è¿”è¿˜
            return takenDamage.amount * 2;
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            const cat = takenDamage.category || '';
            if (cat !== 'special' && cat !== 'spec') {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æ²¡æœ‰å—åˆ°ç‰¹æ®Šæ”»å‡»)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#9b59b6">âœ¨ ${user.cnName} å°†ç‰¹æ®Šä¼¤å®³åŒå€å¥‰è¿˜ï¼</b>`);
            return { damage: takenDamage.amount * 2 };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ç‰¹æ®Šä¼¤å®³åŒå€è¿”è¿˜'
    },
    // Metal Burst: åå¼¹æœ€åå—åˆ°ä¼¤å®³çš„ 1.5 å€ï¼ˆä¸åˆ†ç‰©ç†ç‰¹æ®Šï¼‰
    'Metal Burst': {
        isReflectMove: true,
        reflectCategory: 'any',
        damageCallback: (attacker, defender) => {
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0;
            }
            // 1.5 å€è¿”è¿˜
            return Math.floor(takenDamage.amount * 1.5);
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#7f8c8d">âš”ï¸ ${user.cnName} ä»¥é‡‘å±çˆ†å‘åå‡»ï¼</b>`);
            return { damage: Math.floor(takenDamage.amount * 1.5) };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ 1.5 å€è¿”è¿˜'
    },
    // ============================================
    // å¤ªæ™¶çˆ†å‘ (Tera Blast) - æ˜Ÿæ™¶ç‰¹æ®Šæ•ˆæœ
    // ============================================
    'Tera Blast': {
        onHit: (attacker, defender, damage, logs) => {
            // åªæœ‰åœ¨æ˜Ÿæ™¶å¤ªæ™¶åŒ–çŠ¶æ€ä¸‹æ‰æœ‰å‰¯ä½œç”¨
            if (attacker.isTerastallized && attacker.teraType === 'Stellar') {
                if (typeof attacker.applyBoost === 'function') {
                    attacker.applyBoost('atk', -1);
                    attacker.applyBoost('spa', -1);
                    logs.push(`<span style="color:#d400ff">âœ¦ å› ä¸ºè¿™è‚¡èƒ½é‡è¿‡äºåºå¤§ï¼Œ${attacker.cnName} çš„æ”»å‡»å’Œç‰¹æ”»ä¸‹é™äº†! (æ˜Ÿæ™¶åå™¬)</span>`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
                }
            }
            return {};
        },
        description: 'å¤ªæ™¶åŒ–æ—¶æ”¹å˜å±æ€§ã€‚è‹¥æ˜¯æ˜Ÿæ™¶å±æ€§ï¼Œå¨åŠ›å¼ºå¤§ä½†ä¼šé™ä½åŒæ”»ã€‚'
    }
};
// ============================================
// è¾…åŠ©å‡½æ•°ï¼šè·å–æŠ€èƒ½å¤„ç†å™¨
// ============================================
function getMoveHandler(moveName) {
    return MoveHandlers[moveName] || null;
}
function hasMoveHandler(moveName) {
    return moveName in MoveHandlers;
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
if (typeof window !== 'undefined') {
    window.MoveHandlers = MoveHandlers;
    window.getMoveHandler = getMoveHandler;
    window.hasMoveHandler = hasMoveHandler;
}
]]></file>
    </directory>
    <directory name="mechanics">
        <file name="dynamax.js"><![CDATA[/**
 * ===========================================
 * DYNAMAX.JS - æå·¨åŒ–ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - æå·¨åŒ–çŠ¶æ€ç®¡ç†
 * - æ‹›å¼è½¬æ¢ï¼ˆæ™®é€šæ‹›å¼ <-> æå·¨æ‹›å¼ï¼‰
 * - HP å€å¢/æ¢å¤
 */
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * åº”ç”¨æå·¨åŒ–çŠ¶æ€å˜æ¢ï¼ˆæ‹›å¼æ›¿æ¢/å›é€€ï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 */
function applyDynamaxState(pokemon, isActive) {
    if (!pokemon) return;
    // è·å– getMaxMoveTarget å‡½æ•°ï¼ˆä» z-moves.jsï¼‰
    const getMaxMoveTargetFn = typeof window !== 'undefined' && window.getMaxMoveTarget 
        ? window.getMaxMoveTarget 
        : null;
    if (isActive) {
        // [ON] å¼€å¯æå·¨åŒ–
        console.log(`[DYNAMAX] ${pokemon.name} æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼`);
        // === æ’­æ”¾æå·¨åŒ–å«å£° ===
        if (typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(pokemon.name);
        }
        // 1. å¤‡ä»½åŸå§‹æŠ€èƒ½ (éå¸¸é‡è¦ï¼ä¸ºäº†å›é€€)
        pokemon._originalMoves = JSON.parse(JSON.stringify(pokemon.moves));
        // 2. ä½¿ç”¨è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿç”Ÿæˆæå·¨æ‹›å¼
        pokemon.moves = pokemon._originalMoves.map(m => {
            const maxTarget = getMaxMoveTargetFn ? getMaxMoveTargetFn(m, pokemon) : null;
            if (!maxTarget) {
                // æ— æ³•æ¨å¯¼ï¼Œä¿æŒåŸæ ·
                return { ...m, isMax: true };
            }
            const maxMoveId = maxTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
            const MOVES = typeof window !== 'undefined' ? window.MOVES : null;
            const maxMoveData = (MOVES && MOVES[maxMoveId]) ? MOVES[maxMoveId] : {};
            const inheritedCat = m.cat || (maxMoveData.category === 'Physical' ? 'phys' : 'spec');
            return {
                name: maxTarget.name,
                cn: maxMoveData.cn || maxTarget.name,
                type: maxTarget.type,
                power: maxTarget.power,
                basePower: maxTarget.power,
                accuracy: 100,
                pp: 5,
                cat: inheritedCat,
                category: maxMoveData.category || (inheritedCat === 'phys' ? 'Physical' : 'Special'),
                isMax: true,
                isGMax: maxTarget.isGMax
            };
        });
        console.log(`[DYNAMAX] è‡ªåŠ¨æ¨å¯¼æå·¨æ‹›å¼:`, pokemon.moves.map(m => `${m.name}(${m.type}, pow:${m.power}, gmax:${m.isGMax})`));
    } else {
        // [OFF] å…³é—­æå·¨åŒ–
        console.log(`[DYNAMAX] ${pokemon.name} æ‹›å¼æ¢å¤ä¸ºæ™®é€šæ‹›å¼`);
        // è¿˜åŸæŠ€èƒ½
        if (pokemon._originalMoves) {
            pokemon.moves = pokemon._originalMoves;
            delete pokemon._originalMoves;
            console.log(`[DYNAMAX] æ‹›å¼å·²æ¢å¤:`, pokemon.moves.map(m => m.name));
        }
    }
}
/**
 * åº”ç”¨æå·¨åŒ– HP å˜åŒ–
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 * @param {number} multiplier HP å€ç‡ï¼ˆé»˜è®¤ 2ï¼‰
 */
function applyDynamaxHP(pokemon, isActive, multiplier = 2) {
    if (!pokemon) return;
    if (isActive) {
        // å¤‡ä»½åŸå§‹ HP
        pokemon._originalMaxHp = pokemon.maxHp;
        pokemon._originalCurrHp = pokemon.currHp;
        // HP ç¿»å€
        const hpRatio = pokemon.currHp / pokemon.maxHp;
        pokemon.maxHp = Math.floor(pokemon.maxHp * multiplier);
        pokemon.currHp = Math.floor(pokemon.maxHp * hpRatio);
        console.log(`[DYNAMAX] ${pokemon.name} HP: ${pokemon._originalCurrHp}/${pokemon._originalMaxHp} -> ${pokemon.currHp}/${pokemon.maxHp}`);
    } else {
        // æ¢å¤åŸå§‹ HP
        if (pokemon._originalMaxHp) {
            const hpRatio = pokemon.currHp / pokemon.maxHp;
            pokemon.maxHp = pokemon._originalMaxHp;
            pokemon.currHp = Math.max(1, Math.floor(pokemon.maxHp * hpRatio));
            delete pokemon._originalMaxHp;
            delete pokemon._originalCurrHp;
            console.log(`[DYNAMAX] ${pokemon.name} HP æ¢å¤: ${pokemon.currHp}/${pokemon.maxHp}`);
        }
    }
}
/**
 * å®Œæ•´çš„æå·¨åŒ–åˆ‡æ¢ï¼ˆæ‹›å¼ + HPï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 */
function toggleDynamax(pokemon, isActive) {
    if (!pokemon) return;
    applyDynamaxState(pokemon, isActive);
    applyDynamaxHP(pokemon, isActive);
    pokemon.isDynamaxed = isActive;
    if (isActive) {
        pokemon.dynamaxTurns = 3; // æå·¨åŒ–æŒç»­ 3 å›åˆ
    } else {
        pokemon.dynamaxTurns = 0;
    }
}
/**
 * å‡å°‘æå·¨åŒ–å›åˆæ•°
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {boolean} æ˜¯å¦åº”è¯¥ç»“æŸæå·¨åŒ–
 */
function tickDynamaxTurn(pokemon) {
    if (!pokemon || !pokemon.isDynamaxed) return false;
    pokemon.dynamaxTurns = (pokemon.dynamaxTurns || 0) - 1;
    if (pokemon.dynamaxTurns <= 0) {
        console.log(`[DYNAMAX] ${pokemon.name} æå·¨åŒ–ç»“æŸ`);
        return true;
    }
    console.log(`[DYNAMAX] ${pokemon.name} æå·¨åŒ–å‰©ä½™ ${pokemon.dynamaxTurns} å›åˆ`);
    return false;
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.applyDynamaxState = applyDynamaxState;
    window.applyDynamaxHP = applyDynamaxHP;
    window.toggleDynamax = toggleDynamax;
    window.tickDynamaxTurn = tickDynamaxTurn;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        applyDynamaxState,
        applyDynamaxHP,
        toggleDynamax,
        tickDynamaxTurn
    };
}
]]></file>
        <file name="mechanic-checker.js"><![CDATA[/**
 * ===========================================
 * MECHANIC-CHECKER.JS - æœºåˆ¶äº’æ–¥æ£€æŸ¥ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥æ¿€æ´»æŒ‡å®šæœºåˆ¶
 * - æœºåˆ¶äº’æ–¥é€»è¾‘ (Mega/Dynamax/Z-Move/Tera)
 * - é“å…·å†²çªæ£€æŸ¥
 */
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥æ¿€æ´»æŒ‡å®šæœºåˆ¶
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {string} mechanicType æœºåˆ¶ç±»å‹: 'mega' | 'dynamax' | 'zmove' | 'tera'
 * @returns {boolean} æ˜¯å¦å¯ä»¥æ¿€æ´»
 */
function canActivateMechanic(pokemon, mechanicType) {
    if (!pokemon) return false;
    // 1. å¦‚æœå¤„äºä»»ä½•ä¸€ç§ "Super State"ï¼Œåˆ™ç¦æ­¢å¼€å¯å¦ä¸€ç§
    const inBeastMode = pokemon.isMega || 
                        pokemon.isDynamaxed || 
                        pokemon.hasBondResonance ||
                        pokemon.isTera;
    if (inBeastMode) {
        console.log(`[MECHANIC] ${pokemon.name} å·²å¤„äºç‰¹æ®ŠçŠ¶æ€ï¼Œæ— æ³•æ¿€æ´» ${mechanicType}`);
        return false;
    }
    // 2. æ£€æŸ¥ JSON é…ç½®çš„ç³»ç»Ÿé”
    // å¦‚æœ JSON é‡Œ explicitly è®¾ç½®äº† mechanic: "dynamax"ï¼Œé‚£ä¹ˆå®ƒå°±ä¸èƒ½ Mega
    if (pokemon.mechanic && pokemon.mechanic !== mechanicType) {
        console.log(`[MECHANIC] ${pokemon.name} è¢«é”å®šä¸º ${pokemon.mechanic}ï¼Œæ— æ³•æ¿€æ´» ${mechanicType}`);
        return false;
    }
    // 3. é“å…·å†²çªæ£€æŸ¥
    // Mega çŸ³å’Œ Z çº¯æ™¶äº’æ–¥
    const item = (pokemon.item || '').toLowerCase();
    if (mechanicType === 'zmove' && item.includes('ite') && !item.includes('ium')) {
        // æºå¸¦ Mega çŸ³ï¼ˆå¦‚ Lucarioniteï¼‰æ— æ³•ä½¿ç”¨ Z æ‹›å¼
        console.log(`[MECHANIC] ${pokemon.name} æºå¸¦ Mega çŸ³ï¼Œæ— æ³•ä½¿ç”¨ Z æ‹›å¼`);
        return false;
    }
    if (mechanicType === 'mega' && item.includes('ium z')) {
        // æºå¸¦ Z çº¯æ™¶æ— æ³• Mega
        console.log(`[MECHANIC] ${pokemon.name} æºå¸¦ Z çº¯æ™¶ï¼Œæ— æ³• Mega è¿›åŒ–`);
        return false;
    }
    return true;
}
/**
 * æ£€æŸ¥æ˜¯å¦å¤„äºä»»ä½•ç‰¹æ®ŠçŠ¶æ€
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {boolean} æ˜¯å¦å¤„äºç‰¹æ®ŠçŠ¶æ€
 */
function isInSuperState(pokemon) {
    if (!pokemon) return false;
    return pokemon.isMega || 
           pokemon.isDynamaxed || 
           pokemon.hasBondResonance ||
           pokemon.isTera;
}
/**
 * è·å–å½“å‰æ¿€æ´»çš„æœºåˆ¶ç±»å‹
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {string|null} 'mega' | 'dynamax' | 'bond' | 'tera' | null
 */
function getActiveMechanic(pokemon) {
    if (!pokemon) return null;
    if (pokemon.isMega) return 'mega';
    if (pokemon.isDynamaxed) return 'dynamax';
    if (pokemon.hasBondResonance) return 'bond';
    if (pokemon.isTera) return 'tera';
    return null;
}
/**
 * æ£€æŸ¥é“å…·æ˜¯å¦ä¸º Mega çŸ³
 * @param {string} itemName é“å…·åç§°
 * @returns {boolean}
 */
function isMegaStoneItem(itemName) {
    if (!itemName) return false;
    const item = itemName.toLowerCase();
    // Mega çŸ³ä»¥ 'ite' ç»“å°¾ï¼Œä½†ä¸æ˜¯ 'eviolite'
    return item.endsWith('ite') && item !== 'eviolite';
}
/**
 * æ£€æŸ¥é“å…·æ˜¯å¦ä¸º Z çº¯æ™¶
 * @param {string} itemName é“å…·åç§°
 * @returns {boolean}
 */
function isZCrystalItem(itemName) {
    if (!itemName) return false;
    const item = itemName.toLowerCase();
    return item.endsWith('iumz') || item.endsWith('iniumz') || item.includes('ium z');
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.canActivateMechanic = canActivateMechanic;
    window.isInSuperState = isInSuperState;
    window.getActiveMechanic = getActiveMechanic;
    window.isMegaStoneItem = isMegaStoneItem;
    window.isZCrystalItem = isZCrystalItem;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        canActivateMechanic,
        isInSuperState,
        getActiveMechanic,
        isMegaStoneItem,
        isZCrystalItem
    };
}
]]></file>
        <file name="move-styles.js"><![CDATA[/**
 * ===========================================
 * MOVE-STYLES.JS - å¤æ­¦ç³»ç»Ÿï¼ˆæ‹›å¼é£æ ¼ï¼‰
 * ===========================================
 * 
 * èŒè´£:
 * - æ‹›å¼é£æ ¼çŠ¶æ€ç®¡ç† (é“/è¿…/åˆš)
 * - é£æ ¼åˆ‡æ¢ UI æ›´æ–°
 * - å†·å´çŠ¶æ€æ˜¾ç¤º
 */
// ============================================
// çŠ¶æ€ä¸å¸¸é‡
// ============================================
// å½“å‰é€‰æ‹©çš„æ‹›å¼é£æ ¼
let currentMoveStyle = 'normal';
// é£æ ¼åºåˆ—
const STYLE_SEQUENCE = ['normal', 'agile', 'strong'];
// é£æ ¼æ ‡ç­¾ï¼ˆä¸­æ–‡æ˜¾ç¤ºï¼‰
const STYLE_LABELS = {
    normal: 'é“',
    agile: 'è¿…',
    strong: 'åˆš'
};
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * è®¾ç½®å½“å‰æ‹›å¼é£æ ¼
 * @param {string} style - 'normal' | 'agile' | 'strong'
 * @param {{silent?: boolean, animate?: boolean}} options
 */
function setMoveStyle(style, options = {}) {
    if (!STYLE_SEQUENCE.includes(style)) style = 'normal';
    const prev = currentMoveStyle;
    currentMoveStyle = style;
    const orb = document.getElementById('btn-style-taiji');
    const label = document.getElementById('taiji-text');
    if (orb) {
        STYLE_SEQUENCE.forEach(cls => orb.classList.remove(cls));
        orb.classList.add(style);
        // ã€å†·å´çŠ¶æ€ã€‘æ£€æŸ¥æ˜¯å¦åœ¨å†·å´ä¸­ï¼Œå¦‚æœæ˜¯åˆ™æ·»åŠ  disabled æ ·å¼
        // éœ€è¦è®¿é—®å…¨å±€ battle å¯¹è±¡
        const battle = typeof window !== 'undefined' ? window.battle : null;
        if (battle && battle.playerStyleCooldown > 0) {
            orb.classList.add('cooldown');
            orb.style.opacity = '0.4';
            orb.style.filter = 'grayscale(80%)';
            orb.style.pointerEvents = 'none';
        } else {
            orb.classList.remove('cooldown');
            orb.style.opacity = '';
            orb.style.filter = '';
            orb.style.pointerEvents = '';
        }
    }
    if (label) {
        const nextChar = STYLE_LABELS[style] || 'é“';
        // ã€å†·å´çŠ¶æ€ã€‘å†·å´ä¸­æ˜¾ç¤ºç‰¹æ®Šå­—ç¬¦
        const battle = typeof window !== 'undefined' ? window.battle : null;
        const displayChar = (battle && battle.playerStyleCooldown > 0) ? 'ä¼‘' : nextChar;
        if (options.animate !== false && prev !== style) {
            animateTaijiText(label, displayChar);
        } else {
            label.textContent = displayChar;
        }
    }
    if (!options.silent) {
        console.log(`[STYLES] æ‹›å¼é£æ ¼åˆ‡æ¢ä¸º: ${style}`);
    }
}
/**
 * æ›´æ–°é£æ ¼æŒ‰é’®çš„å†·å´çŠ¶æ€æ˜¾ç¤º
 */
function updateStyleButtonCooldown() {
    const orb = document.getElementById('btn-style-taiji');
    const label = document.getElementById('taiji-text');
    if (!orb) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const isCooldown = battle && battle.playerStyleCooldown > 0;
    if (isCooldown) {
        orb.classList.add('cooldown');
        orb.style.opacity = '0.4';
        orb.style.filter = 'grayscale(80%)';
        orb.style.pointerEvents = 'none';
        if (label) label.textContent = 'ä¼‘';
    } else {
        orb.classList.remove('cooldown');
        orb.style.opacity = '';
        orb.style.filter = '';
        orb.style.pointerEvents = '';
        if (label) label.textContent = STYLE_LABELS[currentMoveStyle] || 'é“';
    }
}
/**
 * æ–‡å­—åˆ‡æ¢åŠ¨ç”»
 */
function animateTaijiText(el, newChar) {
    if (!el) return;
    el.style.transition = 'transform 0.15s ease, opacity 0.15s ease';
    el.style.transform = 'skewX(15deg) scale(0)';
    el.style.opacity = '0';
    setTimeout(() => {
        el.textContent = newChar;
        el.style.transform = 'skewX(15deg) scale(1.2)';
        el.style.opacity = '1';
        setTimeout(() => {
            el.style.transform = 'skewX(15deg) scale(1)';
        }, 150);
    }, 150);
}
/**
 * å¾ªç¯åˆ‡æ¢é£æ ¼ï¼šnormal -> agile -> strong -> normal
 */
function cycleMoveStyle() {
    const idx = STYLE_SEQUENCE.indexOf(currentMoveStyle);
    const nextStyle = STYLE_SEQUENCE[(idx + 1) % STYLE_SEQUENCE.length];
    setMoveStyle(nextStyle);
}
/**
 * è·å–å½“å‰æ‹›å¼é£æ ¼
 * @returns {string} 'normal' | 'agile' | 'strong'
 */
function getCurrentMoveStyle() {
    return currentMoveStyle;
}
/**
 * é‡ç½®æ‹›å¼é£æ ¼ä¸ºé»˜è®¤
 */
function resetMoveStyle() {
    currentMoveStyle = 'normal';
    setMoveStyle('normal', { silent: true, animate: false });
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.currentMoveStyle = currentMoveStyle;
    window.STYLE_SEQUENCE = STYLE_SEQUENCE;
    window.STYLE_LABELS = STYLE_LABELS;
    window.setMoveStyle = setMoveStyle;
    window.updateStyleButtonCooldown = updateStyleButtonCooldown;
    window.animateTaijiText = animateTaijiText;
    window.cycleMoveStyle = cycleMoveStyle;
    window.getCurrentMoveStyle = getCurrentMoveStyle;
    window.resetMoveStyle = resetMoveStyle;
    // ä½¿ç”¨ getter ä¿æŒ currentMoveStyle åŒæ­¥
    Object.defineProperty(window, 'currentMoveStyle', {
        get: () => currentMoveStyle,
        set: (val) => { currentMoveStyle = val; }
    });
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        STYLE_SEQUENCE,
        STYLE_LABELS,
        setMoveStyle,
        updateStyleButtonCooldown,
        animateTaijiText,
        cycleMoveStyle,
        getCurrentMoveStyle,
        resetMoveStyle,
        get currentMoveStyle() { return currentMoveStyle; },
        set currentMoveStyle(val) { currentMoveStyle = val; }
    };
}
]]></file>
        <file name="z-moves.js"><![CDATA[/**
 * ===========================================
 * Z-MOVES.JS - Z æ‹›å¼ä¸æå·¨åŒ–æ‹›å¼æ¨å¯¼ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - Z æ‹›å¼æ¨å¯¼ (é€šç”¨ Z / ä¸“å± Z)
 * - æå·¨åŒ–æ‹›å¼æ¨å¯¼ (Max Move / G-Max Move)
 * - æ‹›å¼æ˜ å°„è¡¨ç®¡ç†
 */
// ============================================
// é€šç”¨å±æ€§ Z æ‹›å¼è¡¨ (Type -> Z-Move Name)
// ============================================
const GENERIC_Z_BY_TYPE = {
    'Normal': 'Breakneck Blitz', 'Fire': 'Inferno Overdrive', 'Water': 'Hydro Vortex',
    'Grass': 'Bloom Doom', 'Electric': 'Gigavolt Havoc', 'Ice': 'Subzero Slammer',
    'Fighting': 'All-Out Pummeling', 'Poison': 'Acid Downpour', 'Ground': 'Tectonic Rage',
    'Flying': 'Supersonic Skystrike', 'Psychic': 'Shattered Psyche', 'Bug': 'Savage Spin-Out',
    'Rock': 'Continental Crush', 'Ghost': 'Never-Ending Nightmare', 'Dragon': 'Devastating Drake',
    'Dark': 'Black Hole Eclipse', 'Steel': 'Corkscrew Crash', 'Fairy': 'Twinkle Tackle'
};
// ============================================
// ä¸“å± Z çŸ©é˜µ (Signature Z Matrix)
// æ ¼å¼: "basemove+species" => "Z-Move Name"
// ============================================
const SIGNATURE_Z_MATRIX = {
    // çš®å¡ä¸˜ç³»
    'thunderbolt+pikachu': '10,000,000 Volt Thunderbolt',
    'volttackle+pikachu': 'Catastropika',
    'thunderbolt+raichu': 'Stoked Sparksurfer',
    'thunderbolt+raichualola': 'Stoked Sparksurfer',
    // ä¼Šå¸ƒ
    'lastresort+eevee': 'Extreme Evoboost',
    // å¡æ¯”å…½
    'gigaimpact+snorlax': 'Pulverizing Pancake',
    // å¾¡ä¸‰å®¶
    'darkestlariat+incineroar': 'Malicious Moonsault',
    'sparklingaria+primarina': 'Oceanic Operetta',
    'spiritshackle+decidueye': 'Sinister Arrow Raid',
    // ä¼ è¯´/ç¥å…½
    'photongeyser+necrozma': 'Light That Burns the Sky',
    'sunsteelstrike+solgaleo': 'Searing Sunraze Smash',
    'moongeistbeam+lunala': 'Menacing Moonraze Maelstrom',
    'spectralthief+marshadow': 'Soul-Stealing 7-Star Strike',
    'clangingscales+kommoo': 'Clangorous Soulblaze',
    'psychic+mew': 'Genesis Supernova',
    // å…¶ä»–
    'playrough+mimikyu': "Let's Snuggle Forever",
    'stoneedge+lycanroc': 'Splintered Stormshards',
    'naturesmadness+tapukoko': 'Guardian of Alola',
    'naturesmadness+tapulele': 'Guardian of Alola',
    'naturesmadness+tapubulu': 'Guardian of Alola',
    'naturesmadness+tapufini': 'Guardian of Alola'
};
// ============================================
// ä¸“å± Z ä¼˜å…ˆçº§è¡¨ (è¶Šé å‰ä¼˜å…ˆçº§è¶Šé«˜)
// ç”¨äºè§£å†³åŒä¸€åªå®å¯æ¢¦æœ‰å¤šä¸ªä¸“å± Z æ—¶çš„å†²çª
// ============================================
const SIGNATURE_Z_PRIORITY = [
    '10,000,000 Volt Thunderbolt', // æ™ºçš® Z (æœ€é«˜ä¼˜å…ˆçº§)
    'Catastropika',                 // çš®å¡ Z
    'Stoked Sparksurfer',           // é›·ä¸˜ Z
    'Extreme Evoboost',             // ä¼Šå¸ƒ Z
    'Clangorous Soulblaze',         // æ–å°¾é³ç”²é¾™ Z
    'Light That Burns the Sky',     // å¥ˆå…‹æ´›å…¹ç› Z
    'Searing Sunraze Smash',        // ç´¢å°”è¿¦é›·æ¬§ Z
    'Menacing Moonraze Maelstrom',  // éœ²å¥ˆé›…æ‹‰ Z
    'Soul-Stealing 7-Star Strike',  // ç›å¤å¤š Z
    'Malicious Moonsault',          // ç‚½ç„°å’†å“®è™ Z
    'Oceanic Operetta',             // è¥¿ç‹®æµ·å£¬ Z
    'Sinister Arrow Raid',          // ç‹™å°„æ ‘æ­ Z
    'Genesis Supernova',            // æ¢¦å¹» Z
    "Let's Snuggle Forever",        // è°œæ‹ŸQ Z
    'Splintered Stormshards',       // é¬ƒå²©ç‹¼äºº Z
    'Guardian of Alola',            // å¡ç’ Z
    'Pulverizing Pancake'           // å¡æ¯”å…½ Z
];
// ============================================
// é€šç”¨ Max æ‹›å¼è¡¨ (Type -> Max Move Name)
// ============================================
const GENERIC_MAX_BY_TYPE = {
    'Normal': 'Max Strike', 'Fire': 'Max Flare', 'Water': 'Max Geyser',
    'Grass': 'Max Overgrowth', 'Electric': 'Max Lightning', 'Ice': 'Max Hailstorm',
    'Fighting': 'Max Knuckle', 'Poison': 'Max Ooze', 'Ground': 'Max Quake',
    'Flying': 'Max Airstream', 'Psychic': 'Max Mindstorm', 'Bug': 'Max Flutterby',
    'Rock': 'Max Rockfall', 'Ghost': 'Max Phantasm', 'Dragon': 'Max Wyrmwind',
    'Dark': 'Max Darkness', 'Steel': 'Max Steelspike', 'Fairy': 'Max Starfall'
};
// ============================================
// åŠ¨æ€ç”Ÿæˆçš„æ˜ å°„è¡¨
// ============================================
// ä¸“å± Z æ‹›å¼åæŸ¥è¡¨ (BaseMove ID -> Z-Move Data)
const EXCLUSIVE_Z_MAP = {};
// G-Max ä¸“å±æ‹›å¼è¡¨ (Species -> { type, moveName })
const GMAX_MOVE_MAP = {};
// ============================================
// åˆå§‹åŒ–ï¼šä»æ•°æ®åº“æ„å»ºåæŸ¥è¡¨
// ============================================
(function buildMoveDerivationMaps() {
    if (typeof MOVES === 'undefined') {
        console.warn('[Z-MOVES] MOVES database not loaded');
        return;
    }
    // ä¸“å± Z æ‹›å¼çš„ baseMove æ˜ å°„ (æ‰‹åŠ¨ç»´æŠ¤ï¼Œå› ä¸ºæ•°æ®åº“æ²¡æœ‰è¿™ä¸ªå­—æ®µ)
    const EXCLUSIVE_Z_BASE_MOVES = {
        '10000000voltthunderbolt': 'thunderbolt',
        'catastropika': 'volttackle',
        'stokedsparksurfer': 'thunderbolt',
        'extremeevoboost': 'lastresort',
        'oceanicoperetta': 'sparklingaria',
        'maliciousmoonsault': 'darkestlariat',
        'soulstealing7starstrike': 'spectralthief',
        'sinisterarrowraid': 'spiritshackle',
        'clangoroussoulblaze': 'clangingscales',
        'lightthatburnsthesky': 'photongeyser',
        'searingsunrazesmash': 'sunsteelstrike',
        'menacingmoonrazemaelstrom': 'moongeistbeam',
        'letssnuggleforever': 'playrough',
        'splinteredstormshards': 'stoneedge',
        'pulverizingpancake': 'gigaimpact',
        'genesis supernova': 'psychic'
    };
    // éå†æ‰€æœ‰æ‹›å¼ï¼Œæ„å»ºæ˜ å°„è¡¨
    for (const moveId in MOVES) {
        const moveData = MOVES[moveId];
        // æ„å»ºä¸“å± Z æ‹›å¼åæŸ¥è¡¨
        if (moveData.isZ && typeof moveData.isZ === 'string') {
            const baseMove = EXCLUSIVE_Z_BASE_MOVES[moveId];
            if (baseMove) {
                EXCLUSIVE_Z_MAP[baseMove] = {
                    name: moveData.name,
                    id: moveId,
                    type: moveData.type,
                    basePower: moveData.basePower || 180,
                    zCrystal: moveData.isZ
                };
            }
        }
        // æ„å»º G-Max ä¸“å±æ‹›å¼è¡¨
        if (moveData.isMax && typeof moveData.isMax === 'string') {
            const species = moveData.isMax.toLowerCase().replace(/[^a-z0-9]/g, '');
            GMAX_MOVE_MAP[species] = {
                name: moveData.name,
                id: moveId,
                type: moveData.type,
                basePower: moveData.basePower || 130
            };
        }
    }
    console.log('[Z-MOVES] Built EXCLUSIVE_Z_MAP:', Object.keys(EXCLUSIVE_Z_MAP).length, 'entries');
    console.log('[Z-MOVES] Built GMAX_MOVE_MAP:', Object.keys(GMAX_MOVE_MAP).length, 'entries');
})();
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * è®¡ç®—å®å¯æ¢¦çš„"å‘½ä¸­æ³¨å®šä¸“å± Z"ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªï¼‰
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {string|null} æœ€é«˜ä¼˜å…ˆçº§çš„ä¸“å± Z åç§°ï¼Œæˆ– null
 */
function calculateBestZForPokemon(pokemon) {
    // ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤è®¡ç®—
    if (pokemon._cachedBestZ !== undefined) return pokemon._cachedBestZ;
    const speciesId = (pokemon.name || '').toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(partner|alola|galar|gmax|mega|cap)/g, '');
    let bestFound = null;
    let highestPrio = Infinity;
    // éå†ç²¾çµæ‰€æœ‰æ‹›å¼ï¼Œæ‰¾å‡ºä¼˜å…ˆçº§æœ€é«˜çš„ä¸“å± Z
    (pokemon.moves || []).forEach(m => {
        const moveId = (m.name || m || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        const matrixKey = `${moveId}+${speciesId}`;
        const targetZName = SIGNATURE_Z_MATRIX[matrixKey];
        if (targetZName) {
            let prio = SIGNATURE_Z_PRIORITY.indexOf(targetZName);
            if (prio === -1) prio = 999; // æœªæ’åºçš„é»˜è®¤å¾ˆä½
            if (prio < highestPrio) {
                highestPrio = prio;
                bestFound = targetZName;
            }
        }
    });
    // ç¼“å­˜ç»“æœ
    pokemon._cachedBestZ = bestFound;
    return bestFound;
}
/**
 * è·å–æ‹›å¼å¯¹åº”çš„ Z æ‹›å¼åç§° (å•ä¸€ Z é”å®šç­–ç•¥)
 * @param {Object} baseMoveObj - åŸå§‹æ‹›å¼å¯¹è±¡
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {Object|null} Z æ‹›å¼ä¿¡æ¯ { name, type, power } æˆ– null
 */
function getZMoveTarget(baseMoveObj, pokemon) {
    // 0. åŸºç¡€é—¨æ§›
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (battle && battle.playerUnlocks && !battle.playerUnlocks.enable_z_move) return null;
    if (pokemon.mechanic !== 'zmove') return null;
    if (pokemon.isMega || pokemon.isDynamaxed || pokemon.hasBondResonance) return null;
    if (baseMoveObj.category === 'Status' || baseMoveObj.cat === 'status') return null;
    // å‡†å¤‡ Key
    const moveId = (baseMoveObj.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveType = baseMoveObj.type || 'Normal';
    const speciesRoot = (pokemon.name || '').toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(partner|alola|galar|gmax|mega|cap)/g, '');
    // 1. è·å–è¿™åªå®å¯æ¢¦"å‘½ä¸­æ³¨å®š"çš„ä¸“å± Zï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªï¼‰
    const theOneZ = calculateBestZForPokemon(pokemon);
    // 2. æ£€æŸ¥å½“å‰æ‹›å¼æ˜¯å¦èƒ½äº§ç”Ÿä¸“å± Z
    const sigKey = `${moveId}+${speciesRoot}`;
    const potentialZ = SIGNATURE_Z_MATRIX[sigKey];
    if (potentialZ) {
        // å…³é”®åˆ¤æ–­ï¼šåªæœ‰å½“è¿™ä¸ªæ‹›å¼äº§ç”Ÿçš„ Z ç­‰äº"å‘½ä¸­æ³¨å®š"çš„ Z æ—¶ï¼Œæ‰ç‚¹äº®
        if (potentialZ === theOneZ) {
            return {
                name: potentialZ,
                type: moveType,
                power: 200,
                isExclusive: true
            };
        }
        // è™½ç„¶æ˜¯ä¸“å±æ‹›å¼ï¼Œä½†å› ä¼˜å…ˆçº§è¾“äº†ï¼Œè¿”å› null
        return null;
    }
    // 3. å¦‚æœè¿™åªå®å¯æ¢¦æ²¡æœ‰ä»»ä½•ä¸“å± Z èƒ½åŠ›ï¼Œå…è®¸é€šç”¨ Z
    if (!theOneZ) {
        if (GENERIC_Z_BY_TYPE[moveType]) {
            const basePower = baseMoveObj.basePower || baseMoveObj.power || 60;
            let zPower = 100;
            if (basePower >= 140) zPower = 200;
            else if (basePower >= 130) zPower = 195;
            else if (basePower >= 120) zPower = 190;
            else if (basePower >= 110) zPower = 185;
            else if (basePower >= 100) zPower = 180;
            else if (basePower >= 90) zPower = 175;
            else if (basePower >= 80) zPower = 160;
            else if (basePower >= 70) zPower = 140;
            else if (basePower >= 60) zPower = 120;
            else zPower = 100;
            return {
                name: GENERIC_Z_BY_TYPE[moveType],
                type: moveType,
                power: zPower,
                isExclusive: false
            };
        }
    }
    // 4. å¦‚æœè¿™åªå®å¯æ¢¦æœ‰ä¸“å± Zï¼ˆtheOneZ å­˜åœ¨ï¼‰ï¼Œå…¶ä»–æ‹›å¼ä¸èƒ½å˜æˆé€šç”¨ Z
    return null;
}
/**
 * è·å–æ‹›å¼å¯¹åº”çš„æå·¨åŒ–æ‹›å¼åç§°
 * @param {Object} baseMoveObj - åŸå§‹æ‹›å¼å¯¹è±¡
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {Object|null} Max æ‹›å¼ä¿¡æ¯ { name, type, power } æˆ– null
 */
function getMaxMoveTarget(baseMoveObj, pokemon) {
    // å˜åŒ–æŠ€å˜æˆ Max Guard
    if (baseMoveObj.category === 'Status' || baseMoveObj.cat === 'status') {
        return {
            name: 'Max Guard',
            type: 'Normal',
            power: 0,
            isGMax: false
        };
    }
    const moveType = baseMoveObj.type || 'Normal';
    // è·å–ç²¾çµçš„åŸºç¡€ ID (å»é™¤ gmax/mega ç­‰åç¼€)
    const pokeName = pokemon.name || '';
    const species = pokeName.toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(gmax|mega|gigantamax)/g, '');
    // æ£€æŸ¥æ˜¯å¦æœ‰ G-Max ä¸“å±æ‹›å¼
    if (GMAX_MOVE_MAP[species]) {
        const gmaxData = GMAX_MOVE_MAP[species];
        // æ£€æŸ¥æ‹›å¼ç±»å‹æ˜¯å¦åŒ¹é… G-Max æ‹›å¼ç±»å‹
        if (gmaxData.type === moveType) {
            return {
                name: gmaxData.name,
                type: gmaxData.type,
                power: gmaxData.basePower || 130,
                isGMax: true
            };
        }
    }
    // é€šç”¨ Max æ‹›å¼
    const genericMaxName = GENERIC_MAX_BY_TYPE[moveType];
    if (genericMaxName) {
        // Max æ‹›å¼å¨åŠ›æ ¹æ®åŸæ‹›å¼å¨åŠ›è®¡ç®—
        const basePower = baseMoveObj.basePower || baseMoveObj.power || 60;
        let maxPower = 90;
        if (basePower >= 150) maxPower = 150;
        else if (basePower >= 110) maxPower = 140;
        else if (basePower >= 75) maxPower = 130;
        else if (basePower >= 65) maxPower = 120;
        else if (basePower >= 55) maxPower = 110;
        else if (basePower >= 45) maxPower = 100;
        else maxPower = 90;
        return {
            name: genericMaxName,
            type: moveType,
            power: maxPower,
            isGMax: false
        };
    }
    return null;
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.GENERIC_Z_BY_TYPE = GENERIC_Z_BY_TYPE;
    window.SIGNATURE_Z_MATRIX = SIGNATURE_Z_MATRIX;
    window.SIGNATURE_Z_PRIORITY = SIGNATURE_Z_PRIORITY;
    window.GENERIC_MAX_BY_TYPE = GENERIC_MAX_BY_TYPE;
    window.EXCLUSIVE_Z_MAP = EXCLUSIVE_Z_MAP;
    window.GMAX_MOVE_MAP = GMAX_MOVE_MAP;
    window.calculateBestZForPokemon = calculateBestZForPokemon;
    window.getZMoveTarget = getZMoveTarget;
    window.getMaxMoveTarget = getMaxMoveTarget;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        GENERIC_Z_BY_TYPE,
        SIGNATURE_Z_MATRIX,
        SIGNATURE_Z_PRIORITY,
        GENERIC_MAX_BY_TYPE,
        EXCLUSIVE_Z_MAP,
        GMAX_MOVE_MAP,
        calculateBestZForPokemon,
        getZMoveTarget,
        getMaxMoveTarget
    };
}
]]></file>
    </directory>
    <directory name="scripts">
        <file name="bundle-trainer-data.js"><![CDATA[const fs = require('fs');
const path = require('path');
const baseDir = __dirname;
const trainerPath = path.resolve(baseDir, '..', 'TRAINER_data.js');
const pluginPath = path.join(baseDir, 'pkm-tavern-plugin.js');
const asyncMarker = '(async function() {';
const inlineMarker = '// ---------------------------------------------------------------\n//  ä»¥ä¸‹ä¸ºå†…ç½®çš„ trainer_data.js';
function bundleTrainerData() {
  if (!fs.existsSync(trainerPath)) {
    throw new Error(`æ— æ³•æ‰¾åˆ°è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶: ${trainerPath}`);
  }
  if (!fs.existsSync(pluginPath)) {
    throw new Error(`æ— æ³•æ‰¾åˆ°æ’ä»¶æ–‡ä»¶: ${pluginPath}`);
  }
  const trainerRaw = fs.readFileSync(trainerPath, 'utf8').trimEnd();
  const trainerContent = `${trainerRaw}\n`;
  const pluginContent = fs.readFileSync(pluginPath, 'utf8');
  const asyncIndex = pluginContent.indexOf(asyncMarker);
  if (asyncIndex === -1) {
    throw new Error('æœªåœ¨æ’ä»¶ä¸­æ‰¾åˆ° (async function() { æ ‡è®°ï¼Œæ— æ³•æ’å…¥æ•°æ®');
  }
  const inlineIndex = pluginContent.indexOf(inlineMarker);
  const header = inlineIndex !== -1
    ? pluginContent.slice(0, inlineIndex)
    : pluginContent.slice(0, asyncIndex);
  const after = pluginContent.slice(asyncIndex);
  const prefix = `${header}// ---------------------------------------------------------------\n//  ä»¥ä¸‹ä¸ºå†…ç½®çš„ trainer_data.jsï¼ˆè‡ªåŠ¨æ‰“åŒ…ç”Ÿæˆï¼‰\n// ---------------------------------------------------------------\n${trainerContent}\n`;
  const bundled = prefix + after;
  fs.writeFileSync(pluginPath, bundled, 'utf8');
  console.log('å·²å°† trainer_data.js å†…è”åˆ° pkm-tavern-plugin.js');
}
bundleTrainerData();
]]></file>
        <file name="convert-showdown-data.js"><![CDATA[#!/usr/bin/env node
/**
 * Pokemon Showdown æ•°æ®è½¬æ¢è„šæœ¬
 * å°† TypeScript æ ¼å¼çš„ pokedex.ts å’Œ moves.ts è½¬æ¢ä¸ºæµè§ˆå™¨å¯ç”¨çš„çº¯ JS
 * 
 * ä½¿ç”¨æ–¹æ³•ï¼š
 *   node convert-showdown-data.js
 * 
 * è¾“å‡ºï¼š
 *   - pokedex-data.js  (å®å¯æ¢¦æ•°æ®åº“)
 *   - moves-data.js    (æŠ€èƒ½æ•°æ®åº“)
 */
const fs = require('fs');
const path = require('path');
const SHOWDOWN_DIR = path.join(__dirname, 'Pokemon Showdown');
const OUTPUT_DIR = __dirname;
// ============================================================
// 1. è½¬æ¢ Pokedex (å®å¯æ¢¦æ•°æ®)
// ============================================================
function convertPokedex() {
    console.log('Converting pokedex.ts...');
    const inputPath = path.join(SHOWDOWN_DIR, 'pokedex.ts');
    const outputPath = path.join(OUTPUT_DIR, 'pokedex-data.js');
    let content = fs.readFileSync(inputPath, 'utf-8');
    // ç§»é™¤ TypeScript ç±»å‹æ³¨è§£
    content = content.replace(
        /^export const Pokedex:\s*import\([^)]+\)\.[^\s=]+ = /m,
        'const POKEDEX = '
    );
    // æ·»åŠ æ–‡ä»¶å¤´æ³¨é‡Š
    const header = `/**
 * Pokemon Showdown Pokedex Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/pokedex.ts
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="pokedex-data.js"></script>
 *   console.log(POKEDEX.pikachu.baseStats);
 */
`;
    content = header + content;
    fs.writeFileSync(outputPath, content, 'utf-8');
    console.log(`  -> ${outputPath}`);
    // ç»Ÿè®¡æ•°é‡
    const count = (content.match(/^\t[a-z]/gm) || []).length;
    console.log(`  -> ${count} Pokemon entries`);
}
// ============================================================
// 2. è½¬æ¢ Moves - ä½¿ç”¨ eval ç›´æ¥è§£æï¼Œæå–çº¯æ•°æ®
// ============================================================
function convertMoves() {
    console.log('Converting moves.ts (extracting static data only)...');
    const inputPath = path.join(SHOWDOWN_DIR, 'moves.ts');
    const outputPath = path.join(OUTPUT_DIR, 'moves-data.js');
    let content = fs.readFileSync(inputPath, 'utf-8');
    // ç§»é™¤ TypeScript ç±»å‹æ³¨è§£
    content = content.replace(
        /^export const Moves:\s*import\([^)]+\)\.[^\s=]+ = /m,
        'const Moves = '
    );
    // ç§»é™¤æ³¨é‡Š
    content = content.replace(/^\/\/.*$/gm, '');
    // ç§»é™¤æ‰€æœ‰å‡½æ•° - ä½¿ç”¨é€’å½’åŒ¹é…å¤§æ‹¬å·
    // åŒ¹é…å½¢å¦‚: funcName(args) { ... } æˆ– funcName: function(args) { ... }
    function removeFunctions(str) {
        let result = str;
        let changed = true;
        while (changed) {
            changed = false;
            // ç§»é™¤æ–¹æ³•å®šä¹‰: name(args) { body }
            // éœ€è¦æ­£ç¡®åŒ¹é…åµŒå¥—å¤§æ‹¬å·
            const funcRegex = /(\w+)\s*\([^)]*\)\s*\{/g;
            let match;
            while ((match = funcRegex.exec(result)) !== null) {
                const startIdx = match.index;
                const braceStart = result.indexOf('{', startIdx);
                // æ‰¾åˆ°åŒ¹é…çš„ç»“æŸå¤§æ‹¬å·
                let depth = 1;
                let endIdx = braceStart + 1;
                while (depth > 0 && endIdx < result.length) {
                    if (result[endIdx] === '{') depth++;
                    if (result[endIdx] === '}') depth--;
                    endIdx++;
                }
                if (depth === 0) {
                    // æ£€æŸ¥è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªæ–¹æ³•å®šä¹‰ï¼ˆä¸æ˜¯å¯¹è±¡å­—é¢é‡ï¼‰
                    const beforeMatch = result.substring(Math.max(0, startIdx - 10), startIdx);
                    if (!beforeMatch.match(/:\s*$/)) {
                        // è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•å®šä¹‰ï¼Œæ›¿æ¢ä¸º null
                        const funcName = match[1];
                        const replacement = `${funcName}: null`;
                        result = result.substring(0, startIdx) + replacement + result.substring(endIdx);
                        changed = true;
                        break;
                    }
                }
            }
        }
        return result;
    }
    content = removeFunctions(content);
    // ç§»é™¤ TypeScript ç‰¹æœ‰è¯­æ³•
    content = content.replace(/!\./g, '.'); // éç©ºæ–­è¨€
    content = content.replace(/!,/g, ',');
    content = content.replace(/!\)/g, ')');
    content = content.replace(/!\]/g, ']');
    content = content.replace(/!\}/g, '}');
    content = content.replace(/ as \w+/g, '');
    content = content.replace(/<[A-Za-z\[\]|, ]+>/g, '');
    // ç§»é™¤ condition å—ï¼ˆåŒ…å«å¤æ‚é€»è¾‘ï¼‰
    function removeConditionBlocks(str) {
        let result = str;
        const conditionRegex = /condition:\s*\{/g;
        let match;
        while ((match = conditionRegex.exec(result)) !== null) {
            const startIdx = match.index;
            const braceStart = result.indexOf('{', startIdx);
            let depth = 1;
            let endIdx = braceStart + 1;
            while (depth > 0 && endIdx < result.length) {
                if (result[endIdx] === '{') depth++;
                if (result[endIdx] === '}') depth--;
                endIdx++;
            }
            if (depth === 0) {
                // ç§»é™¤æ•´ä¸ª condition å—
                result = result.substring(0, startIdx) + 'condition: null' + result.substring(endIdx);
            }
        }
        return result;
    }
    content = removeConditionBlocks(content);
    // æ·»åŠ æ–‡ä»¶å¤´
    const header = `/**
 * Pokemon Showdown Moves Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/moves.ts
 * 
 * æ³¨æ„: å‡½æ•°å›è°ƒã€condition å—å·²è¢«ç§»é™¤ï¼Œä»…ä¿ç•™é™æ€æ•°æ®
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="moves-data.js"></script>
 *   console.log(MOVES.thunderbolt.basePower); // 90
 */
`;
    // é‡å‘½åå˜é‡
    content = content.replace(/const Moves = /, 'const MOVES = ');
    content = header + content;
    fs.writeFileSync(outputPath, content, 'utf-8');
    console.log(`  -> ${outputPath}`);
    // ç»Ÿè®¡æ•°é‡
    const count = (content.match(/^\t[a-z"]/gm) || []).length;
    console.log(`  -> ${count} Move entries`);
}
// ============================================================
// 3. éªŒè¯ç”Ÿæˆçš„æ–‡ä»¶
// ============================================================
function validateFiles() {
    console.log('Validating generated files...');
    const pokedexPath = path.join(OUTPUT_DIR, 'pokedex-data.js');
    const movesPath = path.join(OUTPUT_DIR, 'moves-data.js');
    // éªŒè¯ pokedex
    try {
        const vm = require('vm');
        const pokedexContent = fs.readFileSync(pokedexPath, 'utf-8');
        vm.runInNewContext(pokedexContent);
        console.log('  -> pokedex-data.js: OK');
    } catch (e) {
        console.log('  -> pokedex-data.js: ERROR -', e.message);
    }
    // éªŒè¯ moves
    try {
        const vm = require('vm');
        const movesContent = fs.readFileSync(movesPath, 'utf-8');
        vm.runInNewContext(movesContent);
        console.log('  -> moves-data.js: OK');
    } catch (e) {
        console.log('  -> moves-data.js: ERROR -', e.message.substring(0, 100));
    }
}
// ============================================================
// Main
// ============================================================
function main() {
    console.log('='.repeat(60));
    console.log('Pokemon Showdown Data Converter');
    console.log('='.repeat(60));
    const pokedexPath = path.join(SHOWDOWN_DIR, 'pokedex.ts');
    const movesPath = path.join(SHOWDOWN_DIR, 'moves.ts');
    const hasPokedex = fs.existsSync(pokedexPath);
    const hasMoves = fs.existsSync(movesPath);
    if (!hasPokedex) {
        console.warn('Warning: pokedex.ts not found. Skipping pokedex-data.js generation.');
    }
    if (!hasMoves) {
        console.error('Error: moves.ts not found in', SHOWDOWN_DIR);
        process.exit(1);
    }
    if (hasPokedex) {
        convertPokedex();
    }
    convertMoves();
    validateFiles();
    console.log('='.repeat(60));
    console.log('Done! Files generated:');
    console.log('  - pokedex-data.js');
    console.log('  - moves-data.js');
    console.log('');
    console.log('Usage in HTML:');
    console.log('  <script src="pokedex-data.js"></script>');
    console.log('  <script src="moves-data.js"></script>');
    console.log('='.repeat(60));
}
main();
]]></file>
        <file name="inline-trainer-data.js"><![CDATA[const fs = require('fs');
const path = require('path');
const baseDir = __dirname;
const trainerDataPath = path.resolve(baseDir, '..', 'TRAINER_data.js');
const pluginPath = path.join(baseDir, 'pkm-tavern-plugin.js');
console.log('å¼€å§‹å†…è”è®­ç»ƒå®¶æ•°æ®...');
console.log(`è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶: ${trainerDataPath}`);
console.log(`æ’ä»¶æ–‡ä»¶: ${pluginPath}`);
// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if (!fs.existsSync(trainerDataPath)) {
  console.error(`âŒ é”™è¯¯: æ‰¾ä¸åˆ°è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶ ${trainerDataPath}`);
  process.exit(1);
}
if (!fs.existsSync(pluginPath)) {
  console.error(`âŒ é”™è¯¯: æ‰¾ä¸åˆ°æ’ä»¶æ–‡ä»¶ ${pluginPath}`);
  process.exit(1);
}
// è¯»å–è®­ç»ƒå®¶æ•°æ®
const trainerData = fs.readFileSync(trainerDataPath, 'utf8');
console.log(`âœ“ å·²è¯»å–è®­ç»ƒå®¶æ•°æ® (${trainerData.length} å­—ç¬¦)`);
// è¯»å–æ’ä»¶æ–‡ä»¶
let pluginContent = fs.readFileSync(pluginPath, 'utf8');
console.log(`âœ“ å·²è¯»å–æ’ä»¶æ–‡ä»¶ (${pluginContent.length} å­—ç¬¦)`);
// ç§»é™¤æ—§çš„å†…è”å†…å®¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
const inlineStartMarker = '// ================================================================\n//  ä»¥ä¸‹ä¸ºå†…è”çš„è®­ç»ƒå®¶æ•°æ® (è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘)\n// ================================================================';
const inlineEndMarker = '// ================================================================\n//  è®­ç»ƒå®¶æ•°æ®å†…è”ç»“æŸ\n// ================================================================';
const startIdx = pluginContent.indexOf(inlineStartMarker);
const endIdx = pluginContent.indexOf(inlineEndMarker);
if (startIdx !== -1 && endIdx !== -1) {
  const endOfBlock = endIdx + inlineEndMarker.length;
  // ç§»é™¤æ—§çš„å†…è”å—ï¼ˆåŒ…æ‹¬åé¢çš„ç©ºè¡Œï¼‰
  let afterBlock = pluginContent.substring(endOfBlock);
  // å»æ‰å¼€å¤´çš„ç©ºè¡Œ
  afterBlock = afterBlock.replace(/^\n+/, '\n');
  pluginContent = afterBlock;
  console.log('âœ“ å·²ç§»é™¤æ—§çš„å†…è”å†…å®¹');
}
// æŸ¥æ‰¾æ’å…¥ä½ç½® - åœ¨ (async function() { ä¹‹å‰
const asyncMarker = '(async function() {';
const insertIndex = pluginContent.indexOf(asyncMarker);
if (insertIndex === -1) {
  console.error('âŒ é”™è¯¯: åœ¨æ’ä»¶æ–‡ä»¶ä¸­æ‰¾ä¸åˆ° (async function() { æ ‡è®°');
  process.exit(1);
}
console.log(`âœ“ æ‰¾åˆ°æ’å…¥ä½ç½®: ç¬¬ ${insertIndex} ä¸ªå­—ç¬¦`);
// æ„å»ºæ–°çš„æ’ä»¶å†…å®¹ - ç›´æ¥åœ¨æ–‡ä»¶å¼€å¤´æ’å…¥è®­ç»ƒå®¶æ•°æ®
const inlineBlock = `// ================================================================
//  ä»¥ä¸‹ä¸ºå†…è”çš„è®­ç»ƒå®¶æ•°æ® (è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘)
// ================================================================
${trainerData}
// ================================================================
//  è®­ç»ƒå®¶æ•°æ®å†…è”ç»“æŸ
// ================================================================
`;
const newPluginContent = inlineBlock + pluginContent;
// å†™å…¥æ–°çš„æ’ä»¶æ–‡ä»¶
fs.writeFileSync(pluginPath, newPluginContent, 'utf8');
console.log('âœ“ è®­ç»ƒå®¶æ•°æ®å·²æˆåŠŸå†…è”åˆ°æ’ä»¶æ–‡ä»¶');
console.log(`æ–°æ’ä»¶æ–‡ä»¶å¤§å°: ${newPluginContent.length} å­—ç¬¦`);
console.log('å®Œæˆï¼');
]]></file>
    </directory>
    <directory name="systems">
        <file name="audio-manager.js"><![CDATA[/**
 * ===========================================
 * AUDIO-MANAGER.JS - éŸ³æ•ˆç®¡ç†ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - é¢„åŠ è½½çŸ­éŸ³æ•ˆ (æé«˜å“åº”é€Ÿåº¦)
 * - å®ç°å¹¶å‘æ’­æ”¾ (cloneNode)
 * - ä¸ BGM ç³»ç»ŸååŒå·¥ä½œ
 */
// ============================================
// è·¯å¾„å…¼å®¹ (GitHub Pages)
// ============================================
function getSfxBasePath() {
    const path = window.location.pathname;
    if (path.includes('/pkm12/')) {
        return path.substring(0, path.indexOf('/pkm12/') + 7);
    }
    return './';
}
const SFX_BASE_PATH = getSfxBasePath();
// ============================================
// SFX é…ç½®è¡¨
// ============================================
const SFX_CONFIG = {
    // UI ç±»
    'CONFIRM':    `${SFX_BASE_PATH}data/sfx/ui_01_confirm.mp3`,
    'CANCEL':     `${SFX_BASE_PATH}data/sfx/ui_01_confirm.mp3`,
    // æˆ˜æ–—åé¦ˆç±»
    'HIT_NORMAL': `${SFX_BASE_PATH}data/sfx/hit_00_normal.mp3`,
    'HIT_SUPER':  `${SFX_BASE_PATH}data/sfx/Hit_Super_Effective_XY.mp3`,
    'HIT_WEAK':   `${SFX_BASE_PATH}data/sfx/hit_02_weak.mp3`,
    // èƒ½åŠ›å˜åŒ–ç±»
    'STAT_UP':    `${SFX_BASE_PATH}data/sfx/stat_up.mp3`,
    'STAT_DOWN':  `${SFX_BASE_PATH}data/sfx/stat_down.mp3`,
    // äº‹ä»¶ç±»
    'FAINT':      `${SFX_BASE_PATH}data/sfx/battle_faint.mp3`,
    'HEAL':       `${SFX_BASE_PATH}data/sfx/battle_heal.mp3`,
    'THROW':      `${SFX_BASE_PATH}data/sfx/ball_throw.mp3`,
    'BALL_OPEN':  `${SFX_BASE_PATH}data/sfx/ball_open.mp3`
};
// ============================================
// SFX éŸ³é‡é…ç½®è¡¨ (0.0 - 1.0)
// ============================================
const SFX_VOLUME_CONFIG = {
    'CONFIRM':    0.5,
    'CANCEL':     0.5,
    'HIT_NORMAL': 0.6,
    'HIT_SUPER':  0.7,
    'HIT_WEAK':   0.5,
    'STAT_UP':    0.3,
    'STAT_DOWN':  0.3,
    'FAINT':      0.6,
    'HEAL':       0.5,
    'THROW':      0.6,
    'BALL_OPEN':  0.6
};
// éŸ³é¢‘ç¼“å­˜æ± 
const sfxCache = {};
// ============================================
// é¢„åŠ è½½ SFX
// ============================================
(function preloadSFX() {
    console.log('[SFX] Starting preload...');
    let loadedCount = 0;
    for (const [key, path] of Object.entries(SFX_CONFIG)) {
        const audio = new Audio();
        audio.src = path;
        audio.preload = 'auto';
        audio.volume = SFX_VOLUME_CONFIG[key] || 0.6;
        audio.addEventListener('canplaythrough', () => {
            loadedCount++;
            if (loadedCount === Object.keys(SFX_CONFIG).length) {
                console.log(`[SFX] All ${loadedCount} files preloaded.`);
            }
        }, { once: true });
        audio.addEventListener('error', () => {
            console.warn(`[SFX] Failed to load: ${key} (${path})`);
        }, { once: true });
        sfxCache[key] = audio;
    }
    console.log(`[SFX] Queued ${Object.keys(sfxCache).length} files for preload.`);
})();
// ============================================
// æ’­æ”¾ SFX (æ”¯æŒå¹¶å‘)
// ============================================
/**
 * æ’­æ”¾çŸ­éŸ³æ•ˆ (æ”¯æŒå¹¶å‘)
 * @param {string} key - SFX_CONFIG ä¸­çš„é”®å
 * @param {number} volumeOverride - å¯é€‰çš„éŸ³é‡è¦†ç›– (0.0 - 1.0)
 */
function playSFX(key, volumeOverride = null) {
    const original = sfxCache[key];
    if (!original) {
        return;
    }
    try {
        const clone = original.cloneNode();
        clone.volume = volumeOverride !== null 
            ? volumeOverride 
            : (SFX_VOLUME_CONFIG[key] || 0.6);
        clone.play().catch(() => {
            // å¿½ç•¥æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶é”™è¯¯
        });
    } catch (e) {
        console.error('[SFX] Play error:', e);
    }
}
/**
 * æ ¹æ®ä¼¤å®³æ•ˆæœæ’­æ”¾å¯¹åº”æ‰“å‡»éŸ³æ•ˆ
 * @param {number} effectiveness - å…‹åˆ¶å€ç‡
 * @param {boolean} isCrit - æ˜¯å¦æš´å‡»
 */
function playHitSFX(effectiveness, isCrit = false) {
    if (isCrit || effectiveness >= 2) {
        playSFX('HIT_SUPER');
    } else if (effectiveness > 0 && effectiveness <= 0.5) {
        playSFX('HIT_WEAK');
    } else {
        playSFX('HIT_NORMAL');
    }
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
window.playSFX = playSFX;
window.playHitSFX = playHitSFX;
window.SFX_CONFIG = SFX_CONFIG;
// ============================================
// å®å¯æ¢¦å«å£°ç³»ç»Ÿ
// ============================================
const CRY_VOLUME = 0.45;
/**
 * æ’­æ”¾å®å¯æ¢¦å«å£° (åœ¨çº¿æ‹‰å– Showdown éŸ³é¢‘åº“)
 * @param {string} speciesName - å®å¯æ¢¦åå­— (å¦‚ "Pikachu", "Charizard-Mega-Y")
 */
window.playPokemonCry = function(speciesName) {
    if (!speciesName) return;
    // ä¼˜å…ˆä½¿ç”¨é¢„åŠ è½½ç¼“å­˜
    if (typeof playCachedCry === 'function') {
        playCachedCry(speciesName, CRY_VOLUME);
        return;
    }
    // Fallback: åœ¨çº¿åŠ è½½
    let id = speciesName.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (typeof POKEDEX !== 'undefined' && POKEDEX[id]) {
        if (POKEDEX[id].baseSpecies) {
            id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
    }
    const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
    for (const s of suffixes) {
        if (id.endsWith(s) && id.length > s.length) {
            id = id.replace(s, '');
            break;
        }
    }
    const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
    const cryAudio = new Audio(url);
    cryAudio.volume = CRY_VOLUME;
    cryAudio.play().catch(() => {});
    console.log(`[CRY] Playing online: ${speciesName} -> ${id}`);
};
]]></file>
        <file name="bgm-system.js"><![CDATA[/**
 * ===========================================
 * BGM-SYSTEM.JS - èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
 * ===========================================
 * 
 * æ´›è¿ªäºšç‰¹åŒº BGM ç®¡ç†ç³»ç»Ÿ
 * 
 * èŒè´£:
 * - æˆ˜æ–— BGM é€‰æ‹© (æ ¹æ®ç­‰çº§/è®­ç»ƒå®¶ç±»å‹)
 * - èƒœåˆ©éŸ³ä¹æ’­æ”¾ (é‡ç”Ÿ/è®­ç»ƒå®¶)
 * - åŠ¨æ€åˆ‡æ­Œ (é¦†ä¸»æˆ˜å±æœºæ—¶åˆ»)
 * - éŸ³é¢‘æ·¡å…¥æ·¡å‡º
 */
// ============================================
// BGM èµ„æºç´¢å¼•è¡¨
// ============================================
// è·å–åŸºç¡€è·¯å¾„ (å…¼å®¹ GitHub Pages)
function getBasePath() {
    const path = window.location.pathname;
    // GitHub Pages: /repo-name/
    if (path.includes('/pkm12/')) {
        return path.substring(0, path.indexOf('/pkm12/') + 7);
    }
    return './';
}
const BASE_PATH = getBasePath();
const BGM_INDEX = {
    // === é‡ç”Ÿé­é‡æˆ˜ (Wild Encounters) ===
    WILD_LOW:     `${BASE_PATH}data/bgm/wild_01_low_unova.mp3`,
    WILD_MID:     `${BASE_PATH}data/bgm/wild_02_mid_sinnoh.mp3`,
    WILD_HIGH:    `${BASE_PATH}data/bgm/wild_03_ex_areazero.mp3`,
    // === è®­ç»ƒå®¶æˆ˜æ–— (Trainer Battles) ===
    TIER_1:       `${BASE_PATH}data/bgm/battle_01_raw.mp3`,
    TIER_2:       `${BASE_PATH}data/bgm/battle_02_standard.mp3`,
    // === åŠ¨æ€åˆ‡æ­Œå±‚ (Gym Leader / Tier 3) ===
    TIER_3_MAIN:  `${BASE_PATH}data/bgm/battle_03_gym_main.mp3`,
    TIER_3_LAST:  `${BASE_PATH}data/bgm/battle_03_gym_crisis.mp3`,
    // === é«˜éš¾/BOSSæˆ˜ (High Stakes) ===
    TIER_4:       `${BASE_PATH}data/bgm/battle_04_elite.mp3`,
    TIER_5_BOSS:  `${BASE_PATH}data/bgm/battle_05_legend.mp3`,
    // === èƒœåˆ©éŸ³ä¹ (Victory Events) ===
    WIN_WILD:     `${BASE_PATH}data/bgm/win_01_wild.mp3`,
    WIN_TRAINER:  `${BASE_PATH}data/bgm/win_02_trainer.mp3`
};
// ============================================
// BGM éŸ³é‡é…ç½®è¡¨ (0.0 - 1.0)
// ============================================
// BGM éŸ³é‡é…ç½® (ä½¿ç”¨æ–‡ä»¶åä½œä¸º keyï¼Œå…¼å®¹ä¸åŒè·¯å¾„)
const BGM_VOLUME_CONFIG = {};
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_LOW] = 0.25;
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_MID] = 0.28;
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_HIGH] = 0.20;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_1] = 0.22;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_2] = 0.25;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_3_MAIN] = 0.28;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_3_LAST] = 0.32;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_4] = 0.30;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_5_BOSS] = 0.35;
BGM_VOLUME_CONFIG[BGM_INDEX.WIN_WILD] = 0.20;
BGM_VOLUME_CONFIG[BGM_INDEX.WIN_TRAINER] = 0.27;
// ============================================
// BGM æ’­æ”¾å™¨çŠ¶æ€
// ============================================
const BgmPlayer = {
    currentAudio: null,
    currentKey: null,
    defaultVolume: 0.25,
    play(url, loop = true, fadeInDuration = 500) {
        // å¦‚æœæ­£åœ¨æ’­æ”¾ç›¸åŒçš„ BGM ä¸”æœªæš‚åœï¼Œè·³è¿‡
        if (this.currentAudio && this.currentKey === url && !this.currentAudio.paused) {
            console.log('[BGM] Already playing:', url);
            return;
        }
        // åœæ­¢å½“å‰æ’­æ”¾çš„ BGM
        this.stop(0);
        console.log('[BGM] Starting playback:', url);
        try {
            this.currentAudio = new Audio(url);
            this.currentKey = url;
            this.currentAudio.loop = loop;
            this.currentAudio.volume = 0;
            const playPromise = this.currentAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('[BGM] Playback started successfully');
                }).catch(err => {
                    console.warn('[BGM] Autoplay blocked:', err);
                });
            }
            // ä½¿ç”¨é…ç½®è¡¨ä¸­çš„éŸ³é‡ï¼Œå¦‚æœæ²¡æœ‰é…ç½®åˆ™ä½¿ç”¨é»˜è®¤å€¼
            const targetVolume = BGM_VOLUME_CONFIG[url] || this.defaultVolume;
            this._fadeIn(fadeInDuration, targetVolume);
        } catch (err) {
            console.error('[BGM] Play error:', err);
        }
    },
    stop(fadeOutDuration = 300) {
        if (!this.currentAudio) return;
        if (fadeOutDuration > 0) {
            this._fadeOut(fadeOutDuration, () => {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                    this.currentKey = null;
                }
            });
        } else {
            this.currentAudio.pause();
            this.currentAudio = null;
            this.currentKey = null;
        }
    },
    crossFade(url, loop = true) {
        if (this.currentKey === url) return;
        const oldAudio = this.currentAudio;
        try {
            const newAudio = new Audio(url);
            newAudio.loop = loop;
            newAudio.volume = 0;
            newAudio.play().then(() => {
                if (oldAudio) {
                    this._fadeOutAudio(oldAudio, 800, () => {
                        oldAudio.pause();
                    });
                }
                this.currentAudio = newAudio;
                this.currentKey = url;
                const targetVolume = BGM_VOLUME_CONFIG[url] || this.defaultVolume;
                this._fadeIn(800, targetVolume);
            }).catch(err => {
                console.warn('[BGM] åˆ‡æ¢å¤±è´¥:', err.message);
            });
        } catch (e) {
            console.warn('[BGM] åˆ‡æ¢éŸ³é¢‘å¤±è´¥:', e.message);
        }
    },
    setVolume(vol) {
        this.defaultVolume = Math.max(0, Math.min(1, vol));
        if (this.currentAudio) {
            this.currentAudio.volume = this.defaultVolume;
        }
    },
    _fadeIn(duration, targetVolume = null) {
        if (!this.currentAudio) return;
        const startTime = Date.now();
        const volume = targetVolume !== null ? targetVolume : this.defaultVolume;
        const fade = () => {
            if (!this.currentAudio) return;
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            this.currentAudio.volume = volume * progress;
            if (progress < 1) requestAnimationFrame(fade);
        };
        requestAnimationFrame(fade);
    },
    _fadeOut(duration, callback) {
        if (!this.currentAudio) {
            if (callback) callback();
            return;
        }
        this._fadeOutAudio(this.currentAudio, duration, callback);
    },
    _fadeOutAudio(audio, duration, callback) {
        const startTime = Date.now();
        const startVolume = audio.volume;
        const fade = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            audio.volume = startVolume * (1 - progress);
            if (progress < 1) {
                requestAnimationFrame(fade);
            } else {
                if (callback) callback();
            }
        };
        requestAnimationFrame(fade);
    }
};
// ============================================
// BGM é€‰æ‹©é€»è¾‘
// ============================================
function getBattleBgm(avgLevel, isTrainer, isCrisis = false) {
    if (!isTrainer) {
        if (avgLevel >= 70) return BGM_INDEX.WILD_HIGH;
        if (avgLevel >= 40) return BGM_INDEX.WILD_MID;
        return BGM_INDEX.WILD_LOW;
    } else {
        if (avgLevel >= 85) return BGM_INDEX.TIER_5_BOSS;
        // Tier 4 (70-84çº§) ä¹Ÿæ”¯æŒå±æœº BGM
        if (avgLevel >= 70) return isCrisis ? BGM_INDEX.TIER_3_LAST : BGM_INDEX.TIER_4;
        // Tier 3 (50-69çº§) æ”¯æŒå±æœº BGM
        if (avgLevel >= 50) return isCrisis ? BGM_INDEX.TIER_3_LAST : BGM_INDEX.TIER_3_MAIN;
        if (avgLevel >= 25) return BGM_INDEX.TIER_2;
        return BGM_INDEX.TIER_1;
    }
}
function getPartyAvgLevel(party) {
    if (!party || party.length === 0) return 1;
    const total = party.reduce((sum, p) => sum + (p.level || p.lv || 1), 0);
    return Math.round(total / party.length);
}
function playBattleBgm() {
    if (typeof battle === 'undefined' || !battle) {
        console.warn('[BGM] battle å¯¹è±¡æœªå®šä¹‰');
        return;
    }
    const enemyParty = battle.enemyParty || [];
    if (enemyParty.length === 0) {
        console.warn('[BGM] æ•Œæ–¹é˜Ÿä¼ä¸ºç©ºï¼Œå»¶è¿Ÿ 100ms é‡è¯•');
        setTimeout(playBattleBgm, 100);
        return;
    }
    const avgLevel = getPartyAvgLevel(enemyParty);
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    const bgmUrl = getBattleBgm(avgLevel, isTrainer, false);
    console.log(`[BGM] æˆ˜æ–—å¼€å§‹ - å¹³å‡ç­‰çº§: ${avgLevel}, è®­ç»ƒå®¶: ${isTrainer}, é˜Ÿä¼æ•°: ${enemyParty.length}`);
    console.log(`[BGM] æ’­æ”¾: ${bgmUrl}`);
    BgmPlayer.play(bgmUrl, true);
}
function checkCrisisBgm() {
    if (typeof battle === 'undefined' || !battle) return;
    const enemyParty = battle.enemyParty || [];
    const avgLevel = getPartyAvgLevel(enemyParty);
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    // åªåœ¨ Tier 3 (50-69çº§) å’Œ Tier 4 (70-84çº§) è§¦å‘å±æœº BGM
    if (!isTrainer || avgLevel < 50 || avgLevel >= 85) return;
    const totalEnemies = enemyParty.length;
    const aliveEnemies = enemyParty.filter(p => p.currHp > 0);
    const aliveCount = aliveEnemies.length;
    // æ ¹æ®é˜Ÿä¼æ€»æ•°å†³å®šè§¦å‘æ—¶æœº
    let shouldTriggerCrisis = false;
    if (totalEnemies <= 2) {
        // 1-2åª: ä¸æ’­æ”¾å±æœº BGM
        shouldTriggerCrisis = false;
    } else if (totalEnemies >= 3 && totalEnemies <= 5) {
        // 3-5åª: æœ€åä¸€åªæ—¶æ’­æ”¾
        shouldTriggerCrisis = (aliveCount === 1);
    } else if (totalEnemies === 6) {
        // 6åª: æœ€åä¸¤åªæ—¶æ’­æ”¾
        shouldTriggerCrisis = (aliveCount <= 2);
    }
    if (shouldTriggerCrisis) {
        const crisisBgm = BGM_INDEX.TIER_3_LAST;
        if (BgmPlayer.currentKey !== crisisBgm) {
            console.log(`[BGM] å±æœºæ—¶åˆ»ï¼é˜Ÿä¼: ${totalEnemies}åª, å‰©ä½™: ${aliveCount}åª, åˆ‡æ¢BGM`);
            BgmPlayer.crossFade(crisisBgm, true);
        }
    }
}
function playVictoryBgm(isTrainerBattle) {
    const bgmUrl = isTrainerBattle ? BGM_INDEX.WIN_TRAINER : BGM_INDEX.WIN_WILD;
    console.log(`[BGM] èƒœåˆ©éŸ³ä¹ - è®­ç»ƒå®¶: ${isTrainerBattle}`);
    BgmPlayer.play(bgmUrl, false, 300);
}
function stopBgm(fadeOut = 500) {
    BgmPlayer.stop(fadeOut);
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.BGM_INDEX = BGM_INDEX;
    window.BgmPlayer = BgmPlayer;
    window.getBattleBgm = getBattleBgm;
    window.getPartyAvgLevel = getPartyAvgLevel;
    window.playBattleBgm = playBattleBgm;
    window.checkCrisisBgm = checkCrisisBgm;
    window.playVictoryBgm = playVictoryBgm;
    window.stopBgm = stopBgm;
}
]]></file>
        <file name="catch-system.js"><![CDATA[/**
 * ===========================================
 * CATCH-SYSTEM.JS - æ•è·ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ç²¾çµçƒèœå•æ§åˆ¶
 * - æ•è·æ¦‚ç‡è®¡ç®—
 * - æ•è·åŠ¨ç”»ä¸æµç¨‹
 */
// ============================================
// ç²¾çµçƒèœå•æ§åˆ¶
// ============================================
/**
 * æ‰“å¼€ç²¾çµçƒèœå•
 */
function openBallMenu() {
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const trainer = battle.trainer;
    const isWild = trainer && (trainer.id === 'wild' || !trainer.id);
    if (battle.locked || !isWild) return;
    const layer = document.getElementById('ball-layer');
    if (layer) layer.classList.remove('hidden');
}
/**
 * å…³é—­ç²¾çµçƒèœå•
 */
function closeBallMenu() {
    const layer = document.getElementById('ball-layer');
    if (layer) layer.classList.add('hidden');
}
// ============================================
// æ•è·é€»è¾‘
// ============================================
/**
 * å°è¯•æ•è·é‡ç”Ÿå®å¯æ¢¦
 * @param {number} ballMultiplier ç²¾çµçƒæ•è·ç‡å€æ•°
 */
async function tryCatch(ballMultiplier = 1) {
    closeBallMenu();
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const trainer = battle.trainer;
    const isWild = trainer && (trainer.id === 'wild' || !trainer.id);
    if (battle.locked || !isWild) return;
    const enemy = typeof battle.getEnemy === 'function' ? battle.getEnemy() : null;
    if (!enemy || !enemy.isAlive()) {
        log('å½“å‰æ²¡æœ‰å¯æ•æ‰çš„ç›®æ ‡ã€‚');
        return;
    }
    battle.locked = true;
    // æ’­æ”¾æ•è·åŠ¨ç”»
    const sprite = document.getElementById('enemy-sprite');
    if (sprite) {
        sprite.style.transition = 'transform 0.4s ease-in, opacity 0.3s';
        sprite.style.transform = 'scale(0.1) rotate(360deg)';
        sprite.style.opacity = '0';
    }
    log(`ä½ å‘ ${enemy.cnName} æŠ•æ·äº†ç²¾çµçƒï¼`);
    await wait(600);
    // è®¡ç®—æ•è·ç‡
    const catchResult = calculateCatchRate(enemy, ballMultiplier);
    const { finalChance, caught } = catchResult;
    // æ‘‡æ™ƒåŠ¨ç”»
    const shakeLog = async (count) => {
        log(`(ç²¾çµçƒæ‘‡æ™ƒäº† ${count} ä¸‹...)`);
        await wait(600);
    };
    if (!caught) {
        // æ•è·å¤±è´¥
        const breakShakes = finalChance > 0.7 ? 3 : finalChance > 0.4 ? 2 : 1;
        for (let i = 1; i <= breakShakes; i++) {
            await shakeLog(i);
        }
        if (breakShakes >= 3) {
            log("å•Šï¼æ˜æ˜å°±å·®ä¸€ç‚¹ç‚¹äº†ï¼");
        } else {
            log("å¤ªå¯æƒœäº†ï¼çƒç ´å¼€äº†ï¼");
        }
        // æ¢å¤ç²¾çµå›¾
        if (sprite) {
            sprite.style.transition = 'transform 0.35s ease-out, opacity 0.35s';
            sprite.style.transform = 'scale(1) rotate(0deg)';
            sprite.style.opacity = '1';
            sprite.classList.remove('entering');
            setTimeout(() => {
                sprite.style.transition = '';
                sprite.style.transform = '';
                sprite.style.opacity = '';
                sprite.classList.add('entering');
                setTimeout(() => sprite.classList.remove('entering'), 650);
            }, 400);
        }
        await wait(500);
        if (typeof updateAllVisuals === 'function') {
            updateAllVisuals(true);
        }
        if (typeof enemyTurn === 'function') {
            await enemyTurn();
        }
        return;
    }
    // æ•è·æˆåŠŸ
    await shakeLog(1);
    await shakeLog(2);
    await shakeLog(3);
    log("âœ¨ å’šï¼");
    await wait(500);
    const catchColor = (getComputedStyle(document.documentElement).getPropertyValue('--color-catch') || '#4ade80').trim() || '#4ade80';
    log(`<b style="color:${catchColor}">æˆåŠŸæ”¶æœäº† ${enemy.cnName}!</b>`);
    enemy.currHp = 0;
    battle.phase = 'caught';
    await wait(800);
    if (typeof battleEndSequence === 'function') {
        battleEndSequence('caught');
    }
}
/**
 * è®¡ç®—æ•è·ç‡
 * @param {Object} enemy æ•Œæ–¹å®å¯æ¢¦
 * @param {number} ballMultiplier ç²¾çµçƒå€ç‡
 * @returns {Object} { finalChance, caught }
 */
function calculateCatchRate(enemy, ballMultiplier = 1) {
    // è®¡ç®—ç§æ—å€¼æ€»å’Œ
    const statKeys = ['hp', 'atk', 'def', 'spa', 'spd', 'spe'];
    const stats = enemy.baseStats || {};
    let bst = 0;
    statKeys.forEach(key => {
        const val = typeof stats[key] === 'number' ? stats[key] : 50;
        bst += val;
    });
    // åŸºç¡€æ•è·ç‡ï¼ˆç§æ—å€¼è¶Šé«˜è¶Šéš¾æ•è·ï¼‰
    let baseCatchRate = 350 - (bst / 1.8);
    baseCatchRate = Math.max(3, Math.min(255, baseCatchRate));
    // HP å› å­ï¼ˆHP è¶Šä½è¶Šå®¹æ˜“æ•è·ï¼‰
    const hpFactorRaw = ((3 * enemy.maxHp) - (2 * enemy.currHp)) / (3 * Math.max(1, enemy.maxHp));
    const hpFactor = Math.min(1, Math.max(0.1, hpFactorRaw));
    // çŠ¶æ€å› å­ï¼ˆæš‚æœªå®ç°å¼‚å¸¸çŠ¶æ€åŠ æˆï¼‰
    const statusFactor = 1;
    // æœ€ç»ˆæ•è·ç‡
    let finalChance = (baseCatchRate * hpFactor * ballMultiplier * statusFactor) / 255;
    // å¤§å¸ˆçƒä¿è¯æ•è·
    if (ballMultiplier >= 255) {
        finalChance = 2;
    } else {
        finalChance = Math.max(0.02, Math.min(0.95, finalChance));
    }
    // åˆ¤å®šæ˜¯å¦æ•è·æˆåŠŸ
    const caught = finalChance >= 1 || Math.random() <= finalChance;
    return { finalChance, caught, baseCatchRate, hpFactor };
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.openBallMenu = openBallMenu;
    window.closeBallMenu = closeBallMenu;
    window.tryCatch = tryCatch;
    window.calculateCatchRate = calculateCatchRate;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        openBallMenu,
        closeBallMenu,
        tryCatch,
        calculateCatchRate
    };
}
]]></file>
        <file name="data-loader.js"><![CDATA[/**
 * ===========================================
 * DATA-LOADER.JS - æ•°æ®åŠ è½½ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - é»˜è®¤æˆ˜æ–—æ•°æ®
 * - JSON æ•°æ®è§£æä¸åŠ è½½
 * - æˆ˜æ–—åˆå§‹åŒ–æ•°æ®å¤„ç†
 */
// ============================================
// é»˜è®¤æˆ˜æ–—æ•°æ®
// ============================================
/**
 * è·å–é»˜è®¤æˆ˜æ–—æ•°æ® (å½“æ²¡æœ‰å¤–éƒ¨JSONæ³¨å…¥æ—¶ä½¿ç”¨)
 * 
 * æ–°ç‰ˆæ ¼å¼æ”¯æŒï¼š
 * - stats_meta: { ivs: {...}, ev_level: 0~252 }
 * - nature: æ€§æ ¼åç§°
 * - ability: ç‰¹æ€§åç§°
 * - gender: 'M' | 'F' | null
 * - shiny: boolean
 * - mechanic: 'mega' | 'dynamax' | 'zmove' | 'tera' (äº’æ–¥æœºåˆ¶é”)
 * - dynamax_moves: string[] (æå·¨åŒ–æ—¶çš„æ‹›å¼åˆ—è¡¨)
 * - z_move_config: { base_move, target_move, is_unique }
 */
function getDefaultBattleData() {
    return {"difficulty":"normal","player":{"name":"User","party":[{"slot":1,"name":"Sprigatito","nickname":null,"species":null,"gender":"F","lv":11,"quality":"high","nature":"Jolly","ability":"Overgrow","shiny":false,"item":null,"mechanic":null,"teraType":null,"isAce":true,"moves":["Scratch","Tail Whip","Leafage","Bite"],"stats_meta":{"ivs":{"hp":3,"atk":25,"def":31,"spa":29,"spd":31,"spe":31},"ev_level":23,"ev_up":0},"notes":null,"avs":{"trust":32,"passion":19,"insight":4,"devotion":0}}],"unlocks":{"enable_bond":false,"enable_styles":false,"enable_insight":false,"enable_mega":false,"enable_z_move":false,"enable_dynamax":false,"enable_tera":false}},"enemy":{"id":"Sludge anomaly","type":"wild","name":"Sludge anomaly","lines":{"start":"The Grimer lunges forward, dripping with neon sludge!","win":"The sludge loses its form and splatters across the floor!","lose":"Overwhelmed by the toxic fumes...","escape":"You scramble back up the ladder, gasping for air!"},"unlocks":{"enable_bond":false,"enable_styles":false,"enable_insight":false,"enable_mega":false,"enable_z_move":false,"enable_dynamax":false,"enable_tera":false}},"party":[{"name":"Grimer-Alola","gender":"F","lv":14,"nature":"Brave","ability":"Poison Touch","shiny":false,"item":null,"mechanic":null,"teraType":null,"stats_meta":{"ivs":{"hp":2,"atk":1,"def":15,"spa":12,"spd":8,"spe":3},"ev_level":0},"moves":["Pound","Poison Gas","Harden","Bite"],"mega":null,"avs":{"trust":0,"passion":0,"insight":0,"devotion":0}}],"script":null};
}
// ============================================
// JSON æ•°æ®åŠ è½½
// ============================================
/**
 * ä»å¤–éƒ¨ JSON å­—ç¬¦ä¸²åŠ è½½å¯¹æˆ˜ (ä¾› AI RP è°ƒç”¨)
 * JSON æ ¼å¼:
 * {
 *   "player": { "name": "ä¸»è§’å", "party": [...] },  // å¯é€‰
 *   "trainer": { "name": "è®­ç»ƒå®¶", "id": "xxx", "line": "å°è¯" },
 *   "party": [...],  // æ•Œæ–¹é˜Ÿä¼
 *   "script": "loss" | "win" | null
 * }
 */
function loadBattleFromJSON(jsonString) {
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) {
        console.error('[DATA-LOADER] battle object not found');
        return false;
    }
    try {
        const json = typeof jsonString === 'string' ? JSON.parse(jsonString) : jsonString;
        // åŠ è½½ç©å®¶é˜Ÿä¼ (å¦‚æœæœ‰)
        if (json.player && json.player.party) {
            const unlocks = json.player.unlocks || {};
            battle.playerUnlocks = {
                enable_bond: unlocks.enable_bond !== false,
                enable_styles: unlocks.enable_styles !== false,
                enable_insight: unlocks.enable_insight !== false,
                enable_mega: unlocks.enable_mega !== false,
                enable_z_move: unlocks.enable_z_move !== false,
                enable_dynamax: unlocks.enable_dynamax !== false,
                enable_tera: unlocks.enable_tera !== false
            };
            const playerCanMega = battle.playerUnlocks.enable_mega;
            battle.setPlayerParty(json.player.party, playerCanMega);
            battle.playerName = json.player.name || 'ä¸»è§’';
        }
        // åŠ è½½æ•Œæ–¹æ•°æ®
        battle.loadFromJSON(json);
        // æ›´æ–°è§†è§‰
        if (typeof updateAllVisuals === 'function') {
            updateAllVisuals();
        }
        return true;
    } catch (e) {
        console.error('Invalid battle JSON:', e);
        return false;
    }
}
/**
 * è§£æç©å®¶è§£é”é…ç½®
 * @param {Object} unlocks è§£é”é…ç½®å¯¹è±¡
 * @returns {Object} æ ‡å‡†åŒ–çš„è§£é”é…ç½®
 */
function parseUnlocks(unlocks = {}) {
    return {
        enable_bond: unlocks.enable_bond !== false,
        enable_styles: unlocks.enable_styles !== false,
        enable_insight: unlocks.enable_insight !== false,
        enable_mega: unlocks.enable_mega !== false,
        enable_z_move: unlocks.enable_z_move !== false,
        enable_dynamax: unlocks.enable_dynamax !== false,
        enable_tera: unlocks.enable_tera !== false
    };
}
/**
 * éªŒè¯æˆ˜æ–— JSON æ ¼å¼
 * @param {Object} json æˆ˜æ–—æ•°æ®
 * @returns {Object} { valid: boolean, errors: string[] }
 */
function validateBattleJSON(json) {
    const errors = [];
    if (!json) {
        errors.push('JSON data is null or undefined');
        return { valid: false, errors };
    }
    // æ£€æŸ¥æ•Œæ–¹é˜Ÿä¼
    if (!json.party || !Array.isArray(json.party) || json.party.length === 0) {
        errors.push('Missing or empty enemy party');
    }
    // æ£€æŸ¥æ¯ä¸ªå®å¯æ¢¦çš„å¿…è¦å­—æ®µ
    const checkPokemon = (pokemon, index, side) => {
        if (!pokemon.name) {
            errors.push(`${side} Pokemon #${index + 1}: missing name`);
        }
        if (typeof pokemon.lv !== 'number' || pokemon.lv < 1 || pokemon.lv > 100) {
            errors.push(`${side} Pokemon #${index + 1}: invalid level`);
        }
        if (!pokemon.moves || !Array.isArray(pokemon.moves) || pokemon.moves.length === 0) {
            errors.push(`${side} Pokemon #${index + 1}: missing moves`);
        }
    };
    if (json.party) {
        json.party.forEach((p, i) => checkPokemon(p, i, 'Enemy'));
    }
    if (json.player && json.player.party) {
        json.player.party.forEach((p, i) => checkPokemon(p, i, 'Player'));
    }
    return { valid: errors.length === 0, errors };
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.getDefaultBattleData = getDefaultBattleData;
    window.loadBattleFromJSON = loadBattleFromJSON;
    window.parseUnlocks = parseUnlocks;
    window.validateBattleJSON = validateBattleJSON;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        getDefaultBattleData,
        loadBattleFromJSON,
        parseUnlocks,
        validateBattleJSON
    };
}
]]></file>
        <file name="preloader.js"><![CDATA[/**
 * ===========================================
 * PRELOADER.JS - èµ„æºé¢„åŠ è½½ç³»ç»Ÿ
 * ===========================================
 */
const PreloadCache = {
    sprites: {},
    cries: {},
    bgm: null,
    trainerAvatars: {},
    pokemonIcons: {}
};
/**
 * é¢„åŠ è½½ç²¾çµå›¾
 */
function preloadSprite(name, isBack = false) {
    return new Promise((resolve) => {
        const id = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
        const cacheKey = `${id}_${isBack ? 'back' : 'front'}`;
        if (PreloadCache.sprites[cacheKey]) {
            resolve(PreloadCache.sprites[cacheKey]);
            return;
        }
        const suffix = isBack ? '-back' : '';
        const url = `https://play.pokemonshowdown.com/sprites/ani${suffix}/${id}.gif`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.sprites[cacheKey] = img;
            resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½å«å£°
 */
function preloadCry(name) {
    return new Promise((resolve) => {
        let id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
        if (typeof POKEDEX !== 'undefined' && POKEDEX[id] && POKEDEX[id].baseSpecies) {
            id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
        const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
        for (const s of suffixes) {
            if (id.endsWith(s) && id.length > s.length) {
                id = id.replace(s, '');
                break;
            }
        }
        if (PreloadCache.cries[id]) {
            resolve(PreloadCache.cries[id]);
            return;
        }
        const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
        const audio = new Audio();
        audio.preload = 'auto';
        audio.oncanplaythrough = () => {
            PreloadCache.cries[id] = audio;
            resolve(audio);
        };
        audio.onerror = () => resolve(null);
        audio.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½è®­ç»ƒå®¶å¤´åƒ
 */
function preloadTrainerAvatar(trainerId) {
    return new Promise((resolve) => {
        if (!trainerId || trainerId === 'wild') {
            resolve(null);
            return;
        }
        if (PreloadCache.trainerAvatars[trainerId]) {
            resolve(PreloadCache.trainerAvatars[trainerId]);
            return;
        }
        const url = `./data/trainers/${trainerId}.png`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.trainerAvatars[trainerId] = img;
            resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = url;
        setTimeout(() => resolve(null), 3000);
    });
}
/**
 * é¢„åŠ è½½å®å¯æ¢¦å¤´åƒ sprite sheet (æ‰€æœ‰å®å¯æ¢¦å…±äº«)
 */
function preloadPokemonIconSheet() {
    return new Promise((resolve) => {
        if (PreloadCache.pokemonIcons['sheet']) {
            resolve(PreloadCache.pokemonIcons['sheet']);
            return;
        }
        const url = `https://play.pokemonshowdown.com/sprites/pokemonicons-sheet.png`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.pokemonIcons['sheet'] = img;
            console.log('[PRELOAD] Pokemon icon sheet loaded');
            resolve(img);
        };
        img.onerror = () => {
            console.warn('[PRELOAD] Failed to load pokemon icon sheet');
            resolve(null);
        };
        img.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½æœ¬å±€æ‰€æœ‰èµ„æº
 */
async function preloadBattleResources(playerParty, enemyParty, trainerId, onProgress) {
    const tasks = [];
    // è®¡ç®—æ€»æ•°: ç©å®¶é˜Ÿä¼(ç²¾çµå›¾+å«å£°) + æ•Œæ–¹é˜Ÿä¼(ç²¾çµå›¾+å«å£°) + è®­ç»ƒå®¶å¤´åƒ + å®å¯æ¢¦å¤´åƒsheet
    const total = (playerParty.length + enemyParty.length) * 2 + 2;
    let loaded = 0;
    const updateProgress = () => {
        loaded++;
        if (onProgress) onProgress(loaded, total);
    };
    // ç©å®¶é˜Ÿä¼
    for (const p of playerParty) {
        const name = p.name || p;
        tasks.push(preloadSprite(name, true).then(updateProgress));
        tasks.push(preloadCry(name).then(updateProgress));
    }
    // æ•Œæ–¹é˜Ÿä¼
    for (const e of enemyParty) {
        const name = e.name || e;
        tasks.push(preloadSprite(name, false).then(updateProgress));
        tasks.push(preloadCry(name).then(updateProgress));
    }
    // è®­ç»ƒå®¶å¤´åƒ
    tasks.push(preloadTrainerAvatar(trainerId).then(updateProgress));
    // å®å¯æ¢¦å¤´åƒ sprite sheet (åªåŠ è½½ä¸€æ¬¡)
    tasks.push(preloadPokemonIconSheet().then(updateProgress));
    await Promise.all(tasks);
    console.log('[PRELOAD] All resources loaded');
}
/**
 * è·å–ç¼“å­˜çš„å«å£°å¹¶æ’­æ”¾
 */
function playCachedCry(name, volume = 0.45) {
    let id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (typeof POKEDEX !== 'undefined' && POKEDEX[id] && POKEDEX[id].baseSpecies) {
        id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
    }
    const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
    for (const s of suffixes) {
        if (id.endsWith(s) && id.length > s.length) {
            id = id.replace(s, '');
            break;
        }
    }
    const cached = PreloadCache.cries[id];
    if (cached) {
        const clone = cached.cloneNode();
        clone.volume = volume;
        clone.play().catch(() => {});
        console.log(`[CRY] Playing cached: ${name} -> ${id}`);
    } else {
        // Fallback: ç›´æ¥åœ¨çº¿åŠ è½½ (é¿å…é€’å½’è°ƒç”¨ playPokemonCry)
        const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
        const cryAudio = new Audio(url);
        cryAudio.volume = volume;
        cryAudio.play().catch(() => {});
        console.log(`[CRY] Playing online (cache miss): ${name} -> ${id}`);
    }
}
// å¯¼å‡º
window.preloadBattleResources = preloadBattleResources;
window.preloadTrainerAvatar = preloadTrainerAvatar;
window.preloadPokemonIconSheet = preloadPokemonIconSheet;
window.playCachedCry = playCachedCry;
window.PreloadCache = PreloadCache;
]]></file>
    </directory>
    <directory name="ui">
        <file name="ui-menus.js"><![CDATA[/**
 * ===========================================
 * UI-MENUS.JS - èœå•ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ä¸»èœå•/æŠ€èƒ½èœå•åˆ‡æ¢
 * - Mega/Dynamax/Tera æŒ‰é’®æ§åˆ¶
 * - è¿›åŒ–åŠ¨ç”»æ’­æ”¾
 */
// ============================================
// èœå•åˆ‡æ¢
// ============================================
/**
 * æ˜¾ç¤ºæŠ€èƒ½èœå•
 */
function showMovesMenu() {
    console.log('[UI-MENUS] showMovesMenu called');
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('moves-menu').classList.remove('hidden');
    // ã€å¤æ­¦ç³»ç»Ÿã€‘æ ¹æ® enable_styles æ˜¾ç¤º/éšè—å¤ªæçƒ
    const taijiOrb = document.getElementById('btn-style-taiji');
    const battle = typeof window !== 'undefined' ? window.battle : null;
    console.log('[UI-MENUS] battle:', battle, 'taijiOrb:', taijiOrb);
    if (taijiOrb && battle) {
        const unlocks = battle.playerUnlocks || {};
        console.log('[UI-MENUS] unlocks:', unlocks);
        if (unlocks.enable_styles) {
            taijiOrb.classList.remove('hidden');
            console.log('[UI-MENUS] Showing taiji orb (styles enabled)');
            // åˆå§‹åŒ–é£æ ¼ä¸º normal
            if (typeof setMoveStyle === 'function') {
                setMoveStyle('normal', { silent: true });
            }
        } else {
            taijiOrb.classList.add('hidden');
            console.log('[UI-MENUS] Hiding taiji orb (styles disabled)');
        }
    }
    // æ›´æ–° Mega æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
    console.log('[UI-MENUS] Calling updateMegaButtonVisibility');
    updateMegaButtonVisibility();
}
/**
 * æ˜¾ç¤ºä¸»èœå•
 */
function showMainMenu() {
    if (typeof window.playSFX === 'function') window.playSFX('CANCEL');
    document.getElementById('moves-menu').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
    const battle = typeof window !== 'undefined' ? window.battle : null;
    // è¿”å›ä¸»èœå•æ—¶é‡ç½® Mega é¢„å¤‡çŠ¶æ€
    if (battle && battle.playerMegaArmed) {
        battle.playerMegaArmed = false;
        const megaBtn = document.getElementById('btn-mega');
        if (megaBtn) megaBtn.classList.remove('armed');
    }
}
// ============================================
// Mega/Dynamax/Tera æŒ‰é’®æ§åˆ¶
// ============================================
/**
 * æ›´æ–° Mega/Dynamax/Tera æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
 */
function updateMegaButtonVisibility() {
    const megaBtn = document.getElementById('btn-mega');
    if (!megaBtn) {
        console.log('[MEGA UI] btn-mega element not found!');
        return;
    }
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const p = battle.getPlayer();
    if (!p) {
        console.log('[MEGA UI] No player pokemon');
        megaBtn.classList.add('hidden');
        return;
    }
    // æ¸…é™¤ä¹‹å‰çš„æ ·å¼çŠ¶æ€
    megaBtn.classList.remove('dynamax-style', 'evo-style', 'tera-style');
    const iconText = megaBtn.querySelector('.mega-icon text');
    if (iconText) iconText.textContent = 'M'; // é»˜è®¤ M
    // äº’æ–¥æœºåˆ¶æ£€æŸ¥
    const lockedMechanic = p.mechanic;
    console.log(`[MEGA UI] Player: ${p.name}, canMegaEvolve: ${p.canMegaEvolve}, canDynamax: ${p.canDynamax}, canTera: ${p.canTera}, mechanic: ${lockedMechanic}`);
    const canMegaEvolveFunc = window.canMegaEvolve;
    const canActivateMechanicFunc = window.canActivateMechanic || (() => true);
    // è§£é”ç³»ç»Ÿæ£€æŸ¥
    const unlocks = battle.playerUnlocks || {};
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ Mega è¿›åŒ–
    const canMega = unlocks.enable_mega !== false
        && typeof canMegaEvolveFunc === 'function' 
        && canMegaEvolveFunc(p) 
        && !battle.playerMegaUsed
        && canActivateMechanicFunc(p, 'mega')
        && (!lockedMechanic || lockedMechanic === 'mega');
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æå·¨åŒ–
    const canDynamax = unlocks.enable_dynamax !== false
        && p.canDynamax 
        && !p.isDynamaxed 
        && !battle.playerMaxUsed
        && canActivateMechanicFunc(p, 'dynamax')
        && (!lockedMechanic || lockedMechanic === 'dynamax');
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤ªæ™¶åŒ–
    const canTerastallize = unlocks.enable_tera !== false
        && p.canTera 
        && !p.isTerastallized 
        && !battle.playerTeraUsed
        && canActivateMechanicFunc(p, 'tera')
        && lockedMechanic === 'tera';
    const isDynamaxTarget = p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax');
    console.log(`[MEGA UI] canMega: ${canMega}, canDynamax: ${canDynamax}, canTera: ${canTerastallize}, lockedMechanic: ${lockedMechanic}, isDynamaxTarget: ${isDynamaxTarget}`);
    // å¤ªæ™¶åŒ–æ¨¡å¼
    if (lockedMechanic === 'tera') {
        if (canTerastallize) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.add('tera-style');
            if (iconText) iconText.textContent = 'T';
            p.evolutionType = 'tera';
        } else {
            megaBtn.classList.add('hidden');
            battle.playerMegaArmed = false;
        }
        return;
    }
    // Z-Move æ¨¡å¼ä¸æ˜¾ç¤ºæŒ‰é’®
    if (lockedMechanic === 'zmove') {
        megaBtn.classList.add('hidden');
        battle.playerMegaArmed = false;
        return;
    }
    // Dynamax æ¨¡å¼ï¼ˆä¼˜å…ˆæ£€æŸ¥ï¼‰
    if (lockedMechanic === 'dynamax') {
        if (canDynamax) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.add('dynamax-style');
            if (iconText) iconText.textContent = 'X';
            p.evolutionType = 'dynamax';
            console.log('[MEGA UI] Showing Dynamax button (mechanic locked)');
        } else {
            megaBtn.classList.add('hidden');
            console.log('[MEGA UI] Hidden: mechanic locked to dynamax but canDynamax is false');
        }
        return;
    }
    // Mega æ¨¡å¼
    if (lockedMechanic === 'mega') {
        if (canMega) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.remove('dynamax-style');
            p.evolutionType = 'mega';
            console.log('[MEGA UI] Showing Mega button (mechanic locked)');
        } else {
            megaBtn.classList.add('hidden');
            console.log('[MEGA UI] Hidden: mechanic locked to mega but canMega is false');
        }
        return;
    }
    // æ— é”å®šæœºåˆ¶æ—¶çš„è‡ªåŠ¨æ£€æµ‹
    if (canDynamax || (canMega && isDynamaxTarget)) {
        // æå·¨åŒ–æ¨¡å¼
        megaBtn.classList.remove('hidden');
        megaBtn.classList.add('dynamax-style');
        if (iconText) iconText.textContent = 'X';
        p.evolutionType = 'dynamax';
        console.log('[MEGA UI] Showing Dynamax button (auto-detected)');
    } else if (canMega) {
        // æ™®é€š Mega æ¨¡å¼
        megaBtn.classList.remove('hidden');
        megaBtn.classList.remove('dynamax-style');
        p.evolutionType = 'mega';
        console.log('[MEGA UI] Showing Mega button (auto-detected)');
    } else {
        megaBtn.classList.add('hidden');
        console.log('[MEGA UI] Hidden: no mechanic available');
        battle.playerMegaArmed = false;
        megaBtn.classList.remove('armed');
    }
}
// ============================================
// è¿›åŒ–åŠ¨ç”»
// ============================================
/**
 * æ‰§è¡Œ Mega è¿›åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function playMegaEvolutionAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    const isBack = isPlayer;
    const newSpriteUrl = pokemon.getSprite(isBack);
    sprite.classList.remove('evo-silhouette', 'evo-burst', 'evo-finish');
    // é˜¶æ®µ 1: DNA å‰ªå½±
    sprite.classList.add('evo-silhouette');
    await wait(1000);
    // é˜¶æ®µ 2: ç™½å…‰çˆ†å‘ + åˆ‡æ¢å›¾ç‰‡
    sprite.classList.remove('evo-silhouette');
    sprite.classList.add('evo-burst');
    const spriteRequestedUrls = window.spriteRequestedUrls || {};
    delete spriteRequestedUrls[spriteId];
    if (typeof smartLoadSprite === 'function') {
        smartLoadSprite(spriteId, newSpriteUrl, false);
    }
    spriteRequestedUrls[spriteId] = newSpriteUrl;
    await wait(300);
    // é˜¶æ®µ 3: å†·å´åŠ¨ç”»
    sprite.classList.remove('evo-burst');
    sprite.classList.add('evo-finish');
    await wait(800);
    sprite.className = 'p-sprite loaded';
    sprite.classList.add(isPlayer ? 'mega-player' : 'mega-enemy');
}
/**
 * æ‰§è¡Œæå·¨åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function playDynamaxAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    sprite.classList.remove('evo-silhouette', 'evo-burst', 'evo-finish', 'state-dynamax', 'dynamax-burst', 'dynamax-shrink');
    // é˜¶æ®µ 1: çº¢è‰²çˆ†å‘åŠ¨ç”»
    sprite.classList.add('dynamax-burst');
    await wait(800);
    // é˜¶æ®µ 2: è¿›å…¥æå·¨åŒ–çŠ¶æ€
    sprite.classList.remove('dynamax-burst');
    sprite.classList.add('state-dynamax');
    await wait(200);
}
/**
 * ç»“æŸæå·¨åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function endDynamaxAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    sprite.classList.remove('state-dynamax');
    sprite.classList.add('dynamax-shrink');
    await wait(600);
    sprite.classList.remove('dynamax-shrink', 'dynamax-burst');
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
// ============================================
// Mega/Dynamax/Tera åˆ‡æ¢
// ============================================
/**
 * åˆ‡æ¢ Mega/Dynamax/Tera è¿›åŒ–é¢„å¤‡çŠ¶æ€
 */
function toggleMega() {
    const megaBtn = document.getElementById('btn-mega');
    if (!megaBtn) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const p = battle.getPlayer();
    const canMegaEvolveFunc = window.canMegaEvolve;
    // =========================================================
    // å¤ªæ™¶åŒ–æ¨¡å¼ (ä¼˜å…ˆæ£€æŸ¥)
    // =========================================================
    if (p && p.mechanic === 'tera' && p.canTera) {
        if (battle.playerTeraUsed || p.isTerastallized) {
            return;
        }
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#22d3ee">ğŸ’ å¤ªæ™¶åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œå¤ªæ™¶åŒ–ï¼(${p.teraType})</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆå¤ªæ™¶åŒ–é¢„å¤‡ã€‚</span>`);
        }
        return;
    }
    // æ£€æŸ¥æ˜¯å¦æ˜¯æå·¨åŒ–æ¨¡å¼
    const isDynamaxMode = p && (p.canDynamax || (p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax')));
    if (isDynamaxMode) {
        // === æå·¨åŒ–æ¨¡å¼ ===
        if (battle.playerMaxUsed || p.isDynamaxed) {
            return;
        }
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#e11d48">âœ¦ æå·¨åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œæå·¨åŒ–ï¼</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆæå·¨åŒ–é¢„å¤‡ã€‚</span>`);
        }
        return;
    }
    // === æ™®é€š Mega æ¨¡å¼ ===
    if (!p || !canMegaEvolveFunc || !canMegaEvolveFunc(p) || battle.playerMegaUsed) {
        return;
    }
    // æ£€æŸ¥æ˜¯å¦æ˜¯åŒ Mega å®å¯æ¢¦ï¼ˆå–·ç«é¾™/è¶…æ¢¦ï¼‰
    if (p.hasDualMega && p.megaFormsAvailable && p.megaFormsAvailable.length >= 2) {
        // å¦‚æœå·²ç»é¢„å¤‡ï¼Œåˆ™å–æ¶ˆ
        if (battle.playerMegaArmed) {
            battle.playerMegaArmed = false;
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆ Mega è¿›åŒ–é¢„å¤‡ã€‚</span>`);
            return;
        }
        // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
        if (typeof showMegaFormSelectionDialog === 'function') {
            showMegaFormSelectionDialog(p, (selectedFormId) => {
                if (selectedFormId) {
                    p.megaTargetId = selectedFormId;
                    p.formTargetId = selectedFormId;
                    battle.playerMegaArmed = true;
                    megaBtn.classList.add('armed');
                    const formName = selectedFormId.includes('megax') ? 'Mega X' : 'Mega Y';
                    log(`<span style="color:#a855f7">âœ¦ ${formName} è¿›åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œ Mega è¿›åŒ–ï¼</span>`);
                }
            });
        }
    } else {
        // æ™®é€š Megaï¼ˆå•ä¸€å½¢æ€ï¼‰
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#a855f7">âœ¦ Mega è¿›åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œ Mega è¿›åŒ–ï¼</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆ Mega è¿›åŒ–é¢„å¤‡ã€‚</span>`);
        }
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.showMovesMenu = showMovesMenu;
    window.showMainMenu = showMainMenu;
    window.updateMegaButtonVisibility = updateMegaButtonVisibility;
    window.toggleMega = toggleMega;
    window.playMegaEvolutionAnimation = playMegaEvolutionAnimation;
    window.playDynamaxAnimation = playDynamaxAnimation;
    window.endDynamaxAnimation = endDynamaxAnimation;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        showMovesMenu,
        showMainMenu,
        toggleMega,
        updateMegaButtonVisibility,
        playMegaEvolutionAnimation,
        playDynamaxAnimation,
        endDynamaxAnimation
    };
}
]]></file>
        <file name="ui-renderer.js"><![CDATA[/**
 * ===========================================
 * UI-RENDERER.JS - æ ¸å¿ƒ UI æ¸²æŸ“
 * ===========================================
 * 
 * èŒè´£:
 * - è¡€æ¡æ¸²æŸ“
 * - ç²¾çµçƒæ§½æ¸²æŸ“
 * - UI ç¼©æ”¾
 */
// ============================================
// UI ç¼©æ”¾
// ============================================
/**
 * å›ºå®šç”»å¸ƒç­‰æ¯”ç¼©æ”¾ (åŸºå‡† 1280x720)
 */
function updateUIScale() {
    const baseW = 1280;
    const baseH = 720;
    const pad = 0;
    const vw = Math.max(0, window.innerWidth - pad * 2);
    const vh = Math.max(0, window.innerHeight - pad * 2);
    const scale = Math.min(vw / baseW, vh / baseH);
    const el = document.getElementById('ui-scale');
    if (!el) return;
    el.style.setProperty('--ui-scale', String(scale));
}
// ============================================
// è¡€æ¡æ¸²æŸ“
// ============================================
/**
 * æ¸²æŸ“è¡€æ¡
 * @param {string} who 'player' æˆ– 'enemy'
 * @param {number} curr å½“å‰ HP
 * @param {number} max æœ€å¤§ HP
 */
function renderHp(who, curr, max) {
    const pct = Math.max(0, (curr / max) * 100);
    const bar = document.getElementById(`${who}-hp-fill`);
    const txt = document.getElementById(`${who}-hp-txt`);
    if (bar) {
        bar.style.width = pct + "%";
        bar.style.background = pct < 20 ? 'var(--hp-low)' : (pct < 50 ? 'var(--hp-mid)' : 'var(--hp-high)');
    }
    if (txt) txt.innerText = `${curr}/${max}`;
}
// ============================================
// ç²¾çµçƒæ§½æ¸²æŸ“
// ============================================
/**
 * æ¸²æŸ“ 6 ä¸ªç²¾çµçƒæ§½ä½œä¸ºçŠ¶æ€æ˜¾ç¤º
 * @param {string} idBox DOM å…ƒç´  ID
 * @param {Array} party é˜Ÿä¼æ•°ç»„
 * @param {number} idxActive å½“å‰å‡ºæˆ˜ç´¢å¼•
 */
function renderDots(idBox, party, idxActive) {
    const box = document.getElementById(idBox);
    if (!box) return;
    box.innerHTML = '';
    for (let i = 0; i < 6; i++) {
        const slot = document.createElement('div');
        slot.className = 'poke-slot';
        if (i >= party.length) {
            slot.classList.add('empty');
        } else {
            const pm = party[i];
            if (pm.isAlive()) {
                slot.classList.add('alive');
            } else {
                slot.classList.add('dead');
            }
            if (i === idxActive) {
                slot.classList.add('active');
            }
        }
        box.appendChild(slot);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.updateUIScale = updateUIScale;
    window.renderHp = renderHp;
    window.renderDots = renderDots;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        updateUIScale,
        renderHp,
        renderDots
    };
}
]]></file>
        <file name="ui-sprites.js"><![CDATA[/**
 * ===========================================
 * UI-SPRITES.JS - ç²¾çµå›¾åŠ è½½ä¸ç®¡ç†
 * ===========================================
 * 
 * èŒè´£:
 * - ç²¾çµå›¾æ™ºèƒ½åŠ è½½ï¼ˆæ”¯æŒå¤šå›¾åº“å›é€€ï¼‰
 * - ID å˜ä½“ç”Ÿæˆï¼ˆæ”¯æŒåœ°åŒºå½¢æ€ã€Mega ç­‰ï¼‰
 * - ç²¾çµå›¾çŠ¶æ€é‡ç½®
 */
// ============================================
// çŠ¶æ€ç®¡ç†
// ============================================
// è®°å½•æ¯ä¸ªç²¾çµå½“å‰è¯·æ±‚çš„åŸå§‹URLï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ–°åŠ è½½ï¼‰
const spriteRequestedUrls = {};
// ============================================
// ID å˜ä½“ç”Ÿæˆ
// ============================================
/**
 * ç”Ÿæˆ ID å˜ä½“ï¼ˆæ”¯æŒå¸¦æ¨ªæ çš„å®å¯æ¢¦åå­—ï¼‰
 * @param {string} name åŸå§‹åç§°
 * @returns {object} åŒ…å«å¤šç§ ID å˜ä½“çš„å¯¹è±¡
 */
function generateIdVariants(name = '') {
    const raw = name.toLowerCase().trim();
    // 1. ä¸¥æ ¼æ¨¡å¼ (ä¿ç•™æ¨ªæ ): "vulpix-alola", "ho-oh"
    const strict = raw.replace(/[^a-z0-9-]/g, '');
    // 2. ç´§å‡‘æ¨¡å¼ (æ— æ¨ªæ ): "vulpixalola", "hooh"
    const compact = raw.replace(/[^a-z0-9]/g, '');
    // 3. åŸºç¡€æ¨¡å¼ (å°è¯•ç§»é™¤åç¼€): "vulpix-alola" -> "vulpix"
    const suffixes = [
        '-alola', '-galar', '-hisui', '-paldea',
        '-mega', '-megax', '-megay', '-gmax',
        '-origin', '-therian', '-incarnate',
        '-black', '-white', '-dusk', '-dawn',
        '-school', '-complete', '-attack', '-defense', '-speed',
        '-primal', '-combat', '-blaze', '-aqua'
    ];
    let base = strict;
    for (const suffix of suffixes) {
        if (base.endsWith(suffix)) {
            base = base.replace(suffix, '');
            break;
        }
    }
    // ä¿ç•™ç‰¹æ®Šåå­—çš„æ¨ªæ 
    if (base !== 'ho-oh' && base !== 'porygon-z' && base !== 'jangmo-o' && base !== 'hakamo-o' && base !== 'kommo-o') {
        base = base.replace(/-/g, '');
    }
    return { strict, compact, base };
}
// ============================================
// æ™ºèƒ½ç²¾çµå›¾åŠ è½½
// ============================================
/**
 * æ™ºèƒ½åŠ è½½ç²¾çµå›¾ï¼ˆæ”¯æŒå¤šå›¾åº“å›é€€ï¼‰
 * @param {string} id DOM å…ƒç´  ID
 * @param {string} url ç›®æ ‡ URL
 * @param {boolean} forceAnim æ˜¯å¦å¼ºåˆ¶æ’­æ”¾å…¥åœºåŠ¨ç”»
 */
function smartLoadSprite(id, url, forceAnim = false) {
    const img = document.getElementById(id);
    if (!img) return;
    // å¦‚æœè¯·æ±‚çš„URLæ²¡å˜ä¸”å·²åŠ è½½å®Œæˆï¼Œè·³è¿‡ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
    if (!forceAnim && spriteRequestedUrls[id] === url && img.classList.contains('loaded')) {
        return;
    }
    // å¼ºåˆ¶é‡æ’­åŠ¨ç”»ï¼ˆæ¢äººæ—¶ï¼‰
    if (forceAnim && spriteRequestedUrls[id] === url && img.classList.contains('loaded')) {
        console.log(`[SPRITE] Replay entry animation for: ${url}`);
        img.classList.remove('entering');
        void img.offsetWidth;
        img.classList.add('entering');
        setTimeout(() => img.classList.remove('entering'), 650);
        return;
    }
    // è®°å½•æœ¬æ¬¡è¯·æ±‚çš„åŸå§‹URL
    spriteRequestedUrls[id] = url;
    // æ ‡è®°æ˜¯å¦å·²ç»æ’­æ”¾è¿‡å…¥åœºåŠ¨ç”»
    let hasPlayedAnimation = false;
    // æ’­æ”¾å…¥åœºåŠ¨ç”»çš„helper
    const playEntryAnimation = () => {
        if (!hasPlayedAnimation) {
            hasPlayedAnimation = true;
            img.classList.remove('entering');
            void img.offsetWidth;
            img.classList.add('entering');
            setTimeout(() => img.classList.remove('entering'), 650);
        }
    };
    // === å…³é”®ä¿®å¤ï¼šä½¿ç”¨é¢„åŠ è½½ï¼Œå®Œå…¨åŠ è½½åå†ä¸€æ¬¡æ€§åˆ‡æ¢ ===
    const tryLoadUrl = (targetUrl, fallbackUrls = []) => {
        console.log(`[SPRITE] Trying to load: ${targetUrl}, fallbacks: ${fallbackUrls.length}`);
        const preloader = new Image();
        preloader.onload = () => {
            console.log(`[SPRITE] SUCCESS: ${preloader.src}`);
            img.style.transition = 'none';
            img.classList.remove('loaded', 'fainted-hidden', 'fainting', 'entering');
            img.src = preloader.src;
            void img.offsetWidth;
            img.style.transition = '';
            img.classList.add('loaded');
            playEntryAnimation();
        };
        preloader.onerror = () => {
            console.log(`[SPRITE] FAILED: ${targetUrl}, trying next fallback...`);
            if (fallbackUrls.length > 0) {
                tryLoadUrl(fallbackUrls[0], fallbackUrls.slice(1));
            } else {
                console.log(`[SPRITE] All fallbacks exhausted for: ${targetUrl}`);
                // === åŠ¨æ€æ£€æµ‹éå®˜æ–¹ Megaï¼šæ‰€æœ‰å›é€€éƒ½å¤±è´¥ ===
                const originalUrl = spriteRequestedUrls[id] || url;
                const megaMatch = originalUrl.match(/sprites\/(ani|ani-back)\/(.+?)\.gif$/);
                if (megaMatch && megaMatch[2].includes('mega')) {
                    const isBack = megaMatch[1] === 'ani-back';
                    const baseId = megaMatch[2].replace(/mega[xy]?$/, '').replace(/-$/, '');
                    const baseSpriteUrl = `https://play.pokemonshowdown.com/sprites/${isBack ? 'ani-back' : 'ani'}/${baseId}.gif`;
                    console.log(`[SPRITE] Unofficial Mega detected! Falling back to base form: ${baseSpriteUrl}`);
                    img.classList.add('unofficial-mega');
                    const baseLoader = new Image();
                    baseLoader.onload = () => {
                        img.style.transition = 'none';
                        img.classList.remove('loaded', 'entering');
                        img.src = baseLoader.src;
                        void img.offsetWidth;
                        img.style.transition = '';
                        img.classList.add('loaded');
                        playEntryAnimation();
                    };
                    baseLoader.onerror = () => {
                        img.style.transition = 'none';
                        img.classList.remove('loaded', 'entering');
                        img.src = targetUrl;
                        void img.offsetWidth;
                        img.style.transition = '';
                        img.classList.add('loaded');
                    };
                    baseLoader.src = baseSpriteUrl;
                    return;
                }
                img.style.transition = 'none';
                img.classList.remove('loaded', 'entering');
                img.src = targetUrl;
                void img.offsetWidth;
                img.style.transition = '';
                img.classList.add('loaded');
            }
        };
        preloader.src = targetUrl;
    };
    // æ„å»ºå›é€€URLåˆ—è¡¨
    const m = url.match(/https?:\/\/play\.pokemonshowdown\.com\/sprites\/(ani|ani-back|ani-back-shiny|ani-shiny)\/(.+?)\.gif$/);
    if (m) {
        const spriteFolder = m[1];
        const isBack = spriteFolder.includes('back');
        const isShiny = spriteFolder.includes('shiny');
        const spriteId = m[2];
        const { strict, compact, base } = generateIdVariants(spriteId);
        const baseId = typeof getFallbackSpriteId === 'function' ? getFallbackSpriteId(spriteId) : base;
        const idVariants = [spriteId];
        if (strict !== spriteId) idVariants.push(strict);
        if (compact !== spriteId && compact !== strict) idVariants.push(compact);
        const semiCompact = spriteId.replace(/-([a-z]+)-/g, '-$1');
        if (semiCompact !== spriteId && !idVariants.includes(semiCompact)) {
            idVariants.push(semiCompact);
        }
        if (baseId !== spriteId && !idVariants.includes(baseId)) {
            idVariants.push(baseId);
        }
        const fallbacks = [];
        const isMega = spriteId.includes('mega');
        const isGmax = spriteId.includes('gmax');
        const isPrimal = spriteId.includes('primal');
        const isSpecialForm = isMega || isGmax || isPrimal;
        const aniFolder = isShiny 
            ? (isBack ? 'ani-back-shiny' : 'ani-shiny')
            : (isBack ? 'ani-back' : 'ani');
        const frontFolder = isShiny ? 'ani-shiny' : 'ani';
        const gen5aniFolder = isBack ? 'gen5ani-back' : 'gen5ani';
        const gen5Folder = isBack ? 'gen5-back' : 'gen5';
        const formVariants = idVariants.filter(id => id !== baseId);
        if (isSpecialForm) {
            // ç‰¹æ®Šå½¢æ€ä¼˜å…ˆ
            for (const id of formVariants) {
                if (id !== spriteId) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${id}.gif`);
                }
            }
            if (isBack) {
                for (const id of formVariants) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${id}.gif`);
                }
            }
            // pkparaiso å›¾åº“
            let pkparaisoId = spriteId;
            if (/mega[xy]?$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/mega([xy])?$/i, '-mega$1');
            } else if (/gmax$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/gmax$/i, '-gmax');
            } else if (/primal$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/primal$/i, '-primal');
            }
            const pkparaisoFolder = isBack ? 'animados-espalda' : 'animados';
            const isORASForm = spriteId.includes('rayquaza') || spriteId.includes('primal');
            const pkparaisoGen = isORASForm ? 'rubi-omega-zafiro-alfa' : (isGmax ? 'espada_escudo' : 'xy');
            fallbacks.push(`https://www.pkparaiso.com/imagenes/${pkparaisoGen}/sprites/${pkparaisoFolder}/${pkparaisoId}.gif`);
            for (const id of formVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${id}.gif`);
            }
            for (const id of formVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${id}.png`);
            }
            // æœ€åå›é€€åˆ°åŸºç¡€å½¢æ€
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${baseId}.gif`);
            if (isBack) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${baseId}.gif`);
            }
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${baseId}.gif`);
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${baseId}.png`);
        } else {
            // æ™®é€šå½¢æ€æŒ‰å±‚çº§å›é€€
            for (const id of idVariants) {
                if (id !== spriteId) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${id}.gif`);
                }
            }
            if (isBack) {
                for (const id of idVariants) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${id}.gif`);
                }
            }
            for (const id of idVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${id}.gif`);
            }
            for (const id of idVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${id}.png`);
            }
        }
        // Pokesprite å›¾åº“ï¼ˆåªæœ‰æ­£é¢å›¾ï¼‰
        if (!isBack) {
            for (const id of idVariants) {
                fallbacks.push(`https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${id}.png`);
            }
        }
        tryLoadUrl(url, fallbacks);
    } else {
        tryLoadUrl(url, []);
    }
}
// ============================================
// ç²¾çµå›¾çŠ¶æ€é‡ç½®
// ============================================
/**
 * é‡ç½®ç²¾çµå›¾çŠ¶æ€
 */
function resetSpriteState() {
    ['player-sprite', 'enemy-sprite'].forEach(id => {
        const sprite = document.getElementById(id);
        if (!sprite) return;
        sprite.classList.remove('fainted-hidden', 'fainting', 'entering', 'loaded', 'shake-hit-anim');
        sprite.style.removeProperty('opacity');
        sprite.style.removeProperty('transform');
    });
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.spriteRequestedUrls = spriteRequestedUrls;
    window.generateIdVariants = generateIdVariants;
    window.smartLoadSprite = smartLoadSprite;
    window.resetSpriteState = resetSpriteState;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        spriteRequestedUrls,
        generateIdVariants,
        smartLoadSprite,
        resetSpriteState
    };
}
]]></file>
        <file name="ui-trainer-hud.js"><![CDATA[/**
 * ===========================================
 * UI-TRAINER-HUD.JS - è®­ç»ƒå®¶å¤´åƒä¸ Cut-in ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - è®­ç»ƒå®¶å¤´åƒæ˜¾ç¤ºä¸åŠ è½½
 * - å¤´åƒ ID è§£æä¸å›é€€
 * - Cut-in å‰§åœºåŒ–æ¼”å‡ºç³»ç»Ÿ
 */
// ============================================
// å¤´åƒåº“é…ç½®
// ============================================
const AVATAR_LIBRARY = [
    'player',
    'wild',
    'gloria',
    'rosa',
    'dawn',
    'akari',
    'serena',
    'lusamine',
    'lillie',
    'mallow',
    'lana',
    'irida',
    'roxie',
    'iono',
    'erika',
    'nessa',
    'marnie',
    'hexmaniac',
    'bea',
    'cynthia',
    'sonia',
    'juliana',
    'selene'
];
const AVATAR_ALIAS_MAP = {
    hex: 'hexmaniac'
};
const NORMALIZED_AVATARS = AVATAR_LIBRARY.map(name => ({
    original: name,
    normalized: name.toLowerCase().replace(/[^a-z0-9]/g, '')
}));
// ç”¨äºè®­ç»ƒå®¶å¤´åƒç¼ºå¤±æ—¶çš„é—®å·å¤‡ç”¨å›¾
const MISSING_AVATAR = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Crect width='200' height='200' fill='%23f1f3f6'/%3E%3Cpath fill='%23dde1e7' d='M0,0 L200,200 L200,0 Z' opacity='0.3'/%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' font-weight='900' font-size='120' fill='%23cbd5e1'%3E?%3C/text%3E%3Crect x='10' y='10' width='180' height='180' rx='20' fill='none' stroke='%23cbd5e1' stroke-width='8' stroke-dasharray='15,15'/%3E%3C/svg%3E";
// ============================================
// å¤´åƒ ID è§£æ
// ============================================
/**
 * è§£æå¤´åƒ ID
 * @param {string} source åŸå§‹æ¥æºï¼ˆè®­ç»ƒå®¶åç§°æˆ– IDï¼‰
 * @returns {string|null} è§£æåçš„å¤´åƒ ID
 */
function resolveAvatarId(source) {
    const slug = String(source || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]/g, '');
    if (!slug) return null;
    if (AVATAR_ALIAS_MAP[slug]) {
        return AVATAR_ALIAS_MAP[slug];
    }
    const exact = NORMALIZED_AVATARS.find(entry => entry.normalized === slug);
    if (exact) return exact.original;
    const partial = NORMALIZED_AVATARS.find(entry =>
        entry.normalized.includes(slug) || slug.includes(entry.normalized)
    );
    return partial ? partial.original : null;
}
// ============================================
// è®­ç»ƒå®¶åç§°æ ¼å¼åŒ–
// ============================================
/**
 * æ ¼å¼åŒ–è®­ç»ƒå®¶åç§°
 * @param {Object} trainer è®­ç»ƒå®¶å¯¹è±¡
 * @returns {string} æ ¼å¼åŒ–åçš„åç§°
 */
function formatTrainerName(trainer) {
    if (!trainer) return 'TRAINER';
    if (trainer.displayName) return trainer.displayName;
    if (trainer.name_en) return trainer.name_en;
    if (trainer.id && trainer.id !== 'wild') {
        return trainer.id
            .split(/[-_]/)
            .filter(Boolean)
            .map(part => part.charAt(0).toUpperCase() + part.slice(1))
            .join(' ');
    }
    return 'TRAINER';
}
// ============================================
// è®­ç»ƒå®¶ HUD æ›´æ–°
// ============================================
/**
 * æ›´æ–°è®­ç»ƒå®¶ HUD æ˜¾ç¤º
 */
function updateTrainerHud() {
    const hud = document.getElementById('trainer-hud');
    const nameEl = document.getElementById('trainer-name');
    const avatarEl = document.getElementById('trainer-avatar');
    if (!hud || !nameEl || !avatarEl) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const t = battle?.trainer;
    if (!t) {
        hud.classList.add('hidden');
        return;
    }
    const isWild = t.id === 'wild' || !t.id;
    if (isWild) {
        hud.classList.add('hidden');
        return;
    }
    const displayName = (t.name || '').trim();
    if (displayName) {
        nameEl.textContent = displayName.replace(/^./, match => match.toUpperCase());
    } else {
        nameEl.textContent = 'Unknown';
    }
    const resolvedFromName = resolveAvatarId(displayName);
    const resolvedFromId = resolveAvatarId(t.id);
    const rawId = String(t.id || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    const candidates = [];
    if (resolvedFromId) candidates.push(resolvedFromId);
    if (resolvedFromName) candidates.push(resolvedFromName);
    if (rawId) candidates.push(rawId);
    if (displayName) candidates.push(displayName.toLowerCase());
    const uniqueCandidates = [...new Set(candidates)].filter(Boolean);
    let attemptIndex = 0;
    avatarEl.onload = null;
    avatarEl.onerror = null;
    const tryNext = () => {
        if (attemptIndex >= uniqueCandidates.length) {
            avatarEl.onload = null;
            avatarEl.onerror = () => { hud.classList.add('hidden'); };
            avatarEl.src = MISSING_AVATAR;
            hud.classList.remove('hidden');
            return;
        }
        const candidate = uniqueCandidates[attemptIndex++];
        avatarEl.onload = () => {
            hud.classList.remove('hidden');
        };
        avatarEl.onerror = () => {
            tryNext();
        };
        avatarEl.src = `data/avatar/${candidate}.png`;
    };
    tryNext();
}
// ============================================
// Cut-in å‰§åœºåŒ–æ¼”å‡ºç³»ç»Ÿ
// ============================================
/**
 * æ’­æ”¾ Cut-in æ¼”å‡º
 * @param {string} text æ¼”å‡ºæ–‡æœ¬
 * @param {number} duration æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 */
function playCutIn(text, duration = 3000) {
    if (!text) return;
    const stage = document.getElementById('cutin-stage');
    const nameEl = document.getElementById('cutin-name');
    const textEl = document.getElementById('cutin-text');
    const imgEl = document.getElementById('cutin-avatar');
    if (!stage || !nameEl || !textEl || !imgEl) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const trainer = battle?.trainer;
    const trainerName = trainer?.name || trainer?.title || 'ENEMY';
    nameEl.textContent = trainerName;
    textEl.textContent = text;
    const isWild = trainer?.id === 'wild';
    let targetSrc = '';
    if (isWild) {
        const enemySprite = document.getElementById('enemy-sprite');
        if (enemySprite?.src) {
            targetSrc = enemySprite.src;
        }
    } else {
        const trainerHudImg = document.getElementById('trainer-avatar');
        if (trainerHudImg?.src) {
            targetSrc = trainerHudImg.src;
        }
    }
    if (targetSrc && !targetSrc.includes('html')) {
        imgEl.style.opacity = '';
        imgEl.src = targetSrc;
    } else {
        imgEl.style.opacity = 0;
    }
    stage.classList.remove('hidden', 'outro');
    void stage.offsetWidth;
    stage.classList.add('active');
    clearTimeout(stage._cutinTimer);
    stage._cutinTimer = setTimeout(() => {
        stage.classList.remove('active');
        stage.classList.add('outro');
        clearTimeout(stage._cutinHideTimer);
        stage._cutinHideTimer = setTimeout(() => {
            stage.classList.add('hidden');
            stage.classList.remove('outro');
        }, 650);
    }, duration);
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.AVATAR_LIBRARY = AVATAR_LIBRARY;
    window.AVATAR_ALIAS_MAP = AVATAR_ALIAS_MAP;
    window.NORMALIZED_AVATARS = NORMALIZED_AVATARS;
    window.MISSING_AVATAR = MISSING_AVATAR;
    window.resolveAvatarId = resolveAvatarId;
    window.formatTrainerName = formatTrainerName;
    window.updateTrainerHud = updateTrainerHud;
    window.playCutIn = playCutIn;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        AVATAR_LIBRARY,
        AVATAR_ALIAS_MAP,
        NORMALIZED_AVATARS,
        MISSING_AVATAR,
        resolveAvatarId,
        formatTrainerName,
        updateTrainerHud,
        playCutIn
    };
}
]]></file>
    </directory>
    <file name="form-change-system.js"><![CDATA[/**
 * =============================================
 * FORM CHANGE SYSTEM - é€šç”¨å½¢æ€å˜åŒ–ç³»ç»Ÿ
 * =============================================
 * 
 * æ”¯æŒçš„å½¢æ€å˜åŒ–ç±»å‹ï¼š
 * 1. Mega Evolutionï¼ˆè¶…è¿›åŒ–ï¼‰- æŒ‰é’®è§¦å‘
 * 2. Ultra Burstï¼ˆç©¶æçˆ†å‘ï¼‰- æŒ‰é’®è§¦å‘ï¼Œå¤ç”¨ Mega æŒ‰é’®
 * 3. Primal Reversionï¼ˆåŸå§‹å›å½’ï¼‰- è¿›åœºè‡ªåŠ¨è§¦å‘
 * 4. Crowned Formï¼ˆå‰‘ç›¾ä¹‹ç‹ï¼‰- è¿›åœºè‡ªåŠ¨è§¦å‘
 * 5. Battle Bondï¼ˆç¾ç»Šè¿›åŒ–ï¼‰- å‡»æ€è§¦å‘
 * 6. HP-Threshold Formsï¼ˆè¡€é‡é˜ˆå€¼å½¢æ€ï¼‰- HP å˜åŒ–è§¦å‘
 */
/**
 * æ‰§è¡Œé€šç”¨å½¢æ€å˜åŒ–ï¼ˆå¼•æ“å±‚é¢ï¼‰
 * @param {Pokemon} pokemon - è¦å˜å½¢çš„å®å¯æ¢¦
 * @param {string} targetFormId - ç›®æ ‡å½¢æ€ IDï¼ˆå¦‚ 'charizardmegax', 'kyogreprimal'ï¼‰
 * @param {string} formType - å½¢æ€ç±»å‹ï¼ˆ'mega', 'primal', 'ultra', 'crowned' ç­‰ï¼‰
 * @returns {object|null} - å˜åŒ–ç»“æœä¿¡æ¯ï¼Œæˆ– null å¦‚æœå¤±è´¥
 */
function performFormChange(pokemon, targetFormId, formType = 'mega') {
    if (!targetFormId) {
        console.warn(`[FORM] No target form ID provided for ${pokemon.name}`);
        return null;
    }
    const formData = getPokemonData(targetFormId);
    if (!formData) {
        console.warn(`[FORM] Form data not found: ${targetFormId}`);
        return null;
    }
    // ä¿å­˜æ—§æ•°æ®ç”¨äºæ—¥å¿—
    const oldName = pokemon.cnName;
    const oldTypes = [...pokemon.types];
    const oldAbility = pokemon.ability;
    // æ›´æ–°åŸºç¡€æ•°æ®
    pokemon.name = formData.name;
    pokemon.cnName = formData.name;
    pokemon.types = formData.types || pokemon.types;
    pokemon.baseStats = formData.baseStats;
    // è·å–æ–°å½¢æ€çš„ç‰¹æ€§
    const formPokedexData = typeof POKEDEX !== 'undefined' ? POKEDEX[targetFormId] : null;
    if (formPokedexData && formPokedexData.abilities) {
        pokemon.ability = formPokedexData.abilities['0'] || formPokedexData.abilities['H'] || pokemon.ability;
    }
    // é‡æ–°è®¡ç®—èƒ½åŠ›å€¼
    const oldHp = pokemon.currHp;
    const oldMaxHp = pokemon.maxHp;
    let autoEv = Math.floor(pokemon.level * 1.5);
    if (autoEv > 85) autoEv = 85;
    const newStats = calcStats(formData.baseStats, pokemon.level, 31, autoEv);
    // HP å¤„ç†ï¼šå¤§éƒ¨åˆ†å½¢æ€å˜åŒ–ä¿æŒ HP ä¸å˜ï¼Œä½†åŸºæ ¼å°”å¾·å®Œå…¨ä½“ä¾‹å¤–
    const isZygardeComplete = targetFormId === 'zygardecomplete';
    if (isZygardeComplete) {
        // åŸºæ ¼å°”å¾·å®Œå…¨ä½“ï¼šHP æœ€å¤§å€¼å¢åŠ ï¼Œå½“å‰ HP æŒ‰æ¯”ä¾‹å¢åŠ 
        const hpRatio = oldHp / oldMaxHp;
        pokemon.maxHp = newStats.hp;
        pokemon.currHp = Math.floor(pokemon.maxHp * hpRatio);
    } else {
        // å…¶ä»–å½¢æ€ï¼šHP ä¿æŒä¸å˜
        pokemon.maxHp = oldMaxHp;
        pokemon.currHp = oldHp;
    }
    // æ›´æ–°å…¶ä»–èƒ½åŠ›å€¼
    pokemon.atk = newStats.atk;
    pokemon.def = newStats.def;
    pokemon.spa = newStats.spa;
    pokemon.spd = newStats.spd;
    pokemon.spe = newStats.spe;
    // æ ‡è®°å·²å˜å½¢
    pokemon.isTransformed = true;
    pokemon.currentForm = targetFormId;
    pokemon.formType = formType;
    // å‘åå…¼å®¹ï¼šå¦‚æœæ˜¯ Mega/Ultraï¼Œä¹Ÿæ ‡è®° isMega
    if (formType === 'mega' || formType === 'ultra') {
        pokemon.isMega = true;
    }
    // è¿”å›å˜åŒ–ä¿¡æ¯
    const typeChanged = JSON.stringify(oldTypes) !== JSON.stringify(pokemon.types);
    const abilityChanged = oldAbility !== pokemon.ability;
    return {
        success: true,
        oldName,
        newName: pokemon.cnName,
        formType,
        typeChanged,
        newTypes: pokemon.types,
        abilityChanged,
        newAbility: pokemon.ability
    };
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºæ—¶çš„è‡ªåŠ¨å½¢æ€å˜åŒ–ï¼ˆInit-Transformï¼‰
 * ç”¨äºï¼šPrimal Reversion, Crowned Form
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkInitTransform(pokemon) {
    // ä½¿ç”¨æ–°çš„ needsInitTransform æ ‡è®°
    if (pokemon.needsInitTransform && pokemon.initTransformTarget && !pokemon.isTransformed) {
        console.log(`[FORM] Init-Transform triggered for ${pokemon.name} -> ${pokemon.initTransformTarget} (type: ${pokemon.initTransformType})`);
        const result = performFormChange(pokemon, pokemon.initTransformTarget, pokemon.initTransformType);
        pokemon.needsInitTransform = false; // æ ‡è®°å·²å®Œæˆ
        return result;
    }
    return null;
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œå‡»æ€è§¦å‘çš„å½¢æ€å˜åŒ–ï¼ˆBattle Bondï¼‰
 * ç”¨äºï¼šGreninja (Ash-Greninja)
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkBattleBondTransform(pokemon) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç”²è´ºå¿è›™ä¸”æœ‰ç¾ç»Šç‰¹æ€§
    if (pokemon.ability !== 'Battle Bond') {
        return null;
    }
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ Ash å½¢æ€
    const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (baseId === 'greninjaash' || pokemon.isTransformed) {
        return null;
    }
    // å˜ä¸º Ash-Greninja
    const targetId = 'greninjaash';
    const targetData = getPokemonData(targetId);
    if (!targetData) {
        return null;
    }
    console.log(`[FORM] Battle Bond triggered: ${pokemon.name} -> Ash-Greninja`);
    return performFormChange(pokemon, targetId, 'battlebond');
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œè¡€é‡é˜ˆå€¼è§¦å‘çš„å½¢æ€å˜åŒ–
 * ç”¨äºï¼šWishiwashi (School/Solo), Zygarde (Complete), Minior (Shields Down)
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkHPThresholdTransform(pokemon) {
    const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const hpRatio = pokemon.currHp / pokemon.maxHp;
    // å¼±ä¸é±¼ (Wishiwashi) - é±¼ç¾¤ç‰¹æ€§
    if (pokemon.ability === 'Schooling' && baseId.includes('wishiwashi')) {
        const currentlySchool = baseId === 'wishiwashischool';
        if (hpRatio > 0.25 && !currentlySchool) {
            // å˜ä¸ºé±¼ç¾¤å½¢æ€
            console.log(`[FORM] Schooling: ${pokemon.name} -> School Form`);
            return performFormChange(pokemon, 'wishiwashischool', 'schooling');
        } else if (hpRatio <= 0.25 && currentlySchool) {
            // å˜å›å•ç‹¬å½¢æ€
            console.log(`[FORM] Schooling: ${pokemon.name} -> Solo Form`);
            return performFormChange(pokemon, 'wishiwashi', 'schooling');
        }
    }
    // åŸºæ ¼å°”å¾· (Zygarde) - ç¾¤èšå˜å½¢ç‰¹æ€§
    if (pokemon.ability === 'Power Construct' && baseId.includes('zygarde')) {
        const currentlyComplete = baseId === 'zygardecomplete';
        // åªæœ‰ 10% æˆ– 50% å½¢æ€å¯ä»¥å˜ä¸ºå®Œå…¨ä½“ï¼Œä¸”åªèƒ½å˜ä¸€æ¬¡
        if (hpRatio < 0.5 && !currentlyComplete && !pokemon._zygardeTransformed) {
            console.log(`[FORM] Power Construct: ${pokemon.name} -> Complete Forme`);
            pokemon._zygardeTransformed = true; // æ ‡è®°å·²å˜å½¢ï¼Œä¸å¯é€†
            return performFormChange(pokemon, 'zygardecomplete', 'powerconstruct');
        }
    }
    // å°é™¨æ˜Ÿ (Minior) - ç•Œé™ç›¾ç‰¹æ€§
    if (pokemon.ability === 'Shields Down' && baseId.includes('minior')) {
        const currentlyShielded = !baseId.includes('core');
        if (hpRatio > 0.5 && !currentlyShielded) {
            // å˜å›æµæ˜Ÿå½¢æ€ï¼ˆæœ‰ç›¾ï¼‰
            console.log(`[FORM] Shields Down: ${pokemon.name} -> Meteor Form`);
            return performFormChange(pokemon, 'minior', 'shieldsdown');
        } else if (hpRatio <= 0.5 && currentlyShielded) {
            // å˜ä¸ºæ ¸å¿ƒå½¢æ€ï¼ˆæ— ç›¾ï¼‰
            console.log(`[FORM] Shields Down: ${pokemon.name} -> Core Form`);
            // Minior æœ‰å¤šç§é¢œè‰²ï¼Œè¿™é‡Œç®€åŒ–ä¸ºçº¢è‰²æ ¸å¿ƒ
            return performFormChange(pokemon, 'miniorcoreform', 'shieldsdown');
        }
    }
    return null;
}
// å¯¼å‡ºåˆ°å…¨å±€ï¼ˆå¦‚æœåœ¨æµè§ˆå™¨ç¯å¢ƒï¼‰
if (typeof window !== 'undefined') {
    window.performFormChange = performFormChange;
    window.checkInitTransform = checkInitTransform;
    window.checkBattleBondTransform = checkBattleBondTransform;
    window.checkHPThresholdTransform = checkHPThresholdTransform;
}
// å¯¼å‡ºåˆ° Node.js ç¯å¢ƒï¼ˆå¦‚æœéœ€è¦ï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        performFormChange,
        checkInitTransform,
        checkBattleBondTransform,
        checkHPThresholdTransform
    };
}
]]></file>
    <file name="index.css"><![CDATA[.trainer-avatar-wrap img {
    text-indent: -9999px;
    color: transparent;
}
.trainer-avatar-wrap img:not([src]),
.trainer-avatar-wrap img[src=""] {
    opacity: 0;
}
.hidden {
    display: none !important;
}
:root {
    --bg-base: #f4f6fd;
    --primary-white: #ffffff;
    --primary-pink: #fa709a;
    --primary-dark: #403b4a;
    --accent-yellow: #fee140;
    --accent-blue: #00f2fe;
    --hp-high: #4fd1c5;
    --hp-mid: #fbc63e;
    --hp-low: #ff6b6b;
    --font-main: 'Rubik', sans-serif;
    --radius-l: 18px;
    --radius-m: 12px;
    --color-fight: #ff5e78;
    --color-pokemon: #4fabff;
    --color-run: #ffb830;
    --color-catch: #4ade80;
    --ui-glass: rgba(255, 255, 255, 0.95);
}
@keyframes spawn-rise {
    0% {
        opacity: 0;
        transform: translateY(40px) scale(calc(var(--sprite-scale, 1) * 0.45));
    }
    50% {
        opacity: 0.85;
        transform: translateY(-10px) scale(calc(var(--sprite-scale, 1) * 1.05));
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
    }
}
@keyframes spawn-rise-enemy {
    0% {
        opacity: 0;
        transform: translateY(-20px) scale(calc(var(--sprite-scale, 1) * 1.35)) rotate(-3deg);
    }
    40% {
        opacity: 0.65;
        transform: translateY(25px) scale(calc(var(--sprite-scale, 1) * 0.8)) rotate(2deg);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1)) rotate(0deg);
    }
}
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: transparent;
    width: 100vw;
    height: 100vh;
}
.ui-root {
    position: relative;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, rgba(20,20,30,0.1), transparent), #000;
    overflow: hidden;
}
.bg-gradient {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 120vmax;
    height: 120vmax;
    transform: translate(-50%, -50%);
    z-index: 0;
    opacity: 0.3;
}
.ui-scale {
    width: 1100px !important;
    height: 720px !important;
    flex-shrink: 0;
    position: relative;
    z-index: 10;
    margin: 0;
    border-radius: 32px;
    overflow: hidden;
    box-shadow: none;
    transform-origin: center center;
    transform: scale(var(--ui-scale, 1));
    background: #eef1f5;
    text-shadow:
        1.5px 0px 1px rgba(255, 0, 80, 0.15),
        -1.5px 0px 1px rgba(0, 240, 255, 0.15);
}
/* å¤å¤ç”µè§†å“‘å…‰é®ç½© */
.screen-filters {
    position: absolute;
    inset: 0;
    z-index: 9999;
    pointer-events: none;
    backdrop-filter: brightness(1.05) contrast(0.92) grayscale(0.1) sepia(0.05) blur(0.5px);
    background:
        linear-gradient(rgba(0, 0, 0, 0) 66%, rgba(0, 0, 0, 0.15) 66%),
        radial-gradient(circle at center, transparent 50%, rgba(10, 20, 30, 0.25) 90%, rgba(0, 0, 0, 0.4) 100%);
    background-size: 100% 3px, 100% 100%;
    mix-blend-mode: normal;
}
.screen-filters::before {
    content: "";
    position: absolute;
    inset: -10px;
    z-index: 10;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.5'/%3E%3C/svg%3E");
    box-shadow: inset 1px 0px 1px rgba(255, 0, 0, 0.15), inset -1px 0px 1px rgba(0, 255, 255, 0.15);
    opacity: 0.12;
    pointer-events: none;
    animation: noise-move 0.2s steps(4) infinite;
}
.screen-filters::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, transparent 40%, rgba(255,255,255,0.02) 100%);
    pointer-events: none;
    z-index: 11;
}
@keyframes noise-move {
    0%, 100% { transform: translate(0, 0); }
    10% { transform: translate(-3px, -2px); }
    50% { transform: translate(2px, 3px); }
    80% { transform: translate(-2px, 1px); }
}
.ui-scale::after {
    content: "";
    position: absolute;
    inset: 0;
    z-index: 9998;
    pointer-events: none;
    background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxyZWN0IHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNmZmYiLz48cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjY2NjIi8+PC9zdmc+');
    background-size: 2px 2px;
    opacity: 0.1;
    mix-blend-mode: multiply;
}
.overlay-screen {
    position: absolute;
    inset: 0;
    background: rgba(250, 250, 250, 0.85);
    backdrop-filter: blur(15px);
    z-index: 800;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.5s ease;
}
.result-screen {
    position: absolute;
    inset: 0;
    z-index: 999;
    background: rgba(15, 20, 25, 0.85);
    backdrop-filter: blur(15px);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.result-screen.active {
    opacity: 1;
    pointer-events: auto;
}
.start-card {
    background: white;
    padding: 60px 100px;
    border-radius: 40px;
    box-shadow: 0 20px 60px rgba(250, 112, 154, 0.2);
    text-align: center;
    border: 4px solid var(--primary-pink);
    transform: rotate(-2deg);
}
.logo-title {
    font-size: 3.5rem;
    margin: 0;
    color: var(--primary-dark);
    font-weight: 900;
    text-shadow: -2px 0 var(--accent-blue), 2px 0 var(--primary-pink);
    letter-spacing: -2px;
}
.logo-title .accent {
    color: var(--primary-pink);
}
.loader-notch {
    width: 120px;
    height: 10px;
    border-radius: 999px;
    margin: 22px auto 18px;
    background: linear-gradient(90deg, rgba(250,112,154,0.2), rgba(250,112,154,0.9), rgba(0,242,254,0.65));
    filter: blur(0.2px);
}
.sys-msg {
    color: #999;
    font-size: 0.9rem;
    letter-spacing: 2px;
    margin-top: 10px;
    font-weight: 700;
}
.start-btn {
    margin-top: 30px;
    background: var(--primary-pink);
    color: white;
    border: none;
    padding: 15px 50px;
    font-size: 1.5rem;
    cursor: pointer;
    font-family: inherit;
    font-weight: 900;
    border-radius: 50px;
    box-shadow: 0 5px 0 #d64d78;
    transition: transform 0.1s;
}
.start-btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #d64d78; }
.start-btn:disabled {
    cursor: default;
    background: #ccc;
    box-shadow: none;
    opacity: 0.5;
}
.game-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.game-container.hidden {
    display: none;
}
.battle-stage {
    position: relative;
    flex: 1;
    overflow: hidden;
}
.sprite-wrapper {
    position: absolute;
    pointer-events: none;
}
.p-sprite {
    --sprite-scale: 1;
    opacity: 0;
    transition: opacity 0.5s ease-out, transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}
.p-sprite.mega-player {
    --sprite-scale: 1.5;
    filter: drop-shadow(0 0 18px rgba(147, 197, 253, 0.55));
}
.p-sprite.mega-enemy {
    --sprite-scale: 1.2;
    filter: drop-shadow(0 0 16px rgba(250, 113, 113, 0.55));
}
/* éå®˜æ–¹ Megaï¼ˆRadical Red / ROM Hackï¼‰- ä½¿ç”¨åŸå§‹å›¾ç‰‡ + ç‰¹æ®Šæ»¤é•œ */
.p-sprite.unofficial-mega {
    --sprite-scale: 1.15;
    filter: 
        drop-shadow(0 0 20px rgba(220, 38, 127, 0.8))
        drop-shadow(0 0 10px rgba(147, 51, 234, 0.6))
        saturate(1.4)
        brightness(1.1)
        contrast(1.2);
    animation: unofficial-mega-pulse 2s ease-in-out infinite;
}
@keyframes unofficial-mega-pulse {
    0%, 100% {
        filter: 
            drop-shadow(0 0 20px rgba(220, 38, 127, 0.8))
            drop-shadow(0 0 10px rgba(147, 51, 234, 0.6))
            saturate(1.4)
            brightness(1.1)
            contrast(1.2);
    }
    50% {
        filter: 
            drop-shadow(0 0 25px rgba(220, 38, 127, 1))
            drop-shadow(0 0 15px rgba(147, 51, 234, 0.8))
            saturate(1.5)
            brightness(1.15)
            contrast(1.25);
    }
}
.p-sprite {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: pixelated;
    filter: contrast(1.15) brightness(1.05) drop-shadow(4px 8px 6px rgba(0, 0, 0, 0.3));
    transform: translateY(0) scale(var(--sprite-scale));
    animation:
        var(--sprite-animation, none),
        var(--sprite-faint-animation, none),
        var(--sprite-entry-animation, none);
}
.p-sprite.loaded { opacity: 1; }
.p-sprite.fainted-hidden {
    opacity: 0 !important;
    visibility: hidden;
}
.p-sprite.entering {
    --sprite-entry-animation: spawn-rise 0.55s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}
.enemy-pos .p-sprite.entering {
    --sprite-entry-animation: spawn-rise-enemy 0.65s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}
.sprite-wrapper::after {
    content: '';
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 15px;
    background: rgba(60, 50, 80, 0.18);
    border-radius: 50%;
    z-index: -1;
    opacity: 0.35;
    filter: blur(2px);
    transition: opacity 0.25s ease;
}
.sprite-wrapper.sprite-empty::after {
    opacity: 0;
}
.enemy-pos {
    top: 15%;
    right: 10%;
    width: 250px;
    height: 250px;
    z-index: 2;
}
.player-pos {
    bottom: 200px;
    left: 150px;
    width: 260px;
    height: 270px;
    z-index: 5;
}
.shadow-base {
    display: none;
}
.player-scale {
    --sprite-scale: 1.4;
    transform-origin: center bottom;
}
.hud {
    position: absolute;
    z-index: 10;
    width: 320px;
    filter: drop-shadow(4px 10px 0 rgba(70, 70, 80, 0.1));
    background: var(--primary-white);
    border-radius: var(--radius-l);
    padding: 15px 20px;
    border: none;
    box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.15);
}
.panel-enemy {
    top: 40px;
    left: 40px;
}
.panel-player {
    bottom: 250px;
    right: 40px;
    z-index: 11;
}
.hud-top {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    margin-bottom: 6px;
}
.hud-top.right-align {
    justify-content: space-between;
}
.p-name {
    font-family: var(--font-main);
    font-size: 1.4rem;
    font-weight: 800;
    color: var(--primary-dark);
}
.p-lv {
    color: #888;
    font-size: 1rem;
    font-weight: 700;
    white-space: nowrap;
}
.p-lv-capsule {
    background: var(--accent-yellow);
    color: #5d5122;
    padding: 2px 10px;
    border-radius: 20px;
    font-weight: 800;
    font-size: 0.9em;
    white-space: nowrap;
}
.ball-slots {
    display: flex;
    gap: 6px;
}
.ball-slots.right {
    justify-content: flex-end;
}
.dot {
    width: 12px;
    height: 12px;
    background: #e0e0e0;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 0 1px #ddd;
    transition: 0.3s;
}
.dot.alive {
    background: var(--primary-pink);
    box-shadow: 0 0 0 1px var(--primary-pink);
}
.dot.dead {
    background: #555;
}
.dot.active {
    outline: 2px solid rgba(250, 112, 154, 0.35);
    outline-offset: 2px;
}
.hp-badge {
    position: absolute;
    right: 0;
    bottom: -30px;
    background: var(--primary-dark);
    color: white;
    padding: 4px 12px;
    border-radius: 0 0 10px 10px;
    font-size: 1rem;
    font-weight: 700;
    pointer-events: none;
}
.hp-nums {
    text-align: right;
    font-size: 0.9rem;
    font-weight: 800;
    margin-top: 6px;
    color: #6d6874;
}
.hp-container {
    height: 12px;
    background: #444;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: none;
    box-shadow: none;
}
.panel-enemy .hp-container {
    height: 10px;
    margin-top: 10px;
}
.hp-bar-bg {
    width: 100%;
    height: 12px;
    background: transparent;
    border-radius: 20px;
}
.main-hp .hp-bar-bg {
    height: 18px;
    border-radius: 10px;
}
.hp-fill {
    height: 100%;
    width: 100%;
    background: var(--hp-high);
    transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.4s;
    box-shadow: none;
    border-right: 2px solid rgba(255, 255, 255, 0.85);
}
.command-dashboard {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 220px;
    display: flex;
    gap: 16px;
    padding: 10px 10px 10px 10px;
    box-sizing: border-box;
    background: linear-gradient(to top, rgba(255, 255, 255, 0.95), transparent);
    z-index: 50;
    clip-path: polygon(0 20%, 5% 0, 100% 0, 100% 100%, 0 100%);
}
.log-entry {
    margin-bottom: 6px;
    padding-left: 10px;
    border-left: 3px solid rgba(250, 112, 154, 0.35);
    position: relative;
}
.log-entry:last-child {
    font-weight: 800;
    color: #2e2a35;
}
/* =========================================
   ä¸»èœå• (æˆ˜æ–—/å®å¯æ¢¦/é€ƒè·‘)
   ========================================= */
.main-menu {
    flex: 2;
    display: flex;
    flex-direction: column;
    gap: 12px;
    height: 100%;
}
.menu-btn {
    flex: 1;
    border: none;
    background: white;
    color: var(--primary-dark);
    cursor: pointer;
    font-family: inherit;
    font-size: 1.6rem;
    font-weight: 900;
    border: 3px solid #eee;
    border-radius: 14px;
    box-shadow: 4px 4px 0 #bbb;
    transition: all 0.12s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}
.menu-btn::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    border-radius: 10px 0 0 10px;
}
.menu-btn.fight::before { background: var(--primary-pink); }
.menu-btn.pokemon::before { background: var(--accent-blue); }
.menu-btn.run::before { background: var(--accent-yellow); }
.menu-btn:hover {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
}
.menu-btn:active {
    transform: translate(3px, 3px);
    box-shadow: 1px 1px 0 #888;
}
.menu-label {
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.08);
    opacity: 0;
}
/* =========================================
   ç»“ç®—ç”»é¢ (RESULT SCREEN)
   ========================================= */
/* =========================================
   MODERN RESULT CARD (Switch / SV style)
   ========================================= */
.result-screen.hidden {
    display: none;
}
.res-modern-card {
    width: 680px;
    background: #f7f9fc;
    border-radius: 24px;
    overflow: hidden;
    position: relative;
    box-shadow:
        0 25px 50px -12px rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    transform: scale(0.95);
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    display: flex;
    flex-direction: column;
}
.result-screen.active .res-modern-card {
    transform: scale(1);
}
.res-header-banner {
    background: var(--res-color, #718093);
    color: white;
    padding: 20px 30px 50px;
    position: relative;
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0% 100%);
}
.res-header-content {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.res-modern-card.theme-win { --res-color: #f1c40f; --res-color-dark: #d35400; }
.res-modern-card.theme-win .res-header-banner {
    background: linear-gradient(135deg, #fbc531 0%, #e1b12c 100%);
    color: #2f3640;
}
.res-modern-card.theme-loss { --res-color: #e74c3c; --res-color-dark: #c0392b; }
.res-modern-card.theme-loss .res-header-banner {
    background: linear-gradient(135deg, #ff7675 0%, #d63031 100%);
}
.res-modern-card.theme-escape { --res-color: #95a5a6; --res-color-dark: #7f8c8d; }
.res-modern-card.theme-escape .res-header-banner {
    background: linear-gradient(135deg, #b2bec3 0%, #636e72 100%);
}
.res-flag {
    font-size: 0.8rem;
    font-weight: 900;
    letter-spacing: 2px;
    opacity: 0.8;
}
.res-big-title {
    margin: 5px 0 0;
    font-size: 3.5rem;
    font-style: italic;
    font-weight: 900;
    text-transform: uppercase;
    line-height: 0.9;
    transform: skewX(-5deg);
    text-shadow: 3px 3px 0 rgba(0,0,0,0.1);
}
.res-header-pattern {
    position: absolute;
    right: 0; top: 0; bottom: 0; left: 40%;
    background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.08) 0, rgba(255,255,255,0.08) 10px, transparent 10px, transparent 20px);
    pointer-events: none;
}
.res-rank-stamp-wrap {
    position: absolute;
    top: 25px;
    right: 40px;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
}
.res-rank-ring {
    width: 90px;
    height: 90px;
    background: #fff;
    border: 5px solid var(--res-color-dark, #ccc);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: rotate(15deg);
    color: var(--res-color-dark, #ccc);
    animation: stamp-bounce 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) 0.2s both;
}
@keyframes stamp-bounce {
    from { opacity: 0; transform: scale(3) rotate(-30deg); }
    to { opacity: 1; transform: scale(1) rotate(15deg); }
}
#res-grade-letter {
    font-size: 3rem;
    font-weight: 900;
    line-height: 0.8;
}
#res-grade-sub {
    font-size: 0.65em;
    font-weight: 800;
    background: var(--res-color-dark, #ccc);
    color: white;
    padding: 1px 6px;
    border-radius: 4px;
    line-height: 1;
    margin-top: 2px;
}
.res-body {
    padding: 0 35px 20px;
}
.res-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: -10px;
    z-index: 10;
    position: relative;
}
.res-info-tile {
    background: white;
    border-radius: 12px;
    padding: 12px 18px;
    box-shadow: 0 4px 0 #edf0f5;
    border: 1px solid #eef2f7;
    display: flex;
    flex-direction: column;
}
.res-info-tile.full-width {
    grid-column: span 2;
}
.res-info-tile.description-tile {
    background: #fff;
    border-left: 5px solid var(--res-color, #999);
    flex-direction: row;
    align-items: center;
    gap: 12px;
}
.tile-label {
    font-size: 0.7rem;
    font-weight: 900;
    color: #b2bec3;
    margin-bottom: 4px;
    letter-spacing: 0.5px;
}
.tile-val {
    font-weight: 800;
    color: #2d3436;
    font-size: 1.1rem;
    line-height: 1.2;
}
.tile-val.major {
    font-size: 1.3rem;
}
.tile-icon {
    font-size: 1.5rem;
}
.tile-val.text-desc {
    font-weight: 600;
    font-size: 1rem;
    color: #636e72;
}
.mini-party-dots {
    display: flex;
    gap: 6px;
    height: 18px;
    align-items: center;
}
.res-info-tile.team-tile {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}
.mini-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 0 1px #ddd;
    background: #eee;
}
.mini-dot.hp-100 { background: #4fd1c5; }
.mini-dot.hp-mid { background: #fbc63e; }
.mini-dot.hp-low { background: #ff6b6b; }
.mini-dot.hp-dead {
    background: #444;
    position: relative;
    opacity: 0.6;
}
.mini-dot.hp-dead::after {
    content: "Ã—";
    position: absolute;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    line-height: 12px;
    font-weight: bold;
}
.res-pills-action {
    padding: 24px 35px 30px;
    display: flex;
    gap: 16px;
    background: #fff;
    border-top: 1px solid #f0f0f0;
}
.pill-btn {
    border: none;
    border-radius: 500px;
    height: 64px;
    cursor: pointer;
    font-family: inherit;
    font-weight: 800;
    font-size: 1.1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.pill-btn:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.1);
}
.pill-btn:active {
    transform: translateY(-1px);
}
.pill-btn.restart,
.pill-btn.sec {
    background: #f0f2f5;
    color: #636e72;
    padding: 0 24px;
}
.pill-btn.restart {
    flex: 0.7;
    font-size: 0.85rem;
    color: #999;
}
.pill-btn.restart svg {
    margin-bottom: 4px;
}
.pill-btn.sec {
    flex: 1;
}
.pill-btn.primary {
    flex: 2;
    background: var(--res-color, #2d3436);
    color: white;
    box-shadow: 0 8px 15px -4px currentColor;
}
.res-modern-card.theme-win .pill-btn.primary {
    color: #000;
    box-shadow: 0 8px 15px -4px rgba(241, 196, 15, 0.5);
}
.pill-btn.primary .btn-text {
    font-size: 1.25rem;
    letter-spacing: 0.5px;
}
.pill-btn.primary .btn-sub {
    font-size: 0.75rem;
    opacity: 0.7;
    font-weight: normal;
    margin-top: 2px;
}
#res-clipboard-text {
    position: absolute;
    width: 1px;
    height: 1px;
    opacity: 0;
    pointer-events: none;
    border: none;
    resize: none;
}
.moves-menu {
    flex: 2;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 12px;
    height: 100%;
}
.moves-menu.hidden,
.main-menu.hidden {
    display: none;
}
/* è¿”å›æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
.action-btn.back {
    background: #f5f5f5;
    border-color: #ddd;
    color: #888;
}
.action-btn.back:hover:enabled {
    background: #eee;
    color: #666;
}
/* =========================================
   æ”¹è‰¯ç‰ˆèœå•æ ·å¼ - P5 x SWSH Refined
   ========================================= */
.main-menu {
    flex: 2.2;
    position: relative;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    gap: 0;
    pointer-events: none;
    margin-left: 0;
}
.radical-menu-container {
    display: flex;
    align-items: stretch;
    justify-content: flex-start;
    gap: 16px;
    width: 100%;
    height: 100%;
    padding: 10px 5px;
    perspective: 1000px;
    pointer-events: auto;
    box-sizing: border-box;
}
.radical-btn {
    border: 1px solid rgba(55, 65, 81, 0.3);
    cursor: pointer;
    position: relative;
    background: #fff;
    padding: 0;
    outline: none;
    transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.25), box-shadow 0.2s;
    border-radius: 16px;
    transform: skewX(-15deg);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    box-shadow: 4px 4px 0 rgba(0,0,0,0.1);
}
.skew-fix {
    width: 100%;
    height: 100%;
    transform: skewX(15deg);
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-end;
    padding-right: 20px;
    position: relative;
    z-index: 2;
}
.btn-fight {
    flex: 1.5;
    color: var(--color-fight);
    background: #fff;
    z-index: 10;
}
.btn-fight .skew-fix {
    justify-content: flex-end;
    padding-right: 35px;
}
.r-icon-bg {
    display: none;
}
.btn-fight .r-icon {
    width: 200px;
    height: 200px;
    opacity: 0.22;
    position: absolute;
    right: -25px;
    bottom: -60px;
    transform: rotate(5deg) scale(1.1);
    fill: color-mix(in srgb, var(--color-fight) 85%, #000);
    transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
}
.btn-fight .r-label {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    z-index: 5;
    transform: translateY(2px);
}
.btn-fight .en {
    font-family: var(--font-main);
    font-size: 3.8rem;
    font-weight: 900;
    line-height: 0.85;
    letter-spacing: -2px;
    display: block;
    text-transform: uppercase;
    font-style: italic;
    text-shadow: 2px 2px 0px rgba(0,0,0,0.05);
}
.btn-fight .jp {
    font-size: 1rem;
    font-weight: 800;
    opacity: 0.4;
    letter-spacing: 0.4em;
    margin-top: 6px;
    margin-right: 4px;
    border-bottom: 3px solid rgba(255, 94, 120, 0.3);
}
.btn-fight:hover {
    background: var(--color-fight); 
    color: white; 
    border-color: var(--color-fight); 
    box-shadow: 6px 6px 0 rgba(0,0,0,0.15); 
    transform: skewX(-15deg) scale(1.05) translateY(-3px); 
    z-index: 20;
}
.btn-fight:hover .r-icon {
    opacity: 0.3;
    transform: rotate(-10deg) scale(1.0) translateX(-20px);
    fill: #000;
}
.radical-sub-group {
    flex: 1.1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.radical-sub-group.two-btn .radical-btn {
    flex: 0 0 45%;
}
.radical-sub-group .radical-btn {
    flex: 1;
    border-radius: 12px;
    border: 1px solid rgba(55, 65, 81, 0.3);
    background: #fff;
}
.radical-sub-group .radical-btn .skew-fix {
    justify-content: flex-start;
    padding-left: 20px;
}
.btn-pokemon {
    color: var(--color-pokemon);
    margin-left: 16px;
}
.btn-run {
    color: var(--color-run);
    margin-left: -10px;
    width: 96%;
    align-self: flex-end;
}
.r-icon.small {
    width: 90px;
    height: 90px;
    opacity: 0.22;
    position: absolute;
    right: 5px;
    bottom: -25px;
    transform: rotate(5deg);
    transition: 0.3s;
    fill: rgba(0,0,0,0.25);
}
.r-label-min {
    font-size: 1.9rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: -1px;
    font-style: italic;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.05);
}
.btn-pokemon .r-icon.small {
    fill: color-mix(in srgb, var(--color-pokemon) 80%, #000);
}
.btn-run .r-icon.small {
    fill: color-mix(in srgb, var(--color-run) 80%, #000);
}
.btn-pokemon:hover {
    background: var(--color-pokemon);
    color: white;
    border-color: var(--color-pokemon);
    box-shadow: 6px 6px 0 rgba(20, 50, 80, 0.15);
    transform: skewX(-15deg) scale(1.05) translateX(5px);
}
.btn-pokemon:hover .r-icon.small {
    opacity: 0.3;
    fill: #000;
    transform: rotate(-10deg) scale(1.1);
}
.btn-run:hover {
    background: var(--color-run);
    color: white;
    border-color: var(--color-run);
    box-shadow: 6px 6px 0 rgba(80, 60, 20, 0.12);
    transform: skewX(-15deg) scale(1.05) translateX(5px);
}
.btn-run:hover .r-label-min {
    color: #fff;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
}
.btn-run:hover .r-icon.small {
    opacity: 0.3;
    fill: #000;
    transform: translateX(5px) rotate(0deg);
}
.btn-catch {
    color: var(--color-catch) !important;
    background: #fff;
    margin-left: 25px;
}
.btn-catch .r-icon.small {
    color: color-mix(in srgb, var(--color-catch) 80%, #000);
    fill: currentColor;
    transform: rotate(8deg) scale(1);
    transition: transform 0.35s ease, opacity 0.35s ease, color 0.35s ease;
    opacity: 0.35;
}
.btn-catch:hover {
    background: var(--color-catch) !important;
    color: #fff !important;
    border-color: var(--color-catch) !important;
    box-shadow: 6px 6px 0 rgba(40, 160, 80, 0.15) !important;
    transform: skewX(-15deg) scale(1.05) translateX(5px) !important;
}
.btn-catch:hover .r-icon.small {
    color: #000;
    fill: #000 !important;
    opacity: 1 !important;
    transform: rotate(-12deg) scale(1.15);
}
.radical-btn:active {
    transition: 0.05s;
    transform: skewX(-15deg) scale(0.98);
    box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
}
.radical-sub-group .r-label-min {
    position: relative;
    z-index: 5;
}
.radical-sub-group .radical-btn:hover .r-icon.small {
    opacity: 1;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));
}
.r-label-min {
    font-family: var(--font-main);
    font-size: 1.6rem;
    font-weight: 800;
    font-style: normal;
    text-transform: uppercase;
    letter-spacing: 0;
}
.radical-btn .en,
.radical-btn .jp,
.r-label-min {
    font-weight: 900;
}
.radical-btn .en,
.radical-btn .jp {
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.15);
}
.radical-btn:active {
    filter: none;
}
.btn-fight:active .r-icon {
    transform: scale(0.9);
}
.action-btn {
    border: none;
    background: white;
    color: var(--primary-dark);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    font-family: inherit;
    position: relative;
    border: 3px solid #eee;
    border-radius: 12px;
    box-shadow: 4px 4px 0 #bbb;
}
.action-btn:hover:enabled {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
    color: var(--primary-pink);
    background: #fffafa;
}
.action-btn:active:enabled {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
}
.action-btn:disabled {
    opacity: 0.5;
    cursor: default;
    filter: grayscale(1);
}
.action-btn .move-name {
    font-size: 1.3rem;
    font-weight: 900;
    margin-bottom: 4px;
    pointer-events: none;
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
}
.action-btn .move-type {
    font-size: 0.8em;
    opacity: 0.6;
    pointer-events: none;
    text-transform: uppercase;
    font-weight: bold;
}
.action-btn.util {
    background: var(--accent-blue);
    color: white;
    box-shadow: 0 8px 0 #00bfcb, 0 15px 15px rgba(0, 242, 254, 0.3);
}
.action-btn.util .move-name {
    color: #024;
}
.action-btn .badge-type {
    position: absolute;
    bottom: 8px;
    right: 15px;
    pointer-events: none;
    border: none;
    box-shadow: none;
    border-radius: 8px;
    font-size: 0.7em;
}
.overlay-modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(245, 246, 253, 0.92);
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
}
.overlay-modal.hidden {
    display: none;
}
.cutin-overlay {
    position: absolute;
    inset: 0;
    z-index: 2000;
    pointer-events: none;
    display: flex;
    justify-content: flex-end;
    align-items: flex-start;
    padding-top: 3%;
    padding-right: 25px;
    overflow: hidden;
}
.compact-bar {
    position: relative;
    background: rgba(30, 39, 46, 0.90);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 60px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    display: flex;
    align-items: center;
    box-shadow:
        0 10px 25px rgba(0,0,0,0.4),
        0 4px 10px rgba(0,0,0,0.1);
    min-width: 260px;
    max-width: 360px;
    height: 70px;
    transform: translateX(150%);
    opacity: 0;
    transition:
        transform 0.5s cubic-bezier(0.22, 1, 0.36, 1),
        opacity 0.4s ease;
}
.compact-bar.hidden {
    display: none;
}
.compact-bar.active {
    display: flex;
    transform: translateX(0);
    opacity: 1;
}
.compact-bar.outro {
    transform: translateX(120%);
    opacity: 0;
    transition:
        transform 0.4s cubic-bezier(0.55, 0.085, 0.68, 0.53),
        opacity 0.3s ease;
}
.deco-edge {
    width: 6px;
    height: 60%;
    background: var(--accent-yellow);
    border-radius: 10px;
    margin-left: 20px;
    margin-right: 15px;
    box-shadow: 0 0 10px rgba(254, 225, 64, 0.3);
}
.compact-content {
    display: flex;
    align-items: center;
    gap: 12px;
    padding-right: 28px;
    max-width: 100%;
}
.avatar-slot {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.9);
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    overflow: hidden;
    background: #555;
    flex-shrink: 0;
}
.c-avatar-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #e0e0e0;
}
.text-slot {
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: white;
    min-width: 160px;
    max-width: 320px;
}
.c-name-strip {
    font-size: 0.65rem;
    color: #dfe6e9;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1px;
    line-height: 1.2;
    margin-bottom: 4px;
    display: flex;
    align-items: center;
}
.container-enemy .party-track.enemy-side {
    margin-bottom: -4px;
    margin-left: 6px;
    transform: skewX(-22deg);
    height: 24px;
}
.container-player .party-track.player-side {
    margin-top: 2px;
    margin-left: -4px;
    justify-content: flex-end;
    height: 28px;
    transform: translateX(-22px) skewX(-22deg);
}
.container-player .party-track .poke-slot {
    width: 19px;
    height: 19px;
}
.container-enemy .party-track .poke-slot {
    width: 17px;
    height: 17px;
}
.c-name-strip::before {
    content: 'â—†';
    font-size: 0.6em;
    color: var(--primary-pink);
    margin-right: 4px;
}
.c-dialogue {
    font-family: var(--font-main);
    font-size: 0.98rem;
    font-weight: 600;
    line-height: 1.35;
    color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    overflow: hidden;
    display: -webkit-box;
    line-clamp: 2;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}
.switch-header {
    text-align: center;
    color: var(--primary-dark);
}
.switch-header h2 {
    font-size: 2rem;
    margin-bottom: 5px;
}
.switch-grid-v2 {
    display: grid;
    gap: 20px;
    grid-template-columns: repeat(2, 1fr);
    padding: 20px;
}
.p-card {
    background: white;
    border-radius: 20px;
    padding: 15px;
    display: flex;
    gap: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    border: 3px solid transparent;
    transition: 0.2s;
}
.p-card.active {
    border-color: var(--accent-blue);
    background: #f7feff;
}
.p-card:hover:not(.active) {
    border-color: var(--primary-pink);
    transform: scale(1.02);
}
.card-icon {
    width: 70px;
    height: 70px;
    background: #f4f4f4;
    border-radius: 50%;
    margin-right: 10px;
}
.card-info .name {
    color: var(--primary-dark);
}
.card-info .lvl {
    color: #bbb;
}
.switch-hp-bar {
    background: #eee;
    height: 8px;
    border-radius: 4px;
}
.shake-hit-anim,
.shake-hit {
    --sprite-animation: shake-hard 0.4s cubic-bezier(.36, .07, .19, .97) both;
}
@keyframes shake-hard {
    10% { transform: translateX(-10px) scale(var(--sprite-scale, 1)); }
    50% { transform: translateX(10px) scale(var(--sprite-scale, 1)); }
    100% { transform: translateX(0) scale(var(--sprite-scale, 1)); }
}
.p-sprite.fainting {
    --sprite-faint-animation: faint-blip 0.7s ease forwards;
}
@keyframes faint-blip {
    0% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
    }
    15% {
        opacity: 0.25;
        transform: translateY(0) scale(calc(var(--sprite-scale, 1) * 0.92));
    }
    35% {
        opacity: 0.85;
        transform: translateY(-6px) scale(calc(var(--sprite-scale, 1) * 0.85));
    }
    55% {
        opacity: 0.2;
        transform: translateY(12px) scale(calc(var(--sprite-scale, 1) * 0.55));
    }
    100% {
        opacity: 0;
        transform: translateY(40px) scale(calc(var(--sprite-scale, 1) * 0.25));
    }
}
/* =========================================================
   ä¿®æ­£ç‰ˆå¸ƒå±€ - å½»åº•è§£å†³é‡å é—®é¢˜
   ========================================================= */
/* 1. ä»ªè¡¨ç›˜æ€»å®¹å™¨ */
.command-dashboard {
    position: absolute;
    bottom: 24px;
    left: 24px;
    right: 24px;
    height: 190px;
    display: flex;
    gap: 30px; 
    padding: 0;
    box-sizing: border-box;
    background: transparent;
    z-index: 50;
    clip-path: none;
    perspective: 1000px;
}
.msg-box-modern {
    flex: 0 0 40%; 
    width: 40%; 
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    background: #fff;
    border: 1px solid rgba(55, 65, 81, 0.2);
    transform: skewX(-15deg);
    margin-left: -39px;
    border-radius: 16px;
    box-shadow:
        8px 8px 0 rgba(20, 30, 40, 0.15), 
        inset 0 0 0 1px rgba(255, 255, 255, 0.8);
    overflow: hidden;
    transition: all 0.3s ease;
    padding: 0;
}
.msg-header,
.msg-content-area {
    transform: skewX(15deg);
    transform-origin: center center;
    margin: 0 16px;
}
.msg-header {
    flex: 0 0 42px;
    width: 112%;
    margin-left: -6%;
    background: #f1f3f6;
    border-bottom: 3px solid #e0e4eb;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-left: 30px;
    padding-right: 50px;
    box-sizing: border-box;
    position: relative;
    z-index: 5;
}
.sys-label {
    font-size: 0.9rem;
    font-weight: 950;
    letter-spacing: 1px;
    color: var(--primary-dark);
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 12px;
}
.sys-label::before {
    content: '';
    width: 14px;
    height: 14px;
    background: var(--accent-blue);
    border: 2px solid #fff;
    box-shadow: 2px 2px 0 rgba(0,0,0,0.15);
    border-radius: 4px;
    transform: rotate(15deg);
}
.sys-dots { display: none; }
.msg-content-area {
    flex: 1;
    padding: 12px 10px;
    overflow-y: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
    margin: 0 10px;
    margin-right: -10px;
}
.msg-content-area::-webkit-scrollbar {
    display: none;
}
.log-entry {
    margin-bottom: 6px;
    font-size: 1rem;
    color: #64748b;
    line-height: 1.4;
    font-weight: 600;
    opacity: 0.7;
    padding-left: 2px;
}
.log-entry:last-child {
    font-size: 1.25rem;
    color: #333;
    font-weight: 800;
    margin-top: 8px;
    padding-left: 12px;
    border-left: 6px solid var(--accent-blue);
    background: linear-gradient(90deg, rgba(82, 226, 255, 0.1) 0%, transparent 100%);
    opacity: 1;
    border-radius: 0 8px 8px 0;
    text-shadow: 1px 1px 0 #fff;
    animation: simpleSlideIn 0.25s ease-out;
}
@keyframes simpleSlideIn {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}
.hl-dmg {
    color: white;
    background: #ef4444;
    padding: 0 5px;
    border-radius: 4px;
    box-shadow: 1px 1px 0 rgba(0,0,0,0.2);
}
.hl-crit {
    color: #b45309;
    padding: 2px 6px;
    border: 2px solid var(--accent-yellow);
    background: #fffbeb;
    font-weight: 900;
    font-style: italic;
    display: inline-block;
    transform: rotate(-3deg);
}
.next-cursor {
    position: absolute;
    bottom: -5px;
    right: -5px;
    width: 0;
    height: 0;
    border-bottom: 30px solid var(--accent-blue);
    border-left: 30px solid transparent;
    animation: cursor-bounce 1s infinite;
    opacity: 1;
    z-index: 10;
}
@keyframes cursor-bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(5px);
    }
}
.hl-sup {
    color: #fff;
    background: var(--color-fight);
    padding: 1px 8px;
    clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
    font-size: 0.85em;
    margin-left: 6px;
}
.hl-res {
    color: #475569;
    background: #cbd5e1;
    padding: 1px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    margin-left: 6px;
}
.hl-sys {
    color: var(--accent-blue);
    font-weight: 800;
}
.main-menu {
    margin-left: 5px;
    z-index: 60;
}
/* 
   2. å³ä¾§æ“ä½œé¢æ¿é€šç”¨å¤–å£³ (æ ¸å¿ƒä¿®æ­£ç‚¹)
   ä¸å†å¼ºåˆ¶æ‹‰ä¼¸å®½åº¦ï¼Œä¸¥æ ¼éµå®ˆ flex è¾¹ç•Œ 
*/
.main-menu, .moves-menu {
    flex: 1; 
    width: auto; 
    height: 100%;
    margin-left: 0; 
    background: #fff;
    border: 1px solid rgba(55, 65, 81, 0.2);
    border-radius: 16px;
    transform: skewX(-15deg);
    box-shadow: 6px 6px 0 rgba(20, 30, 40, 0.08);
    padding: 0;
    overflow: hidden; 
    pointer-events: auto;
    animation: simpleOpacity 0.3s ease-out;
}
@keyframes simpleOpacity { from { opacity: 0; } to { opacity: 1; } }
.main-menu.hidden, .moves-menu.hidden {
    display: none;
}
/* =========================================
   ä¸»èœå• (FIGHT/RUN) - ä»…éœ€åŒæ­¥å†…éƒ¨è¾¹è·
   ========================================= */
.radical-menu-container {
     transform: skewX(15deg); /* åå‘æ‰¶æ­£ */
     height: 100%;
     width: 100%; 
     display: flex;
     margin: 0;
     padding: 10px 25px; 
     box-sizing: border-box;
}
/* =========================================
   B. æŠ€èƒ½èœå• (Moves Menu) - é«˜åº¦ç˜¦èº« & æ ·å¼é‡æ„
   ========================================= */ 
.moves-menu {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 12px;
    padding: 20px 30px;
    box-sizing: border-box;
    width: auto;
    margin-left: 0; 
    height: 100%;
    position: relative;
    overflow: visible;
}
/* æŠ€èƒ½æŒ‰é’® - é‡å†™ */
.action-btn {
    display: flex;
    /* æ”¹ä¸ºå·¦å³æ¨ªæ’ï¼Œå·¦è¾¹å½©æ¡å³è¾¹å­—ï¼Œæ›´çœé«˜ */
    flex-direction: row; 
    align-items: center; 
    justify-content: space-between; /* åå­—é å·¦ï¼Œæ ‡ç­¾é å³ */
    border: none;
    cursor: pointer;
    font-family: inherit;
    position: relative;
    overflow: hidden; /* å…³é”®ï¼šåˆ‡æ‰æº¢å‡ºçš„é¢œè‰²æ¡ */
    /* åŸºç¡€æ ·å¼ */
    background: #f8fafc;
    /* è¾¹æ¡†ç»†ä¸€ç‚¹ */
    border: 1px solid rgba(55, 65, 81, 0.3);
    border-radius: 10px; /* ç¨å¾®æ–¹ä¸€ç‚¹ */
    transition: all 0.15s ease-out;
    padding: 0 12px 0 0; /* å³è¾¹ç•™ç©ºç»™èƒ¶å›Š */
    /* 
      å…³é”®ä¿®æ­£ï¼šé«˜åº¦è‡ªé€‚åº”å¡«æ»¡ Grid Cellï¼Œ
      é¿å…å›ºå®š padding å¯¼è‡´çš„æ’‘ç ´ 
    */
    width: 100%;
    height: 100%; 
    box-sizing: border-box;
}
/* æŒ‰é’®å†…éƒ¨çš„å†…å®¹å®¹å™¨ - ç”¨æ¥ä¿®æ­£ Skew */
/* 
   å› ä¸ºçˆ¶çº§ skew äº† -15degï¼Œ.moves-menu æ²¡æœ‰ skew(åå‘)ï¼Œ
   æ‰€ä»¥ .action-btn æ˜¯æ–œçš„ï¼ˆå¦‚æ‚¨æ‰€æ„¿ï¼‰ã€‚
   ä½†é‡Œé¢çš„ æ–‡æœ¬ å¿…é¡»ç›´ç«‹ã€‚
*/
.action-btn .move-name, 
.action-btn .badge-type {
    /* å†æ¬¡æŠŠæ–‡å­—æ‰¶æ­£ï¼Œä¾¿äºé˜…è¯» */
    transform: skewX(15deg);
    position: relative;
    z-index: 2;
}
/* [æ”¹åŠ¨] å·¦ä¾§è£…é¥°æ¡ - å˜ä¸ºçœŸæ­£çš„æ–œåˆ‡è‰²å—å¡«å…… */
.action-btn::before {
    content: '';
    position: absolute;
    left: -1px;
    top: -1px;
    bottom: -1px;
    width: 20px; 
    background: hsl(var(--hue, 0), 75%, 65%);
    border: 1px solid rgba(55, 65, 81, 0.3); 
    border-right: 1px solid rgba(55, 65, 81, 0.3);
    opacity: 1; 
    box-sizing: content-box;
}
/* å®šä¹‰ä¸‰ä¸ªæ§½ä½çš„è‰²ç›¸ */
.moves-menu .action-btn:nth-child(1) { --hue: 0;   /* çº¢ */ } 
.moves-menu .action-btn:nth-child(2) { --hue: 200; /* è“ */ }
.moves-menu .action-btn:nth-child(3) { --hue: 45;  /* é‡‘è‰² */ }
.moves-menu .action-btn:nth-child(4) { --hue: 280; /* ç´« */ }
.back-btn-pill {
    position: absolute;
    top: -15px;
    left: -10px;
    width: 44px;
    height: 44px;
    background: #f8fafc;
    color: #334155;
    border: 3px solid rgba(255,255,255,0.85);
    border-radius: 50%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: transform 0.2s, background 0.2s;
    transform: skewX(15deg); /* è¡¥å¿çˆ¶çº§å€¾æ–œ */
}
.back-btn-pill:hover {
    transform: skewX(15deg) scale(1.15) rotate(-10deg);
    background: #e2e8f0;
}
.back-btn-pill svg {
    width: 22px;
    height: 22px;
    fill: currentColor;
}
/* ===========================
   Mega Evolution Button
   =========================== */
 .mega-btn-pill {
    position: absolute;
    top: -35px;
    left: 50px;
    right: auto;
    width: 56px;
    height: 56px;
    background: linear-gradient(135deg, #FF00CC 0%, #6366f1 50%, #333399 100%);
    color: #fff;
    border: 3px solid rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    box-shadow: 0 0 15px rgba(255, 0, 204, 0.5), inset 0 0 10px rgba(255,255,255,0.2);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 101;
    transition: all 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    transform: skewX(15deg);
    overflow: hidden;
}
.mega-btn-pill:hover {
    transform: skewX(15deg) scale(1.1);
    box-shadow: 0 0 25px rgba(255, 0, 204, 0.7), inset 0 0 15px rgba(255,255,255,0.3);
}
.mega-btn-pill.armed {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 0 0 30px #FF00CC, 0 0 60px rgba(99, 102, 241, 0.5);
    border-color: #fff;
    animation: mega-pulse 0.8s infinite alternate ease-in-out;
}
@keyframes mega-pulse {
    0% { 
        box-shadow: 0 0 20px #FF00CC, 0 0 40px rgba(255, 0, 204, 0.4); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 35px #00ffff, 0 0 60px rgba(0, 255, 255, 0.5); 
        filter: brightness(1.15);
    }
}
.mega-btn-pill .mega-icon {
    width: 36px;
    height: 36px;
    transform: skewX(-15deg);
}
.mega-btn-pill.hidden {
    display: none;
}
/* å·¦ä¾§ç•™ç™½ç»™æ–‡å­—ï¼Œé¿å¼€è‰²å— */
.action-btn .move-name {
    margin-left: 22px; /* è®©å¼€è‰²æ¡ */
    font-size: 1rem;   /* å­—å·æ”¹å°!! */
    font-weight: 700;
    color: #334155;
    line-height: 1.1;
    text-align: left;
    white-space: nowrap; /* ä¸å…è®¸æ¢è¡Œæ’‘å¼€é«˜åº¦ */
}
/* [æ”¹åŠ¨] æŠ€èƒ½å³ä¾§çš„å°æ ‡ç­¾ - æ¢å¤ä¸ºå°èƒ¶å›Š */
.action-btn .badge-type {
    font-size: 0.65rem; /* å¾ˆå° */
    font-weight: 800;
    text-transform: uppercase;
    background: #e2e8f0;
    color: #64748b;
    padding: 2px 6px;
    border-radius: 4px;
    /* å¼ºåˆ¶å•è¡Œ */
    white-space: nowrap;
    opacity: 1; /* å¯è§ */
    box-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
/* æ‚¬åœæ•ˆæœ: æ•´ä½“ç¨å¾®å˜äº®å¹¶ä¸Šæµ® */
.action-btn:hover:enabled {
    border-color: #334155; 
    background: #fff;
    transform: translateY(-2px); 
    box-shadow: 4px 4px 0 rgba(0,0,0,0.15);
}
.action-btn:hover:enabled::before {
    filter: brightness(1.1); /* è‰²æ¡å˜äº® */
    width: 25px; /* è‰²æ¡å˜å®½ä¸€ç‚¹ç‚¹ä½œä¸ºäº’åŠ¨åé¦ˆ */
    transition: 0.2s;
}
/* ======================
   Back (è¿”å›) æŒ‰é’®ç‰¹æ®Šæ ·å¼
   ====================== */
.action-btn.back {
    /* è¿”å›æŒ‰é’®é“ºæ»¡èƒŒæ™¯ */
    background: #fff;
    border-color: #cbd5e1;
    justify-content: center; /* æ–‡å­—å±…ä¸­ */
    padding: 0;
}
.action-btn.back::before {
    display: none; /* æ²¡æœ‰è‰²æ¡ */
}
.action-btn.back .move-name {
    margin-left: 0;
    color: #94a3b8;
    font-size: 0.9rem;
}
.action-btn.back:hover {
    background: #f1f5f9;
    border-color: #94a3b8;
}
.action-btn.back .move-name::before {
    content: 'â†© '; /* åŠ ä¸ªç®€å•çš„è¿”å›ç®­å¤´ */
    font-size: 1.1em;
}
/* =========================================
   NEW HUD DESIGN: æ— è¾¹æ¡†æ‚¬æµ®æ–œåˆ‡é£æ ¼
   ========================================= */
.hud-modern {
    position: absolute;
    z-index: 20;
    font-family: var(--font-main);
    color: var(--primary-dark);
    background: transparent;
    border: none;
    padding: 0;
    box-shadow: none;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.15));
}
.hud-enemy {
    top: 50px;
    left: env(safe-area-inset-left, 40px);
    width: 340px;
}
.hud-player {
    bottom: 220px;
    right: env(safe-area-inset-right, 40px);
    width: 380px;
    text-align: right;
}
.info-group, .main-info {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 2px;
}
.hud-player .main-info {
    justify-content: flex-end;
}
.hud-modern .p-name {
    font-size: 2rem;
    font-weight: 800;
    color: #2d3436;
    letter-spacing: -1px;
    text-transform: capitalize;
    text-shadow:
        2px 2px 0px #fff,
        -1px -1px 0 #fff,
        1px -1px 0 #fff,
        -1px 1px 0 #fff,
        1px 1px 0 #fff;
    position: relative;
    z-index: 2;
}
.hud-modern .p-lv {
    font-size: 1.1rem;
    font-weight: 900;
    color: #999;
    text-shadow: 1px 1px 0 #fff;
}
.p-lv-tag {
    background: #2d3436;
    color: var(--accent-yellow);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 1rem;
    font-weight: 800;
    transform: skewX(-15deg);
    box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
}
.p-lv-tag span {
    display: inline-block;
    transform: skewX(15deg);
}
.hp-track {
    position: relative;
    height: 14px;
    width: 100%;
    margin-top: 4px;
    display: flex;
    align-items: center;
}
.hp-track.is-player {
    justify-content: flex-end;
    height: 18px;
    gap: 6px;
}
.hp-intro-label {
    background: #fecea8;
    color: #cb5309;
    font-size: 0.7em;
    font-weight: 900;
    padding: 2px 4px;
    border-radius: 2px;
    transform: skewX(-20deg);
}
.hp-bar-shape {
    flex-grow: 1;
    height: 100%;
    background: rgba(45, 52, 54, 0.8);
    position: relative;
    clip-path: polygon(0 0, 100% 0, 95% 100%, 0% 100%);
    transform: skewX(-20deg);
    border-radius: 4px;
    border: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    overflow: hidden;
}
.hud-enemy .hp-bar-shape {
    transform: skewX(-20deg);
    clip-path: polygon(0 0, 100% 0, 100% 100%, 5% 100%);
}
.hp-fill-modern {
    height: 100%;
    background: linear-gradient(90deg, #4fd1c5 0%, #38b2ac 100%);
    width: 100%;
    transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.4s;
    position: relative;
}
.hp-shine {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 100%);
    pointer-events: none;
    z-index: 5;
}
.hp-val-floating {
    position: absolute;
    right: 0;
    bottom: -18px;
    font-size: 1.1rem;
    font-weight: 700;
    color: #555;
    text-shadow: 1px 1px 0 #fff;
    font-style: italic;
}
.ball-track-modern {
    display: flex;
    gap: 4px;
    margin-top: 8px;
    opacity: 0.8;
}
.ball-track-modern.is-right {
    justify-content: flex-end;
}
.ball-track-modern .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #dcdde1;
    border: 1px solid #718093;
    transition: 0.3s;
}
.ball-track-modern .dot.alive {
    background: var(--primary-pink);
    border-color: white;
    filter: drop-shadow(0 0 3px var(--primary-pink));
}
.ball-track-modern .dot.dead {
    background: #353b48;
    border-color: #353b48;
    opacity: 0.3;
}
.ball-track-modern .dot.active {
    transform: scale(1.5);
    background: white;
    border-color: var(--primary-pink);
    box-shadow: 0 0 4px var(--primary-pink);
}
/* ==============================================
   SHARP ANGULAR HUD ( J-RPG å°–è§’é£æ ¼ )
   ============================================== */
.hud {
    position: absolute;
    z-index: 20;
    pointer-events: none;
}
.container-enemy {
    top: 30px;
    left: env(safe-area-inset-left, 30px);
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}
.container-player {
    bottom: 240px;
    right: env(safe-area-inset-right, 30px);
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}
.sharp-panel {
    position: relative;
    transform: skewX(-15deg);
    padding: 12px 35px 12px 25px;
    background: rgba(255, 255, 255, 0.95);
    border: none;
    box-shadow:
        0 18px 30px rgba(15, 23, 42, 0.18),
        0 10px 0 rgba(15, 23, 42, 0.10);
    min-width: 320px;
    backdrop-filter: blur(8px);
}
.sharp-panel::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,255,255,0));
    opacity: 0.9;
    mix-blend-mode: soft-light;
}
.container-enemy .sharp-panel {
    background: rgba(255, 255, 255, 0.95);
    border: none;
    color: #1e293b;
    border-left-width: 0;
}
.container-player .sharp-panel {
    border: none;
}
.container-player .sharp-panel {
    box-shadow:
        0 -10px 20px rgba(15, 23, 42, 0.08),
        0 18px 28px rgba(15, 23, 42, 0.08),
        0 8px 0 rgba(15, 23, 42, 0.07);
}
.container-player .sharp-panel::before {
    opacity: 1;
    background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0));
}
.panel-content.unskew {
    transform: skewX(15deg);
}
.deco-strip {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 8px;
    background: var(--primary-pink);
}
.container-enemy .deco-strip {
    left: -11px;
    border: none;
    transform: skewX(0deg);
}
.player-strip {
    right: -11px;
    left: auto;
    background: var(--accent-blue);
    border: 2px solid rgba(255, 255, 255, 0.9);
    transform: skewX(0deg);
}
.info-row {
    display: flex;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 6px;
    white-space: nowrap;
}
.right-align {
    justify-content: flex-end;
}
.p-name {
    font-size: 1.6rem;
    font-weight: 800;
    letter-spacing: -0.5px;
}
.container-enemy .p-name { color: #1e293b; text-shadow: none; }
.container-player .p-name { color: #1e293b; text-shadow: none; }
.p-lv {
    font-size: 1rem;
    color: #94a3b8;
    font-weight: 700;
}
.p-lv-badge {
    background: #0f172a;
    color: var(--accent-yellow);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.9rem;
    display: inline-block;
    vertical-align: middle;
}
.hp-nums-floating {
    position: absolute;
    right: 0;
    top: -24px;
    font-weight: 800;
    font-size: 1.1rem;
    color: #475569;
    text-shadow: 1px 1px 0 #fff;
    font-style: italic;
}
.hp-track-wrapper {
    width: 100%;
    margin-top: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.hp-intro {
    font-size: 0.75rem;
    font-weight: 900;
    background: #000;
    color: var(--accent-yellow);
    padding: 1px 4px;
    border-radius: 2px;
}
.hp-border-frame {
    flex: 1;
    background: #334155;
    border: none;
    height: 14px;
    position: relative;
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.5);
    border-radius: 2px;
    overflow: hidden;
}
.container-player .hp-border-frame {
    height: 18px;
    background: #e2e8f0;
}
.hp-fill-colors {
    height: 100%;
    background: linear-gradient(180deg, #4fd1c5 0%, #2c7a7b 90%);
    box-shadow: 0 0 10px rgba(79, 209, 197, 0.4);
    transition: width 0.6s cubic-bezier(0.25, 1, 0.5, 1), background 0.3s;
    position: relative;
    border-right: none;
}
.hp-gloss {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(to bottom, rgba(255,255,255,0.25), transparent);
    z-index: 5;
    pointer-events: none;
}
/* =========================================
   [æ”¹] 6æ§½ç²¾çµçƒ HUD è®¾è®¡ (Black Glass UI)
   ========================================= */
.party-track {
    display: flex;
    gap: 8px;
    margin-bottom: 5px;
    transform: skewX(-15deg);
    height: 32px;
    align-items: center;
    padding: 2px 12px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.35);
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-sizing: border-box;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}
.player-side {
    margin-top: 5px;
    margin-bottom: 0px;
    justify-content: flex-end;
}
.poke-slot {
    width: 20px;
    height: 20px;
    transform: skewX(15deg) rotate(-10deg);
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    transition: all 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}
.ball-menu-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(5px);
    z-index: 250;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}
.ball-menu-overlay.hidden {
    display: none;
}
.ball-menu-card {
    background: #fff;
    border-radius: 16px;
    padding: 20px 30px;
    width: 320px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.4);
    transform: skewX(-5deg);
    border-right: 6px solid var(--color-catch);
}
.ball-header {
    font-size: 1.2rem;
    font-weight: 800;
    color: #333;
    margin-bottom: 20px;
    border-bottom: 2px solid #eee;
    padding-bottom: 10px;
}
.ball-option {
    width: 100%;
    padding: 15px;
    margin-bottom: 10px;
    border: 2px solid #eee;
    border-radius: 10px;
    background: #fff;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    transition: 0.2s;
}
.ball-option:hover {
    background: #f0fdf4;
    border-color: var(--color-catch);
    color: #166534;
    transform: translateX(5px);
}
.ball-multi {
    font-size: 0.8rem;
    background: #333;
    color: #fff;
    padding: 2px 6px;
    border-radius: 4px;
}
.close-ball-menu {
    margin-top: 15px;
    background: transparent;
    border: none;
    color: #999;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
}
.close-ball-menu:hover {
    color: #555;
}
.poke-slot.alive {
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23eee' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 A46,46 0 0,1 96,50' fill='%23fe6b6b'/%3E%3Cpath d='M4,50 L96,50' stroke='%23333' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='14' fill='%23fff' stroke='%23333' stroke-width='4'/%3E%3C/svg%3E");
    opacity: 0.9;
    filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.3));
}
.poke-slot.dead {
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%235E5E5E' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 L96,50' stroke='%23111' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='14' fill='%23999' stroke='%23111' stroke-width='4'/%3E%3Cpath d='M30,30 L70,70 M70,30 L30,70' stroke='%23222' stroke-width='8' opacity='0.5'/%3E%3C/svg%3E");
    opacity: 0.6;
    transform: skewX(15deg) rotate(-15deg) scale(0.85);
    filter: grayscale(1);
}
.poke-slot.active {
    transform: skewX(15deg) rotate(-15deg) scale(1.3) translateY(-4px);
    z-index: 10;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23f5f5f5' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 A46,46 0 0,1 96,50' fill='%23FFCB05'/%3E%3Cpath d='M4,50 L96,50' stroke='%23333' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='15' fill='%23fff' stroke='%23333' stroke-width='4'/%3E%3Cpath d='M25,25 L40,40 M75,25 L60,40' stroke='%23C13E3E' stroke-width='5' stroke-linecap='round'/%3E%3C/svg%3E");
    filter: drop-shadow(0 0 6px rgb(255, 230, 91)) drop-shadow(0 4px 6px rgba(0,0,0,0.3));
}
.poke-slot.empty::after {
    content: "";
    display: block;
    width: 6px;
    height: 6px;
    background: linear-gradient(135deg, #fff 0%, #ddd 100%);
    border-radius: 50%;
    box-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
    opacity: 0.6;
}
/* ==========================================================
   MODERN SWITCH MENU REVAMP (ç°ä»£æ— è¾¹æ¡†é£æ ¼)
   ========================================================== */
.overlay-modal.modern-layer {
    background: rgba(240, 242, 245, 0.4);
    backdrop-filter: blur(25px) saturate(160%) brightness(1.1);
    -webkit-backdrop-filter: blur(25px) saturate(160%) brightness(1.1);
}
.sharp-panel,
.container-enemy .sharp-panel,
.container-player .sharp-panel {
    background: rgba(0, 0, 0, 0.35) !important;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.12);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    color: #fff;
    transform: skewX(-15deg);
    padding: 10px 25px;
}
.sharp-panel::before,
.container-player .sharp-panel::before {
    display: none !important;
}
.deco-strip {
    left: 0;
    width: 4px;
}
.container-player .deco-strip {
    right: 0;
    left: auto;
    border: none;
    to { opacity: 1; }
}
.switch-container-modern {
    width: min(95vw, 640px);
    max-width: 640px;
    height: 100%;
    max-height: none;
    margin: 0 auto;
    padding: 25px 35px 35px;
    position: relative;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    background: rgba(255, 255, 255, 0.85);
    border-radius: 24px;
    overflow-y: auto;
}
.switch-header-modern {
    margin-bottom: 25px;
    padding-left: 20px;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 15px;
    border-bottom: 2px solid rgba(0, 0, 0, 0.05);
    padding-bottom: 15px;
}
.switch-header-modern h2 {
    font-size: 2.2rem;
    color: #2d3436;
    margin: 0;
    letter-spacing: -1px;
}
.switch-header-subtitle {
    font-weight: 500;
    color: #a4b0be;
    font-size: 1rem;
    margin-top: 8px;
    letter-spacing: 1px;
}
.party-grid-modern {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 5px 0 20px;
    overflow-y: auto;
    overflow-x: hidden;
    width: 100%;
    max-height: none;
    flex: 1;
    box-sizing: border-box;
}
.party-grid-modern::-webkit-scrollbar {
    width: 10px;
}
.party-grid-modern::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.12);
    border-radius: 999px;
}
.party-grid-modern::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.04);
    border-radius: 999px;
}
.party-card-modern {
    position: relative;
    background: #ffffff;
    border-radius: 20px;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 18px;
    flex-shrink: 0;
    min-height: 86px;
    box-shadow:
        0 10px 20px rgba(0,0,0,0.03),
        0 2px 5px rgba(0,0,0,0.02);
    transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
    cursor: pointer;
    overflow: hidden;
    opacity: 0;
    animation: slide-up-card 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}
@keyframes slide-up-card {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
.party-card-modern:hover:not(.disabled) {
    transform: translateY(-4px) scale(1.02);
    box-shadow:
        0 15px 30px rgba(0,0,0,0.08),
        0 5px 10px rgba(0,0,0,0.03);
    z-index: 10;
}
.party-card-modern:active:not(.disabled) {
    transform: scale(0.98);
}
.party-card-modern.current {
    background: #f1f3f6;
    box-shadow: inset 0 0 0 2px #dcdde1;
    pointer-events: none;
    opacity: 0.8;
}
.party-card-modern.dead {
    background: #fdfdfd;
    filter: grayscale(1);
    opacity: 0.7;
    cursor: not-allowed;
}
.party-card-modern.dead:not(.disabled) {
    cursor: default;
}
.card-icon-modern {
    width: 65px;
    height: 65px;
    flex-shrink: 0;
    border-radius: 50%;
    background: #fafafa;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
.card-icon-modern img {
    width: 130%;
    height: auto;
    transform: translateY(-2px);
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
}
/* Mega å½¢æ€å›¾æ ‡æ”¾å¤§ */
.card-icon-modern img.mega-icon {
    width: 165% !important;
    transform: translateY(-4px) scale(1.55) !important;
    filter: drop-shadow(0 0 8px rgba(168, 85, 247, 0.4)) drop-shadow(0 4px 6px rgba(0,0,0,0.2)) !important;
}
.card-info-modern {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.card-top-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 6px;
}
.card-name {
    font-size: 1.3rem;
    font-weight: 800;
    color: #2d3436;
}
.card-lv {
    font-size: 0.9rem;
    font-weight: 700;
    color: #b2bec3;
    font-style: italic;
}
.card-hp-nums {
    font-size: 0.8rem;
    font-weight: 700;
    color: #636e72;
    text-align: right;
    margin-bottom: 3px;
    font-family: inherit;
}
.modern-hp-track {
    height: 8px;
    width: 100%;
    background: #eaeaea;
    border-radius: 10px;
    overflow: hidden;
}
.modern-hp-fill {
    height: 100%;
    border-radius: 10px;
    transition: width 0.3s;
    background: var(--hp-high);
}
.status-tag {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    font-size: 0.8rem;
    font-weight: 900;
    color: #d63031;
    border: 2px solid rgba(214, 48, 49, 0.2);
    padding: 2px 8px;
    border-radius: 8px;
    transform: rotate(5deg) translateY(-50%);
}
.current-tag {
    position: absolute;
    right: 0;
    top: 0;
    background: var(--accent-blue);
    color: white;
    font-size: 0.6rem;
    font-weight: 900;
    padding: 2px 10px;
    border-radius: 0 20px 0 10px;
}
/* =========================================================
   [æ”¹] SWSH å‰‘ç›¾é£æ ¼ç™½è‰²é¢æ¿é‡æ„
   ========================================================= */
body {
    font-family: 'Rubik', sans-serif;
}
.hud {
    position: absolute;
    z-index: 10;
    width: 330px;
    background: var(--primary-white);
    border-radius: var(--radius-l);
    padding: 15px 20px;
    border: 2px solid #ffffff;
    box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.08),
        4px 4px 0 rgba(70, 70, 80, 0.08);
    filter: none;
    transform: translateX(5px);
}
.sharp-panel,
.container-player .sharp-panel,
.container-enemy .sharp-panel {
    position: relative;
    transform: skewX(-22deg);
    background: rgba(255, 255, 255, 0.98) !important;
    border: 2px solid rgba(255, 255, 255, 1);
    border-radius: 6px;
    padding: 8px 30px 8px 40px;
    min-width: 290px;
    box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.1),
        2px 4px 6px rgba(0, 0, 0, 0.12),
        0 10px 25px rgba(0, 0, 0, 0.15);
    z-index: 10;
}
.panel-content.unskew {
    transform: skewX(22deg);
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.deco-strip {
    background: var(--primary-pink);
    width: 6px;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 2px 0 0 2px;
    box-shadow: 1px 0 2px rgba(0,0,0,0.2);
    filter: brightness(0.95);
    z-index: 2;
}
.deco-strip.player {
    background: var(--accent-blue);
    left: auto;
    right: 0;
    border-radius: 0 2px 2px 0;
    border: none;
}
.sw-top-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    width: 100%;
    margin-bottom: 2px;
    line-height: 1;
}
.p-name {
    font-size: 1.55rem;
    font-weight: 800;
    color: #2c3e50;
    text-shadow: 2px 2px 0px #fff, -1px -1px 0 #fff;
    letter-spacing: -0.5px;
    margin-right: 15px;
}
.sw-row-right-group {
    display: flex;
    align-items: baseline;
    gap: 10px;
}
.hp-v-nums {
    font-size: 1.1rem;
    font-weight: 700;
    font-family: "Menlo", "Consolas", monospace;
    color: #7f8c8d;
    letter-spacing: -0.5px;
}
.p-lv {
    font-size: 1.2rem;
    font-weight: 500;
    color: #2c3e50;
}
.p-lv span {
    font-weight: 800;
    margin-left: 1px;
}
.hp-track-wrappersw {
    width: 100%;
    height: 13px;
    position: relative;
    margin-bottom: 2px;
}
.container-player .hp-track-wrappersw {
    height: 13px;
}
.hp-border-frame {
    width: 100%;
    height: 100%;
    background: #e6eaea;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    border: none;
    box-shadow: none;
}
.hp-fill-colors {
    border-radius: 20px;
    height: 100%;
    background: #4cd137;
    transition: width 0.4s ease-out;
    box-shadow: none;
    border: none;
}
.hp-intro,
.p-lv-badge,
.hp-nums-floating,
.hp-gloss,
.sw-bot-row {
    display: none !important;
}
.party-track {
    height: 26px;
    background: rgba(0, 0, 0, 0.45);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.15);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    padding: 2px 12px;
    gap: 8px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    transform: skewX(-22deg);
}
.switch-footer {
    margin-top: 30px;
    display: flex;
    justify-content: center;
}
.btn-close-modern {
    background: #fff;
    border: none;
    padding: 12px 30px;
    border-radius: 50px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: inherit;
    font-weight: 800;
    font-size: 1.1rem;
    color: #636e72;
    box-shadow: 0 5px 15px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: 0.2s;
}
.btn-close-modern:hover {
    transform: scale(1.05);
    background: #fff0f5;
    color: var(--primary-pink);
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
}
.key-hint {
    background: #dfececb6;
    color: #555;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 0.8rem;
}
.trainer-hud {
    position: absolute;
    top: 22px;
    right: 22px;
    z-index: 30;
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: none;
}
.trainer-panel {
    transform: skewX(-15deg);
    padding: 10px 18px;
    background: rgba(255, 255, 255, 0.92);
    border: none;
    border-radius: 14px;
    box-shadow:
        0 18px 30px rgba(15, 23, 42, 0.14),
        0 10px 0 rgba(15, 23, 42, 0.08);
    backdrop-filter: blur(8px);
}
.trainer-panel-content {
    transform: skewX(15deg);
}
.trainer-name {
    font-family: var(--font-main);
    font-weight: 900;
    font-size: 1rem;
    color: #1e293b;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    white-space: nowrap;
}
.trainer-avatar-wrap {
    width: 58px;
    height: 58px;
    border-radius: 16px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.75);
    box-shadow:
        0 14px 24px rgba(15, 23, 42, 0.14),
        0 8px 0 rgba(15, 23, 42, 0.06);
}
#trainer-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
}
/* =========================================
   [ADDON] BATTLE EVOLUTION UI - ä¸´åœºè¿›åŒ–æŒ‰é’®
   ä½äº Mega æŒ‰é’®å³ä¾§ï¼Œé‡‡ç”¨é—ªè€€çš„é‡‘è‰²æµå…‰é£æ ¼
   ========================================= */
.mega-btn-pill.evo-style {
    left: 120px;
    background: linear-gradient(135deg, #FFD700 0%, #FDB931 50%, #FFFACD 100%);
    box-shadow: 
        0 0 15px rgba(255, 215, 0, 0.6), 
        inset 0 0 10px rgba(255,255,255,0.4);
    border: 3px solid #FFF;
    z-index: 105;
    animation: gold-pulse 2s infinite ease-in-out;
}
.mega-btn-pill.evo-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(255, 215, 0, 0.9), 
        inset 0 0 15px rgba(255,255,255,0.6);
}
.evo-particles {
    position: absolute;
    width: 60%;
    height: 60%;
    background: radial-gradient(circle, rgba(255,255,255,0.9), transparent 70%);
    opacity: 0.5;
    animation: spin-shine 3s linear infinite;
}
.evo-text {
    font-size: 0.8rem;
    font-weight: 900;
    color: #8B4513;
    font-style: italic;
    transform: skewX(-15deg);
    letter-spacing: 1px;
}
@keyframes gold-pulse {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.2) drop-shadow(0 0 5px gold); }
    100% { filter: brightness(1); }
}
@keyframes spin-shine {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
/* =========================================
   Mega Evolution DNA-Style Visual Effects
   ========================================= */
.p-sprite.loaded {
    opacity: 1;
    filter: drop-shadow(0 2px 5px rgba(0,0,0,0.4));
}
.p-sprite.evo-silhouette {
    filter:
        brightness(0)
        contrast(200%)
        drop-shadow(0 0 10px #ff00ff)
        drop-shadow(2px 2px 4px #00ffff)
        drop-shadow(-2px -2px 4px #ffff00);
    opacity: 0.9;
    animation: dna-struggle 0.12s linear infinite alternate;
}
.p-sprite.evo-burst {
    filter: brightness(10) contrast(0.5) blur(2px) drop-shadow(0 0 30px rgba(255,255,255,0.9));
    transform: scale(1.1);
    opacity: 1;
}
.p-sprite.evo-finish {
    animation: evolve-cooldown 0.8s ease-out forwards;
}
@keyframes dna-struggle {
    from { transform: translateX(-1px) scale(0.98); }
    to { transform: translateX(1px) scale(1.02); }
}
@keyframes evolve-cooldown {
    0% {
        filter: brightness(2) saturate(1.5) drop-shadow(0 0 20px #5ee7ff);
        transform: scale(1.05);
    }
    100% {
        filter: brightness(1.05) saturate(1.05) drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        transform: scale(1);
    }
}
/* ============================================ */
/* æ™®é€šè¿›åŒ–åŠ¨ç”»ï¼ˆä¸ Mega è¿›åŒ–åŒºåˆ†ï¼‰*/
/* ============================================ */
.p-sprite.bio-evo-glow {
    filter: brightness(2) saturate(0.3) drop-shadow(0 0 15px rgba(255,255,255,0.8));
    animation: bio-evo-pulse 0.4s ease-in-out infinite alternate;
}
.p-sprite.bio-evo-burst {
    filter: brightness(5) contrast(0.8) blur(1px) drop-shadow(0 0 25px rgba(255,255,255,0.95));
    transform: scale(1.08);
    opacity: 1;
}
.p-sprite.bio-evo-finish {
    animation: bio-evo-cooldown 0.6s ease-out forwards;
}
@keyframes bio-evo-pulse {
    from { 
        filter: brightness(1.8) saturate(0.3) drop-shadow(0 0 12px rgba(255,255,255,0.7));
        transform: scale(1.0);
    }
    to { 
        filter: brightness(2.2) saturate(0.3) drop-shadow(0 0 18px rgba(255,255,255,0.9));
        transform: scale(1.02);
    }
}
@keyframes bio-evo-cooldown {
    0% {
        filter: brightness(3) saturate(1.3) drop-shadow(0 0 20px #ffffff);
        transform: scale(1.08);
    }
    100% {
        filter: brightness(1.05) saturate(1.05) drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        transform: scale(1);
    }
}
/* Bond Resonance ç¾ç»Šå…±é¸£çŠ¶æ€ */
.p-sprite.bond-resonance {
    filter: drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15);
    animation: bond-pulse 2s ease-in-out infinite;
}
@keyframes bond-pulse {
    0%, 100% {
        filter: drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15);
    }
    50% {
        filter: drop-shadow(0 0 20px #fbbf24) brightness(1.2) saturate(1.3);
    }
}
/* EVO æŒ‰é’® Bond æ¨¡å¼æ ·å¼ */
#btn-evolved.bond-mode {
    background: linear-gradient(135deg, #22c55e 0%, #4ade80 50%, #86efac 100%);
    box-shadow: 0 0 15px rgba(74, 222, 128, 0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    animation: bond-btn-pulse 1.5s ease-in-out infinite;
}
#btn-evolved.bond-mode::before {
    content: 'âˆ';
    font-size: 1.2em;
}
@keyframes bond-btn-pulse {
    0%, 100% {
        box-shadow: 0 0 15px rgba(74, 222, 128, 0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    50% {
        box-shadow: 0 0 25px rgba(74, 222, 128, 0.9), inset 0 1px 0 rgba(255,255,255,0.5);
    }
}
/* =========================================
   [DYNAMAX] æå·¨åŒ–ä¸“ç”¨æ ·å¼
   ========================================= */
/* 1. æå·¨åŒ–çŠ¶æ€ä¸‹çš„ç²¾çµï¼šå·¨å¤§åŒ– + çº¢è‰²æš—äº‘æ»¤é•œ */
.p-sprite.state-dynamax {
    --sprite-scale: 1.8 !important;
    transform: scale(1.8) !important;
    filter: 
        drop-shadow(0 0 25px #ff0055) 
        drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
        brightness(1.05)
        contrast(1.15) 
        saturate(1.25);
    animation: dynamax-breath 3s ease-in-out infinite;
    z-index: 100 !important;
    position: relative;
}
/* ç©å®¶æ–¹æå·¨åŒ–ï¼šå‘ä¸Šç§»åŠ¨ */
#player-sprite.state-dynamax {
    transform: translateY(-30px) scale(1.8) !important;
}
/* æ•Œæ–¹æå·¨åŒ–ï¼šå‘ä¸‹ç§»åŠ¨ä»¥ä¿æŒåœ¨ç”»é¢å†… */
#enemy-sprite.state-dynamax {
    transform: translateY(20px) scale(1.8) !important;
}
/* æå·¨åŒ–å‘¼å¸åŠ¨ç”» - ç©å®¶æ–¹ */
@keyframes dynamax-breath {
    0%, 100% { 
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* ç©å®¶æ–¹å‘¼å¸åŠ¨ç”»ï¼ˆå¸¦ä¸Šä¸‹æµ®åŠ¨ï¼‰*/
#player-sprite.state-dynamax {
    animation: dynamax-breath-player 3s ease-in-out infinite;
}
@keyframes dynamax-breath-player {
    0%, 100% { 
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        transform: translateY(-35px) scale(1.85);
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* æ•Œæ–¹å‘¼å¸åŠ¨ç”»ï¼ˆå¸¦ä¸Šä¸‹æµ®åŠ¨ï¼‰*/
#enemy-sprite.state-dynamax {
    animation: dynamax-breath-enemy 3s ease-in-out infinite;
}
@keyframes dynamax-breath-enemy {
    0%, 100% { 
        transform: translateY(20px) scale(1.8);
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        transform: translateY(25px) scale(1.85);
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* 2. æå·¨åŒ–æŒ‰é’®ï¼šç²‰çº¢/çº¢è‰²èºæ—‹é£æ ¼ */
.mega-btn-pill.dynamax-style {
    background: linear-gradient(135deg, #ff0055 0%, #cc0033 50%, #990022 100%);
    box-shadow: 
        0 0 15px rgba(255, 0, 85, 0.6), 
        0 0 30px rgba(255, 0, 85, 0.3),
        inset 0 0 5px rgba(0, 0, 0, 0.2);
    border: 3px solid #ff99aa;
}
.mega-btn-pill.dynamax-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(255, 0, 85, 0.8), 
        0 0 50px rgba(255, 0, 85, 0.4),
        inset 0 0 10px rgba(0, 0, 0, 0.2);
}
.mega-btn-pill.dynamax-style.armed {
    transform: skewX(15deg) scale(1.2);
    box-shadow: 
        0 0 35px #ff0055, 
        0 0 70px rgba(255, 0, 85, 0.6);
    border-color: #fff;
    animation: dynamax-btn-pulse 0.6s infinite alternate ease-in-out;
}
@keyframes dynamax-btn-pulse {
    0% { 
        box-shadow: 0 0 25px #ff0055, 0 0 50px rgba(255, 0, 85, 0.5); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 40px #ff3377, 0 0 80px rgba(255, 51, 119, 0.6); 
        filter: brightness(1.2);
    }
}
/* æå·¨åŒ–æŒ‰é’®å†…çš„ X å›¾æ ‡ */
.mega-btn-pill.dynamax-style .mega-icon text {
    font-size: 55px;
}
/* 3. æå·¨åŒ–çˆ†å‘åŠ¨ç”»ï¼ˆè§¦å‘æ—¶çš„è§†è§‰æ•ˆæœï¼‰*/
.p-sprite.dynamax-burst {
    animation: dynamax-explosion 0.8s ease-out forwards;
}
@keyframes dynamax-explosion {
    0% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
    30% {
        transform: scale(1.2);
        filter: brightness(3) saturate(0.5) drop-shadow(0 0 50px #ff0055);
    }
    60% {
        transform: translateY(-20px) scale(1.6);
        filter: brightness(1.5) saturate(1.5) drop-shadow(0 0 40px #ff0055);
    }
    100% {
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 20px #ff0055) 
            drop-shadow(0 0 40px rgba(255, 0, 85, 0.5))
            contrast(1.1) 
            saturate(1.2);
    }
}
/* 4. æå·¨åŒ–ç»“æŸæ”¶ç¼©åŠ¨ç”» */
.p-sprite.dynamax-shrink {
    animation: dynamax-shrink 0.6s ease-in forwards;
}
@keyframes dynamax-shrink {
    0% {
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 20px #ff0055) 
            drop-shadow(0 0 40px rgba(255, 0, 85, 0.5))
            contrast(1.1) 
            saturate(1.2);
    }
    50% {
        transform: translateY(-10px) scale(1.3);
        filter: brightness(2) drop-shadow(0 0 30px #ffffff);
    }
    100% {
        transform: translateY(0) scale(var(--sprite-scale, 1));
        filter: contrast(1.15) brightness(1.05) drop-shadow(4px 8px 6px rgba(0, 0, 0, 0.3));
    }
}
/* 5. æå·¨åŒ–å›åˆå€’è®¡æ—¶æŒ‡ç¤ºå™¨ */
.dynamax-turns-indicator {
    position: absolute;
    top: -60px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #ff0055, #cc0033);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 800;
    box-shadow: 0 2px 8px rgba(255, 0, 85, 0.5);
    z-index: 101;
    animation: indicator-pulse 1s ease-in-out infinite;
}
@keyframes indicator-pulse {
    0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
    50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); }
}
/* =========================================
   [Z-MOVE] Zæ‹›å¼æŒ‰é’®æ ·å¼
   ========================================= */
/* Zæ‹›å¼æŒ‰é’®åŸºç¡€æ ·å¼ (æ¨¡æ‹Ÿæ™¶ä½“å…‰æ³½) */
.action-btn.z-move-btn {
    background: linear-gradient(135deg, #FFF 0%, #f3f4f6 40%, rgba(255,255,255,0.8) 100%);
    border: 2px solid transparent !important;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
/* åŠ¨æ€å½©è™¹è¾¹æ¡† (ç”¨ä¼ªå…ƒç´ è£åˆ‡) */
.action-btn.z-move-btn::after {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(45deg, 
        #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
    z-index: -1;
    border-radius: 9px;
    animation: z-border-spin 3s linear infinite;
}
/* å½©è™¹å†…å®¹åº•æ¿ */
.action-btn.z-move-btn .z-bg-overlay {
    position: absolute;
    inset: 2px;
    background: white;
    border-radius: 8px;
    z-index: 0;
}
/* åå­—å’Œå±æ€§æ ‡ç­¾æé«˜å±‚çº§ */
.action-btn.z-move-btn span {
    position: relative;
    z-index: 2;
}
.action-btn.z-move-btn .move-name {
    font-weight: 800;
    font-style: italic;
    background: linear-gradient(90deg, #333, #666);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.action-btn.z-move-btn::before {
    display: none !important;
}
/* å³ä¸Šè§’æ‰“æ ‡ Z */
.action-btn.z-move-btn .z-badge-icon {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 20px;
    height: 20px;
    background: #333;
    border-radius: 50%;
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    z-index: 10;
}
/* å·²ä½¿ç”¨çŠ¶æ€ (Burned Out) */
.action-btn.z-move-used {
    background: #e5e7eb !important;
    border: 2px solid #d1d5db !important;
    opacity: 0.6;
    cursor: not-allowed;
    animation: none;
}
.action-btn.z-move-used::after { display: none; }
.action-btn.z-move-used .move-name {
    -webkit-text-fill-color: #9ca3af;
    text-decoration: line-through;
}
@keyframes z-border-spin {
    0% { filter: hue-rotate(0deg); }
    100% { filter: hue-rotate(360deg); }
}
/* =========================================
   [MAX-MOVE] æå·¨æ‹›å¼æŒ‰é’®æ ·å¼
   ========================================= */
/* æå·¨æ‹›å¼æŒ‰é’® (çº¢è‰²ä¸»é¢˜) */
.action-btn.max-move-btn {
    background: linear-gradient(135deg, #fff5f5 0%, #fee2e2 40%, rgba(255,255,255,0.9) 100%);
    border: 2px solid transparent !important;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(255,0,85,0.2);
}
.action-btn.max-move-btn::after {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(45deg, #ff0055, #ff3377, #ff0055, #cc0033, #ff0055);
    z-index: -1;
    border-radius: 9px;
    animation: max-border-pulse 2s ease-in-out infinite;
}
.action-btn.max-move-btn .z-bg-overlay {
    position: absolute;
    inset: 2px;
    background: linear-gradient(135deg, #fff 0%, #fff5f5 100%);
    border-radius: 8px;
    z-index: 0;
}
.action-btn.max-move-btn span {
    position: relative;
    z-index: 2;
}
.action-btn.max-move-btn .move-name {
    font-weight: 800;
    background: linear-gradient(90deg, #e11d48, #be123c);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.action-btn.max-move-btn::before {
    display: none !important;
}
.action-btn.max-move-btn .z-badge-icon {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 24px;
    height: 24px;
    background: linear-gradient(135deg, #ff0055, #cc0033);
    border-radius: 50%;
    color: white;
    font-size: 10px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(255,0,85,0.4);
    z-index: 10;
}
@keyframes max-border-pulse {
    0%, 100% { 
        filter: brightness(1);
        opacity: 1;
    }
    50% { 
        filter: brightness(1.2);
        opacity: 0.9;
    }
}
/* =========================================================
   å¤ªæ™¶åŒ– (Terastallization) æ ·å¼ç³»ç»Ÿ
   ========================================================= */
/* 1. å¤ªæ™¶åŒ–æŒ‰é’®ï¼šé’»çŸ³/æ°´æ™¶é£æ ¼ - é’è“è‰²æ¸å˜ */
.mega-btn-pill.tera-style {
    background: linear-gradient(135deg, #06b6d4 0%, #0891b2 50%, #0e7490 100%);
    box-shadow: 
        0 0 15px rgba(6, 182, 212, 0.6), 
        0 0 30px rgba(6, 182, 212, 0.3),
        inset 0 0 5px rgba(255, 255, 255, 0.3);
    border: 3px solid #67e8f9;
}
.mega-btn-pill.tera-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(6, 182, 212, 0.8), 
        0 0 50px rgba(6, 182, 212, 0.4),
        inset 0 0 10px rgba(255, 255, 255, 0.4);
}
.mega-btn-pill.tera-style.armed {
    transform: skewX(15deg) scale(1.2);
    box-shadow: 
        0 0 35px #22d3ee, 
        0 0 70px rgba(34, 211, 238, 0.6);
    border-color: #fff;
    animation: tera-btn-pulse 0.6s infinite alternate ease-in-out;
}
@keyframes tera-btn-pulse {
    0% { 
        box-shadow: 0 0 25px #22d3ee, 0 0 50px rgba(34, 211, 238, 0.5); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 40px #67e8f9, 0 0 80px rgba(103, 232, 249, 0.6); 
        filter: brightness(1.2);
    }
}
/* å¤ªæ™¶åŒ–æŒ‰é’®å†…çš„ T å›¾æ ‡ */
.mega-btn-pill.tera-style .mega-icon text {
    font-size: 50px;
}
/* 2. å¤ªæ™¶åŒ–ç²¾çµå›¾æ•ˆæœï¼šæ°´æ™¶å‘å…‰æ»¤é•œ */
.p-sprite.state-terastal {
    filter: 
        brightness(1.3) 
        saturate(1.2)
        drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
        drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    animation: tera-crystal-shimmer 2s infinite ease-in-out;
}
@keyframes tera-crystal-shimmer {
    0%, 100% {
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    50% {
        filter: 
            brightness(1.5) 
            saturate(1.4)
            drop-shadow(0 0 12px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 25px var(--tera-glow-color, #22d3ee));
    }
}
/* 3. å¤ªæ™¶åŒ–çˆ†å‘åŠ¨ç”»ï¼ˆè§¦å‘æ—¶çš„è§†è§‰æ•ˆæœï¼‰*/
.p-sprite.tera-burst {
    animation: tera-crystallize 0.8s ease-out forwards;
}
@keyframes tera-crystallize {
    0% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
    30% {
        transform: scale(1.15);
        filter: brightness(2) saturate(0.5) hue-rotate(180deg);
    }
    60% {
        transform: scale(1.1);
        filter: brightness(1.8) saturate(1.5);
    }
    100% {
        transform: scale(1);
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
}
/* 4. å¤ªæ™¶å±æ€§é¢œè‰²æ˜ å°„ (ç”¨äºå‘å…‰æ•ˆæœ) */
.tera-type-normal { --tera-glow-color: #a8a878; }
.tera-type-fire { --tera-glow-color: #f08030; }
.tera-type-water { --tera-glow-color: #6890f0; }
.tera-type-electric { --tera-glow-color: #f8d030; }
.tera-type-grass { --tera-glow-color: #78c850; }
.tera-type-ice { --tera-glow-color: #98d8d8; }
.tera-type-fighting { --tera-glow-color: #c03028; }
.tera-type-poison { --tera-glow-color: #a040a0; }
.tera-type-ground { --tera-glow-color: #e0c068; }
.tera-type-flying { --tera-glow-color: #a890f0; }
.tera-type-psychic { --tera-glow-color: #f85888; }
.tera-type-bug { --tera-glow-color: #a8b820; }
.tera-type-rock { --tera-glow-color: #b8a038; }
.tera-type-ghost { --tera-glow-color: #705898; }
.tera-type-dragon { --tera-glow-color: #7038f8; }
.tera-type-dark { --tera-glow-color: #705848; }
.tera-type-steel { --tera-glow-color: #b8b8d0; }
.tera-type-fairy { --tera-glow-color: #ee99ac; }
/* =========================================
   [ADDON] Stellar (æ˜Ÿæ™¶) å±æ€§è§†è§‰é£æ ¼
   æµåŠ¨çš„å½©è™¹å…‰æ•ˆ + çš‡å† è´¨æ„Ÿ
   ========================================= */
.tera-type-stellar { 
    --tera-glow-color: #ffffff;
}
/* è¦†ç›–é»˜è®¤çš„ filter åŠ¨ç”»ï¼Œå®ç°å½©è™¹æµå…‰ */
.p-sprite.state-terastal.tera-type-stellar {
    filter: 
        brightness(1.1)
        contrast(1.1)
        drop-shadow(0 0 5px rgba(255, 0, 0, 0.4))
        drop-shadow(0 0 10px rgba(0, 255, 0, 0.4))
        drop-shadow(0 0 15px rgba(0, 0, 255, 0.4));
    animation: stellar-rainbow-pulse 3s linear infinite;
}
/* å¦‚æœæ˜¯æ˜Ÿæ™¶çˆ†å‘ç¬é—´ */
.p-sprite.tera-burst.tera-type-stellar {
    animation: stellar-crystallize 1s ease-out forwards;
}
@keyframes stellar-rainbow-pulse {
    0% { filter: drop-shadow(0 0 8px #ff0000) brightness(1.2); }
    15% { filter: drop-shadow(0 0 8px #ffbd00) brightness(1.2); }
    30% { filter: drop-shadow(0 0 8px #00ff00) brightness(1.2); }
    45% { filter: drop-shadow(0 0 8px #00ffff) brightness(1.2); }
    60% { filter: drop-shadow(0 0 8px #0000ff) brightness(1.2); }
    75% { filter: drop-shadow(0 0 8px #d400ff) brightness(1.2); }
    100% { filter: drop-shadow(0 0 8px #ff0000) brightness(1.2); }
}
@keyframes stellar-crystallize {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.3); filter: brightness(5) hue-rotate(360deg) saturate(2); }
    100% { transform: scale(1); filter: brightness(1.2) drop-shadow(0 0 15px white); }
}
/* åå­—æ ‡ç­¾çš„ç‰¹æ®Šæ ·å¼ */
.tera-name-badge.stellar {
    background: linear-gradient(90deg, #ff0000, #ffff00, #00fbff, #d400ff);
    background-size: 200% 200%;
    animation: gradient-scroll 2s ease infinite;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    border: 1px solid white;
}
@keyframes gradient-scroll {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
/* 5. å¤ªæ™¶åŒ–åå­—æ ‡ç­¾æ ·å¼ */
.tera-name-badge {
    display: inline-block;
    padding: 2px 6px;
    margin-left: 4px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: bold;
    background: linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%);
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    box-shadow: 0 0 5px rgba(34, 211, 238, 0.5);
}
/* 6. å¤ªæ™¶åŒ–æˆ˜è´¥åŠ¨ç”»ï¼šæ°´æ™¶ç¢è£‚æ•ˆæœ */
.p-sprite.state-terastal.fainting {
    --sprite-faint-animation: tera-shatter 0.9s ease forwards;
}
@keyframes tera-shatter {
    0% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    20% {
        opacity: 1;
        transform: translateY(-5px) scale(calc(var(--sprite-scale, 1) * 1.05));
        filter: 
            brightness(2) 
            saturate(0.5)
            drop-shadow(0 0 20px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 40px var(--tera-glow-color, #22d3ee));
    }
    40% {
        opacity: 0.8;
        transform: translateY(0) scale(calc(var(--sprite-scale, 1) * 0.9));
        filter: 
            brightness(1.5) 
            saturate(1.5)
            hue-rotate(30deg)
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    60% {
        opacity: 0.5;
        transform: translateY(10px) scale(calc(var(--sprite-scale, 1) * 0.6));
        filter: 
            brightness(1.2) 
            saturate(2)
            hue-rotate(-30deg)
            drop-shadow(0 0 10px var(--tera-glow-color, #22d3ee));
    }
    80% {
        opacity: 0.2;
        transform: translateY(25px) scale(calc(var(--sprite-scale, 1) * 0.35));
        filter: 
            brightness(0.8) 
            saturate(0.5)
            drop-shadow(0 0 5px var(--tera-glow-color, #22d3ee));
    }
    100% {
        opacity: 0;
        transform: translateY(45px) scale(calc(var(--sprite-scale, 1) * 0.15));
        filter: 
            brightness(0.3) 
            saturate(0)
            drop-shadow(0 0 0px transparent);
    }
}
/* =========================================================
   ã€å¿ƒçœ¼ç³»ç»Ÿã€‘å±æ€§å…‹åˆ¶æç¤ºæ ·å¼ (enable_insight)
   ========================================================= */
.insight-hint {
    display: inline-block;
    margin-left: 4px;
    font-weight: bold;
    font-size: 0.9em;
    vertical-align: middle;
}
.insight-super {
    color: #22c55e;
    text-shadow: 0 0 4px rgba(34, 197, 94, 0.6);
    animation: insight-pulse 1.2s ease-in-out infinite;
}
.insight-resist {
    color: #f97316;
    text-shadow: 0 0 4px rgba(249, 115, 22, 0.5);
}
.insight-immune {
    color: #ef4444;
    text-shadow: 0 0 4px rgba(239, 68, 68, 0.6);
    font-size: 1em;
}
@keyframes insight-pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.15); }
}
/* =========================================================
   ã€å¤æ­¦ç³»ç»Ÿ V4ã€‘å¤ªæå®šå¼ç  (The Taiji Orb)
   è§†è§‰é€»è¾‘ï¼šç±»ä¼¼ Mega æŒ‰é’®çš„åœ†å½¢æµ®é›•ï¼Œç‚¹å‡»åé˜´é˜³æµè½¬
   ========================================================= */
.taiji-orb {
    position: absolute;
    top: -40px;
    right: 100px;
    z-index: 50;
    appearance: none;
    border: none;
    cursor: pointer;
    background: transparent;
    padding: 0;
    width: 58px;
    height: 58px;
    border-radius: 50%;
    transform: skewX(-15deg);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.2s ease;
    box-shadow: 0 6px 12px rgba(0,0,0,0.25);
}
.taiji-orb.hidden {
    opacity: 0;
    pointer-events: none;
    transform: skewX(-15deg) scale(0);
}
.taiji-orb:hover {
    transform: skewX(-15deg) scale(1.08);
    filter: brightness(1.1);
}
.taiji-orb .spinner {
    position: absolute;
    inset: 4px;
    border-radius: 50%;
    overflow: hidden;
    background: conic-gradient(
        from 90deg,
        #0fb6f2 0% 50%,
        #ff5050 50% 100%
    );
    box-shadow: inset 0 0 12px rgba(0,0,0,0.4);
    transition: transform 0.6s cubic-bezier(0.18, 0.89, 0.32, 1.28), background 0.4s ease;
    transform: rotate(0deg);
}
.taiji-orb::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 3px solid rgba(255, 230, 200, 0.85);
    box-shadow:
        inset 0 0 8px rgba(255,255,255,0.4),
        0 2px 5px rgba(0,0,0,0.3);
    pointer-events: none;
}
.taiji-orb .center-content {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5;
}
.taiji-orb .label-kanji {
    font-weight: 900;
    font-size: 1.4rem;
    color: white;
    text-shadow:
        0 2px 6px rgba(0,0,0,0.7),
        0 0 8px rgba(0,0,0,0.5);
    transform: skewX(15deg);
    transition: transform 0.15s ease, opacity 0.15s ease;
}
.taiji-orb .aura-ring {
    position: absolute;
    inset: -4px;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
}
/* çŠ¶æ€ï¼šNormal */
.taiji-orb.normal .spinner {
    transform: rotate(0deg);
    filter: grayscale(0.4);
}
.taiji-orb.normal .label-kanji {
    opacity: 0.8;
}
/* çŠ¶æ€ï¼šAgile */
.taiji-orb.agile .spinner {
    transform: rotate(360deg);
    background: #0ea5e9;
    box-shadow: inset 0 0 20px rgba(255,255,255,0.5);
}
.taiji-orb.agile .label-kanji {
    transform: skewX(15deg) scale(1.1);
    text-shadow: 0 0 12px #38bdf8, 0 0 6px rgba(0,0,0,0.7);
}
.taiji-orb.agile .aura-ring {
    opacity: 0.6;
    box-shadow: 0 0 20px #22d3ee, 0 0 35px rgba(56,189,248,0.7);
    animation: pulse-blue 1.5s infinite;
}
/* çŠ¶æ€ï¼šStrong */
.taiji-orb.strong .spinner {
    transform: rotate(-200deg);
    background: #dc2626;
    box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
}
.taiji-orb.strong .label-kanji {
    transform: skewX(15deg) scale(1.15);
    text-shadow: 0 0 10px rgba(220,38,38,0.8), 0 0 4px rgba(0,0,0,0.8);
}
.taiji-orb.strong .aura-ring {
    opacity: 0.6;
    box-shadow: 0 0 22px #f87171, 0 0 35px rgba(248,113,113,0.8);
    animation: pulse-red 1.1s infinite alternate;
}
@keyframes pulse-blue {
    0% { transform: scale(1); opacity: 0.45; }
    50% { transform: scale(1.08); opacity: 0.75; }
    100% { transform: scale(1); opacity: 0.45; }
}
@keyframes pulse-red {
    0% { transform: scale(1); opacity: 0.5; }
    100% { transform: scale(1.05); opacity: 0.85; }
}
]]></file>
    <file name="index.html"><![CDATA[<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PKM Battle System - Switch Style</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,400;0,500;0,700;0,900;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./index.css">
    <!-- Pokemon Showdown å®Œæ•´æ•°æ®åº“ -->
    <script src="./data/pokedex-data.js"></script>
    <script src="./data/moves-data.js"></script>
    <!-- æ‹›å¼ç¡¬ç¼–ç å¸¸é‡ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./data/move-constants.js"></script>
    <!-- é“å…·æ•°æ®åº“ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/items-data.js"></script>
    <!-- æˆ˜æ–—æœºåˆ¶æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./mechanics/move-styles.js"></script>
    <script src="./mechanics/z-moves.js"></script>
    <script src="./mechanics/mechanic-checker.js"></script>
    <script src="./mechanics/dynamax.js"></script>
    <!-- UI æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./ui/ui-renderer.js"></script>
    <script src="./ui/ui-sprites.js"></script>
    <script src="./ui/ui-trainer-hud.js"></script>
    <script src="./ui/ui-menus.js"></script>
    <!-- ç³»ç»Ÿæ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./systems/data-loader.js"></script>
    <script src="./systems/catch-system.js"></script>
    <script src="./systems/bgm-system.js"></script>
    <script src="./systems/audio-manager.js"></script>
    <script src="./systems/preloader.js"></script>
    <!-- æˆ˜æ–—æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./battle/battle-damage.js"></script>
    <script src="./battle/battle-switch.js"></script>
    <script src="./battle/battle-turns.js"></script>
    <!-- æ‹›å¼å¤„ç†å™¨ - ç­–ç•¥æ¨¡å¼ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/move-handlers.js"></script>
    <!-- ç‰¹æ€§å¤„ç†å™¨ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/ability-handlers.js"></script>
    <!-- æˆ˜æ–—å¼•æ“ -->
    <script src="./engine/battle-engine.js"></script>
    <!-- AI å¼•æ“ -->
    <script src="./engine/ai-engine.js"></script>
    <!-- å½¢æ€å˜åŒ–ç³»ç»Ÿ -->
    <script src="./form-change-system.js"></script>
    <!-- Mega å½¢æ€é€‰æ‹©å¯¹è¯æ¡† -->
    <script src="./mega-selection-dialog.js"></script>
    <!-- æŠ€èƒ½æ•ˆæœæ‰©å±•æ¨¡å— -->
    <script src="./engine/move-effects.js"></script>
    <!-- è®­ç»ƒå®¶ AVs é…ç½® (æ´›è¿ªäºšç‰¹åŒºä¸“å±ç³»ç»Ÿ) -->
    <script src="./data/trainer-avs.js"></script>
</head>
<body>
    <div class="ui-root" id="ui-root">
        <div class="ui-scale" id="ui-scale">
            <div class="screen-filters"></div>
            <div class="bg-gradient"></div>
            <div id="start-view" class="overlay-screen">
                <div class="start-card">
                    <h1 class="logo-title">BATTLE <span class="accent">LINK</span></h1>
                    <div class="loader-notch"></div>
                    <p class="sys-msg">PRESS START TO INITIALIZE</p>
                    <button class="start-btn" onclick="initGame()" id="btn-start" disabled>è¿æ¥ä¸­...</button>
                </div>
            </div>
            <div id="game-view" class="game-container hidden">
                <div class="battle-stage">
                    <div class="trainer-hud hidden" id="trainer-hud">
                        <div class="trainer-panel">
                            <div class="trainer-panel-content">
                                <div class="trainer-name" id="trainer-name">TRAINER</div>
                            </div>
                        </div>
                        <div class="trainer-avatar-wrap">
                            <img id="trainer-avatar" alt="trainer" />
                        </div>
                    </div>
                    <div class="hud container-enemy">
                        <div class="party-track enemy-side" id="ui-enemy-dots"></div>
                        <div class="sharp-panel panel-enemy-bg">
                            <div class="panel-content unskew">
                                <div class="sw-top-row">
                                    <span class="p-name" id="enemy-name">Pokemon</span>
                                    <span class="p-lv">Lv.<span id="enemy-lvl">50</span></span>
                                </div>
                                <div class="hp-track-wrappersw">
                                    <div class="hp-border-frame">
                                        <div class="hp-fill-colors" id="enemy-hp-fill" style="width: 100%;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="deco-strip enemy"></div>
                        </div>
                    </div>
                    <div class="sprite-wrapper enemy-pos">
                        <img id="enemy-sprite" class="p-sprite" src="" alt="">
                        <div class="shadow-base"></div>
                    </div>
                    <div class="sprite-wrapper player-pos">
                        <img id="player-sprite" class="p-sprite player-scale" src="" alt="">
                        <div class="shadow-base"></div>
                    </div>
                    <div class="hud container-player">
                        <div class="sharp-panel panel-player-bg">
                            <div class="panel-content unskew">
                                <div class="sw-top-row">
                                    <span class="p-name" id="player-name">Pokemon</span>
                                    <div class="sw-row-right-group">
                                        <span class="hp-v-nums" id="player-hp-txt">--/--</span>
                                        <span class="p-lv">Lv.<span id="player-lvl">80</span></span>
                                    </div>
                                </div>
                                <div class="hp-track-wrappersw">
                                    <div class="hp-border-frame bg-player">
                                        <div class="hp-fill-colors" id="player-hp-fill" style="width: 100%;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="deco-strip player"></div>
                        </div>
                        <div class="party-track player-side" id="ui-player-dots"></div>
                    </div>
                </div>
                <div class="command-dashboard">
                    <div class="msg-box-modern">
                        <div class="msg-header">
                            <span class="sys-label">BATTLE LOG</span>
                            <div class="sys-dots">
                                <span></span><span></span><span></span>
                            </div>
                        </div>
                        <div class="msg-content-area" id="log-box"></div>
                        <div class="next-cursor"></div>
                    </div>
                    <!-- ä¸»èœå• (P5 x å‰‘ç›¾ æ··åˆé£æ ¼) -->
                    <div class="main-menu" id="main-menu">
                        <div class="radical-menu-container">
                            <button class="radical-btn btn-fight" id="btn-fight" onclick="showMovesMenu()">
                                <div class="skew-fix">
                                    <div class="r-icon-bg"></div>
                                    <svg class="r-icon" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                                        <path d="M168,16H120A56,56,0,0,0,64,72v31.73A8.17,8.17,0,0,1,56.53,112,8,8,0,0,1,48,104V78.7a4,4,0,0,0-5.63-3.65A32,32,0,0,0,24,104v29.19a16.14,16.14,0,0,0,3.5,10q.3.36.63.69L64,179.34V216a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V177.12l15.38-53.84a16,16,0,0,0,.62-4.4V72A56,56,0,0,0,168,16Zm3.58,168.84a8,8,0,0,1-7.16,14.32L136,184.94l-28.42,14.22a8,8,0,1,1-7.16-14.32L118.11,176l-17.69-8.84a8,8,0,1,1,7.16-14.32L136,167.06l28.42-14.22a8,8,0,1,1,7.16,14.32L153.89,176Z"/>
                                    </svg>
                                    <div class="r-label">
                                        <span class="en">FIGHT</span>
                                        <span class="jp">æˆ¦é—˜</span>
                                    </div>
                                </div>
                            </button>
                            <div class="radical-sub-group" id="menu-right-col">
                                <button class="radical-btn btn-catch hidden" id="btn-catch" onclick="openBallMenu()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="0 0 100 125">
                                            <g><path d="M50,70.2c-9.2,0-16.9-6.4-19-14.9H6.6c2.3,21.9,20.8,39,43.4,39s41.1-17.1,43.4-39H68.9C66.9,63.8,59.2,70.2,50,70.2z"/></g><circle cx="50" cy="50.7" r="12"/><path d="M30.9,46C33,37.4,40.7,31,50,31S67,37.4,69,46h24.5c-0.4-4.1-1.4-8-2.9-11.6c0.5-0.7,0.9-1.5,1.1-2.4c0.5-1.9,0.1-4-0.9-5.8  c-3.6-6-9.8-12.2-13.8-15c-1.2-0.9-2.6-1.4-4.1-1.4h0c-1.5,0-2.8,0.5-3.9,1.4C63.3,8.4,56.8,6.8,50,6.8c-6.8,0-13.3,1.6-19.1,4.4  c-1.1-0.9-2.5-1.4-3.9-1.4c-1.5,0-2.9,0.5-4.1,1.4c-4,2.9-10.2,9.1-13.8,15C8,28,7.6,30.1,8.1,32c0.2,0.9,0.6,1.7,1.1,2.4  C7.8,38.1,6.8,42,6.4,46H30.9z M68,24.7C68,24.7,68,24.7,68,24.7l4-9c0.2-0.4,0.6-0.6,1-0.6c0.3,0,0.7,0.1,1,0.4  c3.7,2.6,9.4,8.5,12.5,13.5c0.6,1.1,0.5,2.3-0.4,2.8l-6.5,3.8c-0.3,0.2-0.6,0.2-0.9,0.2c-0.5,0-1.1-0.2-1.4-0.7  c-2.4-3.2-5.3-6-8.5-8.4C68,26.2,67.7,25.4,68,24.7z M13.5,29c3.1-5.1,8.7-10.9,12.5-13.5c0.3-0.2,0.7-0.4,1-0.4  c0.4,0,0.8,0.2,1,0.6l4,9c0,0,0,0,0,0c0.3,0.7,0,1.6-0.6,2c-3.2,2.4-6.1,5.2-8.5,8.4c-0.3,0.5-0.9,0.7-1.4,0.7  c-0.3,0-0.6-0.1-0.9-0.2L14,31.8C13.1,31.2,12.9,30,13.5,29z"/>
                                        </svg>
                                        <span class="r-label-min">CATCH</span>
                                    </div>
                                </button>
                                <button class="radical-btn btn-pokemon" id="btn-pokemon" onclick="renderSwitchMenu()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="22 28 56 48" fill="currentColor" aria-hidden="true">
                                            <path fill-rule="evenodd" d="m50.004 29.184c10.695 0 19.656 8.0234 20.699 18.609h-13.609c-0.92969-3.0234-3.7188-5.2383-7.0938-5.2383-3.3711 0-6.1602 2.2148-7.0938 5.2383h-13.605c1.1641-10.586 10.113-18.609 20.703-18.609zm0 16.512c2.4453 0 4.4219 1.8594 4.4219 4.3047s-1.9766 4.4219-4.4219 4.4219c-2.4414 0-4.3047-1.9766-4.3047-4.4219 0-2.4414 1.8594-4.3047 4.3047-4.3047zm20.695 6.5195c-1.0391 10.582-10 18.602-20.695 18.602-10.586 0-19.535-8.0234-20.703-18.605l13.609 0.003906c0.92969 3.0195 3.7188 5.2305 7.0938 5.2305s6.1602-2.2148 7.0938-5.2305z"/>
                                        </svg>
                                        <span class="r-label-min">POKÃ‰MON</span>
                                    </div>
                                </button>
                                <button class="radical-btn btn-run" id="btn-run" onclick="tryRun()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="0 0 100 100" fill="currentColor" aria-hidden="true">
                                            <path d="M71.738,94.995c-0.03-0.001-0.06-0.001-0.091-0.003C71.677,94.993,71.707,94.994,71.738,94.995z"/>
                                            <path d="M27.068,30.372c-0.239,0.239-0.487,0.492-0.733,0.739c0.591-0.563,1.195-1.09,1.811-1.586   C27.785,29.797,27.425,30.075,27.068,30.372z"/>
                                            <path d="M71.04,22.853c0.205-0.186,0.396-0.385,0.586-0.585c-1.787,1.653-4.176,2.653-6.788,2.653   C67.283,24.92,69.351,24.17,71.04,22.853z"/>
                                            <path d="M72.329,43.413c-0.086,0.007-0.172,0.011-0.257,0.017C72.158,43.424,72.244,43.42,72.329,43.413z"/>
                                            <path d="M68.214,43.376c-0.211-0.02-0.422-0.037-0.634-0.062C67.791,43.339,68.002,43.357,68.214,43.376z"/>
                                            <path d="M75.362,32.625c-0.024,0.024-0.046,0.038-0.07,0.056c0.338-0.13,0.672-0.28,1.004-0.44   C75.986,32.385,75.674,32.514,75.362,32.625z"/>
                                            <path d="M73.767,43.251c-0.031,0.005-0.063,0.01-0.094,0.014C73.704,43.261,73.736,43.256,73.767,43.251z"/>
                                            <path d="M61.835,30.935c-0.189-0.188-0.566-0.375-0.755-0.375c0.229,0.135,0.455,0.249,0.683,0.375H61.835z"/>
                                            <path d="M83.421,39.525c-0.074,0.049-0.15,0.094-0.224,0.142C83.272,39.619,83.347,39.573,83.421,39.525z"/>
                                            <path d="M22.886,34.977c0.206-0.269,0.415-0.531,0.625-0.791C23.299,34.445,23.092,34.709,22.886,34.977z"/>
                                            <path d="M72.258,94.986c-0.013,0.001-0.026,0.001-0.04,0.002C72.231,94.988,72.244,94.987,72.258,94.986z"/>
                                            <path d="M75.362,93.888c0.108-0.108,0.202-0.228,0.299-0.345c-0.69,0.629-1.552,1.08-2.472,1.301   C73.965,94.666,74.711,94.34,75.362,93.888z"/>
                                            <path d="M57.136,62.318c-0.357-0.238-0.737-0.476-1.125-0.714c0.374,0.232,0.749,0.472,1.124,0.715L57.136,62.318z"/>
                                            <path d="M64.886,42.847c-0.578-0.132-1.156-0.275-1.736-0.448C63.73,42.571,64.309,42.717,64.886,42.847z"/>
                                            <path d="M66.597,43.174c-0.292-0.047-0.585-0.099-0.878-0.157C66.012,43.074,66.305,43.128,66.597,43.174z"/>
                                            <path d="M71.264,94.957c-0.061-0.008-0.123-0.013-0.184-0.023C71.141,94.943,71.203,94.949,71.264,94.957z"/>
                                            <path d="M72.81,94.923c-0.018,0.003-0.035,0.005-0.053,0.008C72.775,94.928,72.793,94.926,72.81,94.923z"/>
                                            <path d="M57.51,28.492c-6.577-3.946-13.152-5.073-19.166-3.946c0,0.028-0.012,0.046-0.019,0.067   C44.361,23.365,50.934,24.602,57.51,28.492z"/>
                                            <path d="M83.802,25.422c-0.12,0.078-0.24,0.159-0.356,0.249c-0.188,0.189-0.376,0.379-0.563,0.755   C83.163,26.033,83.474,25.704,83.802,25.422z"/>
                                            <path d="M67.471,92.197c0.797,1.594,2.056,2.43,3.417,2.698C69.545,94.619,68.287,93.777,67.471,92.197z"/>
                                            <path d="M58.457,7.356c-0.129,0.091-0.26,0.18-0.383,0.275c-0.288,0.288-0.557,0.6-0.815,0.921   C57.625,8.122,58.025,7.721,58.457,7.356z"/>
                                            <path d="M85.887,37.701c0.096-0.086,0.185-0.179,0.28-0.266c-0.174,0.15-0.345,0.31-0.521,0.455   C85.726,37.824,85.807,37.766,85.887,37.701z"/>
                                            <path d="M85.126,38.296c-0.26,0.204-0.524,0.399-0.788,0.591C84.603,38.697,84.865,38.498,85.126,38.296z"/>
                                            <path d="M76.43,32.178c0.233-0.115,0.465-0.231,0.694-0.361C76.894,31.944,76.662,32.068,76.43,32.178z"/>
                                            <path d="M83.802,25.422c-0.328,0.282-0.639,0.611-0.919,1.004c-1.759,2.44-3.692,4.217-5.758,5.391   c-0.229,0.13-0.462,0.246-0.694,0.361c-0.044,0.022-0.089,0.042-0.133,0.064c-0.332,0.16-0.666,0.31-1.004,0.44   c-4.132,1.583-8.728,0.912-13.529-1.746c-0.228-0.126-0.454-0.24-0.683-0.375c-0.563-0.376-3.007-1.881-3.57-2.069   c-6.576-3.889-13.15-5.126-19.185-3.879c-3.627,0.749-7.059,2.398-10.179,4.912c-0.616,0.496-1.22,1.023-1.811,1.586   c-0.979,0.933-1.921,1.96-2.824,3.076c-0.21,0.26-0.42,0.521-0.625,0.791c-0.302,0.396-0.601,0.801-0.893,1.218   c-3.757,5.263,5.075,10.337,8.647,5.077c4.695-6.578,10.523-8.458,16.914-6.391c-3.195,5.826-6.202,11.462-10.15,19.357   c-4.136,8.08-12.966,14.469-21.614,9.582c-6.198-3.757-11.649,5.263-5.635,8.834c11.837,6.764,25.557,2.631,32.509-6.202   c0.188,0,0.563,0.186,0.751,0.186c5.826,2.069,13.344,7.329,15.6,9.212c2.253,1.877,6.199,11.462,8.456,16.346   c0.815,1.58,2.074,2.422,3.417,2.698c0.064,0.013,0.127,0.028,0.191,0.039c0.061,0.01,0.123,0.015,0.184,0.023   c0.127,0.016,0.255,0.028,0.383,0.035c0.03,0.002,0.06,0.002,0.091,0.003c0.16,0.005,0.32,0.003,0.48-0.006   c0.013-0.001,0.026-0.001,0.04-0.002c0.167-0.011,0.334-0.029,0.5-0.056c0.018-0.003,0.036-0.005,0.053-0.008   c0.128-0.022,0.254-0.049,0.379-0.079c0.92-0.221,1.782-0.672,2.472-1.301c1.423-1.296,2.11-3.339,1.019-5.668   c-2.633-5.449-7.142-16.349-10.524-19.167c-2.064-1.515-5.539-4.134-9.022-6.388c-0.375-0.243-0.75-0.483-1.124-0.715   c-0.896-0.557-1.782-1.079-2.635-1.541c3.195-6.014,6.391-11.838,9.773-17.664c0.58,0.173,1.159,0.316,1.736,0.448   c0.278,0.064,0.555,0.116,0.833,0.17c0.293,0.057,0.586,0.11,0.878,0.157c0.328,0.053,0.656,0.101,0.983,0.14   c0.212,0.026,0.423,0.042,0.634,0.062c1.3,0.123,2.587,0.14,3.858,0.054c0.086-0.006,0.172-0.01,0.257-0.017   c0.45-0.036,0.898-0.085,1.344-0.147c0.031-0.004,0.063-0.01,0.094-0.014c3.309-0.475,6.481-1.674,9.43-3.585   c0.074-0.048,0.15-0.093,0.224-0.142c0.308-0.204,0.613-0.418,0.917-0.638c0.265-0.192,0.528-0.387,0.788-0.591   c0.173-0.136,0.348-0.266,0.52-0.407c0.176-0.145,0.347-0.305,0.521-0.455c1.915-1.652,3.716-3.619,5.359-5.936   C95.002,26.631,87.866,21.929,83.802,25.422z"/>
                                            <path d="M64.838,24.92c2.612,0,5.001-0.999,6.788-2.653c1.943-1.798,3.174-4.37,3.174-7.307c0-5.448-4.511-9.958-9.962-9.958   c-2.417,0-4.645,0.891-6.381,2.354c-0.432,0.365-0.833,0.765-1.199,1.197c-1.476,1.74-2.376,3.979-2.376,6.408   C54.882,20.6,59.39,24.92,64.838,24.92z"/>
                                        </svg>
                                        <span class="r-label-min">ESCAPE</span>
                                    </div>
                                </button>
                            </div>
                        </div>
                    </div>
                    <!-- æŠ€èƒ½èœå• (ç‚¹å‡»æˆ˜æ–—åæ˜¾ç¤º) -->
                    <div class="moves-menu hidden" id="moves-menu">
                        <!-- å¤æ­¦æµæ´¾åˆ‡æ¢ï¼šé˜´é˜³å®šå¼çƒ (Taiji Orb) -->
                        <button class="taiji-orb normal hidden" id="btn-style-taiji" onclick="cycleMoveStyle()" title="å¤æ­¦æ¶åŠ¿ï¼šç‚¹å‡»åˆ‡æ¢ åˆš/è¿…">
                            <div class="spinner">
                                <span class="yang"></span>
                                <span class="yin"></span>
                            </div>
                            <div class="center-content">
                                <span class="label-kanji" id="taiji-text">é“</span>
                            </div>
                            <div class="aura-ring"></div>
                        </button>
                        <button class="action-btn" id="btn-m0" onclick="handleAttack(0)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m1" onclick="handleAttack(1)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m2" onclick="handleAttack(2)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m3" onclick="handleAttack(3)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="back-btn-pill" id="btn-back" onclick="showMainMenu()" title="Back">
                            <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                <path d="M19 11H7.83l4.88-4.88a1 1 0 0 0-1.42-1.42l-6.59 6.59a1 1 0 0 0 0 1.41l6.59 6.59a1 1 0 0 0 1.42-1.41L7.83 13H19a1 1 0 0 0 0-2z"/>
                            </svg>
                        </button>
                        <!-- Mega Evolution Button -->
                        <button class="mega-btn-pill hidden" id="btn-mega" onclick="toggleMega()" title="Mega Evolution">
                            <svg viewBox="0 0 100 100" class="mega-icon">
                                <circle cx="50" cy="50" r="42" stroke="currentColor" stroke-width="6" fill="none" opacity="0.4"/>
                                <text x="50" y="68" font-size="50" text-anchor="middle" fill="currentColor" font-weight="900" style="font-family: inherit;">M</text>
                            </svg>
                        </button>
                        <!-- âœ¨ ä¸´åœºè¿›åŒ–æŒ‰é’® âœ¨ -->
                        <button class="mega-btn-pill evo-style hidden" id="btn-evolved" onclick="triggerBattleEvolution()" title="Evolution">
                            <div class="evo-particles"></div>
                            <span class="evo-text">EVO</span>
                        </button>
                    </div>
                </div>
                <!-- ç»“ç®—ç”»é¢ Overlay -->
                <div id="result-overlay" class="result-screen hidden">
                    <div class="res-modern-card" id="res-card-bg">
                        <div class="res-header-banner">
                            <div class="res-header-content">
                                <span class="res-flag">BATTLE RESULT</span>
                                <h1 class="res-big-title" id="res-title">VICTORY</h1>
                            </div>
                            <div class="res-header-pattern"></div>
                        </div>
                        <div class="res-rank-stamp-wrap">
                            <div class="res-rank-ring">
                                <span id="res-grade-letter">S</span>
                                <span id="res-grade-sub">RANK</span>
                            </div>
                        </div>
                        <div class="res-body">
                            <div class="res-info-grid">
                                <div class="res-info-tile full-width">
                                    <span class="tile-label">STATUS</span>
                                    <span class="tile-val major" id="col-status">Victory against Cynthia</span>
                                </div>
                                <div class="res-info-tile full-width description-tile">
                                    <span class="tile-icon">ğŸ’¬</span>
                                    <span class="tile-val text-desc" id="col-desc">ä¸€åœºå‹å€’æ€§çš„å®Œèƒœã€‚</span>
                                </div>
                                <div class="res-info-tile team-tile">
                                    <span class="tile-label">PARTY</span>
                                    <div class="mini-party-dots" id="res-party-viz"></div>
                                </div>
                                <div class="res-info-tile">
                                    <span class="tile-label">REASON</span>
                                    <span class="tile-val" id="col-reason">Total Domination</span>
                                </div>
                            </div>
                            <textarea id="res-clipboard-text" readonly></textarea>
                        </div>
                        <div class="res-pills-action">
                            <button class="pill-btn restart" onclick="restartBattle()">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" class="pill-icon">
                                    <path d="M4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4V2M12 4L8 8M12 4L16 8" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                RETRY
                            </button>
                            <button class="pill-btn sec" onclick="copyResultOnly()">
                                DATA ONLY
                            </button>
                            <button class="pill-btn primary" onclick="copyFullProcess()">
                                <span class="btn-text">COPY FULL LOG</span>
                                <span class="btn-sub">RP Mode</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="overlay-modal hidden" id="switch-menu-layer"></div>
                <div id="ball-layer" class="ball-menu-overlay hidden">
                    <div class="ball-menu-card">
                        <div class="ball-header">SELECT BALL</div>
                        <button class="ball-option" onclick="tryCatch(1)">
                            <span>Poke Ball</span> <span class="ball-multi">x1.0</span>
                        </button>
                        <button class="ball-option" onclick="tryCatch(1.5)">
                            <span>Great Ball</span> <span class="ball-multi">x1.5</span>
                        </button>
                        <button class="ball-option" onclick="tryCatch(2.0)">
                            <span>Ultra Ball</span> <span class="ball-multi">x2.0</span>
                        </button>
                        <button class="ball-option" style="border-color:#a855f7;color:#9333ea" onclick="tryCatch(255)">
                            <span style="font-weight:900">Master Ball</span> <span class="ball-multi" style="background:#9333ea">MAX</span>
                        </button>
                        <button class="close-ball-menu" onclick="closeBallMenu()">CANCEL</button>
                    </div>
                </div>
            </div>
            <!-- å‰§åœºåŒ–åˆ‡å…¥å±‚ -->
            <div id="theater-layer" class="cutin-overlay pointer-events-none">
                <div id="cutin-stage" class="compact-bar hidden">
                    <div class="deco-edge"></div>
                    <div class="compact-content">
                        <div class="avatar-slot">
                            <img id="cutin-avatar" src="" class="c-avatar-img" alt="cutin avatar" onerror="this.style.opacity=0">
                        </div>
                        <div class="text-slot">
                            <div class="c-name-strip" id="cutin-name">TRAINER</div>
                            <div class="c-dialogue" id="cutin-text">Battle text goes here...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<script>
    (function () {
        function handleInjectedData(data) {
            if (!data) return;
            window.globalBattleData = data;
            if (typeof window.onBattleDataInjected === 'function' && window.onBattleDataInjected !== handleInjectedData) {
                try {
                    window.onBattleDataInjected(data);
                } catch (e) {
                    console.warn('[PKM] onBattleDataInjected error:', e);
                }
            }
        }
        window.globalBattleData = window.globalBattleData || null;
        window.onBattleDataInjected = handleInjectedData;
        window.addEventListener('message', (event) => {
            const payload = event?.data;
            if (!payload || payload.type !== 'pkm-battle-data') return;
            handleInjectedData(payload.payload);
        });
        window.requestBattleDataFromParent = function () {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'pkm-battle-data-request' }, '*');
                } catch (e) {
                    console.warn('[PKM] requestBattleDataFromParent failed:', e);
                }
            }
        };
        window.requestBattleDataFromParent();
    })();
</script>
<script src="./index.js"></script>
</body>
</html>]]></file>
    <file name="index.js"><![CDATA[/**
 * ===========================================
 * INDEX.JS - UI æ§åˆ¶å™¨ & å…¥å£
 * ===========================================
 * 
 * ä¾èµ–: pokedex-data.js, moves-data.js, battle-engine.js
 * 
 * èŒè´£:
 * - UI æ¸²æŸ“ (è¡€æ¡ã€ç²¾çµå›¾ã€æŒ‰é’®)
 * - ç”¨æˆ·äº¤äº’å¤„ç†
 * - æˆ˜æ–—æµç¨‹æ§åˆ¶
 * - JSON åŠ è½½å…¥å£
 */
// å…¨å±€æˆ˜æ–—çŠ¶æ€
let battle = new BattleState();
window.battle = battle;  // å¯¼å‡ºåˆ°å…¨å±€ï¼Œä¾›æ¨¡å—è®¿é—®
// ============================================
// ã€å·²è¿ç§»ã€‘å¤æ­¦ç³»ç»Ÿ -> mechanics/move-styles.js
// ã€å·²è¿ç§»ã€‘Z-Move/Max Move æ¨å¯¼ -> mechanics/z-moves.js
// ============================================
// ============================================
// ã€å·²è¿ç§»ã€‘è®­ç»ƒå®¶å¤´åƒç³»ç»Ÿ -> ui/ui-trainer-hud.js
// ã€å·²è¿ç§»ã€‘Cut-in æ¼”å‡ºç³»ç»Ÿ -> ui/ui-trainer-hud.js
// ã€å·²è¿ç§»ã€‘UI ç¼©æ”¾ -> ui/ui-renderer.js
// ============================================
// é¢„åŠ è½½æ¨¡æ‹Ÿ
setTimeout(() => {
    document.getElementById('btn-start').innerText = "START GAME";
    document.getElementById('btn-start').disabled = false;
    document.getElementById('btn-start').style.fontWeight = "900";
}, 800);
window.addEventListener('resize', updateUIScale);
updateUIScale();
/**
 * åˆå§‹åŒ–æ¸¸æˆ - åŠ è½½ç¤ºä¾‹å¯¹æˆ˜
 */
async function initGame() {
    const startBtn = document.getElementById('btn-start');
    const sysMsg = document.querySelector('.sys-msg');
    // === é¢„åŠ è½½é˜¶æ®µ ===
    startBtn.disabled = true;
    startBtn.innerText = "LOADING...";
    if (sysMsg) sysMsg.textContent = "PRELOADING RESOURCES...";
    // è·å–æˆ˜æ–—æ•°æ®
    let json;
    if (typeof globalBattleData !== 'undefined' && globalBattleData) {
        json = globalBattleData;
    } else {
        json = getDefaultBattleData();
    }
    // é¢„åŠ è½½æœ¬å±€èµ„æº
    const playerParty = (json.player && json.player.party) || [];
    const enemyParty = json.party || (json.enemy && json.enemy.party) || [];
    const trainerId = (json.enemy && json.enemy.id) || (json.trainer && json.trainer.id) || null;
    if (typeof preloadBattleResources === 'function' && (playerParty.length > 0 || enemyParty.length > 0)) {
        try {
            await preloadBattleResources(playerParty, enemyParty, trainerId, (loaded, total) => {
                if (sysMsg) sysMsg.textContent = `LOADING... ${Math.floor(loaded/total*100)}%`;
            });
        } catch (e) {
            console.warn('[PRELOAD] Error:', e);
        }
    }
    if (sysMsg) sysMsg.textContent = "READY!";
    // éšè—åŠ è½½é¡µï¼Œæ˜¾ç¤ºæ¸¸æˆç•Œé¢
    document.getElementById('start-view').style.opacity = 0;
    setTimeout(() => document.getElementById('start-view').style.display = 'none', 500);
    document.getElementById('game-view').classList.remove('hidden');
    resetSpriteState();
    // åŠ è½½å¯¹æˆ˜ JSON (å·²åœ¨é¢„åŠ è½½é˜¶æ®µè·å–)
    try {
        console.log('[PKM] ä½¿ç”¨æˆ˜æ–—æ•°æ®:', json);
        // ä» JSON åŠ è½½ç©å®¶é˜Ÿä¼
        if (json.player && json.player.party) {
            // === è§£é”ç³»ç»Ÿ (Unlock System) ===
            // è§£æ unlocks å¯¹è±¡ï¼Œå†³å®šç©å®¶æ˜¯å¦æœ‰èµ„æ ¼ä½¿ç”¨å„æœºåˆ¶
            const unlocks = json.player.unlocks || {};
            battle.playerUnlocks = {
                enable_bond: unlocks.enable_bond !== false,        // ç¾ç»Šå…±é¸£
                enable_styles: unlocks.enable_styles !== false,    // åˆšçŒ›/è¿…ç–¾
                enable_insight: unlocks.enable_insight !== false,  // å¿ƒçœ¼/AVsçªç ´
                enable_mega: unlocks.enable_mega !== false,        // Megaè¿›åŒ–
                enable_z_move: unlocks.enable_z_move !== false,    // Zæ‹›å¼
                enable_dynamax: unlocks.enable_dynamax !== false,  // æå·¨åŒ–
                enable_tera: unlocks.enable_tera !== false         // å¤ªæ™¶åŒ–
            };
            console.log('[UNLOCK] ç©å®¶è§£é”çŠ¶æ€:', battle.playerUnlocks);
            // æ£€æŸ¥ç©å®¶æ˜¯å¦æœ‰ Mega æƒé™ (ç›´æ¥ä» unlocks è¯»å–)
            const playerCanMega = battle.playerUnlocks.enable_mega;
            battle.setPlayerParty(json.player.party, playerCanMega);
            battle.playerName = json.player.name || 'ä¸»è§’';
            log(`<b>${battle.playerName}</b> å‡†å¤‡æˆ˜æ–—ï¼`);
        } else {
            // Fallback: é»˜è®¤ç©å®¶é˜Ÿä¼
            battle.setPlayerParty([
                { name: 'Charmander', lv: 5, moves: ['Scratch', 'Ember'] },
                { name: 'Pikachu', lv: 5, moves: ['Thunder Shock', 'Quick Attack'] },
            ], false);
            battle.playerName = 'ä¸»è§’';
        }
        // åŠ è½½æ•Œæ–¹æ•°æ®
        battle.loadFromJSON(json);
        updateTrainerHud();
        const t = battle.trainer;
        const btnCatch = document.getElementById('btn-catch');
        const rightCol = document.getElementById('menu-right-col');
        const catchLayer = document.getElementById('ball-layer');
        if (btnCatch && rightCol) {
            if (t && (t.id === 'wild' || !t.id)) {
                btnCatch.classList.remove('hidden');
                rightCol.classList.remove('two-btn');
            } else {
                btnCatch.classList.add('hidden');
                rightCol.classList.add('two-btn');
                if (catchLayer) catchLayer.classList.add('hidden');
            }
        }
        if (t) {
            const isWild = t.id === 'wild';
            if (isWild) {
                log(`é‡ç”Ÿå®å¯æ¢¦ã€${battle.getEnemy().cnName}ã€‘å‡ºç°äº†ï¼`);
            } else {
                log(`<b style="color:#e74c3c">ã€${t.name}ã€‘</b>å‘èµ·æŒ‘æˆ˜ï¼`);
            }
            if (t.lines?.start) {
                log(`<i>${t.name}: "${t.lines.start}"</i>`);
            }
        }
        log(`æ•Œæ–¹æ´¾å‡ºäº† <b>${battle.getEnemy().cnName}</b> (Lv.${battle.getEnemy().level})!`);
        if (battle.scriptedResult === 'loss') {
            log(`<span style="color:#e67e22">[å‰§æƒ…æˆ˜] è¿™æ˜¯ä¸€åœºå¿…è´¥çš„æˆ˜æ–—...</span>`);
        }
    } catch (e) {
        console.error('Failed to load battle JSON:', e);
        // Fallback: ç®€å•å¯¹æˆ˜
        battle.setPlayerParty([
            { name: 'Pikachu', lv: 5, moves: ['Thunder Shock', 'Quick Attack'] }
        ]);
        battle.loadFromJSON({
            trainer: { name: 'é‡ç”Ÿå®å¯æ¢¦', id: 'wild', line: '' },
            party: [{ name: 'Rattata', lv: 3, moves: ['Tackle'] }]
        });
        log("é‡ç”Ÿçš„å°æ‹‰è¾¾å‡ºç°äº†ï¼");
    }
    const openingPoke = battle.getPlayer();
    const openingEnemy = battle.getEnemy();
    if (openingPoke) {
        log(`å»å§ï¼${openingPoke.cnName}ï¼ˆLv.${openingPoke.level}ï¼‰ï¼`);
    }
    // === æ’­æ”¾åŒæ–¹å®å¯æ¢¦å«å£° ===
    setTimeout(() => {
        if (openingPoke && typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(openingPoke.name);
        }
    }, 500);
    setTimeout(() => {
        if (openingEnemy && typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(openingEnemy.name);
        }
    }, 1200);
    // === æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºè‡ªåŠ¨å˜å½¢ (Primal/Crowned) ===
    const checkInitTransformFunc = typeof window.checkInitTransform === 'function' ? window.checkInitTransform : null;
    if (checkInitTransformFunc) {
        // æ£€æŸ¥ç©å®¶å®å¯æ¢¦
        if (openingPoke && openingPoke.needsInitTransform) {
            console.log('[FORM] Checking player init transform:', openingPoke.name);
            const result = checkInitTransformFunc(openingPoke);
            if (result) {
                log(`<span style="color:#a855f7">âœ¦ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                // é¢„åŠ è½½æ–°å½¢æ€çš„ç²¾çµå›¾ï¼Œé¿å…é—ªçƒ
                const newSpriteUrl = openingPoke.getSprite(true); // ç©å®¶æ˜¯èƒŒé¢
                const preloader = new Image();
                preloader.src = newSpriteUrl;
            }
        }
        // æ£€æŸ¥æ•Œæ–¹å®å¯æ¢¦
        if (openingEnemy && openingEnemy.needsInitTransform) {
            console.log('[FORM] Checking enemy init transform:', openingEnemy.name);
            const result = checkInitTransformFunc(openingEnemy);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                // é¢„åŠ è½½æ–°å½¢æ€çš„ç²¾çµå›¾ï¼Œé¿å…é—ªçƒ
                const newSpriteUrl = openingEnemy.getSprite(false); // æ•Œæ–¹æ˜¯æ­£é¢
                const preloader = new Image();
                preloader.src = newSpriteUrl;
            }
        }
    }
    // å»¶è¿Ÿä¸€å¸§å†æ›´æ–°è§†è§‰ï¼Œç¡®ä¿é¢„åŠ è½½å®Œæˆ
    setTimeout(() => {
        updateAllVisuals();
    }, 50);
    // === æ’­æ”¾æˆ˜æ–— BGM ===
    if (typeof playBattleBgm === 'function') {
        playBattleBgm();
    }
    // === è§¦å‘åŒæ–¹å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰) ===
    if (openingEnemy) {
        triggerEntryAbilities(openingEnemy, openingPoke);
    }
    if (openingPoke) {
        triggerEntryAbilities(openingPoke, openingEnemy);
    }
    const trainerHud = document.getElementById('trainer-hud');
    if (trainerHud) {
        trainerHud.classList.add('hidden');
        trainerHud.style.opacity = '0';
    }
    const trainer = battle.trainer;
    if (trainer && trainer.id !== 'wild') {
        const introLine = trainer.lines?.start || `${trainer.name || 'Opponent'} is challenging you!`;
        setTimeout(() => {
            playCutIn(introLine, 3500);
            setTimeout(() => {
                updateTrainerHud();
                if (trainerHud) {
                    trainerHud.classList.remove('hidden');
                    trainerHud.style.transition = 'opacity 1s';
                    trainerHud.style.opacity = '1';
                }
            }, 3800);
        }, 500);
    }
}
// =========================================================
// ã€å·²è¿ç§»ã€‘æœºåˆ¶äº’æ–¥ç³»ç»Ÿ -> mechanics/mechanic-checker.js
// ã€å·²è¿ç§»ã€‘æå·¨åŒ–çŠ¶æ€ç®¡ç† -> mechanics/dynamax.js
// =========================================================
// =========================================================
// ã€å·²è¿ç§»ã€‘é»˜è®¤æˆ˜æ–—æ•°æ® -> systems/data-loader.js
// ã€å·²è¿ç§»ã€‘JSON æ•°æ®åŠ è½½ -> systems/data-loader.js
// =========================================================
/**
 * ç•Œé¢åˆ·æ–°ï¼šæ¸²æŸ“æ–‡æœ¬ã€è¡€é‡ã€å›¾ç‰‡
 * @param {string|boolean} forceSpriteAnim - false: ä¸å¼ºåˆ¶åŠ¨ç”», 'player': åªæœ‰ç©å®¶åŠ¨ç”», 'enemy': åªæœ‰æ•Œæ–¹åŠ¨ç”», true: ä¸¤è¾¹éƒ½åŠ¨ç”»
 */
function updateAllVisuals(forceSpriteAnim = false) {
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!p || !e) return;
    // 1. åå­— LV (æ•Œæ–¹é«˜ç­‰çº§ç”¨çº¢è‰²å¼ºè°ƒ)
    document.getElementById('player-name').innerText = p.cnName;
    document.getElementById('player-lvl').innerText = p.level;
    const enemyNameEl = document.getElementById('enemy-name');
    const trainerName = battle.trainer?.name;
    enemyNameEl.innerText = (battle.trainer?.id === 'wild' && trainerName) ? trainerName : e.cnName;
    const enemyLvEl = document.getElementById('enemy-lvl');
    enemyLvEl.innerText = e.level;
    enemyLvEl.style.color = (e.level > p.level + 20) ? '#e74c3c' : '';
    enemyLvEl.style.fontWeight = (e.level > p.level + 20) ? '900' : '';
    // 2. è¡€æ¡æ¸²æŸ“
    renderHp('player', p.currHp, p.maxHp);
    renderHp('enemy', e.currHp, e.maxHp);
    // 3. å›¾ç‰‡æ™ºèƒ½åŠ è½½ (é˜²é—ªçƒ: åŠ è½½å®Œå†æ˜¾ç¤º)
    // forceSpriteAnim å¯ä»¥æ˜¯ 'player' æˆ– 'enemy' æ¥æŒ‡å®šåªæœ‰ä¸€æ–¹æ’­æ”¾åŠ¨ç”»
    const playerAnim = (forceSpriteAnim === true || forceSpriteAnim === 'player');
    const enemyAnim = (forceSpriteAnim === true || forceSpriteAnim === 'enemy');
    // æå·¨åŒ–çŠ¶æ€ä¸‹ä¸é‡æ–°åŠ è½½ç²¾çµå›¾ï¼ˆä¿æŒ G-Max å›¾ç‰‡ï¼‰
    if (!p.isDynamaxed) {
        smartLoadSprite('player-sprite', p.getSprite(true), playerAnim);
    }
    if (!e.isDynamaxed) {
        smartLoadSprite('enemy-sprite', e.getSprite(false), enemyAnim);
    }
    const playerSpriteEl = document.getElementById('player-sprite');
    if (playerSpriteEl) {
        playerSpriteEl.classList.toggle('mega-player', !!p.isMega);
        playerSpriteEl.classList.toggle('mega-enemy', false);
        // æå·¨åŒ–çŠ¶æ€
        playerSpriteEl.classList.toggle('state-dynamax', !!p.isDynamaxed);
        // ã€ä¿®å¤ã€‘å¤ªæ™¶åŒ–çŠ¶æ€å’Œå±æ€§é¢œè‰²ç±»ç®¡ç†
        playerSpriteEl.classList.toggle('state-terastal', !!p.isTerastallized);
        // æ¸…é™¤æ‰€æœ‰å¤ªæ™¶å±æ€§é¢œè‰²ç±»
        const allTeraTypes = ['normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy', 'stellar'];
        allTeraTypes.forEach(type => playerSpriteEl.classList.remove(`tera-type-${type}`));
        // å¦‚æœå¤ªæ™¶åŒ–ï¼Œæ·»åŠ å¯¹åº”å±æ€§é¢œè‰²ç±»
        if (p.isTerastallized && p.teraType) {
            playerSpriteEl.classList.add(`tera-type-${p.teraType.toLowerCase()}`);
        }
        // æ¸…é™¤éå®˜æ–¹ Mega æ•ˆæœï¼ˆå¦‚æœå½“å‰å®å¯æ¢¦ä¸æ˜¯éå®˜æ–¹ Megaï¼‰
        if (!p.isUnofficialMega) {
            playerSpriteEl.classList.remove('unofficial-mega');
        }
        // ç¾ç»Šå…±é¸£çŠ¶æ€ï¼šåªæœ‰å½“å‰å®å¯æ¢¦æœ‰ hasBondResonance æ ‡è®°æ—¶æ‰ä¿ç•™æ ·å¼
        if (p.hasBondResonance) {
            playerSpriteEl.classList.add('bond-resonance');
            playerSpriteEl.style.filter = 'drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15)';
        } else {
            playerSpriteEl.classList.remove('bond-resonance');
            // æ¸…é™¤å¯èƒ½æ®‹ç•™çš„ filter æ ·å¼
            if (playerSpriteEl.style.filter && playerSpriteEl.style.filter.includes('gold')) {
                playerSpriteEl.style.filter = '';
            }
        }
    }
    const enemySpriteEl = document.getElementById('enemy-sprite');
    if (enemySpriteEl) {
        enemySpriteEl.classList.toggle('mega-enemy', !!e.isMega);
        enemySpriteEl.classList.toggle('mega-player', false);
        // æå·¨åŒ–çŠ¶æ€
        enemySpriteEl.classList.toggle('state-dynamax', !!e.isDynamaxed);
        // ã€ä¿®å¤ã€‘å¤ªæ™¶åŒ–çŠ¶æ€å’Œå±æ€§é¢œè‰²ç±»ç®¡ç†
        enemySpriteEl.classList.toggle('state-terastal', !!e.isTerastallized);
        // æ¸…é™¤æ‰€æœ‰å¤ªæ™¶å±æ€§é¢œè‰²ç±»
        const allTeraTypes = ['normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy', 'stellar'];
        allTeraTypes.forEach(type => enemySpriteEl.classList.remove(`tera-type-${type}`));
        // å¦‚æœå¤ªæ™¶åŒ–ï¼Œæ·»åŠ å¯¹åº”å±æ€§é¢œè‰²ç±»
        if (e.isTerastallized && e.teraType) {
            enemySpriteEl.classList.add(`tera-type-${e.teraType.toLowerCase()}`);
        }
        // æ¸…é™¤éå®˜æ–¹ Mega æ•ˆæœï¼ˆå¦‚æœå½“å‰å®å¯æ¢¦ä¸æ˜¯éå®˜æ–¹ Megaï¼‰
        if (!e.isUnofficialMega) {
            enemySpriteEl.classList.remove('unofficial-mega');
        }
        // ã€ä¿®å¤ã€‘ç¾ç»Šå…±é¸£çŠ¶æ€ï¼šåªæœ‰å½“å‰å®å¯æ¢¦æœ‰ hasBondResonance æ ‡è®°æ—¶æ‰ä¿ç•™æ ·å¼
        if (e.hasBondResonance) {
            enemySpriteEl.classList.add('bond-resonance');
            enemySpriteEl.style.filter = 'drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15)';
        } else {
            enemySpriteEl.classList.remove('bond-resonance');
            // æ¸…é™¤å¯èƒ½æ®‹ç•™çš„ filter æ ·å¼
            if (enemySpriteEl.style.filter && enemySpriteEl.style.filter.includes('gold')) {
                enemySpriteEl.style.filter = '';
            }
        }
    }
    // 4. é˜Ÿä¼çŠ¶æ€çƒ
    renderDots('ui-player-dots', battle.playerParty, battle.playerActive);
    renderDots('ui-enemy-dots', battle.enemyParty, battle.enemyActive);
    updateTrainerHud();
    // 5. æŒ‰é’®åŒº
    document.getElementById('switch-menu-layer').classList.add('hidden');
    if (p.currHp <= 0) {
        // æ­»äº¡çŠ¶æ€ï¼Œç­‰å¾…å¼ºåˆ¶æ¢äºº
    } else {
        // æ¸²æŸ“æŠ€èƒ½æŒ‰é’®ï¼ˆæ”¯æŒ 4 æŠ€ï¼‰
        const btnIds = ['btn-m0', 'btn-m1', 'btn-m2', 'btn-m3'];
        btnIds.forEach((id, i) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            // é‡ç½®æ‰€æœ‰ç‰¹æ®Šæ ·å¼
            btn.className = 'action-btn';
            btn.style.opacity = '1';
            if (i < p.moves.length) {
                const m = p.moves[i];
                // =========================================================
                // Z-Move / Max Move è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿ
                // åŸºäº mechanic å­—æ®µå’Œæ•°æ®åº“è‡ªåŠ¨åˆ¤æ–­æ‹›å¼å˜æ¢
                // =========================================================
                const mId = (m.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                const mData = (typeof MOVES !== 'undefined' && MOVES[mId]) ? MOVES[mId] : {};
                // ä½¿ç”¨æ–°çš„è‡ªåŠ¨æ¨å¯¼å‡½æ•°
                const zTarget = getZMoveTarget(m, p);  // è¿”å› { name, type, power } æˆ– null
                const maxTarget = p.isDynamaxed ? getMaxMoveTarget(m, p) : null; // åªæœ‰æå·¨åŒ–çŠ¶æ€æ‰æ¨å¯¼
                // åˆ¤æ–­å½“å‰æ‹›å¼åº”è¯¥æ˜¾ç¤ºä»€ä¹ˆæ ·å¼
                const showZStyle = zTarget && !battle.playerZUsed;
                const showMaxStyle = maxTarget !== null;
                // ç¦ç”¨é€»è¾‘
                let isDisabled = false;
                if (showZStyle && battle.playerZUsed) isDisabled = true;
                // è·å–æ˜¾ç¤ºåç§°å’Œç±»å‹
                let displayName = m.cn || m.name;
                let displayType = m.type || 'Normal';
                if (showZStyle) {
                    // Z æ‹›å¼æ ·å¼
                    const zMoveId = zTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                    const zMoveData = (typeof MOVES !== 'undefined' && MOVES[zMoveId]) ? MOVES[zMoveId] : {};
                    displayName = zMoveData.cn || zTarget.name;
                    displayType = zTarget.type;
                } else if (showMaxStyle) {
                    // Max æ‹›å¼æ ·å¼
                    const maxMoveId = maxTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                    const maxMoveData = (typeof MOVES !== 'undefined' && MOVES[maxMoveId]) ? MOVES[maxMoveId] : {};
                    displayName = maxMoveData.cn || maxTarget.name;
                    displayType = maxTarget.type;
                }
                // =========================================================
                // ã€å¿ƒçœ¼ç³»ç»Ÿã€‘å±æ€§å…‹åˆ¶æç¤º (enable_insight)
                // æ˜¾ç¤º â–²(æ•ˆæœç»ä½³) / â–¼(æ•ˆæœä¸å¥½) / Ã—(æ— æ•ˆ)
                // =========================================================
                let insightHint = '';
                const insightUnlocked = battle.playerUnlocks && battle.playerUnlocks.enable_insight !== false;
                if (insightUnlocked && e && e.types) {
                    const moveType = displayType || m.type || 'Normal';
                    const eff = window.getTypeEffectiveness ? 
                        window.getTypeEffectiveness(moveType, e.types) : 1;
                    if (eff === 0) {
                        insightHint = '<span class="insight-hint insight-immune" title="æ— æ•ˆ">Ã—</span>';
                    } else if (eff >= 2) {
                        insightHint = '<span class="insight-hint insight-super" title="æ•ˆæœç»ä½³">â–²</span>';
                    } else if (eff <= 0.5) {
                        insightHint = '<span class="insight-hint insight-resist" title="æ•ˆæœä¸å¥½">â–¼</span>';
                    }
                }
                if (showZStyle || showMaxStyle) {
                    // åº”ç”¨ç‰¹æ®Šæ ·å¼
                    if (showZStyle) {
                        btn.classList.add('z-move-btn');
                    } else {
                        btn.classList.add('max-move-btn');
                    }
                    if (isDisabled) {
                        btn.classList.add('z-move-used');
                    }
                    const labelText = showZStyle ? 'Z' : 'MAX';
                    btn.innerHTML = `
                        <div class="z-bg-overlay"></div>
                        <div class="z-badge-icon">${labelText}</div>
                        <span class="move-name">${displayName}${insightHint}</span>
                        <span class="badge-type type-${displayType}">${displayType}</span>
                    `;
                } else {
                    // æ™®é€šæŠ€èƒ½
                    btn.innerHTML = `
                        <span class="move-name">${displayName}${insightHint}</span>
                        <span class="badge-type type-${displayType}">${displayType}</span>
                    `;
                }
                // äº¤äº’äº‹ä»¶
                if (isDisabled) {
                    btn.disabled = true;
                    btn.onclick = null;
                } else {
                    btn.disabled = false;
                    // å¦‚æœæ˜¯ Z æ‹›å¼æ¨¡å¼ï¼Œä¼ é€’ useZ æ ‡è®°å’Œæ¨å¯¼ç»“æœ
                    if (showZStyle) {
                        btn.onclick = () => handleAttack(i, { useZ: true, zTarget: zTarget });
                    } else {
                        btn.onclick = () => handleAttack(i);
                    }
                }
                btn.style.visibility = 'visible';
            } else {
                btn.disabled = true;
                btn.style.visibility = 'hidden';
                btn.innerHTML = '<span class="move-name">---</span><span class="move-type">---</span>';
            }
        });
    }
    // 6. æ›´æ–°è¿›åŒ–æŒ‰é’®å¯è§æ€§
    if (typeof updateEvolutionButtonVisuals === 'function') {
        updateEvolutionButtonVisuals();
    }
}
// ============================================
// ã€å·²è¿ç§»ã€‘ç²¾çµå›¾åŠ è½½ -> ui/ui-sprites.js
// ã€å·²è¿ç§»ã€‘è¡€æ¡/ç²¾çµçƒæ§½æ¸²æŸ“ -> ui/ui-renderer.js
// ============================================
/**
 * æ ¸å¿ƒé€»è¾‘ï¼šå‘èµ·æ”»å‡»å¤„ç† (æ”¯æŒå…ˆåˆ¶æŠ€ä¼˜å…ˆçº§)
 * @param {number} moveIndex æ‹›å¼ç´¢å¼•
 * @param {object} options å¯é€‰å‚æ•° { useZ: boolean, zConfig: object }
 */
async function handleAttack(moveIndex, options = {}) {
    if (typeof window.playSFX === 'function') window.playSFX('CONFIRM');
    if (battle.locked) return;
    battle.locked = true;
    // ã€å¤æ­¦ç³»ç»Ÿã€‘å›åˆå¼€å§‹æ—¶é€’å‡å†·å´ï¼ˆç®€åŒ–é€»è¾‘ï¼šä½¿ç”¨åä¸‹ä¸€å›åˆä¸èƒ½ç”¨ï¼Œä¸‹ä¸‹å›åˆå¯ä»¥ç”¨ï¼‰
    if (battle.playerStyleCooldown > 0) {
        battle.playerStyleCooldown--;
        console.log(`[STYLES] ç©å®¶é£æ ¼å†·å´é€’å‡: ${battle.playerStyleCooldown + 1} -> ${battle.playerStyleCooldown}`);
        updateStyleButtonCooldown();
    }
    if (battle.enemyStyleCooldown > 0) {
        battle.enemyStyleCooldown--;
        console.log(`[STYLES] æ•Œæ–¹é£æ ¼å†·å´é€’å‡: ${battle.enemyStyleCooldown + 1} -> ${battle.enemyStyleCooldown}`);
    }
    // ä¿å­˜ Mega é¢„å¤‡çŠ¶æ€ï¼ˆåœ¨ showMainMenu é‡ç½®ä¹‹å‰ï¼‰
    const megaArmedThisTurn = battle.playerMegaArmed;
    // æ”»å‡»åè¿”å›ä¸»èœå•
    showMainMenu();
    let p = battle.getPlayer();  // ä½¿ç”¨ letï¼Œå› ä¸º pivot æ¢äººæ—¶éœ€è¦æ›´æ–°å¼•ç”¨
    let e = battle.getEnemy();   // ä½¿ç”¨ letï¼Œå› ä¸º AI æ¢äººæ—¶éœ€è¦æ›´æ–°å¼•ç”¨
    let playerMove = p.moves[moveIndex];
    // === ã€ä¿®å¤ã€‘æ£€æŸ¥ Taunt ç­‰ Volatile çŠ¶æ€æ˜¯å¦é˜»æ­¢ä½¿ç”¨è¯¥æŠ€èƒ½ ===
    if (typeof MoveEffects !== 'undefined' && MoveEffects.canUseMove) {
        const canUseResult = MoveEffects.canUseMove(p, playerMove);
        if (!canUseResult.canUse) {
            log(`<span style="color:#e74c3c">${canUseResult.reason}</span>`);
            battle.locked = false;
            return;
        }
    }
    // =========================================================
    // Z-Move è½¬æ¢é€»è¾‘ï¼šä½¿ç”¨è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿ
    // ã€äº’æ–¥æ£€æŸ¥ã€‘Mega/æå·¨åŒ–çŠ¶æ€ä¸‹ç¦æ­¢ä½¿ç”¨ Z æ‹›å¼
    // =========================================================
    if (options.useZ && options.zTarget && !battle.playerZUsed) {
        // ã€å®‰å…¨æ£€æŸ¥ã€‘å¦‚æœå·²ç» Mega æˆ–æå·¨åŒ–ï¼Œç¦æ­¢ä½¿ç”¨ Z æ‹›å¼
        if (p.isMega || p.isDynamaxed || p.hasBondResonance) {
            console.warn(`[CHEAT BLOCK] è¯•å›¾åœ¨ Mega/æå·¨åŒ– çŠ¶æ€ä¸‹ä½¿ç”¨ Z æ‹›å¼ï¼å·²å¼ºåˆ¶æ‹¦æˆªã€‚`);
            log(`<b style="color:#aaa">...ä½†åœ¨ç›®å‰çš„å½¢æ€ä¸‹æ— æ³•å¼•å‡º Z åŠ›é‡ï¼</b>`);
            // ä¸è½¬æ¢ï¼Œä½¿ç”¨åŸå§‹æ‹›å¼
        } else {
            const zTarget = options.zTarget;
            const zMoveId = zTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
            const zMoveData = (typeof MOVES !== 'undefined' && MOVES[zMoveId]) ? MOVES[zMoveId] : {};
            // ä½¿ç”¨è‡ªåŠ¨æ¨å¯¼çš„ Z æ‹›å¼æ•°æ®
            playerMove = {
                name: zTarget.name,
                cn: zMoveData.cn || zTarget.name,
                type: zTarget.type || playerMove.type || 'Normal',
                power: zTarget.power || 180,
                basePower: zTarget.power || 180,
                accuracy: 100,
                pp: 1,
                isZ: true,
                priority: zMoveData.priority || 0,
                cat: zMoveData.category === 'Physical' ? 'phys' : 'spec',
                category: zMoveData.category || 'Special'
            };
            console.log(`[Z-MOVE] è‡ªåŠ¨æ¨å¯¼ Z æ‹›å¼: ${playerMove.name} (å¨åŠ›: ${playerMove.power})`);
        }
    }
    // =========================================================
    // ã€å¤æ­¦ç³»ç»Ÿ v2.1ã€‘åˆšçŒ›/è¿…ç–¾ é£æ ¼ä¿®æ­£ (enable_styles)
    // åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®é€Ÿåº¦ä¼˜åŠ¿å†³å®šæƒ©ç½šç¨‹åº¦
    // è¿…ç–¾ (Agile): é€Ÿåº¦å¿«æ—¶0.75x(ä¿å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶0.5x(æŠ¢èŠ‚å¥)
    // åˆšçŒ› (Strong): é€Ÿåº¦å¿«æ—¶å¿…ä¸­(å–å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8x(ç™½å«–)
    // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
    // =========================================================
    if (currentMoveStyle !== 'normal' && battle.playerUnlocks?.enable_styles) {
        // ã€å†·å´æ£€æŸ¥ã€‘å¦‚æœåœ¨å†·å´ä¸­ï¼Œå¼ºåˆ¶ä½¿ç”¨æ™®é€šé£æ ¼
        if (battle.playerStyleCooldown > 0) {
            log(`<span style="color:#aaa">é£æ ¼ç³»ç»Ÿå†·å´ä¸­ï¼Œæœ¬å›åˆåªèƒ½ä½¿ç”¨æ™®é€šé£æ ¼</span>`);
            currentMoveStyle = 'normal';
        } else {
            const originalPower = playerMove.basePower || playerMove.power || 0;
            const originalPriority = playerMove.priority || 0;
            const originalAccuracy = playerMove.accuracy;
            const isStatus = (playerMove.category === 'Status' || playerMove.cat === 'status' || originalPower === 0);
            // ã€v2.1ã€‘è®¡ç®—æœ‰æ•ˆé€Ÿåº¦ï¼Œåˆ¤æ–­é€Ÿåº¦ä¼˜åŠ¿
            let mySpe = (typeof p.getStat === 'function') ? p.getStat('spe') : (p.spe || 100);
            let enemySpe = (typeof e.getStat === 'function') ? e.getStat('spe') : (e.spe || 100);
            // éº»ç—¹å‡é€Ÿ
            if (p.status === 'par') mySpe = Math.floor(mySpe * 0.5);
            if (e.status === 'par') enemySpe = Math.floor(enemySpe * 0.5);
            // æˆæ³•ç©ºé—´åˆ¤å®š
            const isTrickRoom = battle.field && battle.field.trickRoom > 0;
            let haveSpeedAdvantage = false;
            if (isTrickRoom) {
                haveSpeedAdvantage = mySpe < enemySpe; // ç©ºé—´ä¸‹ï¼šæ…¢å°±æ˜¯å¿«
            } else {
                haveSpeedAdvantage = mySpe > enemySpe; // æ­£å¸¸ï¼šå¿«å°±æ˜¯å¿«
            }
            // ============================================
            // âš¡ è¿…ç–¾é£æ ¼ (Agile Style)
            // ============================================
            if (currentMoveStyle === 'agile') {
                // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘å˜åŒ–æŠ€ç¦æ­¢ä½¿ç”¨è¿…ç–¾
                if (isStatus) {
                    log(`<span style="color:#aaa">å˜åŒ–ç±»æ‹›å¼æ— æ³•ä½¿ç”¨è¿…ç–¾é£æ ¼ï¼(è‡ªåŠ¨åˆ‡æ¢å›æ™®é€š)</span>`);
                    currentMoveStyle = 'normal';
                } else {
                    playerMove = { ...playerMove };
                    playerMove.priority = originalPriority + 1;
                    playerMove.styleUsed = 'agile';
                    const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                    if (haveSpeedAdvantage) {
                        // åœºæ™¯ A: æ‹¥æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ä¹°ä¿é™©æ±‚ç¨³ï¼Œé˜²å…ˆåˆ¶
                        playerMove.basePower = Math.floor(originalPower * 0.75);
                        playerMove.accuracy = Math.floor(oldAcc * 0.9); // å‘½ä¸­ç‡ 0.9x
                        log(`<span style="color:#3b82f6">âš¡ è¿…ç–¾Â·åˆ¶å˜ï¼šé€Ÿåº¦å‹åˆ¶ä¸‹ç¡®ä¿å…ˆæ‰‹ - å¨åŠ›Ã—0.75ï¼Œå‘½ä¸­Ã—0.9</span>`);
                        console.log(`[STYLES] è¿…ç–¾(å¿«): power 0.75x, acc 0.9x (${mySpe} vs ${enemySpe})`);
                    } else {
                        // åœºæ™¯ B: æ²¡æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ç»åœ°åå‡»ï¼Œå·å›åˆ
                        playerMove.basePower = Math.floor(originalPower * 0.50);
                        playerMove.accuracy = Math.floor(oldAcc * 0.85); // å‘½ä¸­ç‡ 0.85x
                        log(`<span style="color:#60a5fa">âš¡ è¿…ç–¾Â·ç¥é€Ÿï¼šé€†è½¬è¡ŒåŠ¨é¡ºä½ - å¨åŠ›Ã—0.50ï¼Œå‘½ä¸­Ã—0.85</span>`);
                        console.log(`[STYLES] è¿…ç–¾(æ…¢): power 0.5x, acc 0.85x (${mySpe} vs ${enemySpe})`);
                    }
                    playerMove.power = playerMove.basePower;
                    // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                    battle.playerStyleCooldown = 1;
                }
            } 
            // ============================================
            // ğŸ’ª åˆšçŒ›é£æ ¼ (Strong Style)
            // ============================================
            else if (currentMoveStyle === 'strong') {
                playerMove = { ...playerMove };
                playerMove.priority = originalPriority - 1;
                playerMove.basePower = Math.floor(originalPower * 1.30);
                playerMove.power = playerMove.basePower;
                playerMove.breaksProtect = true; // å¯ç©¿é€å®ˆä½
                playerMove.styleUsed = 'strong';
                if (!haveSpeedAdvantage) {
                    // åœºæ™¯ A: é€Ÿåº¦åŠ£åŠ¿ (æœ¬æ¥å°±æ…¢) - æ²¡ä»˜å‡ºä»£ä»·ï¼Œé™å‘½ä¸­
                    const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                    playerMove.accuracy = Math.floor(oldAcc * 0.8);
                    log(`<span style="color:#ef4444">ğŸ’ª åˆšçŒ›Â·èˆèº«ï¼šé€Ÿåº¦åŠ£åŠ¿ä¸‹çš„å¼ºæ”» - å¨åŠ›Ã—1.3ï¼Œå‘½ä¸­Ã—0.8</span>`);
                    console.log(`[STYLES] åˆšçŒ›(æ…¢): power 1.3x, acc 0.8x (${mySpe} vs ${enemySpe})`);
                } else {
                    // åœºæ™¯ B: é€Ÿåº¦ä¼˜åŠ¿ (æœ¬æ¥è¯¥æˆ‘å…ˆ) - å–å…ˆæ‰‹æ¢ä¼¤å®³ï¼Œä¸ä¿®æ­£å‘½ä¸­
                    // ã€v2.3ã€‘ä¸å†å¿…ä¸­ï¼Œä¿æŒåŸå‘½ä¸­ç‡
                    log(`<span style="color:#b91c1c">ğŸ’ª åˆšçŒ›Â·è“„åŠ›ï¼šæ”¾å¼ƒå…ˆæ‰‹ï¼Œå…¨åŠ›ä¸€å‡»ï¼(å¨åŠ›Ã—1.3ï¼Œè´¯ç©¿å®ˆä½)</span>`);
                    console.log(`[STYLES] åˆšçŒ›(å¿«): power 1.3x, acc unchanged (${mySpe} vs ${enemySpe})`);
                }
                // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                battle.playerStyleCooldown = 1;
            }
        }
        // ä½¿ç”¨åé‡ç½®ä¸ºæ™®é€šé£æ ¼
        setMoveStyle('normal');
    }
    // === å›åˆå¼€å§‹ï¼šæ¸…é™¤åŒæ–¹çš„ Protect çŠ¶æ€ï¼ˆæ–°å›åˆå¼€å§‹ï¼Œå®ˆä½å¤±æ•ˆï¼‰===
    if (p.volatile) p.volatile.protect = false;
    if (e.volatile) e.volatile.protect = false;
    // === Mega/Dynamax è¿›åŒ–å¤„ç† (å›åˆå¼€å§‹æ—¶ï¼Œå‡ºæ‹›å‰) ===
    // ç©å®¶ Mega/Dynamax è¿›åŒ– - ä½¿ç”¨ä¿å­˜çš„çŠ¶æ€ï¼ˆå› ä¸º showMainMenu ä¼šé‡ç½® battle.playerMegaArmedï¼‰
    const canMegaEvolveFunc = window.canMegaEvolve;
    const performMegaEvolutionFunc = window.performMegaEvolution;
    // æ£€æŸ¥æ˜¯å¦æ˜¯æå·¨åŒ–æ¨¡å¼
    // ã€ä¿®å¤ã€‘mechanic å­—æ®µæ˜¯æœ€é«˜æƒå¨ï¼Œå¦‚æœ mechanic === 'mega'ï¼Œåˆ™ä¸åº”è§¦å‘æå·¨åŒ–
    const isDynamaxMode = p && p.mechanic !== 'mega' && (p.canDynamax || (p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax')));
    if (megaArmedThisTurn && isDynamaxMode && !battle.playerMaxUsed && !p.isDynamaxed) {
        // === æå·¨åŒ–å¤„ç† ===
        battle.playerMegaArmed = false;
        battle.playerMaxUsed = true;
        const oldName = p.cnName;
        const oldMaxHp = p.maxHp;
        const oldCurrHp = p.currHp;
        log(`<div style="border-bottom: 2px solid #e11d48; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
        log(`${oldName} çš„èº«ä½“å¼€å§‹æ€¥å‰§è†¨èƒ€ï¼ä»¿ä½›è¦å†²ç ´å¤©é™…ï¼`);
        await wait(600);
        // æ’­æ”¾æå·¨åŒ–çˆ†å‘åŠ¨ç”»
        await playDynamaxAnimation(p, true);
        // ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å½¢æ€ï¼Œåˆ‡æ¢ç²¾çµå›¾
        // ã€å…³é”®ã€‘é€šç”¨æå·¨åŒ– (isGenericDynamax) ä¸åˆ‡æ¢å›¾ç‰‡ï¼Œåªç”¨ CSS æ”¾å¤§
        const gmaxFormId = p.megaTargetId;
        if (gmaxFormId && gmaxFormId.includes('gmax') && !p.isGenericDynamax) {
            // ä¿å­˜åŸå§‹åç§°ï¼Œç”¨äºå›é€€
            p.originalName = p.name;
            p.name = gmaxFormId.charAt(0).toUpperCase() + gmaxFormId.slice(1);
            // G-Max ç²¾çµå›¾æ ¼å¼: laprasgmax -> lapras-gmax (å¸¦æ¨ªæ )
            const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
            const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani-back/${gmaxSpriteId}.gif`;
            smartLoadSprite('player-sprite', gmaxSpriteUrl, true);
            console.log(`[DYNAMAX] åˆ‡æ¢ç©å®¶ç²¾çµå›¾: ${gmaxSpriteUrl}`);
        } else if (p.isGenericDynamax) {
            console.log(`[DYNAMAX] é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${p.name}`);
        }
        // HP å€ç‡ x1.5
        const hpMultiplier = 1.5;
        p.maxHp = Math.floor(oldMaxHp * hpMultiplier);
        p.currHp = Math.floor(oldCurrHp * hpMultiplier);
        // è®¾ç½®æå·¨åŒ–çŠ¶æ€
        p.isDynamaxed = true;
        p.dynamaxTurns = 3; // 3 å›åˆåå˜å›
        p.preDynamaxMaxHp = oldMaxHp;
        p.preDynamaxCurrHp = oldCurrHp;
        // ã€å…³é”®ã€‘æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼
        applyDynamaxState(p, true);
        // ã€ä¿®å¤ã€‘é‡æ–°è·å–å½“å‰å›åˆçš„æ‹›å¼ï¼ˆå› ä¸ºæ‹›å¼åˆ—è¡¨å·²ç»è¢«æ›¿æ¢ï¼‰
        playerMove = p.moves[moveIndex];
        log(`<b style="color:#e11d48">${oldName} æå·¨åŒ–äº†ï¼(HP x${hpMultiplier})</b>`);
        log(`<span style="color:#ff6b8a">[æå·¨åŒ–å‰©ä½™å›åˆ: ${p.dynamaxTurns}]</span>`);
        updateAllVisuals('player');
        await wait(800);
    } else if (megaArmedThisTurn && canMegaEvolveFunc && canMegaEvolveFunc(p) && !battle.playerMegaUsed && p.mechanic !== 'tera') {
        // === æ™®é€š Mega è¿›åŒ–å¤„ç† ===
        // ã€ä¿®å¤ã€‘å¿…é¡»æ’é™¤ mechanic='tera' çš„å®å¯æ¢¦ï¼Œé¿å…ä¸å¤ªæ™¶åŒ–å†²çª
        battle.playerMegaArmed = false;
        battle.playerMegaUsed = true;
        const oldName = p.cnName;
        log(`<div style="border-bottom: 2px solid #c084fc; margin-bottom: 5px;"></div>`);
        log(`${oldName} çš„è¿›åŒ–çŸ³å¯¹ ${battle.playerName || 'è®­ç»ƒå®¶'} çš„é’¥çŸ³äº§ç”Ÿäº†ååº”ï¼`);
        await wait(600);
        const megaResult = performMegaEvolutionFunc(p);
        if (megaResult) {
            await playMegaEvolutionAnimation(p, true);
            log(`<b style="color:#d8b4fe">${oldName} Mega è¿›åŒ–æˆäº† ${megaResult.newName}ï¼</b>`);
            if (megaResult.typeChanged) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">${megaResult.newName} å˜æˆäº† ${megaResult.newTypes.join('/')} å±æ€§ï¼</span>`);
            }
            if (megaResult.abilityChanged && megaResult.newAbility) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">è·å¾—äº†ç‰¹æ€§ <b>${megaResult.newAbility}</b>ï¼</span>`);
                triggerEntryAbilities(p, e);
            }
        }
        updateAllVisuals('player');
        await wait(800);
    } else if (megaArmedThisTurn && p.mechanic === 'tera' && p.canTera && !battle.playerTeraUsed && !p.isTerastallized) {
        // === å¤ªæ™¶åŒ–å¤„ç† ===
        battle.playerMegaArmed = false;
        battle.playerTeraUsed = true;
        const oldName = p.cnName;
        const oldTypes = [...p.types];
        const teraType = p.teraType;
        log(`<div style="border-bottom: 2px solid #22d3ee; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#22d3ee">ğŸ’ TERASTALLIZE !!! ğŸ’</b>`);
        log(`${oldName} çš„èº«ä½“å¼€å§‹ç»“æ™¶åŒ–ï¼é—ªè€€ç€ ${teraType} å±æ€§çš„å…‰èŠ’ï¼`);
        await wait(600);
        // æ’­æ”¾å¤ªæ™¶åŒ–åŠ¨ç”»
        const playerSprite = document.getElementById('player-sprite');
        if (playerSprite) {
            // æ·»åŠ å±æ€§é¢œè‰²ç±»
            playerSprite.classList.add('tera-burst', `tera-type-${teraType.toLowerCase()}`);
            await wait(800);
            playerSprite.classList.remove('tera-burst');
            playerSprite.classList.add('state-terastal');
        }
        // æ‰§è¡Œå¤ªæ™¶åŒ–ï¼šå±æ€§å˜æ›´
        p.isTerastallized = true;
        p.originalTypes = oldTypes; // ä¿å­˜åŸå§‹å±æ€§ï¼ˆç”¨äº STAB å›æº¯ï¼‰
        p.types = [teraType]; // å±æ€§å˜ä¸ºå•ä¸€å¤ªæ™¶å±æ€§
        log(`<b style="color:#22d3ee">${oldName} å¤ªæ™¶åŒ–äº†ï¼</b>`);
        log(`<span style="color:#67e8f9">å±æ€§å˜åŒ–: ${oldTypes.join('/')} â†’ <b>${teraType}</b></span>`);
        updateAllVisuals('player');
        await wait(800);
    }
    // =====================================================
    // === æ•Œæ–¹ AI Mega/Dynamax/Tera è§¦å‘é€»è¾‘ ===
    // =====================================================
    // ã€ä¿®å¤ã€‘ä¸‰ç§æœºåˆ¶ç‹¬ç«‹è®¡æ•°ï¼Œä¸å†å…±ç”¨ enemyMegaUsed
    // ã€è§£é”æ£€æŸ¥ã€‘å¿…é¡»æ£€æŸ¥ enemyUnlocks é…ç½®
    const enemyUnlocks = battle.enemyUnlocks || {};
    const isEnemyDynamax = (e.mechanic === 'dynamax') ||
                           (e.evolutionType === 'dynamax') || 
                           (e.canDynamax && e.mechanic !== 'mega' && e.mechanic !== 'tera') || 
                           (e.megaTargetId && e.megaTargetId.includes('gmax') && e.mechanic !== 'mega');
    // ã€è§£é”æ£€æŸ¥ã€‘Mega éœ€è¦ enable_megaï¼ŒDynamax éœ€è¦ enable_dynamax
    const canEnemyMega = enemyUnlocks.enable_mega && e.mechanic === 'mega' && (canMegaEvolveFunc && canMegaEvolveFunc(e));
    const canEnemyDynamax = enemyUnlocks.enable_dynamax && isEnemyDynamax && !e.isDynamaxed;
    // Mega è¿›åŒ–ï¼šæ£€æŸ¥ enemyMegaUsed
    // Dynamaxï¼šæ£€æŸ¥ enemyMaxUsed
    // Teraï¼šæ£€æŸ¥ enemyTeraUsedï¼ˆå·²åœ¨ä¸‹æ–¹å•ç‹¬å¤„ç†ï¼‰
    const shouldTriggerMega = canEnemyMega && !battle.enemyMegaUsed;
    const shouldTriggerDynamax = canEnemyDynamax && !battle.enemyMaxUsed;
    // === æ•Œæ–¹æå·¨åŒ–å¤„ç† ===
    if (shouldTriggerDynamax) {
        battle.enemyMaxUsed = true;
        const oldEnemyName = e.cnName;
        const oldMaxHp = e.maxHp;
        const oldCurrHp = e.currHp;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        // è¯»å–è®­ç»ƒå®¶ç‰¹æ®Šå°è¯
        if (battle.trainer && battle.trainer.lines && battle.trainer.lines.gmax_trigger) {
            log(`<i>${trainerName}: "${battle.trainer.lines.gmax_trigger}"</i>`);
        }
        log(`<div style="border-bottom: 2px solid #e11d48; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
        log(`${trainerName} çš„ ${oldEnemyName} å¼€å§‹æ€¥å‰§è†¨èƒ€ï¼ç©ºæ°”åœ¨éœ‡åŠ¨ï¼`);
        await wait(600);
        // ä¿å­˜åŸå§‹åç§°ï¼Œç”¨äºå›é€€
        e.originalName = e.name;
        // æ’­æ”¾æå·¨åŒ–çˆ†å‘åŠ¨ç”» + åˆ‡æ¢å›¾ç‰‡
        const spriteEl = document.getElementById('enemy-sprite');
        if (spriteEl) {
            spriteEl.classList.add('dynamax-burst');
            await wait(400);
            // æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å½¢æ€ï¼ˆmegaTargetId åŒ…å« gmaxï¼‰
            // ã€å…³é”®ã€‘é€šç”¨æå·¨åŒ– (isGenericDynamax) ä¸åˆ‡æ¢å›¾ç‰‡ï¼Œåªç”¨ CSS æ”¾å¤§
            const gmaxFormId = e.megaTargetId;
            if (gmaxFormId && gmaxFormId.includes('gmax') && !e.isGenericDynamax) {
                // æœ‰ G-Max å½¢æ€ï¼Œåˆ‡æ¢ç²¾çµå›¾
                e.name = gmaxFormId.charAt(0).toUpperCase() + gmaxFormId.slice(1);
                const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
                const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani/${gmaxSpriteId}.gif`;
                smartLoadSprite('enemy-sprite', gmaxSpriteUrl, false);
            } else if (e.isGenericDynamax) {
                console.log(`[DYNAMAX] æ•Œæ–¹é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${e.name}`);
            }
            // å¦åˆ™ä¿æŒåŸç²¾çµå›¾ï¼Œåªåº”ç”¨æ”¾å¤§æ•ˆæœ
            await wait(400);
            spriteEl.classList.remove('dynamax-burst');
            spriteEl.classList.add('state-dynamax');
        }
        // HP å€ç‡ x1.5
        const hpMultiplier = 1.5;
        e.maxHp = Math.floor(oldMaxHp * hpMultiplier);
        e.currHp = Math.floor(oldCurrHp * hpMultiplier);
        // è®¾ç½®æå·¨åŒ–çŠ¶æ€
        e.isDynamaxed = true;
        e.dynamaxTurns = 3;
        e.preDynamaxMaxHp = oldMaxHp;
        e.preDynamaxCurrHp = oldCurrHp;
        // ã€å…³é”®ã€‘æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼
        applyDynamaxState(e, true);
        log(`<b style="color:#e11d48">${oldEnemyName} æå·¨åŒ–äº†ï¼(HP x${hpMultiplier})</b>`);
        log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${e.dynamaxTurns}]</span>`);
        updateAllVisuals('enemy');
        await wait(800);
    }
    // === æ•Œæ–¹ Mega è¿›åŒ–å¤„ç† ===
    if (shouldTriggerMega) {
        battle.enemyMegaUsed = true;
        const oldEnemyName = e.cnName;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        log(`<div style="border-bottom: 2px solid #ef4444; margin-bottom: 5px;"></div>`);
        log(`å¯¹æ‰‹çš„ ${oldEnemyName} çš„è¿›åŒ–çŸ³å¯¹ ${trainerName} çš„é’¥çŸ³äº§ç”Ÿäº†ååº”ï¼`);
        await wait(600);
        // å°è¯•æ‰§è¡Œ Mega è¿›åŒ–
        const megaResult = performMegaEvolutionFunc ? performMegaEvolutionFunc(e) : null;
        if (megaResult) {
            await playMegaEvolutionAnimation(e, false);
            log(`<b style="color:#fca5a5">å¯¹æ‰‹çš„ ${oldEnemyName} Mega è¿›åŒ–æˆäº† ${megaResult.newName}ï¼</b>`);
            if (megaResult.typeChanged) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">å¯¹æ‰‹çš„ ${megaResult.newName} å˜æˆäº† ${megaResult.newTypes.join('/')} å±æ€§ï¼</span>`);
            }
            if (megaResult.abilityChanged && megaResult.newAbility) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">è·å¾—äº†ç‰¹æ€§ <b>${megaResult.newAbility}</b>ï¼</span>`);
                triggerEntryAbilities(e, p);
            }
        } else {
            // mechanic è®¾ç½®ä¸º mega ä½†æ²¡æœ‰å®é™… Mega æ•°æ®ï¼Œè·³è¿‡æ¼”å‡º
            console.warn(`[MEGA] ${e.name} è®¾ç½®äº† mechanic: 'mega' ä½†æ²¡æœ‰ Mega å½¢æ€æ•°æ®ï¼Œè·³è¿‡`);
            battle.enemyMegaUsed = false; // å›æ»šä½¿ç”¨æ ‡è®°
        }
        updateAllVisuals('enemy');
        await wait(800);
    }
    // === æ•Œæ–¹ AI å¤ªæ™¶åŒ–å¤„ç† ===
    // ã€è§£é”æ£€æŸ¥ã€‘Tera éœ€è¦ enable_tera
    if (enemyUnlocks.enable_tera && e.mechanic === 'tera' && e.canTera && !battle.enemyTeraUsed && !e.isTerastallized) {
        // AI å†³ç­–ï¼šç¬¬ä¸€å›åˆç«‹å³å¤ªæ™¶åŒ–
        battle.enemyTeraUsed = true;
        const oldEnemyName = e.cnName;
        const oldTypes = [...e.types];
        const teraType = e.teraType;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        log(`<div style="border-bottom: 2px solid #22d3ee; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#22d3ee">ğŸ’ TERASTALLIZE !!! ğŸ’</b>`);
        log(`${trainerName} çš„ ${oldEnemyName} å¼€å§‹ç»“æ™¶åŒ–ï¼é—ªè€€ç€ ${teraType} å±æ€§çš„å…‰èŠ’ï¼`);
        await wait(600);
        // æ’­æ”¾å¤ªæ™¶åŒ–åŠ¨ç”»
        const enemySprite = document.getElementById('enemy-sprite');
        if (enemySprite) {
            enemySprite.classList.add('tera-burst', `tera-type-${teraType.toLowerCase()}`);
            await wait(800);
            enemySprite.classList.remove('tera-burst');
            enemySprite.classList.add('state-terastal');
        }
        // æ‰§è¡Œå¤ªæ™¶åŒ–ï¼šå±æ€§å˜æ›´
        e.isTerastallized = true;
        e.originalTypes = oldTypes;
        e.types = [teraType];
        log(`<b style="color:#22d3ee">${trainerName} çš„ ${oldEnemyName} å¤ªæ™¶åŒ–äº†ï¼</b>`);
        log(`<span style="color:#67e8f9">å±æ€§å˜åŒ–: ${oldTypes.join('/')} â†’ <b>${teraType}</b></span>`);
        updateAllVisuals('enemy');
        await wait(800);
    }
    // =====================================================
    // === æ•Œæ–¹ AI ç¾ç»Šå…±é¸£ (Bond Resonance) è§¦å‘é€»è¾‘ ===
    // =====================================================
    // ã€è§£é”æ£€æŸ¥ã€‘Bond éœ€è¦ enable_bond
    // ã€å…¨å±€é™åˆ¶ã€‘æ¯åœºæˆ˜æ–—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ Bond Resonance
    if (enemyUnlocks.enable_bond && e.isAce && !battle.enemyBondUsed && !e.hasBondResonance && !e.hasEvolvedThisBattle) {
        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³è§¦å‘æ¡ä»¶
        const eHpRatio = e.currHp / e.maxHp;
        const eAvs = e.avs || { trust: 0, passion: 0, insight: 0, devotion: 0 };
        const eTotalAVs = (e.getEffectiveAVs?.('trust') || eAvs.trust || 0) + 
                         (e.getEffectiveAVs?.('passion') || eAvs.passion || 0) + 
                         (e.getEffectiveAVs?.('insight') || eAvs.insight || 0) + 
                         (e.getEffectiveAVs?.('devotion') || eAvs.devotion || 0);
        // æ¡ä»¶ï¼šAce å®å¯æ¢¦ + AVs >= 300
        const meetsAVsReq = eTotalAVs >= 300;
        // ã€ä¸¥æ ¼åŠ£åŠ¿åˆ¤æ–­ã€‘
        // è®¡ç®—åŒæ–¹æ€»è¡€é‡
        let enemyTotalHp = 0, enemyTotalMaxHp = 0;
        let playerTotalHp = 0, playerTotalMaxHp = 0;
        battle.enemyParty.forEach(ep => {
            if (ep && typeof ep.isAlive === 'function') {
                enemyTotalMaxHp += ep.maxHp || 0;
                enemyTotalHp += Math.max(0, ep.currHp || 0);
            }
        });
        battle.playerParty.forEach(pp => {
            if (pp && typeof pp.isAlive === 'function') {
                playerTotalMaxHp += pp.maxHp || 0;
                playerTotalHp += Math.max(0, pp.currHp || 0);
            }
        });
        const aliveEnemies = battle.enemyParty.filter(ep => ep && typeof ep.isAlive === 'function' && ep.isAlive()).length;
        const alivePlayers = battle.playerParty.filter(pp => pp && typeof pp.isAlive === 'function' && pp.isAlive()).length;
        const isLastStand = aliveEnemies === 1;
        // ã€ä¸¥æ ¼åŠ£åŠ¿æ¡ä»¶ã€‘
        // æ ¸å¿ƒæ¡ä»¶ï¼šå¿…é¡»æ˜¯æœ€åä¸€åªå®å¯æ¢¦ ä¸” HP <= 50%
        // å°è§„æ¨¡æˆ˜æ–—ï¼ˆåŒæ–¹å„ <= 2 åªï¼‰æ—¶ï¼Œå…è®¸è¡€é‡åŠ£åŠ¿è§¦å‘
        const currentPokemonCritical = eHpRatio <= 0.50;
        const isSmallBattle = (battle.enemyParty.length <= 2 && battle.playerParty.length <= 2);
        const isHpDisadvantage = enemyTotalHp < playerTotalHp * 0.5;
        // è§¦å‘æ¡ä»¶ï¼š
        // 1. æœ€åä¸€åªå®å¯æ¢¦ + HP <= 50%
        // 2. æˆ–è€… å°è§„æ¨¡æˆ˜æ–— + è¡€é‡åŠ£åŠ¿ + HP <= 50%
        const canTriggerBond = meetsAVsReq && currentPokemonCritical && (isLastStand || (isSmallBattle && isHpDisadvantage));
        if (canTriggerBond) {
            e.hasBondResonance = true;
            battle.enemyBondUsed = true; // ã€å…¨å±€é™åˆ¶ã€‘æ ‡è®°å·²ä½¿ç”¨
            const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
            log(`<div style="border-top: 2px solid #ef4444; border-bottom: 2px solid #ef4444; padding: 8px; text-align: center; margin: 10px 0; background: linear-gradient(90deg, rgba(239,68,68,0.1), rgba(239,68,68,0.3), rgba(239,68,68,0.1));">`);
            log(`<b style="font-size:1.4em; color:#ef4444; text-shadow: 0 0 10px #dc2626;">âˆ BOND RESONANCE âˆ</b>`);
            log(`</div>`);
            await wait(500);
            log(`${trainerName} ä¸ ${e.cnName} çš„å¿ƒè·³å®Œå…¨é‡åˆäº†â€¦â€¦`);
            await wait(400);
            log(`ä¸ºäº†å›åº”å½»åº•çš„ä¿¡èµ– <span style="color:#facc15">(Total AVs: ${eTotalAVs})</span>ï¼Œæ²‰ç¡åœ¨ä½“å†…çš„ç•Œé™è¢«æ‰“ç ´äº†ï¼`);
            // åŠ¨ç”»ï¼šçº¢è‰²å…‰æ™•çˆ†å‘
            const enemySprite = document.getElementById('enemy-sprite');
            if (enemySprite) {
                enemySprite.classList.add('evo-burst');
                enemySprite.style.filter = 'brightness(3) drop-shadow(0 0 20px #ef4444)';
            }
            await wait(400);
            if (enemySprite) {
                enemySprite.classList.remove('evo-burst');
                enemySprite.classList.add('evo-finish');
                enemySprite.style.filter = 'drop-shadow(0 0 15px #ef4444) brightness(1.15) saturate(1.2)';
            }
            await wait(600);
            if (enemySprite) {
                enemySprite.classList.remove('evo-finish');
                enemySprite.classList.add('bond-resonance');
            }
            // æ•°æ®å˜æ›´
            // 1. HP å›å¤ +60%
            const healAmount = Math.floor(e.maxHp * 0.6);
            e.currHp = Math.min(e.currHp + healAmount, e.maxHp);
            // 2. æ¸…é™¤å¼‚å¸¸
            e.status = null;
            // 3. å…¨èƒ½åŠ›+1
            if (typeof e.applyBoost === 'function') {
                e.applyBoost('atk', 1);
                e.applyBoost('def', 1);
                e.applyBoost('spa', 1);
                e.applyBoost('spd', 1);
                e.applyBoost('spe', 1);
            }
            log(`<b style="color:#ef4444">âœ¦ ${trainerName} çš„ ${e.cnName} æ½œèƒ½è¢«å”¤é†’! å…¨å±æ€§æå¤§å¹…æå‡!</b>`);
            log(`<span style="color:#60a5fa">âœ¦ æ°”åŠ¿(HP)å¤§å¹…å›å¤ï¼(+${healAmount})</span>`);
            if (isLastStand) {
                log(`<span style="color:#f87171; font-style:italic;">ã€Œ${trainerName}: è¿™æ˜¯æˆ‘ä»¬æœ€åçš„åå‡»ï¼ã€</span>`);
            }
            updateAllVisuals('enemy');
            await wait(800);
        }
    }
    // === è·å–æ•Œæ–¹ AI å†³ç­– (æ”¯æŒæ¢äºº) ===
    let enemyMove = null;
    let enemyAction = null;
    let enemyWillSwitch = false;
    let switchTargetIndex = -1;
    // ä¼˜å…ˆä½¿ç”¨æ–°çš„ AI å¼•æ“
    if (typeof window.getAiAction === 'function') {
        enemyAction = window.getAiAction(e, p, battle.aiDifficulty || 'normal', battle.enemyParty, {
            turnCount: battle.turnCount || 1
        });
    }
    // æ£€æŸ¥ AI æ˜¯å¦å†³å®šæ¢äºº
    if (enemyAction && enemyAction.type === 'switch' && typeof enemyAction.index === 'number') {
        const switchTarget = battle.enemyParty[enemyAction.index];
        // ä¸¥æ ¼æ£€æŸ¥ï¼šç›®æ ‡å¿…é¡»å­˜åœ¨ã€å­˜æ´»ã€ä¸æ˜¯å½“å‰å®å¯æ¢¦ã€HP > 0
        const targetIsValid = switchTarget && 
            typeof switchTarget.isAlive === 'function' && 
            switchTarget.isAlive() && 
            switchTarget.currHp > 0 &&
            switchTarget !== e;
        if (targetIsValid) {
            enemyWillSwitch = true;
            switchTargetIndex = enemyAction.index;
            if (enemyAction.reasoning) {
                console.log(`[AI] Switch reasoning: ${enemyAction.reasoning}`);
            }
        }
    }
    // è·å–æ•Œæ–¹æ”»å‡»æ‹›å¼ï¼ˆå¦‚æœä¸æ¢äººï¼‰
    if (!enemyWillSwitch) {
        if (enemyAction && enemyAction.move) {
            enemyMove = enemyAction.move;
            if (enemyAction.reasoning) {
                console.log(`[AI] Move reasoning: ${enemyAction.reasoning}`);
            }
        }
        // å›é€€åˆ°æ—§ AI
        if (!enemyMove && typeof window.getAiMove === 'function') {
            enemyMove = window.getAiMove(e, p, battle.aiDifficulty || 'normal');
        }
        if (!enemyMove) {
            enemyMove = e.moves[Math.floor(Math.random() * e.moves.length)];
        }
        // === ã€ä¿®å¤ã€‘æ£€æŸ¥ Taunt ç­‰ Volatile çŠ¶æ€æ˜¯å¦é˜»æ­¢ AI ä½¿ç”¨è¯¥æŠ€èƒ½ ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.canUseMove && enemyMove) {
            const canUseResult = MoveEffects.canUseMove(e, enemyMove);
            if (!canUseResult.canUse) {
                log(`<span style="color:#e74c3c">${canUseResult.reason}</span>`);
                // å°è¯•é€‰æ‹©å…¶ä»–å¯ç”¨æŠ€èƒ½
                const availableMoves = e.moves.filter(m => {
                    const check = MoveEffects.canUseMove(e, m);
                    return check.canUse;
                });
                if (availableMoves.length > 0) {
                    enemyMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    console.log(`[AI] Taunt é˜»æ­¢äº†åŸæŠ€èƒ½ï¼Œæ”¹ç”¨: ${enemyMove.name}`);
                } else {
                    // æ²¡æœ‰å¯ç”¨æŠ€èƒ½ï¼Œä½¿ç”¨æŒ£æ‰
                    enemyMove = { name: 'Struggle', cn: 'æŒ£æ‰', power: 50, type: 'Normal', cat: 'phys' };
                    log(`<span style="color:#aaa">${e.cnName} æ— æŠ€å¯ç”¨ï¼Œåªèƒ½æŒ£æ‰!</span>`);
                }
            }
        }
        // =====================================================
        // === ã€AI Z æ‹›å¼æ¨å¯¼ã€‘ ===
        // =====================================================
        // å¦‚æœæ•Œæ–¹é…ç½®äº† mechanic='zmove' ä¸”è¿˜æ²¡ç”¨è¿‡ Z æ‹›å¼
        // ã€è§£é”æ£€æŸ¥ã€‘Z æ‹›å¼éœ€è¦ enable_z_move
        // ä¼˜å…ˆå¯»æ‰¾èƒ½è§¦å‘ä¸“å± Z çš„æ‹›å¼ï¼Œå¦åˆ™å°è¯•è½¬æ¢å½“å‰æ‹›å¼
        const enemyUnlocksForZ = battle.enemyUnlocks || {};
        if (enemyUnlocksForZ.enable_z_move && e.mechanic === 'zmove' && !battle.enemyZUsed && enemyMove) {
            let zTarget = null;
            let zBaseMove = null;
            // 1. ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æœ‰èƒ½è§¦å‘ä¸“å± Z çš„æ‹›å¼
            for (const move of e.moves) {
                const potentialZ = typeof getZMoveTarget === 'function' 
                    ? getZMoveTarget(move, e) 
                    : null;
                if (potentialZ && potentialZ.isExclusive) {
                    // æ‰¾åˆ°ä¸“å± Z æ‹›å¼ï¼
                    zTarget = potentialZ;
                    zBaseMove = move;
                    console.log(`[AI Z-MOVE] æ‰¾åˆ°ä¸“å± Z æ‹›å¼: ${move.name} -> ${potentialZ.name}`);
                    break;
                }
            }
            // 2. å¦‚æœæ²¡æœ‰ä¸“å± Zï¼Œå°è¯•ç”¨å½“å‰é€‰ä¸­çš„æ‹›å¼è½¬æ¢
            if (!zTarget) {
                zTarget = typeof getZMoveTarget === 'function' 
                    ? getZMoveTarget(enemyMove, e) 
                    : null;
                zBaseMove = enemyMove;
            }
            if (zTarget) {
                console.log(`[AI Z-MOVE] æ•Œæ–¹ AI æ¨å¯¼ Z æ‹›å¼: ${zBaseMove.name} -> ${zTarget.name} (å¨åŠ›: ${zTarget.power})`);
                // åˆ›å»º Z æ‹›å¼å¯¹è±¡
                enemyMove = {
                    name: zTarget.name,
                    type: zTarget.type || zBaseMove.type,
                    power: zTarget.power,
                    cat: zBaseMove.cat || 'phys',
                    accuracy: true, // Z æ‹›å¼å¿…ä¸­
                    isZ: true,
                    baseMove: zBaseMove.name // ä¿ç•™åŸå§‹æ‹›å¼å
                };
            }
        }
        // =====================================================
        // === ã€AI åˆšçŒ›/è¿…ç–¾é£æ ¼ v2.1ã€‘ (enable_styles) ===
        // =====================================================
        // åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®é€Ÿåº¦ä¼˜åŠ¿å†³å®šæƒ©ç½šç¨‹åº¦
        // è¿…ç–¾ (Agile): é€Ÿåº¦å¿«æ—¶0.75x(ä¿å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶0.5x(æŠ¢èŠ‚å¥)
        // åˆšçŒ› (Strong): é€Ÿåº¦å¿«æ—¶å¿…ä¸­(å–å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8x(ç™½å«–)
        // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
        const enemyUnlocksForStyles = battle.enemyUnlocks || {};
        if (enemyUnlocksForStyles.enable_styles && enemyMove && !enemyMove.isZ) {
            // ã€å†·å´æ£€æŸ¥ã€‘å¦‚æœåœ¨å†·å´ä¸­ï¼ŒAI ä¸ä½¿ç”¨é£æ ¼
            if (battle.enemyStyleCooldown > 0) {
                console.log(`[AI STYLES] æ•Œæ–¹é£æ ¼ç³»ç»Ÿå†·å´ä¸­ï¼Œæœ¬å›åˆä½¿ç”¨æ™®é€šé£æ ¼`);
            } else {
                const originalPower = enemyMove.basePower || enemyMove.power || 0;
                const originalPriority = enemyMove.priority || 0;
                const originalAccuracy = enemyMove.accuracy;
                const isStatus = (enemyMove.category === 'Status' || enemyMove.cat === 'status' || originalPower === 0);
                // ã€v2.1ã€‘è®¡ç®—æœ‰æ•ˆé€Ÿåº¦ï¼Œåˆ¤æ–­é€Ÿåº¦ä¼˜åŠ¿
                let aiSpe = (typeof e.getStat === 'function') ? e.getStat('spe') : (e.spe || 100);
                let playerSpe = (typeof p.getStat === 'function') ? p.getStat('spe') : (p.spe || 100);
                // éº»ç—¹å‡é€Ÿ
                if (e.status === 'par') aiSpe = Math.floor(aiSpe * 0.5);
                if (p.status === 'par') playerSpe = Math.floor(playerSpe * 0.5);
                // æˆæ³•ç©ºé—´åˆ¤å®š
                const isTrickRoom = battle.field && battle.field.trickRoom > 0;
                let aiHasSpeedAdvantage = false;
                if (isTrickRoom) {
                    aiHasSpeedAdvantage = aiSpe < playerSpe; // ç©ºé—´ä¸‹ï¼šæ…¢å°±æ˜¯å¿«
                } else {
                    aiHasSpeedAdvantage = aiSpe > playerSpe; // æ­£å¸¸ï¼šå¿«å°±æ˜¯å¿«
                }
                // ã€v2.1ã€‘ä¼˜å…ˆä½¿ç”¨ AI å¼•æ“è¿”å›çš„é£æ ¼é€‰æ‹©
                let aiStyle = 'normal';
                if (enemyAction && enemyAction.style) {
                    aiStyle = enemyAction.style;
                    console.log(`[AI STYLES] ä½¿ç”¨ AI å¼•æ“æ¨èçš„é£æ ¼: ${aiStyle}`);
                }
                // ============================================
                // âš¡ AI è¿…ç–¾é£æ ¼ (Agile Style)
                // ============================================
                if (aiStyle === 'agile') {
                    // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘å˜åŒ–æŠ€ç¦æ­¢ä½¿ç”¨è¿…ç–¾
                    if (isStatus) {
                        console.log(`[AI STYLES] å˜åŒ–æŠ€æ— æ³•ä½¿ç”¨è¿…ç–¾ï¼Œæ”¹ç”¨æ™®é€šé£æ ¼`);
                    } else {
                        enemyMove = { ...enemyMove };
                        enemyMove.priority = originalPriority + 1;
                        enemyMove.styleUsed = 'agile';
                        const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                        if (aiHasSpeedAdvantage) {
                            // åœºæ™¯ A: æ‹¥æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ä¹°ä¿é™©æ±‚ç¨³ï¼Œé˜²å…ˆåˆ¶
                            enemyMove.basePower = Math.floor(originalPower * 0.75);
                            enemyMove.accuracy = Math.floor(oldAcc * 0.9); // å‘½ä¸­ç‡ 0.9x
                            log(`<span style="color:#3b82f6">âš¡ æ•Œæ–¹è¿…ç–¾Â·åˆ¶å˜ï¼šé€Ÿåº¦å‹åˆ¶ä¸‹ç¡®ä¿å…ˆæ‰‹ - å¨åŠ›Ã—0.75ï¼Œå‘½ä¸­Ã—0.9</span>`);
                            console.log(`[AI STYLES] è¿…ç–¾(å¿«): power 0.75x, acc 0.9x (${aiSpe} vs ${playerSpe})`);
                        } else {
                            // åœºæ™¯ B: æ²¡æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ç»åœ°åå‡»ï¼Œå·å›åˆ
                            enemyMove.basePower = Math.floor(originalPower * 0.50);
                            enemyMove.accuracy = Math.floor(oldAcc * 0.85); // å‘½ä¸­ç‡ 0.85x
                            log(`<span style="color:#60a5fa">âš¡ æ•Œæ–¹è¿…ç–¾Â·ç¥é€Ÿï¼šé€†è½¬è¡ŒåŠ¨é¡ºä½ - å¨åŠ›Ã—0.50ï¼Œå‘½ä¸­Ã—0.85</span>`);
                            console.log(`[AI STYLES] è¿…ç–¾(æ…¢): power 0.5x, acc 0.85x (${aiSpe} vs ${playerSpe})`);
                        }
                        enemyMove.power = enemyMove.basePower;
                        // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                        battle.enemyStyleCooldown = 1;
                    }
                } 
                // ============================================
                // ğŸ’ª AI åˆšçŒ›é£æ ¼ (Strong Style)
                // ============================================
                else if (aiStyle === 'strong') {
                    enemyMove = { ...enemyMove };
                    enemyMove.priority = originalPriority - 1;
                    enemyMove.basePower = Math.floor(originalPower * 1.30);
                    enemyMove.power = enemyMove.basePower;
                    enemyMove.breaksProtect = true; // å¯ç©¿é€å®ˆä½
                    enemyMove.styleUsed = 'strong';
                    if (!aiHasSpeedAdvantage) {
                        // åœºæ™¯ A: é€Ÿåº¦åŠ£åŠ¿ (æœ¬æ¥å°±æ…¢) - æ²¡ä»˜å‡ºä»£ä»·ï¼Œé™å‘½ä¸­
                        const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                        enemyMove.accuracy = Math.floor(oldAcc * 0.8);
                        log(`<span style="color:#ef4444">ğŸ’ª æ•Œæ–¹åˆšçŒ›Â·èˆèº«ï¼šé€Ÿåº¦åŠ£åŠ¿ä¸‹çš„å¼ºæ”» - å¨åŠ›Ã—1.3ï¼Œå‘½ä¸­Ã—0.8</span>`);
                        console.log(`[AI STYLES] åˆšçŒ›(æ…¢): power 1.3x, acc 0.8x (${aiSpe} vs ${playerSpe})`);
                    } else {
                        // åœºæ™¯ B: é€Ÿåº¦ä¼˜åŠ¿ (æœ¬æ¥è¯¥AIå…ˆ) - å–å…ˆæ‰‹æ¢ä¼¤å®³ï¼Œä¸ä¿®æ­£å‘½ä¸­
                        // ã€v2.3ã€‘ä¸å†å¿…ä¸­ï¼Œä¿æŒåŸå‘½ä¸­ç‡
                        log(`<span style="color:#b91c1c">ğŸ’ª æ•Œæ–¹åˆšçŒ›Â·è“„åŠ›ï¼šæ”¾å¼ƒå…ˆæ‰‹ï¼Œå…¨åŠ›ä¸€å‡»ï¼(å¨åŠ›Ã—1.3ï¼Œè´¯ç©¿å®ˆä½)</span>`);
                        console.log(`[AI STYLES] åˆšçŒ›(å¿«): power 1.3x, acc unchanged (${aiSpe} vs ${playerSpe})`);
                    }
                    // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                    battle.enemyStyleCooldown = 1;
                }
            }
        }
    }
    // ========================================
    // å›åˆæ‰§è¡Œé¡ºåºï¼ˆæ­£ç¡®çš„å®å¯æ¢¦æˆ˜æ–—æµç¨‹ï¼‰ï¼š
    // 1. æ¢äººå…ˆæ‰§è¡Œï¼ˆæ¢äººä¼˜å…ˆçº§æœ€é«˜ï¼Œåœ¨æ”»å‡»ä¹‹å‰ï¼‰
    // 2. ç„¶åæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§æ‰§è¡Œæ”»å‡»
    // ========================================
    // === é˜¶æ®µ 1ï¼šæ•Œæ–¹æ¢äººï¼ˆåœ¨ç©å®¶æ”»å‡»ä¹‹å‰ï¼‰ ===
    if (enemyWillSwitch) {
        log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${e.cnName}ï¼</span>`);
        // ã€ä¿®å¤ã€‘æ¸…é™¤ Choice é”æ‹›çŠ¶æ€ï¼ˆæ¢äººè§£é™¤é”æ‹›ï¼‰
        if (e.choiceLockedMove) {
            console.log(`[CHOICE] ${e.name} æ¢ä¸‹ï¼Œè§£é™¤ ${e.choiceLockedMove} é”å®š`);
            delete e.choiceLockedMove;
        }
        // é‡ç½®å½“å‰å®å¯æ¢¦èƒ½åŠ›ç­‰çº§
        if (typeof e.resetBoosts === 'function') {
            e.resetBoosts();
        }
        battle.enemyActive = switchTargetIndex;
        const newE = battle.getEnemy();
        log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
        // æ£€æŸ¥è¿›åœºå˜å½¢
        const checkInitTransformFunc = typeof window.checkInitTransform === 'function' ? window.checkInitTransform : null;
        if (checkInitTransformFunc && newE.needsInitTransform) {
            const result = checkInitTransformFunc(newE);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
            }
        }
        updateAllVisuals('enemy');
        await wait(500);
        triggerEntryAbilities(newE, p);
        // === ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³ ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
        // æ›´æ–°æ•Œæ–¹å¼•ç”¨ä¸ºæ–°å®å¯æ¢¦
        e = newE;
    }
    // === é˜¶æ®µ 2ï¼šæ‰§è¡Œæ”»å‡»ï¼ˆæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§é¡ºåºï¼‰ ===
    // å¦‚æœæ•Œæ–¹æ¢äººäº†ï¼Œå®ƒè¿™å›åˆä¸æ”»å‡»ï¼Œåªæœ‰ç©å®¶æ”»å‡»
    if (enemyWillSwitch) {
        console.log('[handleAttack] Enemy switched, player attacks only');
        // ç©å®¶æ”»å‡»æ¢å…¥çš„å®å¯æ¢¦
        const playerResult = await executePlayerTurn(p, e, playerMove);
        if (!e.isAlive()) {
            await handleEnemyFainted(e);
            return;
        }
        // ç©å®¶ä½¿ç”¨äº† pivot æŠ€èƒ½ï¼Œè§¦å‘æ¢äºº
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            console.log('[handleAttack] Player pivot in enemySwitch branch, calling handlePlayerPivot...');
            try {
                await handlePlayerPivot();
                console.log('[handleAttack] handlePlayerPivot Promise resolved successfully');
            } catch (err) {
                console.error('[handleAttack] handlePlayerPivot error:', err);
            }
        }
        // å›åˆæœ«ç»“ç®—
        console.log('[handleAttack] Calling executeEndPhase...');
        const currentP = battle.getPlayer();
        const currentE = battle.getEnemy();
        await executeEndPhase(currentP, currentE);
        console.log('[handleAttack] executeEndPhase returned');
        return;
    }
    // === é˜¶æ®µ 2bï¼šåŒæ–¹éƒ½æ”»å‡»ï¼ŒæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§é¡ºåº ===
    // === è®¡ç®—è¡ŒåŠ¨é¡ºåº (Priority + Speed) ===
    // æ³¨æ„ï¼šGen7+ è§„åˆ™ï¼ŒMega è¿›åŒ–åé€Ÿåº¦ç«‹å³ç”Ÿæ•ˆ
    const playerPriority = typeof window.getMovePriority === 'function' 
        ? window.getMovePriority(playerMove) : 0;
    const enemyPriority = typeof window.getMovePriority === 'function' 
        ? window.getMovePriority(enemyMove) : 0;
    let playerFirst = true;
    if (playerPriority !== enemyPriority) {
        // ä¼˜å…ˆçº§ä¸åŒï¼Œé«˜ä¼˜å…ˆçº§å…ˆåŠ¨
        playerFirst = playerPriority > enemyPriority;
        console.log(`[Speed Check] Priority differs: P(${playerMove?.name || playerMove?.cn}) prio=${playerPriority} vs E(${enemyMove?.name || enemyMove?.cn}) prio=${enemyPriority} => PlayerFirst? ${playerFirst}`);
    } else {
        // ä¼˜å…ˆçº§ç›¸åŒï¼Œæ¯”è¾ƒé€Ÿåº¦
        let playerSpeed = p.getStat('spe');
        let enemySpeed = e.getStat('spe');
        // =========================================================
        // åœºåœ°çŠ¶æ€å¯¹é€Ÿåº¦çš„å½±å“
        // =========================================================
        // Tailwind (é¡ºé£): é€Ÿåº¦ç¿»å€
        if (battle.playerSide && battle.playerSide.tailwind > 0) {
            playerSpeed *= 2;
            console.log(`[Speed Check] Player has Tailwind! Speed doubled.`);
        }
        if (battle.enemySide && battle.enemySide.tailwind > 0) {
            enemySpeed *= 2;
            console.log(`[Speed Check] Enemy has Tailwind! Speed doubled.`);
        }
        console.log(`[Speed Check] ${p.cnName}(base spe=${p.spe}, effective=${playerSpeed}) vs ${e.cnName}(base spe=${e.spe}, effective=${enemySpeed})`);
        // Trick Room (æˆæ³•ç©ºé—´): é€Ÿåº¦æ…¢çš„å…ˆåŠ¨
        const isTrickRoom = battle.field && battle.field.trickRoom > 0;
        if (playerSpeed !== enemySpeed) {
            if (isTrickRoom) {
                // ç©ºé—´ä¸‹ï¼šæ…¢çš„å…ˆåŠ¨
                playerFirst = playerSpeed < enemySpeed;
                console.log(`[Speed Check] TRICK ROOM active! Slower moves first. PlayerFirst? ${playerFirst}`);
            } else {
                // æ­£å¸¸ï¼šå¿«çš„å…ˆåŠ¨
                playerFirst = playerSpeed > enemySpeed;
            }
        } else {
            // é€Ÿåº¦ç›¸åŒï¼Œéšæœºå†³å®š
            playerFirst = Math.random() < 0.5;
            console.log(`[Speed Check] Same speed, random result: PlayerFirst? ${playerFirst}`);
        }
        console.log(`[Speed Check] Result: PlayerFirst? ${playerFirst}${isTrickRoom ? ' (Trick Room)' : ''}`);
    }
    // === æ‰§è¡Œå›åˆ ===
    // æ­£ç¡®çš„ Pivot æ—¶åºï¼šå…ˆæ‰‹æ”»å‡» -> å…ˆæ‰‹ Pivot æ¢äºº -> åæ‰‹æ”»å‡»æ‰“æ–°æ€ª -> åæ‰‹ Pivot æ¢äºº
    if (playerFirst) {
        // ========== ç©å®¶å…ˆåŠ¨ ==========
        console.log('[handleAttack] Player moves first');
        const playerResult = await executePlayerTurn(p, e, playerMove);
        // ã€ä¿®å¤ã€‘U-turn/Volt Switch æ—¶åºï¼šå…ˆå¤„ç† Pivot æ¢äººï¼Œå†å¤„ç†æ•Œæ–¹å€’ä¸‹
        // æ­£ä½œé€»è¾‘ï¼šå³ä½¿å‡»æ€å¯¹æ‰‹ï¼Œä½¿ç”¨è€…ä¹Ÿå¿…é¡»å…ˆæ¢äºº
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            const oldP = battle.getPlayer();
            const moveName = playerMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldP.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldP.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldP.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            console.log('[handleAttack] Player pivot triggered, waiting for switch...');
            await handlePlayerPivot();
            p = battle.getPlayer();
            console.log('[handleAttack] Player pivot complete, new pokemon:', p?.cnName);
        } else if (playerResult?.pivot) {
            log(`<span style="color:#999">ä½†æ˜¯æ²¡æœ‰å¯ä»¥æ¢å…¥çš„å®å¯æ¢¦äº†!</span>`);
        }
        // æ•Œæ–¹å€’ä¸‹åˆ¤å®šï¼ˆåœ¨ pivot æ¢äººä¹‹åï¼‰
        if (!e.isAlive()) {
            await handleEnemyFainted(e);
            return;
        }
        // ========== æ•Œæ–¹ååŠ¨ï¼ˆæ”»å‡»æ–°æ¢å…¥çš„å®å¯æ¢¦ï¼‰ ==========
        console.log('[handleAttack] Enemy turn starting, move:', enemyMove?.name || enemyMove?.cn);
        const enemyResult = await executeEnemyTurn(e, p, enemyMove);
        console.log('[handleAttack] Enemy turn complete');
        // ã€ä¿®å¤ã€‘æ•Œæ–¹ Pivot ä¹Ÿè¦å…ˆå¤„ç†ï¼Œå†åˆ¤å®šç©å®¶å€’ä¸‹
        if (enemyResult?.pivot && hasAliveSwitch(battle.enemyParty, battle.enemyActive)) {
            const oldE = battle.getEnemy();
            const moveName = enemyMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldE.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldE.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldE.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handleEnemyPivot();
            e = battle.getEnemy();
        }
        if (!p.isAlive()) {
            await handlePlayerFainted(p);
            return;
        }
    } else {
        // ========== æ•Œæ–¹å…ˆåŠ¨ ==========
        const enemyResult = await executeEnemyTurn(e, p, enemyMove);
        // ã€ä¿®å¤ã€‘æ•Œæ–¹ Pivot å…ˆå¤„ç†ï¼Œå†åˆ¤å®šç©å®¶å€’ä¸‹
        if (enemyResult?.pivot && hasAliveSwitch(battle.enemyParty, battle.enemyActive)) {
            const oldE = battle.getEnemy();
            const moveName = enemyMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldE.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldE.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldE.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handleEnemyPivot();
            e = battle.getEnemy();
        }
        if (!p.isAlive()) {
            await handlePlayerFainted(p);
            return;
        }
        // ========== ç©å®¶ååŠ¨ï¼ˆæ”»å‡»æ–°æ¢å…¥çš„å®å¯æ¢¦ï¼‰ ==========
        const playerResult = await executePlayerTurn(p, e, playerMove);
        // ã€ä¿®å¤ã€‘ç©å®¶ Pivot å…ˆå¤„ç†ï¼Œå†åˆ¤å®šæ•Œæ–¹å€’ä¸‹
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            const oldP = battle.getPlayer();
            const moveName = playerMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldP.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldP.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldP.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handlePlayerPivot();
            p = battle.getPlayer();
        } else if (playerResult?.pivot) {
            log(`<span style="color:#999">ä½†æ˜¯æ²¡æœ‰å¯ä»¥æ¢å…¥çš„å®å¯æ¢¦äº†!</span>`);
        }
        if (!e.isAlive()) {
            await handleEnemyFainted(e);
            return;
        }
    }
    // === å›åˆæœ«ç»“ç®— ===
    // é‡æ–°è·å–æœ€æ–°å¼•ç”¨ï¼ˆpivot æ¢äººåå¯èƒ½å·²å˜åŒ–ï¼‰
    const currentP = battle.getPlayer();
    const currentE = battle.getEnemy();
    await executeEndPhase(currentP, currentE);
}
// ============================================
// ã€å·²è¿ç§»ã€‘å›åˆæ‰§è¡Œ -> battle/battle-turns.js
// ============================================
// ============================================
// ã€å·²è¿ç§»ã€‘æ¢äººç³»ç»Ÿ -> battle/battle-switch.js
// ============================================
// ã€å·²è¿ç§»ã€‘handleEnemyFainted -> battle/battle-switch.js
// ã€å·²è¿ç§»ã€‘handlePlayerFainted -> battle/battle-switch.js
// ã€å·²è¿ç§»ã€‘enemyTurn -> battle/battle-turns.js
// ã€å·²è¿ç§»ã€‘triggerEntryAbilities -> battle/battle-switch.js
/**
 * å›åˆæœ«ç»“ç®—
 */
async function executeEndPhase(p, e) {
    console.log('[executeEndPhase] Starting with:', p?.cnName, 'vs', e?.cnName);
    try {
        await wait(300);
        // å®‰å…¨æ£€æŸ¥
        if (!p || !e) {
            console.warn('[executeEndPhase] Invalid pokemon reference:', { p, e });
            battle.locked = false;
            return;
        }
        if (typeof window.getEndTurnStatusLogs === 'function') {
        // ç»“ç®—ç©å®¶çš„çŠ¶æ€ä¼¤å®³ï¼ˆisPlayerPoke = trueï¼ŒAVs æ•ˆæœç”Ÿæ•ˆï¼‰
        if (p.isAlive()) {
            const pLogs = window.getEndTurnStatusLogs(p, e, true);
            if (pLogs.length > 0) {
                pLogs.forEach(txt => {
                    // Devotion æ²»æ„ˆæ—¥å¿—å·²ç»æœ‰æ ·å¼ï¼Œç›´æ¥è¾“å‡º
                    if (txt.includes('Devotion')) {
                        log(txt);
                    } else {
                        log(`<span style="color:#d35400">${txt}</span>`);
                    }
                });
                updateAllVisuals();
                await wait(400);
                if (!p.isAlive()) {
                    await handlePlayerFainted(p);
                    return;
                }
            }
        }
        // ç»“ç®—æ•Œæ–¹çš„çŠ¶æ€ä¼¤å®³ï¼ˆisPlayerPoke = falseï¼ŒAVs æ•ˆæœä¸ç”Ÿæ•ˆï¼‰
        if (e.isAlive()) {
            const eLogs = window.getEndTurnStatusLogs(e, p, false);
            if (eLogs.length > 0) {
                eLogs.forEach(txt => {
                    // Devotion æ²»æ„ˆæ—¥å¿—å·²ç»æœ‰æ ·å¼ï¼Œç›´æ¥è¾“å‡º
                    if (txt.includes('Devotion')) {
                        log(txt);
                    } else {
                        log(`<span style="color:#d35400">${txt}</span>`);
                    }
                });
                updateAllVisuals();
                await wait(400);
                if (!e.isAlive()) {
                    await handleEnemyFainted(e);
                    return;
                }
            }
        }
    }
    // å¢åŠ åŒæ–¹ä¸Šåœºå›åˆæ•°ï¼ˆç”¨äº Fake Out ç­‰é¦–å›åˆé™åˆ¶æŠ€èƒ½ï¼‰
    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºå®ˆä½ç±»æŠ€èƒ½ï¼ˆæ•°æ®é©±åŠ¨ï¼‰
    const isProtectMove = (moveName) => {
        if (!moveName) return false;
        const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
        const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : null;
        return moveData?.stallingMove || false;
    };
    if (p && p.isAlive()) {
        p.turnsOnField = (p.turnsOnField || 0) + 1;
        // é‡ç½®å®ˆä½è®¡æ•°å™¨ï¼ˆå¦‚æœä¸Šå›åˆæ²¡ç”¨å®ˆä½ç±»æŠ€èƒ½ï¼‰
        if (!isProtectMove(p.lastMoveUsed)) {
            p.protectCounter = 0;
        }
        // === ã€ä¿®å¤ã€‘é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨ (Taunt, Disable ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.tickVolatileStatus) {
            const volatileLogs = MoveEffects.tickVolatileStatus(p);
            volatileLogs.forEach(txt => log(txt));
        }
    }
    if (e && e.isAlive()) {
        e.turnsOnField = (e.turnsOnField || 0) + 1;
        // é‡ç½®å®ˆä½è®¡æ•°å™¨ï¼ˆå¦‚æœä¸Šå›åˆæ²¡ç”¨å®ˆä½ç±»æŠ€èƒ½ï¼‰
        if (!isProtectMove(e.lastMoveUsed)) {
            e.protectCounter = 0;
        }
        // === ã€ä¿®å¤ã€‘é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨ (Taunt, Disable ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.tickVolatileStatus) {
            const volatileLogs = MoveEffects.tickVolatileStatus(e);
            volatileLogs.forEach(txt => log(txt));
        }
    }
    // ã€å¤æ­¦ç³»ç»Ÿã€‘é£æ ¼å†·å´å·²ç§»è‡³ handleAttack å¼€å§‹æ—¶é€’å‡ï¼Œæ­¤å¤„ä¸å†å¤„ç†
    // =========================================================
    // æå·¨åŒ–å›åˆå€’è®¡æ—¶ (Dynamax Turn Tick)
    // =========================================================
    if (p && p.isAlive() && p.isDynamaxed && p.dynamaxTurns > 0) {
        p.dynamaxTurns--;
        if (p.dynamaxTurns === 0) {
            // æå·¨åŒ–ç»“æŸ
            log(`<b style="color:#94a3b8">âš¡ æå·¨åŒ–èƒ½é‡è€—å°½äº†...</b>`);
            log(`${p.cnName} å˜å›äº†åŸæ¥çš„æ ·å­ã€‚`);
            // ã€å…³é”®ã€‘æ‹›å¼æ¢å¤ä¸ºæ™®é€šæ‹›å¼
            applyDynamaxState(p, false);
            // æ¢å¤åŸå§‹åç§°
            if (p.originalName) {
                p.name = p.originalName;
                delete p.originalName;
            }
            // æ’­æ”¾æ”¶ç¼©åŠ¨ç”»
            await endDynamaxAnimation(p, true);
            // åˆ‡æ¢å›åŸå§‹ç²¾çµå›¾
            const originalSpriteUrl = p.getSprite(true); // true = èƒŒé¢
            smartLoadSprite('player-sprite', originalSpriteUrl, true);
            // HP å›é€€ï¼ˆæŒ‰æ¯”ä¾‹ï¼‰
            const hpRatio = p.currHp / p.maxHp;
            p.maxHp = p.preDynamaxMaxHp || Math.floor(p.maxHp / 1.5);
            p.currHp = Math.max(1, Math.floor(p.maxHp * hpRatio));
            // æ¸…é™¤æå·¨åŒ–çŠ¶æ€
            p.isDynamaxed = false;
            delete p.preDynamaxMaxHp;
            delete p.preDynamaxCurrHp;
            updateAllVisuals();
            await wait(500);
        } else {
            log(`<span style="color:#ff6b8a">[æå·¨åŒ–å‰©ä½™å›åˆ: ${p.dynamaxTurns}]</span>`);
        }
    }
    // æ•Œæ–¹æå·¨åŒ–å€’è®¡æ—¶
    if (e && e.isAlive() && e.isDynamaxed && e.dynamaxTurns > 0) {
        e.dynamaxTurns--;
        if (e.dynamaxTurns === 0) {
            log(`<b style="color:#94a3b8">âš¡ æ•Œæ–¹çš„æå·¨åŒ–èƒ½é‡è€—å°½äº†...</b>`);
            log(`æ•Œæ–¹çš„ ${e.cnName} å˜å›äº†åŸæ¥çš„æ ·å­ã€‚`);
            // ã€å…³é”®ã€‘æ‹›å¼æ¢å¤ä¸ºæ™®é€šæ‹›å¼
            applyDynamaxState(e, false);
            // æ¢å¤åŸå§‹åç§°å’Œç²¾çµå›¾
            if (e.originalName) {
                e.name = e.originalName;
                delete e.originalName;
            }
            await endDynamaxAnimation(e, false);
            // åˆ‡æ¢å›åŸå§‹ç²¾çµå›¾
            const originalSpriteUrl = e.getSprite(false);
            smartLoadSprite('enemy-sprite', originalSpriteUrl, false);
            const hpRatio = e.currHp / e.maxHp;
            e.maxHp = e.preDynamaxMaxHp || Math.floor(e.maxHp / 1.5);
            e.currHp = Math.max(1, Math.floor(e.maxHp * hpRatio));
            e.isDynamaxed = false;
            delete e.preDynamaxMaxHp;
            delete e.preDynamaxCurrHp;
            updateAllVisuals();
            await wait(500);
        } else {
            log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${e.dynamaxTurns}]</span>`);
        }
    }
    // =========================================================
    // åœºåœ°çŠ¶æ€å€’è®¡æ—¶ (Field Condition Tick)
    // =========================================================
    if (battle.tickFieldConditions) {
        const fieldLogs = battle.tickFieldConditions();
        if (fieldLogs && fieldLogs.length > 0) {
            for (const txt of fieldLogs) {
                log(`<span style="color:#a78bfa">${txt}</span>`);
            }
            await wait(300);
        }
    }
    battle.locked = false;
    console.log('[executeEndPhase] Complete, battle.locked = false');
    } catch (err) {
        console.error('[executeEndPhase] Error:', err);
        battle.locked = false;
    }
}
// ============================================
// ã€å·²è¿ç§»ã€‘ä¼¤å®³ç³»ç»Ÿ -> battle/battle-damage.js
// ============================================
/**
 * ===========================================
 * Part C: Switch System (Manual & Forced)
 * ===========================================
 */
function checkPlayerDefeatOrForceSwitch() {
    const battleEnd = battle.checkBattleEnd();
    if (battleEnd === 'loss') {
        log("ğŸ’€ <b style='color:#e74c3c'>çœ¼å‰ä¸€ç‰‡æ¼†é»‘... ä½ è¾“äº†.</b>");
        if (battle.trainer && battle.trainer.id !== 'wild' && battle.trainer.lines?.win) {
            log(`<i>${battle.trainer.name}: "${battle.trainer.lines.win}"</i>`);
        } else if (battle.scriptedResult === 'loss' && battle.trainer) {
            log(`<i>"æ­£å¦‚æˆ‘æ‰€é¢„æ–™çš„..." ${battle.trainer.name}è½»å£°è¯´é“ã€‚</i>`);
        }
        setTimeout(() => battleEndSequence('loss'), 2000);
        return;
    }
    // å¼ºåˆ¶æ¢äºº
    battle.phase = 'force_switch';
    renderSwitchMenu(false);
}
// æ¸²æŸ“åˆ‡æ¢åˆ—è¡¨
function renderSwitchMenu(allowCancel = true) {
    if (battle.locked && battle.phase !== 'force_switch' && battle.phase !== 'pivot_switch') return;
    const layer = document.getElementById('switch-menu-layer');
    layer.className = 'overlay-modal modern-layer';
    layer.classList.remove('hidden');
    layer.style.display = 'flex';
    layer.innerHTML = '';
    const container = document.createElement('div');
    container.className = 'switch-container-modern';
    const header = document.createElement('div');
    header.className = 'switch-header-modern';
    const actionColor = !allowCancel ? 'var(--primary-pink)' : 'var(--accent-blue)';
    header.innerHTML = `
        <div style="width:6px; height:40px; background:${actionColor}; border-radius:10px;"></div>
        <div>
            <h2>pokÃ©mon</h2>
            <div class="switch-header-subtitle">
                ${!allowCancel ? 'Choose a replacement (Must Switch)' : 'Select a partner to switch in'}
            </div>
        </div>
    `;
    const grid = document.createElement('div');
    grid.className = 'party-grid-modern';
    battle.playerParty.forEach((pm, idx) => {
        const card = document.createElement('div');
        const isCurrent = (idx === battle.playerActive);
        const isDead = (pm.currHp <= 0);
        const hpRatio = pm.maxHp ? (pm.currHp / pm.maxHp) : 0;
        card.className = 'party-card-modern';
        card.style.animationDelay = `${idx * 0.05}s`;
        if (isCurrent) card.classList.add('current');
        if (isDead) card.classList.add('dead');
        if (!allowCancel && isDead) card.classList.add('disabled');
        let hpColor = '#4fd1c5';
        if (hpRatio < 0.5) hpColor = '#fbc63e';
        if (hpRatio <= 0.2) hpColor = '#ff6b6b';
        // =========================================================
        // æ•°æ®é©±åŠ¨çš„ Sprite URL ç”Ÿæˆ
        // ä½¿ç”¨ pokedex-data.js ä¸­çš„ forme å­—æ®µåˆ¤æ–­å½¢æ€ç±»å‹
        // =========================================================
        const seedIdWithHyphen = pm.name.toLowerCase().replace(/[^a-z0-9-]/g, '');
        const seedIdCompact = pm.name.toLowerCase().replace(/[^a-z0-9]/g, '');
        // ä» pokedex-data.js è·å–å®å¯æ¢¦æ•°æ®
        const pokeData = (typeof POKEDEX !== 'undefined' && POKEDEX[seedIdCompact]) 
            ? POKEDEX[seedIdCompact] : null;
        const forme = pokeData?.forme || '';
        const baseSpecies = pokeData?.baseSpecies || '';
        // åŸºç¡€å½¢æ€ IDï¼ˆç”¨äº fallbackï¼‰
        const baseId = baseSpecies ? baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '') : seedIdCompact;
        const fallbackId = typeof getFallbackSpriteId === 'function' 
            ? getFallbackSpriteId(pm.name) 
            : baseId;
        // =========================================================
        // å½¢æ€ç±»å‹æ£€æµ‹ï¼ˆæ•°æ®é©±åŠ¨ + åç§°æ£€æµ‹åŒä¿é™©ï¼‰
        // =========================================================
        const formeLower = forme.toLowerCase();
        // åœ°åŒºå½¢æ€ï¼šAlola, Galar, Hisui, Paldea
        const regionalForms = ['alola', 'galar', 'hisui', 'paldea'];
        const isRegionalForm = regionalForms.some(r => formeLower.includes(r)) ||
            regionalForms.some(r => seedIdWithHyphen.includes(`-${r}`));
        // Mega å½¢æ€
        const isMegaForm = formeLower.includes('mega') || seedIdWithHyphen.includes('-mega');
        // åŸå§‹å›å½’å½¢æ€
        const isPrimalForm = formeLower === 'primal' || seedIdWithHyphen.includes('-primal');
        // ç‹å† å½¢æ€ï¼ˆZacian/Zamazentaï¼‰
        const isCrownedForm = formeLower === 'crowned' || seedIdWithHyphen.includes('-crowned');
        // ç©¶æå½¢æ€ï¼ˆNecrozmaï¼‰
        const isUltraForm = formeLower === 'ultra' || seedIdWithHyphen.includes('-ultra');
        // ç‰¹æ®Šå½¢æ€ï¼šRotom, Necrozma åˆä½“, Calyrex éª‘ä¹˜, Darmanitan Zen ç­‰
        const specialForms = ['wash', 'heat', 'mow', 'frost', 'fan', // Rotom
            'dusk-mane', 'dawn-wings', // Necrozma
            'ice', 'shadow', // Calyrex
            'zen', 'therian', 'origin', 'sky', 'attack', 'defense', 'speed', // å„ç§å½¢æ€
            'combat', 'blaze', 'aqua']; // Tauros-Paldea
        const isOtherSpecialForm = specialForms.some(f => formeLower.includes(f)) ||
            specialForms.some(f => seedIdWithHyphen.includes(`-${f}`));
        // å¸½å­çš®å¡ä¸˜ç‰¹æ®Šå¤„ç†ï¼ˆpokesprite icons ç›®å½•ï¼‰
        const pikachuCapForms = ['original', 'hoenn', 'sinnoh', 'unova', 'kalos', 'alola', 'partner', 'world'];
        const isPikachuCap = baseSpecies === 'Pikachu' && pikachuCapForms.includes(formeLower);
        // Cosplay çš®å¡ä¸˜
        const pikachuCosplayForms = ['cosplay', 'rock-star', 'belle', 'pop-star', 'phd', 'libre'];
        const isPikachuCosplay = baseSpecies === 'Pikachu' && pikachuCosplayForms.some(f => formeLower.includes(f));
        // æ˜¯å¦éœ€è¦ä½¿ç”¨ pokesprite å›¾åº“
        const needsPokesprite = isRegionalForm || isMegaForm || isPrimalForm || isUltraForm || isOtherSpecialForm;
        // =========================================================
        // ç”Ÿæˆ Sprite URL
        // =========================================================
        let imgSrc;
        if (isPikachuCap) {
            // å¸½å­çš®å¡ä¸˜ä½¿ç”¨ pokesprite icons ç›®å½•
            const capName = `pikachu-${formeLower}-cap`;
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/icons/pokemon/regular/${capName}.png`;
        } else if (isPikachuCosplay) {
            // Cosplay çš®å¡ä¸˜
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/icons/pokemon/regular/${seedIdWithHyphen}.png`;
        } else if (isCrownedForm) {
            // Crowned å½¢æ€ä½¿ç”¨ pokespriteï¼ˆzacian-crowned, zamazenta-crownedï¼‰
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${seedIdWithHyphen}.png`;
        } else if (needsPokesprite) {
            // å…¶ä»–ç‰¹æ®Šå½¢æ€ä½¿ç”¨ pokesprite
            let pokespriteId = seedIdWithHyphen;
            // Mega X/Y æ ¼å¼ä¿®æ­£
            if (isMegaForm && !pokespriteId.includes('-mega')) {
                pokespriteId = pokespriteId.replace(/mega([xy])$/i, '-mega-$1');
                if (!pokespriteId.includes('-mega')) {
                    pokespriteId = pokespriteId.replace(/mega$/i, '-mega');
                }
            }
            // Primal æ ¼å¼ä¿®æ­£
            if (isPrimalForm && !pokespriteId.includes('-primal')) {
                pokespriteId = pokespriteId.replace(/primal$/i, '-primal');
            }
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${pokespriteId}.png`;
        } else {
            // æ™®é€šå½¢æ€ä½¿ç”¨ Showdown spritesï¼ˆä¸å¸¦æ¨ªæ ï¼‰
            imgSrc = `https://play.pokemonshowdown.com/sprites/gen5/${seedIdCompact}.png`;
        }
        const fallbackSrc = `https://play.pokemonshowdown.com/sprites/gen5/${fallbackId}.png`;
        card.innerHTML = `
            ${isCurrent ? '<div class="current-tag">ACTIVE</div>' : ''}
            <div class="card-icon-modern">
                <img class="${isMegaForm ? 'mega-icon' : ''}" src="${imgSrc}" onerror="if(this.src!=='${fallbackSrc}'){this.src='${fallbackSrc}'}else{this.style.display='none'}">
            </div>
            <div class="card-info-modern">
                <div class="card-top-row">
                    <span class="card-name">${pm.cnName}</span>
                    <span class="card-lv">Lv.<span style="color:#2d3436;margin-left:2px">${pm.level}</span></span>
                </div>
                <div class="card-hp-nums">
                    ${pm.currHp} <span style="color:#b2bec3;font-weight:400">/ ${pm.maxHp}</span>
                </div>
                <div class="modern-hp-track">
                    <div class="modern-hp-fill" style="width:${hpRatio * 100}%; background:${hpColor}"></div>
                </div>
            </div>
            ${isDead ? '<div class="status-tag">FANT</div>' : ''}
        `;
        if (!isDead && !isCurrent) {
            card.onclick = () => {
                console.log('[renderSwitchMenu] Card clicked, calling performSwitch with index:', idx);
                layer.classList.add('hidden');
                layer.style.display = '';
                layer.className = 'overlay-modal hidden';
                performSwitch(idx);
            };
        }
        grid.appendChild(card);
    });
    container.appendChild(header);
    container.appendChild(grid);
    if (allowCancel) {
        const footer = document.createElement('div');
        footer.className = 'switch-footer';
        footer.innerHTML = `
            <button class="btn-close-modern">
                <span class="key-hint">Ã—</span> CANCEL
            </button>
        `;
        footer.querySelector('button').onclick = () => {
            layer.classList.add('hidden');
            layer.style.display = '';
            layer.className = 'overlay-modal hidden';
        };
        container.appendChild(footer);
    }
    layer.appendChild(container);
    if (allowCancel) {
        layer.onclick = (e) => {
            if (e.target === layer) {
                layer.classList.add('hidden');
                layer.style.display = '';
                layer.className = 'overlay-modal hidden';
            }
        };
    } else {
        layer.onclick = null;
    }
}
async function performSwitch(newIndex) {
    console.log('[performSwitch] Called with index:', newIndex);
    console.log('[performSwitch] battle.phase:', battle.phase);
    console.log('[performSwitch] battle.pivotResolve:', !!battle.pivotResolve);
    console.log('[performSwitch] battle.locked:', battle.locked);
    document.getElementById('switch-menu-layer').classList.add('hidden');
    const oldP = battle.getPlayer();
    const isForced = !oldP.isAlive();
    const isPivot = battle.phase === 'pivot_switch';
    const newPoke = battle.playerParty[newIndex];
    console.log('[performSwitch] isPivot:', isPivot, 'isForced:', isForced, 'hasPivotResolve:', !!battle.pivotResolve);
    // æ¢ä¸‹åœºçš„å®å¯æ¢¦é‡ç½®èƒ½åŠ›ç­‰çº§
    if (oldP.isAlive()) {
        // ã€ä¿®å¤ã€‘å¦‚æœæ¢ä¸‹çš„å®å¯æ¢¦å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œæ¢å¤æ‹›å¼
        if (oldP.isDynamaxed) {
            console.log(`[SWITCH] Player ${oldP.name} was Dynamaxed, restoring moves`);
            applyDynamaxState(oldP, false);
        }
        oldP.resetBoosts();
    }
    // Pivot æ¢äººä½¿ç”¨ä¸åŒçš„æ—¥å¿—
    if (isPivot) {
        log(`${oldP.cnName} æ’¤å›ï¼${newPoke.cnName} ç™»åœºï¼`);
    } else {
        log(isForced 
            ? `å»å§! ${newPoke.cnName}!` 
            : `å›æ¥å§ ${oldP.cnName}! ${newPoke.cnName}, ä¸Š!`);
    }
    // === æ’­æ”¾æ–°ä¸Šåœºå®å¯æ¢¦å«å£° ===
    if (typeof window.playPokemonCry === 'function') {
        window.playPokemonCry(newPoke.name);
    }
    // === è§¦å‘å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰) ===
    // æ³¨æ„ï¼šåœ¨è®¾ç½® playerActive ä¹‹å‰å…ˆè§¦å‘ç‰¹æ€§ï¼Œé¿å…æ’’è±å‡»å€’æ—¶ç´¢å¼•é”™è¯¯
    triggerEntryAbilities(newPoke, battle.getEnemy());
    // === ç»“ç®—åœºåœ°é’‰å­ä¼¤å®³ ===
    if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
        const hazardLogs = MoveEffects.applyEntryHazards(newPoke, true, battle);
        hazardLogs.forEach(msg => log(msg));
        // å¦‚æœé’‰å­ä¼¤å®³å¯¼è‡´å®å¯æ¢¦å€’ä¸‹ï¼Œéœ€è¦å¼ºåˆ¶æ¢äºº
        if (newPoke.currHp <= 0) {
            log(`ç³Ÿç³•! ${newPoke.cnName} è¢«åœºåœ°ä¼¤å®³å‡»å€’äº†!`);
            updateAllVisuals();
            // ä¸è®¾ç½® playerActiveï¼Œä¿æŒåŸæ¥çš„ç´¢å¼•ï¼Œè®© checkPlayerDefeatOrForceSwitch æ­£ç¡®åˆ¤æ–­
            checkPlayerDefeatOrForceSwitch();
            return;
        }
    }
    // åªæœ‰åœ¨å®å¯æ¢¦å­˜æ´»çš„æƒ…å†µä¸‹æ‰è®¾ç½®ä¸ºå½“å‰æ´»è·ƒå®å¯æ¢¦
    battle.playerActive = newIndex;
    // === ç¾ç»Šå…±é¸£çŠ¶æ€æ¢å¤ ===
    // å¦‚æœæ¢ä¸Šåœºçš„å®å¯æ¢¦æœ‰ç¾ç»Šå…±é¸£æ ‡è®°ï¼Œé‡æ–°åº”ç”¨èƒ½åŠ›æå‡
    if (newPoke.hasBondResonance && typeof newPoke.applyBoost === 'function') {
        // ã€å¹³è¡¡è°ƒæ•´ã€‘å…±é¸£æ€å…¨èƒ½åŠ› +1ï¼ˆåŸ +2ï¼‰
        newPoke.applyBoost('atk', 1);
        newPoke.applyBoost('def', 1);
        newPoke.applyBoost('spa', 1);
        newPoke.applyBoost('spd', 1);
        newPoke.applyBoost('spe', 1);
        log(`<span style="color:#4ade80"><b>${newPoke.cnName} çš„ç¾ç»Šå…±é¸£ä»åœ¨å»¶ç»­ï¼Œå…¨å±æ€§ç»´æŒæå‡!</b></span>`);
    }
    // Pivot æ¢äººï¼šresolve Promise å¹¶è¿”å›ï¼Œä¸è§¦å‘æ•Œæ–¹æ”»å‡»
    if (isPivot) {
        console.log('[performSwitch] Pivot switch detected');
        battle.phase = 'battle';
        updateAllVisuals();
        battle.locked = false;
        if (battle.pivotResolve) {
            console.log('[performSwitch] Resolving pivot Promise');
            const resolve = battle.pivotResolve;
            battle.pivotResolve = null;
            battle.pivotSide = null;
            console.log('[performSwitch] Calling resolve()');
            resolve();
            console.log('[performSwitch] resolve() called');
        }
        console.log('[performSwitch] Pivot handling complete, returning');
        return;
    }
    battle.phase = 'battle';
    if (!isForced) {
        // ä¸»åŠ¨æ¢äººè¦æŒ¨æ‰“
        log("ç”±äºäº¤æ¢å®å¯æ¢¦ï¼Œæ•Œæ–¹å‘èµ·äº†æ”»å‡»ï¼");
        battle.locked = true;
        await enemyTurn();
    } else {
        // å¼ºåˆ¶æ¢äººå®Œæˆåï¼Œåˆ·æ–°ç•Œé¢å¹¶è§£é”
        updateAllVisuals();
        battle.locked = false;
    }
}
// è¾…åŠ© LOG
function log(msg) {
    const box = document.getElementById('log-box');
    let formatMsg = msg;
    formatMsg = formatMsg.replace(/(\d+)\s*(ä¼¤å®³)/g, '<span class="hl-dmg">$1</span> <span style="font-size:0.9em;color:#888">$2</span>');
    formatMsg = formatMsg.replace(/(æ•ˆæœæ‹”ç¾¤|æ•ˆæœç»ä½³!|Super Effective!)/gi, '<span class="hl-sup">æ•ˆæœç»ä½³</span>');
    formatMsg = formatMsg.replace(/(æ•ˆæœä¸å¥½|æ”¶æ•ˆç”šå¾®|Not Very Effective\.\.\.)/gi, '<span class="hl-res">æ•ˆæœä¸å¥½</span>');
    formatMsg = formatMsg.replace(/(ä¼šå¿ƒä¸€å‡»!|Critical Hit!)/gi, '<span class="hl-crit">CRITICAL HIT!!</span>');
    formatMsg = formatMsg.replace(/(å€’ä¸‹äº†|å¤±å»æˆ˜æ–—èƒ½åŠ›)/gi, '<b style="color:#e11d48; text-decoration:underline; text-decoration-color:rgba(225,29,72,0.4)">$1</b>');
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.innerHTML = formatMsg;
    box.appendChild(div);
    requestAnimationFrame(() => {
        box.scrollTop = box.scrollHeight;
    });
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
// =========================================
// ã€å·²è¿ç§»ã€‘èœå•åˆ‡æ¢ -> ui/ui-menus.js
// ã€å·²è¿ç§»ã€‘Mega/Dynamax æŒ‰é’®æ§åˆ¶ -> ui/ui-menus.js
// ã€å·²è¿ç§»ã€‘è¿›åŒ–åŠ¨ç”» -> ui/ui-menus.js
// =========================================
// é€ƒè·‘åŠŸèƒ½
function tryRun() {
    if (battle.locked && battle.phase !== 'battle') return;
    const playerLabel = battle.playerName || 'ç©å®¶';
    if (battle.trainer && battle.trainer.id !== 'wild') {
        log(`é¢å¯¹å¼ºæ•Œï¼Œ${playerLabel} é€‰æ‹©äº†æˆ˜ç•¥æ€§æ’¤é€€ï¼ (æŠ•é™)`);
        const escapeLine = battle.trainer.lines?.escape || battle.trainer.lines?.win;
        if (escapeLine) {
            log(`<i>${battle.trainer.name}: "${escapeLine}"</i>`);
        }
    } else {
        log(`${playerLabel} å¸¦ç€åŒä¼´æˆåŠŸé€ƒç¦»äº†æˆ˜åœºï¼`);
    }
    battle.phase = 'ended';
    battle.locked = true;
    setTimeout(() => battleEndSequence('escape'), 600);
}
// =========================================================
// ã€å·²è¿ç§»ã€‘æ•è·ç³»ç»Ÿ -> systems/catch-system.js
// =========================================================
// ä¾› HTML inline handler è°ƒç”¨
// æ³¨ï¼šéƒ¨åˆ†å‡½æ•°å·²è¿ç§»åˆ°ç‹¬ç«‹æ¨¡å—ï¼Œé€šè¿‡æ¨¡å—è‡ªèº«å¯¼å‡ºåˆ° window
window.initGame = initGame;
window.handleAttack = handleAttack;
window.renderSwitchMenu = renderSwitchMenu;
window.tryRun = tryRun;
/* ===========================================
   æ–°å¢åŠŸèƒ½ï¼šæˆ˜æ–—ç»“ç®—ä¸æ€»ç»“ç”Ÿæˆ
=========================================== */
function battleEndSequence(result) {
    battle.phase = 'ended';
    battle.locked = true;
    // === BGM å¤„ç† ===
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    // èƒœåˆ©æ—¶æ’­æ”¾èƒœåˆ©éŸ³ä¹ (win/caught)
    if (result === 'win' || result === 'caught') {
        if (typeof playVictoryBgm === 'function') {
            playVictoryBgm(isTrainer);
        }
    } else {
        // å¤±è´¥/é€ƒè·‘æ—¶åœæ­¢BGM
        if (typeof stopBgm === 'function') {
            stopBgm(500);
        }
    }
    const analysis = generateBattleReport(result);
    const overlay = document.getElementById('result-overlay');
    const card = document.getElementById('res-card-bg');
    const titleEl = document.getElementById('res-title');
    const rankLetterEl = document.getElementById('res-grade-letter');
    const rankSubEl = document.getElementById('res-grade-sub');
    const statusEl = document.getElementById('col-status');
    const descEl = document.getElementById('col-desc');
    const reasonEl = document.getElementById('col-reason');
    const dotsEl = document.getElementById('res-party-viz');
    const clipEl = document.getElementById('res-clipboard-text');
    if (!overlay || !card) return;
    overlay.classList.remove('active');
    card.classList.remove('theme-win', 'theme-loss', 'theme-escape');
    const enemyName = analysis.enemyName || 'Opponent';
    let titleCopy = 'VICTORY';
    let statusCopy = `Victory vs. ${enemyName}`;
    let themeClass = 'theme-win';
    if (result === 'loss') {
        titleCopy = 'DEFEATED';
        statusCopy = `Overwhelmed by ${enemyName}`;
        themeClass = 'theme-loss';
    } else if (result === 'escape') {
        titleCopy = 'ESCAPED';
        statusCopy = `Retreated from ${enemyName}`;
        themeClass = 'theme-escape';
    } else if (result === 'caught') {
        titleCopy = 'CAPTURED';
        statusCopy = `Captured ${enemyName}`;
        themeClass = 'theme-win';
    }
    card.classList.add(themeClass);
    if (titleEl) titleEl.textContent = titleCopy;
    if (statusEl) statusEl.textContent = statusCopy;
    const rankMatch = typeof analysis.rank === 'string'
        ? analysis.rank.match(/^([A-Z][A-Z\+\-]*)\s*(?:\((.+)\))?/i)
        : null;
    const rankLetter = rankMatch ? rankMatch[1] : analysis.rank || '?';
    const rankDescriptor = rankMatch && rankMatch[2] ? rankMatch[2] : 'RANK';
    if (rankLetterEl) rankLetterEl.textContent = rankLetter.toUpperCase();
    if (rankSubEl) rankSubEl.textContent = rankDescriptor;
    if (reasonEl) reasonEl.textContent = rankDescriptor;
    if (descEl) descEl.textContent = analysis.description || 'æš‚æ— æˆ˜å†µæè¿°ã€‚';
    if (dotsEl) {
        dotsEl.innerHTML = '';
        battle.playerParty.forEach(p => {
            const dot = document.createElement('div');
            const ratio = p.maxHp > 0 ? p.currHp / p.maxHp : 0;
            let state = 'hp-low';
            if (p.currHp <= 0) state = 'hp-dead';
            else if (ratio > 0.6) state = 'hp-100';
            else if (ratio > 0.25) state = 'hp-mid';
            dot.className = `mini-dot ${state}`;
            dotsEl.appendChild(dot);
        });
    }
    if (clipEl) {
        clipEl.value = analysis.fullReport;
    }
    let endLine = '';
    const lines = battle.trainer?.lines || {};
    if (result === 'win') {
        endLine = lines.lose;
    } else if (result === 'escape') {
        endLine = lines.escape || lines.win || lines.lose || '';
    } else {
        // result === 'loss'
        endLine = lines.win;
    }
    if (battle.trainer && battle.trainer.id !== 'wild' && endLine) {
        setTimeout(() => playCutIn(endLine, 4500), 100);
    }
    overlay.classList.remove('hidden');
    void overlay.offsetWidth;
    overlay.classList.add('active');
}
function generateBattleReport(result) {
    const pParty = battle.playerParty;
    const eParty = battle.enemyParty;
    const pName = battle.playerName || "Player";
    const activeEnemy = typeof battle.getEnemy === 'function'
        ? battle.getEnemy()
        : (eParty[battle.enemyActive ?? 0] || eParty[0] || null);
    const fallbackEnemyName = activeEnemy?.cnName || activeEnemy?.name || "Wild Pokemon";
    let eName = fallbackEnemyName || "Enemy";
    if (battle.trainer) {
        if (battle.trainer.id !== 'wild') {
            eName = battle.trainer.name || battle.trainer.title || battle.trainer.id || fallbackEnemyName || "Enemy";
        } else {
            eName = battle.trainer.name?.trim()
                || fallbackEnemyName
                || (battle.trainer.title && battle.trainer.title.toLowerCase() !== 'wild' ? battle.trainer.title : '')
                || "Wild Pokemon";
        }
    }
    const survivors = pParty.filter(p => p.currHp > 0);
    const fallen = pParty.filter(p => p.currHp <= 0);
    const survivorTxt = survivors.length > 0
        ? survivors.map(p => `${p.cnName}(${Math.round((p.currHp / Math.max(1, p.maxHp)) * 100)}%)`).join(', ')
        : "æ¿’æ­»ä¸­æ’¤èµ°";
    const avgLevel = party => party.length
        ? party.reduce((sum, poke) => sum + (poke.level || poke.lv || 1), 0) / party.length
        : 0;
    let pTotalHpPct = 0;
    pParty.forEach(p => pTotalHpPct += (p.maxHp > 0 ? p.currHp / p.maxHp : 0));
    const pHpHealth = pParty.length > 0 ? Math.floor((pTotalHpPct / pParty.length) * 100) : 0;
    const eFallen = eParty.filter(p => p.currHp <= 0);
    let eTotalHpPct = 0;
    eParty.forEach(p => eTotalHpPct += (p.maxHp > 0 ? p.currHp / p.maxHp : 0));
    const eHpHealth = eParty.length > 0 ? Math.floor((eTotalHpPct / eParty.length) * 100) : 0;
    const avgPLv = avgLevel(pParty);
    const avgELv = avgLevel(eParty);
    const levelDiff = avgELv - avgPLv;
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    let rank = 'C';
    let desc = '';
    let resultTextDisplay = result === 'win' ? 'ã€ç©å®¶èƒœåˆ©ã€‘' : 'ã€ç©å®¶å¤±è´¥ã€‘';
    if (result === 'escape') {
        if (levelDiff > 30) {
            rank = 'B (æˆ˜æœ¯æ’¤é€€)';
            desc = 'é¢å¯¹ä¸å¯èƒ½æˆ˜èƒœçš„é‡çº§å·®è·ï¼Œç†æ™ºåœ°é€‰æ‹©ä¿å…¨é˜Ÿä¼ã€‚æ´»ä¸‹å»æ¯”ä»€ä¹ˆéƒ½é‡è¦ã€‚';
        } else if (levelDiff > 10) {
            rank = 'C (è°¨æ…å›é¿)';
            desc = 'æ„è¯†åˆ°å¯¹æ‰‹çš„éš¾ç¼ ï¼Œåœ¨æ²¡æœ‰æŠŠæ¡çš„æƒ…å†µä¸‹é€‰æ‹©ä¸ç¡¬ç¢°ç¡¬ã€‚';
        } else if (survivors.length === 0) {
            rank = 'D (æºƒé€ƒ)';
            desc = 'å…¨çº¿å´©æºƒçš„è¾¹ç¼˜å¼ºè¡Œè„±ç¦»æˆ˜åœºã€‚';
        } else {
            rank = 'D (è„±ç¦»æˆ˜åœº)';
            desc = isTrainer
                ? 'é¢å¯¹è®­ç»ƒå®¶çš„æŒ‘æˆ˜é€‰æ‹©äº†å›é¿ï¼ˆæŠ•é™ï¼‰ã€‚'
                : 'æˆåŠŸä»é‡ç”Ÿå®å¯æ¢¦é¢å‰è„±èº«ã€‚';
        }
        resultTextDisplay = 'ã€æ’¤é€€ / ä¸­æ–­ã€‘';
} else if (result === 'caught') {
    rank = 'CAPTURE (æ•è·æˆåŠŸ)';  // æŠŠ GET æ”¹ä¸º CAPTURE æ›´å…·ç³»ç»Ÿæ„Ÿï¼Œæˆ–è€…ä¿ç•™ GET ä¹Ÿè¡Œ
    desc = 'ä¼´éšç€çƒä½“æŒ‡ç¤ºç¯åœæ­¢æ‘‡æ™ƒï¼Œä¸­å¤®å‘å‡ºäº†æ¸…è„†çš„é”å®šéŸ³ã€‚ç›®æ ‡æ•æ‰å®Œæ¯•ã€‚'; 
    resultTextDisplay = 'ã€æ”¶æœç¡®è®¤ã€‘';
    if (eHpHealth > 70) {
        // æ»¡è¡€æ•è·ï¼šä¸å†è¯´æ˜¯â€œå¥‡è¿¹â€ï¼Œå¼ºè°ƒâ€œå¼ºè¿â€æˆ–â€œä¸€å‘å…¥é­‚â€
        desc += ' ç«Ÿç„¶åœ¨æœªå‰Šå‡ä½“åŠ›çš„çŠ¶æ€ä¸‹åªæœ‰ä¸€çƒï¼Ÿç»ä½³çš„ã€Critical Captureã€‘ã€‚';
    } else if (eHpHealth < 10) {
        // çº¢è¡€æ•è·ï¼šä¸å†è¯´æ˜¯â€œæŒæ§â€ï¼Œå¼ºè°ƒâ€œå‹åˆ¶â€å’Œâ€œç²¾å‡†â€
        desc += ' å°†ä½“åŠ›å‹åˆ¶åˆ°äº†æé™çš„çº¢è‰²åŒºåŸŸï¼Œæ•™ç§‘ä¹¦èˆ¬ç²¾å‡†çš„æ”¶æœä½œä¸š!';
    }
    } else if (result === 'win') {
        const deadCount = fallen.length;
        if (deadCount === 0) {
            if (pHpHealth >= 95) { rank = 'S+ (æ— ä¼¤)'; desc = 'æœªå—åˆ°å®è´¨æ€§ä¼¤å®³çš„å®Œç¾èƒœåˆ©ã€‚'; }
            else if (pHpHealth >= 80) { rank = 'S (å®Œèƒœ)'; desc = 'æŒæ§äº†èŠ‚å¥ï¼Œæ¯«æ— æ‚¬å¿µçš„å‹å€’æ€§èƒœåˆ©ã€‚'; }
            else if (pHpHealth >= 60) { rank = 'A+ (è½»å–)'; desc = 'è™½æœ‰äº¤é”‹ï¼Œä½†å§‹ç»ˆå æ®ç€ä¸»å¯¼æƒã€‚'; }
            else { rank = 'A (ä¼˜èƒœ)'; desc = 'å¯¹æ‰‹ä¹Ÿæœ‰å¤‡è€Œæ¥ï¼Œä½†è¿˜æ˜¯æŠ€é«˜ä¸€ç­¹ã€‚'; }
        } else {
            const deadRatio = pParty.length > 0 ? deadCount / pParty.length : 1;
            if (deadRatio < 0.5) { rank = 'B (è‹¦æˆ˜)'; desc = 'ä»˜å‡ºäº†åŒä¼´å€’ä¸‹çš„ä»£ä»·ï¼Œæ‰æ‹¿ä¸‹çš„è‰°éš¾èƒœåˆ©ã€‚'; }
            else if (deadRatio < 0.9) { rank = 'C (æ­»æ–—)'; desc = 'é™¤äº†ç«™åˆ°æœ€åçš„è‹±é›„ï¼Œå…¶ä»–åŒä¼´éƒ½å·²å€’ä¸‹â€¦â€¦'; }
            else { rank = 'C- (ç»å¢ƒåæ€)'; desc = 'ä»…å‰©æœ€åçš„ä¸€ä¸çº¢è¡€â€¦â€¦å¥‡è¿¹èˆ¬çš„æé™ç¿»ç›˜ã€‚'; }
        }
    } else {
        if (eFallen.length === 0) {
            if (eHpHealth >= 90) { rank = 'F (ç¢¾å‹)'; desc = 'æ¯«æ— è¿˜æ‰‹ä¹‹åŠ›â€¦â€¦é‚£æ˜¯æ¬¡å…ƒçº§çš„æˆ˜åŠ›å·®è·ã€‚'; }
            else if (eHpHealth >= 70) { rank = 'E (å®Œè´¥)'; desc = 'æ²¡èƒ½å¯¹æ•Œäººé€ æˆæœ‰æ•ˆå¨èƒï¼Œé—æ†¾è½è´¥ã€‚'; }
            else if (eHpHealth >= 40) { rank = 'D (ä¸‹é£)'; desc = 'è™½ç„¶å°½åŠ›åå‡»ï¼Œä½†ä»è¢«å¯¹æ–¹å‹åˆ¶ã€‚'; }
            else if (eHpHealth >= 15) { rank = 'C (æŠ—è¡¡)'; desc = 'æœ‰æ¥æœ‰å›çš„æ¿€æˆ˜ï¼Œåªå·®ä¸€å£æ°”å°±èƒ½æ‰­è½¬å±€åŠ¿ã€‚'; }
            else { rank = 'C+ (æƒœè´¥)'; desc = 'æŠŠå¯¹æ‰‹é€¼å…¥ç»å¢ƒï¼æ˜æ˜åªå·®æœ€åä¸€ä¸‹â€¦â€¦'; }
        } else {
            const killRatio = eParty.length > 0 ? (eFallen.length / eParty.length) : 0;
            if (killRatio > 0.6) {
                rank = 'B- (æ¯å¤©ç­åœ°)';
                desc = 'åŒæ–¹éƒ½å·²æ‹¼å°½å…¨åŠ›ï¼Œè™½ç„¶è¾“äº†ï¼Œä½†è¿™ç»å¯¹æ˜¯ä¸€åœºå€¼å¾—èµ¢å¾—å°Šé‡çš„æˆ˜æ–—ã€‚';
            } else {
                rank = 'D+ (æ··æˆ˜)';
                desc = 'è™½ç„¶é‡åˆ›äº†å¯¹æ‰‹ï¼Œä½†æœ€ç»ˆè¿˜æ˜¯æ²¡èƒ½åšæŒåˆ°æœ€åã€‚';
            }
        }
    }
    const rows = [];
    let summaryLine;
    if (result === 'escape') {
        summaryLine = `- ç»¼è¿°ï¼š${pName} åœ¨é¢å¯¹ ${eName} æ—¶é€‰æ‹©äº†ã€é€ƒè·‘/æŠ•é™ã€‘ã€‚`;
    } else if (result === 'caught') {
        summaryLine = `- ç»¼è¿°ï¼š${pName} æˆåŠŸåœ¨é‡å¤–æ”¶æœäº† ${eName}ã€‚`;
    } else {
        summaryLine = `- ç»¼è¿°ï¼š${pName} å¯¹é˜µ ${eName}ï¼Œ${result === 'win' ? 'è·å¾—èƒœåˆ©' : 'é—æ†¾è½è´¥'}ã€‚`;
    }
    rows.push(`- äº¤äº’ç»“æœï¼š${resultTextDisplay}`);
    rows.push(`- è¯„çº§ï¼š${rank}`);
    rows.push(summaryLine);
    rows.push(`- å±€åŠ¿è¯´æ˜ï¼š${desc}`);
    if (result === 'win' && battle.trainer?.lines?.lose) {
        rows.push(`- æ•Œæ–¹è´¥é€€å°è¯ï¼š"${battle.trainer.lines.lose}"`);
    } else if (result === 'escape' && battle.trainer?.lines?.escape) {
        rows.push(`- æ•Œæ–¹ç¦»åœºèµ è¨€ï¼š"${battle.trainer.lines.escape}"`);
    } else if (result === 'loss' && battle.trainer?.lines?.win) {
        rows.push(`- æ•Œæ–¹èƒœåˆ©/å˜²è®½å°è¯ï¼š"${battle.trainer.lines.win}"`);
    }
    const formatEnemyName = poke => (poke?.cnName || poke?.name || '???');
    const enemyStatusLine = eParty.length > 0
        ? eParty.map((poke, idx) => {
            const pct = poke.maxHp > 0 ? Math.round((Math.max(0, poke.currHp) / poke.maxHp) * 100) : 0;
            const state = poke.currHp <= 0 ? 'å€’ä¸‹' : `${pct}%`;
            const marker = idx === (battle.enemyActive ?? 0) ? '*' : '';
            return `${marker}${formatEnemyName(poke)}(${state})`;
        }).join(' / ')
        : 'æœªçŸ¥';
    rows.push(`- æˆ‘æ–¹å¸¦å‡ºæˆ˜åœºï¼š${survivorTxt}`);
    rows.push(`- æ•Œæ–¹çŠ¶æ€ï¼š${enemyStatusLine}`);
    if (result !== 'escape' && fallen.length > 0) {
        rows.push(`- æ¿’æ­»åå•ï¼š${fallen.map(p => p.cnName).join(', ')}`);
    } else if (result === 'escape' && fallen.length > 0) {
        rows.push(`- å€’ä¸‹éœ€æ²»ç–—ï¼š${fallen.map(p => p.cnName).join(', ')}`);
    }
    return {
        rank,
        description: desc,
        playerName: pName,
        enemyName: eName,
        resultLabel: resultTextDisplay,
        summaryLine,
        fullReport: rows.join('\n'),
        fallenCount: fallen.length,
        survivorCount: survivors.length,
        hpHealth: pHpHealth
    };
}
window.restartBattle = function() {
    document.getElementById('result-overlay').classList.add('hidden');
    const logBox = document.getElementById('log-box');
    if (logBox) {
        logBox.innerHTML = '';
    }
    battle = new BattleState();
    window.battle = battle;  // ã€ä¿®å¤ã€‘åŒæ­¥æ›´æ–°å…¨å±€å¼•ç”¨
    // åœæ­¢å½“å‰ BGM (ç«‹å³åœæ­¢ï¼Œä¸æ·¡å‡º)
    if (typeof stopBgm === 'function') {
        stopBgm(0);
    }
    log("=== é‡ç½®æˆ˜æ–— ===");
    initGame();
};
window.copyResultOnly = function() {
    const summary = document.getElementById('res-clipboard-text').value;
    copyToAndClose(summary);
};
window.copyFullProcess = function() {
    const summary = document.getElementById('res-clipboard-text').value;
    const processLog = extractBattleLog();
    const finalContent = [
        "<CORE TASK>",
        "ğŸ›‘ [SYSTEM COMMAND // å¼ºåˆ¶æ‰§è¡Œ] ğŸ›‘",
        "ğŸš« DO NOT ADVANCE THE PLOT! (ç¦æ­¢æ¨è¿›åç»­å‰§æƒ…)",
        "ğŸš« DO NOT SKIP BATTLE DETAILS! (ç¦æ­¢è·³è¿‡æˆ˜æ–—ç»†èŠ‚)",
        "âš ï¸ æ ¸å¿ƒä»»åŠ¡ (CORE TASK):",
        "ä½ ç°åœ¨çš„ä»»åŠ¡æ˜¯ã€æˆ˜æ–—å›æ”¾å‘˜ (Battle Replayer)ã€‘ã€‚",
        "ä¸ä»…è¦åŸºäºä¸‹æ–¹çš„ã€Œå›åˆåˆ¶æ—¥å¿— (Log)ã€ä¸ã€Œæœ€ç»ˆç»“ç®— (Result)ã€ï¼Œæ’°å†™ä¸€åœº**å­—æ•°å……è¶³**çš„å®Œæ•´æˆ˜æ–—è¿‡ç¨‹ã€‚",
        "ğŸ“œ REQUIREMENTS:é€å›åˆæ¼”ç»ã€æˆ˜æœ¯ç‰¹å†™ã€é«˜å…‰æ—¶åˆ»:",
        "ğŸ“ INPUT LOGS START BELOW...",
        "(ä»¥ä¸‹æ˜¯ç³»ç»Ÿç”Ÿæˆçš„æˆ˜æ–—æ•°æ®ï¼Œè¯·å³åˆ»å¼€å§‹å°†å…¶è½¬åŒ–ä¸ºå…¨å½©å›æ”¾)",
        "</CORE TASK>",
        "",
        "<BATTLE LOG>",
        "=== æˆ˜æ–—å›é¡¾ (BATTLE LOG) ===",
        processLog,
        "</BATTLE LOG>",
        "",
        "<RESULT>",
        "=== ç»Ÿè®¡ç»“ç®— (RESULT) ===",
        summary.replace("[ç³»ç»Ÿæç¤ºï¼šå®å¯æ¢¦å¯¹æˆ˜ç»“æœç»“ç®—]\n", ""),
        "</RESULT>"
    ].join('\n');
    copyToAndClose(finalContent);
};
function extractBattleLog() {
    const logBox = document.getElementById('log-box');
    if (!logBox) return '';
    const entries = [];
    logBox.querySelectorAll('.log-entry').forEach(entry => {
        const text = entry.innerText.trim();
        if (text) entries.push(`> ${text}`);
    });
    return entries.join('\n');
}
function copyToAndClose(textStr) {
    const fallbackCopy = () => {
        const el = document.createElement('textarea');
        el.value = textStr;
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
        endGameCleanup();
    };
    if (navigator.clipboard) {
        navigator.clipboard.writeText(textStr).then(() => {
            endGameCleanup();
        }).catch(fallbackCopy);
    } else {
        fallbackCopy();
    }
}
function endGameCleanup() {
    setTimeout(() => {
        if (window.parent) {
            window.parent.postMessage({ type: 'pkm-battle-close' }, '*');
        }
        document.getElementById('ui-root').style.filter = "grayscale(1) brightness(0.2)";
        document.body.innerHTML = "<div style='color:white;text-align:center;margin-top:20%'><h1>SESSION ENDED</h1><p>å·²å¤åˆ¶ç»“æœï¼Œè¯·åœ¨å¯¹è¯æ¡†ç²˜è´´ã€‚</p></div>";
    }, 600);
}
/**
 * =========================================================
 * BATTLE EVOLUTION SYSTEM V2 (ä¸´åœºè¿›åŒ–ç³»ç»Ÿ)
 * =========================================================
 * åŒè½¨è®¾è®¡ï¼š
 * 1. ç”Ÿå‘½è¿›åŒ– (Bio): ä¸€äºŒé˜¶æ®µå±æœºæ—¶è¿›åŒ–çªç ´
 * 2. çµé­‚å…±é¸£ (Bond): æœ€ç»ˆå½¢æ€ç»å¢ƒçˆ†å‘
 * =========================================================
 * ä¾èµ–: POKEDEX (data layer), calcStats (battle-engine.js)
 */
window.EvolutionSystem = {
    /**
     * è®¡ç®—å·±æ–¹ä¸æ•Œæ–¹çš„æ€»è¡€é‡æ¯”ï¼Œåˆ¤æ–­æ˜¯å¦å¤„äºæ˜æ˜¾åŠ£åŠ¿
     * @returns {boolean}
     */
    checkDisadvantage: function() {
        if (!battle || !battle.playerParty || !battle.enemyParty) return false;
        // è®¡ç®—å·±æ–¹æ€»è¡€é‡æ¯”
        let pTotalNow = 0, pTotalMax = 0;
        battle.playerParty.forEach(p => { 
            if (p && typeof p.currHp === 'number') {
                pTotalNow += Math.max(0, p.currHp); 
                pTotalMax += p.maxHp || 1;
            }
        });
        const playerRatio = pTotalNow / Math.max(1, pTotalMax);
        // è®¡ç®—æ•Œæ–¹æ€»è¡€é‡æ¯”
        let eTotalNow = 0, eTotalMax = 0;
        battle.enemyParty.forEach(e => { 
            if (e && typeof e.currHp === 'number') {
                eTotalNow += Math.max(0, e.currHp); 
                eTotalMax += e.maxHp || 1;
            }
        });
        const enemyRatio = eTotalNow / Math.max(1, eTotalMax);
        // å­˜æ´»æ•°é‡
        const alivePlayer = battle.playerParty.filter(p => p && typeof p.isAlive === 'function' && p.isAlive()).length;
        const aliveEnemy = battle.enemyParty.filter(e => e && typeof e.isAlive === 'function' && e.isAlive()).length;
        // ã€æè‡´æ”¶ç´§ã€‘çœŸÂ·ç»å¢ƒåˆ¤å®šï¼š
        // 1. ç»å¯¹æœ€åä¸€äºº + è¡€é‡å±æœºï¼ˆLast Man Standing + HP Crisisï¼‰
        //    ã€ä¿®å¤ã€‘1v1 æ»¡è¡€ä¸åº”è§¦å‘ï¼Œå¿…é¡»åŒæ—¶æ»¡è¶³"æœ€åä¸€åª"ä¸”"è¡€é‡ â‰¤ 40%"
        const isAbsoluteLastOne = (alivePlayer === 1) && (playerRatio <= 0.40);
        // 2. å…¨é˜Ÿæ¿’æ­»ï¼ˆå…¨é˜Ÿæ€»HP â‰¤ 10%ï¼Œå³ä½¿æœ‰å¤šåªå­˜æ´»ä¹Ÿéƒ½æ˜¯æ®‹è¡€ï¼‰
        const isNearWipeout = playerRatio <= 0.10;
        // 3. å·±æ–¹åªå‰©1åªï¼Œæ•Œæ–¹è¿˜æœ‰2åªä»¥ä¸Šï¼ˆçœŸæ­£çš„1vNåŠ£åŠ¿ï¼‰
        //    è¿™ç§æƒ…å†µä¸éœ€è¦è¡€é‡æ£€æŸ¥ï¼Œå› ä¸ºæ•°é‡åŠ£åŠ¿æœ¬èº«å°±æ˜¯ç»å¢ƒ
        const isOneVsMany = (alivePlayer === 1) && (aliveEnemy >= 2);
        return isAbsoluteLastOne || isNearWipeout || isOneVsMany;
    },
    /**
     * æ£€æŸ¥å½“å‰æ´»è·ƒç©å®¶ç²¾çµæ˜¯å¦æ»¡è¶³è¿›åŒ–/å…±é¸£æ¡ä»¶
     * @param {Pokemon} pokemon - è¦æ£€æŸ¥çš„å®å¯æ¢¦
     * @returns {Object|null} è¿›åŒ–ä¿¡æ¯æˆ– null
     */
    checkEligibility: function(pokemon) {
        // åŸºç¡€æ£€æŸ¥
        if (!pokemon || pokemon.currHp <= 0) return null;
        if (pokemon.hasEvolvedThisBattle || pokemon.hasBondResonance) return null;
        // è®¡ç®— AVs æ€»å’Œï¼ˆä½¿ç”¨æœ‰æ•ˆå€¼ï¼Œè€ƒè™‘ enable_insight è§£é”é™åˆ¶ï¼‰
        const avs = pokemon.avs || { trust: 0, passion: 0, insight: 0, devotion: 0 };
        const totalAVs = (pokemon.getEffectiveAVs('trust') || 0) + 
                         (pokemon.getEffectiveAVs('passion') || 0) + 
                         (pokemon.getEffectiveAVs('insight') || 0) + 
                         (pokemon.getEffectiveAVs('devotion') || 0);
        const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
        const data = typeof POKEDEX !== 'undefined' ? POKEDEX[baseId] : null;
        if (!data) return null;
        const hpRatio = pokemon.currHp / pokemon.maxHp;
        // ============================================
        // è·¯å¾„ A: ç”Ÿå‘½è¿›åŒ– (Biological Evolution)
        // é€‚ç”¨ï¼šæœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦ï¼Œå±æœºæ—¶çªç ´
        // ============================================
        if (data.evos && data.evos.length > 0) {
            // å·² Mega æˆ–å·²å˜èº«çš„ä¸èƒ½å†è¿›åŒ–
            if (pokemon.isMega || pokemon.isTransformed) return null;
            const nextFormName = data.evos[0];
            const nextId = nextFormName.toLowerCase().replace(/[^a-z0-9]/g, '');
            const nextData = typeof POKEDEX !== 'undefined' ? POKEDEX[nextId] : null;
            if (!nextData) return null;
            // 1. ç­‰çº§é” (å…è®¸è¶Šçº§5çº§)
            const reqLevel = Math.max(1, (nextData.evoLevel || 1) - 3);
            if (pokemon.level < reqLevel) return null;
            // 2. AVs é˜ˆå€¼ï¼šä¸€é˜¶(æ— prevo)è¦100ï¼ŒäºŒé˜¶(æœ‰prevo)è¦300
            const isFirstStage = !data.prevo;
            const reqAVs = isFirstStage ? 100 : 300;
            if (totalAVs < reqAVs) return null;
            // 3. å±æœºé” (HP 35% ä»¥ä¸‹) æˆ– Ace å®å¯æ¢¦ 60% ä»¥ä¸‹
            const isCrisis = hpRatio <= 0.35;
            const isAceMoment = pokemon.isAce && hpRatio <= 0.6;
            if (isCrisis || isAceMoment) {
                return {
                    type: 'bio',
                    currentName: pokemon.cnName,
                    targetName: nextFormName,
                    targetId: nextId,
                    nextData: nextData,
                    totalAVs: totalAVs,
                    reqAVs: reqAVs
                };
            }
        }
        // ============================================
        // è·¯å¾„ B: çµé­‚å…±é¸£ (Bond Resonance)
        // é€‚ç”¨ï¼šæœ€ç»ˆå½¢æ€ï¼Œç»å¢ƒæ—¶çš„æœ€ååæ‰‘
        // ============================================
        else {
            // ã€è§£é”æ£€æŸ¥ã€‘ç»¿è‰²ç¾ç»Šå…±é¸£éœ€è¦ enable_bond è§£é”
            const unlocks = battle.playerUnlocks || {};
            if (unlocks.enable_bond === false) return null;
            // ã€å…¨å±€é™åˆ¶ã€‘æ¯åœºæˆ˜æ–—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ Bond Resonance
            if (battle.playerBondUsed) return null;
            // æœ€ç»ˆå½¢æ€ (æ— è¿›åŒ–å‹)
            // 1. AVs ç»å¯¹é˜ˆå€¼ï¼š300
            if (totalAVs < 300) return null;
            // 2. å¿…é¡»æ˜¯ Ace å®å¯æ¢¦
            if (!pokemon.isAce) return null;
            // 3. ã€ä¸¥æ ¼åŠ£åŠ¿åˆ¤æ–­ã€‘ä¸ AI ä¸€è‡´
            //    è®¡ç®—åŒæ–¹æ€»è¡€é‡
            let playerTotalHp = 0, enemyTotalHp = 0;
            battle.playerParty.forEach(pp => {
                if (pp && typeof pp.isAlive === 'function') {
                    playerTotalHp += Math.max(0, pp.currHp || 0);
                }
            });
            battle.enemyParty.forEach(ep => {
                if (ep && typeof ep.isAlive === 'function') {
                    enemyTotalHp += Math.max(0, ep.currHp || 0);
                }
            });
            const aliveCount = battle.playerParty.filter(p => p && typeof p.isAlive === 'function' && p.isAlive()).length;
            const isLastStand = aliveCount === 1;
            // ã€ä¸¥æ ¼åŠ£åŠ¿æ¡ä»¶ã€‘
            // æ ¸å¿ƒæ¡ä»¶ï¼šå¿…é¡»æ˜¯æœ€åä¸€åªå®å¯æ¢¦ ä¸” HP <= 50%
            // å°è§„æ¨¡æˆ˜æ–—ï¼ˆåŒæ–¹å„ <= 2 åªï¼‰æ—¶ï¼Œå…è®¸è¡€é‡åŠ£åŠ¿è§¦å‘
            const currentPokemonCritical = hpRatio <= 0.50;
            const isSmallBattle = (battle.playerParty.length <= 2 && battle.enemyParty.length <= 2);
            const isHpDisadvantage = playerTotalHp < enemyTotalHp * 0.5;
            // è§¦å‘æ¡ä»¶ï¼š
            // 1. æœ€åä¸€åªå®å¯æ¢¦ + HP <= 50%
            // 2. æˆ–è€… å°è§„æ¨¡æˆ˜æ–— + è¡€é‡åŠ£åŠ¿ + HP <= 50%
            const canTriggerBond = currentPokemonCritical && (isLastStand || (isSmallBattle && isHpDisadvantage));
            if (canTriggerBond) {
                return {
                    type: 'bond',
                    currentName: pokemon.cnName,
                    targetName: `ç¾ç»ŠÂ·${pokemon.cnName}`,
                    totalAVs: totalAVs,
                    isLastStand: isLastStand,
                    isHpDisadvantage: isHpDisadvantage
                };
            }
        }
        return null;
    }
};
/**
 * æ›´æ–°è¿›åŒ–æŒ‰é’®å¯è§æ€§
 * åœ¨ updateAllVisuals ä¸­è°ƒç”¨
 */
function updateEvolutionButtonVisuals() {
    const btn = document.getElementById('btn-evolved');
    if (!btn) return;
    const p = battle.getPlayer();
    if (!p) {
        btn.classList.add('hidden');
        return;
    }
    const evoInfo = window.EvolutionSystem.checkEligibility(p);
    if (evoInfo) {
        btn.classList.remove('hidden');
        // æ ¹æ®ç±»å‹æ›´æ–°æŒ‰é’®æ ·å¼
        if (evoInfo.type === 'bond') {
            btn.classList.add('bond-mode');
            btn.title = 'ç¾ç»Šå…±é¸£ (Bond Resonance)';
        } else {
            btn.classList.remove('bond-mode');
            btn.title = 'è¿›åŒ– (Evolution)';
        }
        // æ˜¾ç¤ºæç¤ºæ—¥å¿—ï¼ˆæ¯ç§ç±»å‹åªæç¤ºä¸€æ¬¡ï¼‰
        if (evoInfo.type === 'bio' && !p._evoHintLogged) {
            log(`<span style="color:#d4ac0d; text-shadow:0 0 5px gold;">âœ¨ ${p.cnName} çš„å‘¨èº«æ¶ŒåŠ¨ç€è¿›åŒ–çš„å…‰èŠ’...å®ƒåœ¨å›åº”ä½ çš„æ„å¿—ï¼</span>`);
            p._evoHintLogged = true;
        } else if (evoInfo.type === 'bond' && !p._bondHintLogged) {
            log(`<span style="color:#4ade80; text-shadow:0 0 8px #22c55e;">âˆ ${p.cnName} ä¸è®­ç»ƒå®¶çš„å¿ƒè·³å¼€å§‹åŒæ­¥...ç¾ç»Šæ­£åœ¨è§‰é†’ï¼</span>`);
            p._bondHintLogged = true;
        }
    } else {
        btn.classList.add('hidden');
    }
}
/**
 * è§¦å‘æˆ˜æ–—ä¸­è¿›åŒ–/ç¾ç»Šå…±é¸£
 * ç‚¹å‡» EVO æŒ‰é’®æ—¶è°ƒç”¨
 */
window.triggerBattleEvolution = async function() {
    const btn = document.getElementById('btn-evolved');
    const p = battle.getPlayer();
    if (!p) return;
    const evoInfo = window.EvolutionSystem.checkEligibility(p);
    if (!evoInfo) return;
    battle.locked = true;
    btn.classList.add('hidden');
    const spriteRef = document.getElementById('player-sprite');
    // ============================================
    // è·¯å¾„ A: ç”Ÿå‘½è¿›åŒ– (Biological Evolution)
    // ============================================
    if (evoInfo.type === 'bio') {
        p.hasEvolvedThisBattle = true;
        const oldName = p.cnName;
        log(`<div class="log-evo-intro">âœ¨ å®å¯æ¢¦è¿›åŒ– âœ¨</div>`);
        log(`${oldName} çš„æ ·å­â€¦â€¦ï¼`);
        await wait(300);
        // åŠ¨ç”»ï¼šæ™®é€šè¿›åŒ–ç™½å…‰ï¼ˆä¸ Mega åŒºåˆ†ï¼‰
        if (spriteRef) {
            spriteRef.classList.add('bio-evo-glow');
        }
        await wait(800);
        // æ•°æ®å˜æ›´
        const newData = evoInfo.nextData;
        p.name = newData.name;
        p.cnName = newData.name;
        p.types = newData.types || p.types;
        p.baseStats = newData.baseStats;
        const stats = calcStats(p.baseStats, p.level, {
            ivs: p.statsMeta?.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 },
            ev_level: p.statsMeta?.ev_level || 0,
            nature: p.nature
        });
        p.maxHp = stats.hp;
        p.atk = stats.atk;
        p.def = stats.def;
        p.spa = stats.spa;
        p.spd = stats.spd;
        p.spe = stats.spe;
        // å…¨å›å¤ + æ¸…çŠ¶æ€
        p.currHp = p.maxHp;
        p.status = null;
        // å…¨èƒ½åŠ›+1
        if (typeof p.applyBoost === 'function') {
            p.applyBoost('atk', 1);
            p.applyBoost('def', 1);
            p.applyBoost('spa', 1);
            p.applyBoost('spd', 1);
            p.applyBoost('spe', 1);
        }
        // ç™½å…‰çˆ†å‘ + æ¢å›¾
        if (spriteRef) {
            spriteRef.classList.remove('bio-evo-glow');
            spriteRef.classList.add('bio-evo-burst');
            const newSrc = p.getSprite(true);
            if (typeof smartLoadSprite === 'function') {
                delete spriteRequestedUrls['player-sprite'];
                smartLoadSprite('player-sprite', newSrc, false);
                spriteRequestedUrls['player-sprite'] = newSrc;
            }
        }
        await wait(400);
        // å†·å´åŠ¨ç”»
        if (spriteRef) {
            spriteRef.classList.remove('bio-evo-burst');
            spriteRef.classList.add('bio-evo-finish');
        }
        await wait(600);
        // æ¸…ç†åŠ¨ç”»ç±»
        if (spriteRef) {
            spriteRef.className = 'p-sprite loaded';
        }
        log(`â€¦â€¦${oldName} å…¨èº«åŒ…å›´äº†è€€çœ¼çš„å…‰èŠ’ï¼`);
        log(`<b style="color:#a855f7">æ­å–œï¼${oldName} è¿›åŒ–æˆäº† ${p.cnName}ï¼</b>`);
        log(`<span style="color:#4ade80">ä½“èƒ½å®Œå…¨æ¢å¤ï¼å…¨èƒ½åŠ›æå‡äº†ï¼</span>`);
        // AVs æ•ˆæœç¿»å€
        if (p.avs) {
            p.avsEvolutionBoost = true;
            log(`<span style="color:#ff6b9d">ğŸ’– è¿›åŒ–æ¿€å‘äº†æ½œåœ¨çš„æƒ…æ„ŸåŠ›é‡ï¼AVs æ•ˆæœç¿»å€ï¼</span>`);
        }
    }
    // ============================================
    // è·¯å¾„ B: çµé­‚å…±é¸£ (Bond Resonance)
    // ============================================
    else if (evoInfo.type === 'bond') {
        p.hasBondResonance = true;
        battle.playerBondUsed = true; // ã€å…¨å±€é™åˆ¶ã€‘æ ‡è®°å·²ä½¿ç”¨
        const oldName = p.cnName;
        const avs = p.avs || {};
        const totalAVs = (avs.trust || 0) + (avs.passion || 0) + (avs.insight || 0) + (avs.devotion || 0);
        // æ ‡é¢˜
        log(`<div style="border-top: 2px solid #4ade80; border-bottom: 2px solid #4ade80; padding: 8px; text-align: center; margin: 10px 0; background: linear-gradient(90deg, rgba(74,222,128,0.1), rgba(74,222,128,0.3), rgba(74,222,128,0.1));">`);
        log(`<b style="font-size:1.4em; color:#4ade80; text-shadow: 0 0 10px #22c55e;">âˆ BOND RESONANCE âˆ</b>`);
        log(`</div>`);
        await wait(500);
        log(`ä¸¤äººçš„å¿ƒè·³å®Œå…¨é‡åˆäº†â€¦â€¦`);
        await wait(400);
        log(`ä¸ºäº†å›åº”å½»åº•çš„ä¿¡èµ– <span style="color:#facc15">(Total AVs: ${totalAVs})</span>ï¼Œæ²‰ç¡åœ¨ä½“å†…çš„ç•Œé™è¢«æ‰“ç ´äº†ï¼`);
        // åŠ¨ç”»ï¼šé‡‘è‰²å…‰æ™•çˆ†å‘ï¼ˆä¸æ¢å›¾ï¼‰
        if (spriteRef) {
            spriteRef.classList.add('evo-burst');
            spriteRef.style.filter = 'brightness(3) drop-shadow(0 0 20px gold)';
        }
        await wait(400);
        if (spriteRef) {
            spriteRef.classList.remove('evo-burst');
            spriteRef.classList.add('evo-finish');
            // ä¿æŒé‡‘è‰²å…‰æ™•
            spriteRef.style.filter = 'drop-shadow(0 0 15px gold) brightness(1.15) saturate(1.2)';
        }
        await wait(600);
        if (spriteRef) {
            spriteRef.classList.remove('evo-finish');
            // æ·»åŠ ç¾ç»ŠçŠ¶æ€æ ‡è®°
            spriteRef.classList.add('bond-resonance');
        }
        // æ•°æ®å˜æ›´ï¼šä¸æ”¹å˜å½¢æ€ï¼Œä½†å¤§å¹… buff
        // 1. HP å›å¤ +60%ï¼ˆä¸æº¢å‡ºä¸Šé™ï¼‰
        const healAmount = Math.floor(p.maxHp * 0.6);
        p.currHp = Math.min(p.currHp + healAmount, p.maxHp);
        // 2. æ¸…é™¤æ‰€æœ‰å¼‚å¸¸
        p.status = null;
        // 3. å…¨èƒ½åŠ›+1ï¼ˆå¹³è¡¡è°ƒæ•´ï¼ŒåŸ +2ï¼‰
        if (typeof p.applyBoost === 'function') {
            p.applyBoost('atk', 1);
            p.applyBoost('def', 1);
            p.applyBoost('spa', 1);
            p.applyBoost('spd', 1);
            p.applyBoost('spe', 1);
            // è‹¥æœ‰ç‰¹æ®Šçš„ç¾ç»ŠæŒ‡æ ‡ï¼Œå¯ä»¥é™„åŠ é¢å¤–åŠ æˆ
            log(`<b style="color:#4ade80">âœ¦ ${p.cnName} çš„æ½œèƒ½è¢«å”¤é†’! æ”»é˜²ç‰¹æ”»ç‰¹é˜²é€Ÿåº¦å…¨é¢æå‡!</b>`);
        }
        await wait(300);
        log(`è¿™å¹¶éè¿›åŒ–â€¦â€¦è€Œæ˜¯è¶…è¶Šè¿›åŒ–çš„ <b style="color:#facc15">å…±é¸£å½¢æ€</b>ï¼`);
        log(`<span style="color:#4ade80">âœ¦ å…¨å±æ€§æå¤§å¹…æå‡ï¼</span>`);
        log(`<span style="color:#60a5fa">âœ¦ æ°”åŠ¿(HP)å¤§å¹…å›å¤ï¼(+${healAmount})</span>`);
        log(`<span style="color:#ff6b9d">âœ¦ AVs æ•ˆæœç¿»å€ï¼</span>`);
        if (evoInfo.isLastStand) {
            log(`<span style="color:#f87171; font-style:italic;">ã€Œå“ªæ€•åªå‰©æœ€åä¸€å£æ°”â€¦â€¦ä¹Ÿç»ä¸ä¼šæ”¾å¼ƒï¼ã€</span>`);
        }
    }
    updateAllVisuals();
    battle.locked = false;
};
]]></file>
    <file name="mega-selection-dialog.js"><![CDATA[/**
 * æ˜¾ç¤º Mega å½¢æ€é€‰æ‹©å¯¹è¯æ¡†ï¼ˆå–·ç«é¾™/è¶…æ¢¦ X/Y é€‰æ‹©ï¼‰
 * [UIé‡æ„ V2]ï¼šå±€éƒ¨ç£¨ç ‚ç»ç’ƒé£æ ¼ (Container Glassmorphism)
 * å»é™¤äº†å…¨å±æ¨¡ç³Šï¼Œåªè®©å¡ç‰‡æœ¬èº«æœ‰åŠé€æ˜ç£¨ç ‚æ„Ÿ
 * 
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {Function} callback - é€‰æ‹©å®Œæˆåçš„å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºé€‰ä¸­çš„å½¢æ€ ID
 */
function showMegaFormSelectionDialog(pokemon, callback) {
    // 1. æ³¨å…¥åŠ¨ç”»æ ·å¼
    if (!document.getElementById('mega-selection-modern-style')) {
        const style = document.createElement('style');
        style.id = 'mega-selection-modern-style';
        style.textContent = `
            :root {
                --mega-x-color: #3b82f6; 
                --mega-y-color: #ef4444; 
                --mega-base-color: #a855f7;
            }
            .mega-overlay-simple {
                animation: fadeInOpacity 0.3s ease-out forwards;
            }
            @keyframes fadeInOpacity {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes glassUp {
                from { opacity: 0; transform: translateY(30px) skewX(-10deg); }
                to { opacity: 1; transform: translateY(0) skewX(-10deg); }
            }
            /* èƒŒæ™¯çº¹ç†å¾®è°ƒ */
            .mega-bg-grid {
                background-image: 
                    linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
                background-size: 20px 20px;
            }
        `;
        document.head.appendChild(style);
    }
    // 2. åˆ›å»ºé®ç½©å±‚ (çº¯ç²¹çš„åŠé€æ˜é»‘åº•å±‚ï¼Œæ— æ¨¡ç³Š)
    const overlay = document.createElement('div');
    overlay.className = 'mega-selection-overlay mega-overlay-simple';
    overlay.style.cssText = `
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.45); /* ç¨å¾®åŠ æ·±é®ç½©ï¼Œçªå‡ºä¸­é—´çš„ç»ç’ƒå¡ç‰‡ */
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 12000;
    `;
    // 3. åˆ›å»º UI ä¸è§„åˆ™å®¹å™¨ (è¿™æ‰æ˜¯å¸¦é«˜æ–¯æ¨¡ç³Šçš„ä¸»ä½“)
    const dialogShape = document.createElement('div');
    dialogShape.className = 'mega-dialog-shape';
    dialogShape.style.cssText = `
        position: relative;
        /* æ”¹åŠ¨ç‚¹ï¼šèƒŒæ™¯è®¾ä¸ºåŠé€æ˜ï¼Œæ‰“å¼€ Backdrop Filter */
        background: rgba(255, 255, 255, 0.85); 
        backdrop-filter: blur(20px) saturate(1.8);
        -webkit-backdrop-filter: blur(20px) saturate(1.8);
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 
            0 25px 50px -12px rgba(0, 0, 0, 0.4), /* æŠ•å½±ä¹Ÿæ›´æ·±ä¸€ç‚¹ä»¥å¢åŠ ç«‹ä½“æ„Ÿ */
            inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        padding: 40px 60px;
        border-radius: 20px;
        max-width: 620px;
        /* ä¿æŒæ–œåˆ‡é£æ ¼ï¼Œä½†è§’åº¦ç¨å¾®æ¸©å’Œä¸€ç‚¹ */
        transform: skewX(-10deg);
        animation: glassUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); /* æœ‰å¼¹æ€§çš„å…¥åœº */
        overflow: hidden;
    `;
    // 3.1 è£…é¥°æ€§ç½‘æ ¼èƒŒæ™¯ (è®©ç»ç’ƒè´¨æ„Ÿæ›´æ˜æ˜¾)
    const bgDecor = document.createElement('div');
    bgDecor.className = 'mega-bg-grid';
    bgDecor.style.cssText = `
        position: absolute;
        top: -50%; left: -50%; width: 200%; height: 200%;
        z-index: 0;
        pointer-events: none;
        transform: skewX(10deg); /* æŠµæ¶ˆçˆ¶çº§æ–œåˆ‡ */
        opacity: 0.6;
    `;
    dialogShape.appendChild(bgDecor);
    // 3.2 é¡¶éƒ¨å½©è‰²è£…é¥°æ¡ (ä¿ç•™ï¼Œå¢åŠ è§†è§‰é‡å¿ƒ)
    const topBar = document.createElement('div');
    topBar.style.cssText = `
        position: absolute;
        top: 0; left: 0; right: 0;
        height: 6px;
        background: linear-gradient(90deg, #3b82f6 0%, #a855f7 50%, #ef4444 100%);
        z-index: 2;
        /* ç»™ä¸€ç‚¹å…‰æ³½ */
        box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    `;
    dialogShape.appendChild(topBar);
    // 4. å†…å®¹å®¹å™¨ (åå‘æ–œåˆ‡ 10åº¦ æ‰¶æ­£)
    const content = document.createElement('div');
    content.style.cssText = `
        transform: skewX(10deg);
        position: relative;
        z-index: 5;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    `;
    // 5. æ ‡é¢˜ä¸ä¿¡æ¯
    const title = document.createElement('h2');
    title.innerHTML = `MEGA EVOLUTION`;
    title.style.cssText = `
        color: #1e293b;
        font-family: inherit;
        font-size: 36px;
        font-weight: 900;
        font-style: italic;
        margin: 0;
        letter-spacing: -1.5px;
        line-height: 1;
        text-shadow: 2px 2px 0px rgba(255,255,255,0.4);
    `;
    const subTitle = document.createElement('div');
    subTitle.textContent = `Select form for ${pokemon.cnName || pokemon.name}`;
    subTitle.style.cssText = `
        color: #64748b;
        font-size: 15px;
        font-weight: 600;
        margin-top: 5px;
        margin-bottom: 35px;
        text-transform: uppercase;
        letter-spacing: 1px;
    `;
    // 6. é€‰é¡¹æŒ‰é’®å®¹å™¨
    const optionsContainer = document.createElement('div');
    optionsContainer.style.cssText = `
        display: flex;
        gap: 24px;
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
    `;
    // 7. å½¢æ€å¤„ç†é€»è¾‘
    const forms = pokemon.megaFormsAvailable || [];
    if(forms.length === 0) {
        const base = pokemon.name.toLowerCase();
        if(base.includes('mewtwo') || base.includes('charizard')) {
            forms.push(base.endsWith('mega') ? base + 'x' : base + 'megax');
            forms.push(base.endsWith('mega') ? base + 'y' : base + 'megay');
        } else {
            forms.push('default'); 
        }
    }
    forms.forEach(formId => {
        const isX = formId.toLowerCase().includes('x');
        const isY = formId.toLowerCase().includes('y');
        let labelLarge = isX ? 'X' : isY ? 'Y' : 'âˆ';
        let subText = isX ? 'ATTACK' : isY ? 'SPECIAL' : 'POWER'; // ç®€å•çš„æè¿°
        if (formId === 'default') subText = 'UNLOCK';
        let themeColor = isX ? '#3b82f6' : isY ? '#ef4444' : '#a855f7';
        // æŒ‰é’® (çº¯ç™½èƒŒæ™¯å¡ç‰‡ï¼Œå¯ä»¥å¾®å¾®é€å‡ºä¸€ç‚¹åº•è‰²)
        const btn = document.createElement('div');
        btn.style.cssText = `
            flex: 1;
            min-width: 130px;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255,255,255,0.8);
            border-bottom: 4px solid ${themeColor}15; /* ææ·¡å½©è‰²åº•è¾¹ */
            border-radius: 16px;
            padding: 25px 15px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* å†…éƒ¨ä¸éœ€è¦æ¨¡ç³Šï¼Œä¿æŒæ¸…æ™° */
        `;
        btn.innerHTML = `
            <div style="font-size: 12px; font-weight: 800; color: ${themeColor}; opacity: 0.8; letter-spacing: 1.5px; margin-bottom: 4px;">MEGA</div>
            <div style="font-size: 56px; font-weight: 900; color: #1e293b; line-height:1; font-style: italic; position: relative; z-index:2;">${labelLarge}</div>
            <div style="font-size: 11px; font-weight: 700; color: #94a3b8; margin-top: 4px; letter-spacing: 0.5px;">${subText}</div>
            <div class="fill-anim" style="
                position: absolute; bottom: 0; left: 0; right: 0; height: 0; 
                background: ${themeColor}; z-index: 1;
                transition: height 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            "></div>
        `;
        // æ‚¬åœäº¤äº’ (å¡ç‰‡ä¸Šæµ® + å¡«è‰²)
        btn.onmouseenter = () => {
             btn.style.transform = 'translateY(-6px)';
             // ä¸‹è¾¹æ¡†æ¶ˆå¤±ï¼Œå˜æˆæ•´ä½“é¢œè‰²
             btn.style.borderBottomColor = themeColor; 
             // æŠ•å½±åŠ æ·±
             btn.style.boxShadow = `0 12px 25px -5px ${themeColor}40`;
             // æ–‡å­—å˜ç™½
             btn.children[0].style.color = 'rgba(255,255,255,0.8)';
             btn.children[1].style.color = '#fff'; 
             btn.children[2].style.color = 'rgba(255,255,255,0.6)';
             // å¡«å……èƒŒæ™¯
             btn.querySelector('.fill-anim').style.height = '100%';
        };
        btn.onmouseleave = () => {
             btn.style.transform = 'translateY(0)';
             btn.style.borderBottomColor = `${themeColor}15`;
             btn.style.boxShadow = 'none';
             btn.children[0].style.color = themeColor;
             btn.children[1].style.color = '#1e293b';
             btn.children[2].style.color = '#94a3b8';
             btn.querySelector('.fill-anim').style.height = '0';
        };
        btn.onclick = () => {
            overlay.style.transition = 'opacity 0.2s';
            overlay.style.opacity = '0';
            setTimeout(() => document.body.removeChild(overlay), 200);
            callback(formId);
        };
        optionsContainer.appendChild(btn);
    });
    // 8. å–æ¶ˆæŒ‰é’®
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'CANCEL';
    cancelBtn.style.cssText = `
        margin-top: 35px;
        background: transparent;
        border: 2px solid #cbd5e1;
        color: #94a3b8;
        font-weight: 800;
        font-size: 13px;
        letter-spacing: 1px;
        cursor: pointer;
        padding: 8px 32px;
        border-radius: 50px;
        transition: all 0.2s;
        font-family: inherit;
    `;
    cancelBtn.onmouseenter = () => {
        cancelBtn.style.borderColor = '#94a3b8';
        cancelBtn.style.color = '#64748b';
        cancelBtn.style.background = '#fff';
    };
    cancelBtn.onmouseleave = () => {
        cancelBtn.style.borderColor = '#cbd5e1';
        cancelBtn.style.color = '#94a3b8';
        cancelBtn.style.background = 'transparent';
    };
    cancelBtn.onclick = () => {
        overlay.style.transition = 'opacity 0.2s';
        overlay.style.opacity = '0';
        setTimeout(() => document.body.removeChild(overlay), 200);
        callback(null);
    };
    // ç»„è£…ç»“æ„
    content.appendChild(title);
    content.appendChild(subTitle);
    content.appendChild(optionsContainer);
    content.appendChild(cancelBtn);
    dialogShape.appendChild(content);
    overlay.appendChild(dialogShape);
    // ä¸€å®šè¦å…ˆæŒ‚è½½åˆ° bodyï¼ŒBackdrop Filter æ‰ä¼šç”Ÿæ•ˆ
    document.body.appendChild(overlay);
    overlay.onclick = (e) => {
        if(e.target === overlay) {
            cancelBtn.click();
        }
    };
}
]]></file>
</pkm_project>