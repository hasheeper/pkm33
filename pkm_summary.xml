<?xml version="1.0" ?>
<pkm_project>
    <directory name="battle">
        <file name="battle-calc.js"><![CDATA[/**
 * ===========================================
 * BATTLE-CALC.JS - ä¼¤å®³è®¡ç®—å¼•æ“
 * ===========================================
 * 
 * ä» engine/battle-engine.js è¿ç§»
 * 
 * èŒè´£:
 * - çº¯ä¼¤å®³æ•°å€¼è®¡ç®—
 * - å±æ€§å…‹åˆ¶è®¡ç®—
 * - æš´å‡»/å‘½ä¸­åˆ¤å®š
 * - å¤šæ®µæ”»å‡»
 * - ç‰¹æ€§/é“å…·ä¿®æ­£
 * 
 * ä¾èµ–: pokedex-data.js, moves-data.js, ability-handlers.js, items-data.js
 */
/**
 * ä¼¤å®³è®¡ç®— (å«èƒ½åŠ›ç­‰çº§ä¿®æ­£ã€å‘½ä¸­åˆ¤å®šã€å¤šæ®µæ”»å‡»ã€æš´å‡»ç‡)
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move - { type, power, cat, accuracy }
 * @param {object} options - { isSimulation: boolean } å¯é€‰å‚æ•°
 * @returns {object} - { damage, effectiveness, isCrit, miss, hitCount, blocked }
 */
function calcDamage(attacker, defender, move, options = {}) {
    // è·å–å®Œæ•´æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // === ã€ç‰¹æ€§é’©å­ã€‘onModifyMove - ä¿®æ”¹æ‹›å¼å±æ€§/å¨åŠ› (Liquid Voice ç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && attacker.ability) {
        const abilityHandler = AbilityHandlers[attacker.ability];
        if (abilityHandler && abilityHandler.onModifyMove) {
            abilityHandler.onModifyMove(move, attacker);
        }
    }
    const accuracy = move.accuracy ?? fullMoveData.accuracy;
    let category = fullMoveData.category || (move.cat === 'spec' ? 'Special' : (move.cat === 'phys' ? 'Physical' : 'Status'));
    let basePower = move.power ?? fullMoveData.basePower ?? 0;
    // =====================================================
    // === ã€æå·¨åŒ–/Zæ‹›å¼å¨åŠ›ä¿®æ­£è¡¥ä¸ã€‘ ===
    // =====================================================
    const moveName = move.name || '';
    const isMaxMoveName = moveName.startsWith('Max ') || moveName.startsWith('G-Max ');
    const isZMoveName = moveName.includes('10,000,000') || 
                        moveName.includes('Catastropika') || 
                        moveName.includes('Stoked Sparksurfer') ||
                        moveName.includes('Pulverizing Pancake') ||
                        (fullMoveData.isZ && basePower < 100);
    if (isMaxMoveName && basePower < 100) {
        const oldPower = basePower;
        basePower = 130;
        console.warn(`[ENGINE FIX] Max/G-Max å¨åŠ›ä¿®æ­£: ${moveName} (${oldPower} -> ${basePower})`);
    }
    if (isZMoveName && basePower < 100) {
        const oldPower = basePower;
        basePower = 180;
        console.warn(`[ENGINE FIX] Z-Move å¨åŠ›ä¿®æ­£: ${moveName} (${oldPower} -> ${basePower})`);
    }
    // =====================================================
    // === ã€Tera Blast ç‰¹åˆ¤ã€‘ ===
    // =====================================================
    if (moveName === 'Tera Blast' && attacker.isTerastallized) {
        move.type = attacker.teraType;
        const atkStat = attacker.getStat ? attacker.getStat('atk') : attacker.atk;
        const spaStat = attacker.getStat ? attacker.getStat('spa') : attacker.spa;
        if (atkStat > spaStat) {
            move.cat = 'phys';
            category = 'Physical';
        } else {
            move.cat = 'spec';
            category = 'Special';
        }
        console.log(`[TERA BLAST] ${attacker.name} ä½¿ç”¨ Tera Blast: å±æ€§=${move.type}, åˆ†ç±»=${category} (Atk=${atkStat}, SpA=${spaStat})`);
    }
    // === ç­–ç•¥æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç‰¹æ®Šå¤„ç†å™¨ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    // === å›ºå®šä¼¤å®³æŠ€èƒ½ (damageCallback) ===
    if (handler && handler.damageCallback) {
        const fixedDamage = handler.damageCallback(attacker, defender);
        return { 
            damage: fixedDamage, 
            effectiveness: 1, 
            isCrit: false, 
            miss: false, 
            hitCount: 1,
            fixedDamage: true
        };
    }
    // === åŠ¨æ€å¨åŠ›æŠ€èƒ½ (basePowerCallback) ===
    if (handler && handler.basePowerCallback) {
        basePower = handler.basePowerCallback(attacker, defender);
    }
    // === ç‰¹æ€§å¨åŠ›åŠ æˆ Hook (æŠ€å¸ˆã€çŒ›ç«ã€æ¿€æµç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && attacker.ability && AbilityHandlers[attacker.ability]) {
        const ah = AbilityHandlers[attacker.ability];
        if (ah.onBasePower) {
            basePower = ah.onBasePower(basePower, attacker, defender, move);
        }
    }
    // === ã€å……ç”µ Chargeã€‘ç”µç³»æ‹›å¼å¨åŠ›ç¿»å€ ===
    const chargeMoveType = move.type || fullMoveData.type || 'Normal';
    if (attacker.volatile && attacker.volatile.charge && chargeMoveType === 'Electric') {
        basePower = Math.floor(basePower * 2);
        console.log(`[CHARGE] ${attacker.cnName} çš„å……ç”µä½¿ç”µç³»æ‹›å¼å¨åŠ›ç¿»å€ï¼(${basePower / 2} -> ${basePower})`);
        // ä½¿ç”¨åæ¶ˆè€—
        delete attacker.volatile.charge;
    }
    // === ã€ç£¨ç º Laser Focusã€‘ä¸‹å›åˆå¿…å®šæš´å‡» ===
    // åœ¨æš´å‡»åˆ¤å®šå¤„å¤„ç†ï¼Œè¿™é‡Œåªåšæ ‡è®°æ£€æŸ¥
    // === Mirror Coat / Counter ç®€åŒ–å¤„ç† ===
    if (move.name === 'Mirror Coat') {
        basePower = 100;
        move.cat = 'spec';
    } else if (move.name === 'Counter') {
        basePower = 80;
        move.cat = 'phys';
    }
    // === Protect/Detect å®ˆä½åˆ¤å®š ===
    if (defender.volatile && defender.volatile.protect && basePower > 0) {
        const isContact = fullMoveData.flags && fullMoveData.flags.contact;
        let protectEffect = null;
        // ã€æ— å½¢æ‹³ (Unseen Fist)ã€‘æ¥è§¦ç±»æ‹›å¼ç©¿é€å®ˆä½
        const attackerAbility = (attacker.ability || '').toLowerCase().replace(/[^a-z]/g, '');
        if (isContact && attackerAbility === 'unseenfist') {
            console.log(`[Unseen Fist] ${attacker.cnName} çš„æ— å½¢æ‹³ç©¿é€äº†å®ˆä½ï¼`);
            // ä¸ return blockedï¼Œç»§ç»­è®¡ç®—ä¼¤å®³
            // ä½†ä»ç„¶è§¦å‘å®ˆä½çš„æ¥è§¦å‰¯ä½œç”¨ï¼ˆå¦‚ç‹ç›¾é™æ”»ï¼‰
            if (defender.volatile.kingsShield) {
                if (!attacker.boosts) attacker.boosts = {};
                attacker.boosts.atk = Math.max(-6, (attacker.boosts.atk || 0) - 2);
                protectEffect = { type: 'statDrop', msg: `${attacker.cnName} çš„æ”»å‡»å¤§å¹…ä¸‹é™ï¼` };
            }
            // æ— å½¢æ‹³ç©¿é€åç»§ç»­æ‰§è¡Œä¼¤å®³è®¡ç®—ï¼Œä¸åœ¨è¿™é‡Œ return
        } else if (isContact) {
            // ç¢‰å ¡ (Baneful Bunker): æ¥è§¦æ”»å‡»è€…ä¸­æ¯’
            if (defender.volatile.banefulBunker) {
                const attackerTypes = attacker.types || [];
                const canPoison = !attackerTypes.includes('Poison') && !attackerTypes.includes('Steel');
                if (canPoison && !attacker.status) {
                    attacker.status = 'psn';
                    protectEffect = { type: 'poison', msg: `${attacker.cnName} æ¥è§¦äº†ç¢‰å ¡ï¼Œä¸­æ¯’äº†ï¼` };
                }
            }
            // å°–åˆºé˜²å®ˆ (Spiky Shield)
            else if (defender.volatile.spikyShield) {
                const spikeDmg = Math.floor(attacker.maxHp / 8);
                attacker.takeDamage(spikeDmg);
                protectEffect = { type: 'damage', msg: `${attacker.cnName} è¢«å°–åˆºåˆºä¼¤äº†ï¼(-${spikeDmg})` };
            }
            // ç‹è€…ç›¾ç‰Œ (King's Shield)
            else if (defender.volatile.kingsShield) {
                if (!attacker.boosts) attacker.boosts = {};
                attacker.boosts.atk = Math.max(-6, (attacker.boosts.atk || 0) - 2);
                protectEffect = { type: 'statDrop', msg: `${attacker.cnName} çš„æ”»å‡»å¤§å¹…ä¸‹é™ï¼` };
            }
            // æ‹¦å µ (Obstruct)
            else if (defender.volatile.obstruct) {
                if (!attacker.boosts) attacker.boosts = {};
                attacker.boosts.def = Math.max(-6, (attacker.boosts.def || 0) - 2);
                protectEffect = { type: 'statDrop', msg: `${attacker.cnName} çš„é˜²å¾¡å¤§å¹…ä¸‹é™ï¼` };
            }
            // ä¸ç»¸é™·é˜± (Silk Trap)
            else if (defender.volatile.silkTrap) {
                if (!attacker.boosts) attacker.boosts = {};
                attacker.boosts.spe = Math.max(-6, (attacker.boosts.spe || 0) - 1);
                protectEffect = { type: 'statDrop', msg: `${attacker.cnName} çš„é€Ÿåº¦ä¸‹é™äº†ï¼` };
            }
            // ç«ç„°å®ˆæŠ¤ (Burning Bulwark)
            else if (defender.volatile.burningBulwark) {
                const attackerTypes = attacker.types || [];
                const canBurn = !attackerTypes.includes('Fire');
                if (canBurn && !attacker.status) {
                    attacker.status = 'brn';
                    protectEffect = { type: 'burn', msg: `${attacker.cnName} è¢«ç¼ä¼¤äº†ï¼` };
                }
            }
            // éæ— å½¢æ‹³çš„æƒ…å†µï¼Œå®ˆä½æˆåŠŸ
            return { 
                damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true,
                protectEffect 
            };
        }
        // éæ¥è§¦ç±»æ‹›å¼ä¹Ÿè¢«å®ˆä½æŒ¡ä½
        if (!isContact) {
            return { 
                damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true,
                protectEffect: null 
            };
        }
        // æ— å½¢æ‹³ç©¿é€å®ˆä½çš„æƒ…å†µï¼Œç»§ç»­æ‰§è¡Œåç»­ä¼¤å®³è®¡ç®—
    }
    // === ã€ç ´æ ¼ç³»ç‰¹æ€§ã€‘åˆ¤å®š ===
    const attackerAbilityId = (attacker.ability || '').toLowerCase().replace(/[^a-z]/g, '');
    const moldBreakerAbilities = ['moldbreaker', 'teravolt', 'turboblaze'];
    const moldBreakerMoves = ['sunsteelstrike', 'moongeistbeam', 'photongeyser', 'menacingmoonrazemaelstrom', 'searingsunrazesmash'];
    const ignoresAbilities = moldBreakerAbilities.includes(attackerAbilityId) || 
                             moldBreakerMoves.includes(moveId);
    // === ç‰¹æ€§å…ç–«åˆ¤å®š Hook ===
    if (!ignoresAbilities && typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onImmunity && ahDef.onImmunity(move.type, move)) {
            console.log(`[ABILITY IMMUNE] ${defender.cnName} çš„ ${defender.ability} å…ç–«äº† ${move.name}ï¼`);
            return { damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true, abilityImmune: defender.ability };
        }
        // ã€ä¿®å¤ã€‘onTryHit éœ€è¦é¢„è®¡ç®— effectiveness ç”¨äº Wonder Guard ç­‰ç‰¹æ€§
        if (ahDef.onTryHit) {
            // é¢„è®¡ç®—å±æ€§å…‹åˆ¶å€ç‡
            const defensiveTypes = defender.types || ['Normal'];
            const preEffectiveness = getTypeEffectiveness(move.type || 'Normal', defensiveTypes, move.name);
            const tryHitResult = ahDef.onTryHit(attacker, defender, move, preEffectiveness);
            if (tryHitResult && tryHitResult.blocked) {
                console.log(`[ABILITY BLOCK] ${tryHitResult.message || defender.ability + ' é˜»æ­¢äº†æ”»å‡»'}`);
                return { damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true, abilityImmune: defender.ability };
            }
        }
    }
    if (ignoresAbilities && defender.ability) {
        console.log(`[MOLD BREAKER] ${attacker.cnName} çš„ç‰¹æ€§/æ‹›å¼æ— è§†äº† ${defender.cnName} çš„ ${defender.ability}ï¼`);
    }
    // å˜åŒ–æŠ€ä¸é€ æˆä¼¤å®³
    if (basePower === 0 || category === 'Status') {
        // === ã€æ¶ä½œå‰§ä¹‹å¿ƒã€‘æ¶ç³»å…ç–«æ£€æŸ¥ ===
        const isPrankster = attackerAbilityId === 'prankster';
        const defenderTypes = defender.types || [];
        const defenderIsDark = defenderTypes.includes('Dark');
        const moveTarget = fullMoveData.target || 'normal';
        const targetsOpponent = ['normal', 'randomNormal', 'allAdjacentFoes', 'foeSide', 'any', 'adjacentFoe'].includes(moveTarget);
        if (isPrankster && defenderIsDark && targetsOpponent) {
            console.log(`[PRANKSTER IMMUNITY] ${defender.cnName} æ˜¯æ¶ç³»ï¼Œå…ç–«äº† ${attacker.cnName} çš„æ¶ä½œå‰§ä¹‹å¿ƒå˜åŒ–æŠ€ï¼`);
            return { 
                damage: 0, effectiveness: 0, isCrit: false, miss: false, hitCount: 0, blocked: true, 
                pranksterImmune: true,
                message: `${defender.cnName} æ˜¯æ¶å±æ€§ï¼Œå…ç–«äº†æ¶ä½œå‰§ä¹‹å¿ƒçš„æ•ˆæœï¼`
            };
        }
        // å˜åŒ–æŠ€å‘½ä¸­åˆ¤å®š
        let statusAcc = (accuracy === true || accuracy === undefined) ? 100 : accuracy;
        const accStage = attacker.boosts.accuracy;
        const evaStage = defender.boosts.evasion;
        const finalStage = Math.min(6, Math.max(-6, accStage - evaStage));
        let accMult = 1.0;
        if (finalStage >= 0) accMult = (3 + finalStage) / 3;
        else accMult = 3 / (3 + Math.abs(finalStage));
        const finalAcc = statusAcc * accMult;
        if (statusAcc < 100 && Math.random() * 100 >= finalAcc) {
            return { damage: 0, effectiveness: 1, isCrit: false, miss: true, hitCount: 0 };
        }
        return { damage: 0, effectiveness: 1, isCrit: false, miss: false, hitCount: 0 };
    }
    // === å‘½ä¸­åˆ¤å®š ===
    let moveAcc = (accuracy === true || accuracy === undefined) ? 100 : accuracy;
    // æ— é˜²å®ˆ (No Guard)
    const attackerHasNoGuard = attackerAbilityId === 'noguard';
    const defenderHasNoGuard = (defender.ability || '').toLowerCase().replace(/[^a-z]/g, '') === 'noguard';
    const alwaysHit = accuracy === true || attackerHasNoGuard || defenderHasNoGuard;
    // å¿…ä¸­æ‹›å¼åˆ—è¡¨
    const neverMissMoves = ['aerialace', 'aurasphere', 'clearsmog', 'disarmingvoice', 'feintattack', 
        'magicalleaf', 'magnetbomb', 'shadowpunch', 'shockwave', 'smartstrike', 'swift', 'vitalthrow'];
    const isNeverMiss = neverMissMoves.includes(moveId);
    // å‘½ä¸­/é—ªé¿ä¿®æ­£
    const accStage = attacker.boosts.accuracy || 0;
    const evaStage = defender.boosts.evasion || 0;
    const getAccuracyMultiplier = (stage) => {
        const clampedStage = Math.min(6, Math.max(-6, stage));
        if (clampedStage >= 0) return (3 + clampedStage) / 3;
        return 3 / (3 - clampedStage);
    };
    const accMult = getAccuracyMultiplier(accStage);
    const evaMult = getAccuracyMultiplier(-evaStage);
    let hitRate = moveAcc * accMult / evaMult;
    if (alwaysHit || isNeverMiss) {
        hitRate = 100;
    }
    // Z æ‹›å¼å’Œæå·¨æ‹›å¼å¿…ä¸­
    const isZMove = move.isZ || (move.name && (
        move.name.includes('10,000,000') ||
        move.name.includes('Catastropika') ||
        move.name.includes('Breakneck Blitz') ||
        move.name.includes('Inferno Overdrive') ||
        move.name.includes('Hydro Vortex') ||
        move.name.includes('Gigavolt Havoc')
    ));
    const isMaxMove = move.isMax || (move.name && (
        move.name.startsWith('Max ') ||
        move.name.startsWith('G-Max ')
    ));
    const isSureHit = isZMove || isMaxMove || accuracy === true;
    // === Insight å¥‡è¿¹é—ªé¿ ===
    if (isSureHit && defender.isAce && defender.avs && defender.avs.insight >= 250) {
        const baseInsight = defender.getEffectiveAVs('insight');
        const effectiveInsight = defender.avsEvolutionBoost ? baseInsight * 2 : baseInsight;
        const miracleChance = effectiveInsight >= 255 ? 10 : 5;
        if (Math.random() * 100 < miracleChance) {
            console.log(`[Insight] MIRACLE DODGE TRIGGERED! Bypassed Sure-Hit.`);
            return {
                damage: 0, effectiveness: 0, isCrit: false, miss: true, hitCount: 0,
                insightMiracle: true
            };
        }
    }
    // === AVs: Insight é—ªé¿åŠ æˆ ===
    // ã€çº¿æ€§æœºåˆ¶ã€‘é—ªé¿åŠ æˆ = (effectiveInsight / 255) * 20
    // æ»¡å€¼ 255 æ—¶ 20% é—ªé¿åŠ æˆï¼Œ100 æ—¶çº¦ 8% é—ªé¿åŠ æˆ
    if (defender.isAce && defender.avs && defender.avs.insight > 0 && !isSureHit) {
        const baseInsight = defender.getEffectiveAVs('insight');
        const effectiveInsight = defender.avsEvolutionBoost ? baseInsight * 2 : baseInsight;
        // çº¿æ€§é—ªé¿åŠ æˆï¼šæ»¡å€¼ 20%ï¼Œæœ€ä½ 1%
        let evasionBonus = Math.max(1, Math.floor((effectiveInsight / 255) * 20));
        hitRate = Math.max(20, hitRate - evasionBonus); // æœ€ä½å‘½ä¸­ç‡é™è‡³ 20%
        console.log(`[AVs] Insight é—ªé¿åŠ æˆ: -${evasionBonus}% (Insight: ${baseInsight}${defender.avsEvolutionBoost ? ' x2' : ''})`);
    }
    // ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘DODGE! æŒ‡ä»¤ï¼šå›ºå®š 50% é—ªé¿åŠ æˆ
    if (defender.commandDodgeActive && !isSureHit) {
        const dodgeBonus = 50; // å›ºå®š 50% é—ªé¿
        hitRate = Math.max(20, hitRate - dodgeBonus);
        console.log(`[COMMANDER] DODGE! æŒ‡ä»¤æ¿€æ´»ï¼å›ºå®šé—ªé¿ -${dodgeBonus}% (å‘½ä¸­ç‡: ${hitRate}%)`);
    }
    // Miss æ£€æµ‹
    if (typeof accuracy === 'number' && !isSureHit) {
        if (Math.random() * 100 > hitRate) {
            return { damage: 0, effectiveness: 0, isCrit: false, miss: true, hitCount: 0, insightDodge: defender.avs?.insight >= 100 };
        }
    }
    // === å¤šæ®µæ”»å‡» (Multi-Hit) ===
    let hitCount = 1;
    const multihit = fullMoveData.multihit;
    if (multihit) {
        if (Array.isArray(multihit)) {
            const [min, max] = multihit;
            if (attackerAbilityId === 'skilllink') {
                hitCount = max;
                console.log(`[SKILL LINK] ${attacker.cnName} çš„è¿ç»­æ”»å‡»ç‰¹æ€§å‘åŠ¨ï¼å¼ºåˆ¶å‘½ä¸­ ${max} æ¬¡ï¼`);
            } else {
                hitCount = Math.floor(Math.random() * (max - min + 1)) + min;
            }
        } else {
            hitCount = multihit;
        }
    }
    // === é€‰æ‹©æ”»å‡»/é˜²å¾¡èƒ½åŠ› ===
    const isSpecial = (move.cat === 'spec' || category === 'Special');
    let atkStat = isSpecial ? attacker.getStat('spa') : attacker.getStat('atk');
    let defStat = isSpecial ? defender.getStat('spd') : defender.getStat('def');
    // === ã€çº¯æœ´ Unawareã€‘ç‰¹æ€§å¤„ç† ===
    if (typeof AbilityHandlers !== 'undefined') {
        const attackerHandler = attacker.ability ? AbilityHandlers[attacker.ability] : null;
        const defenderHandler = defender.ability ? AbilityHandlers[defender.ability] : null;
        if (attackerHandler && attackerHandler.ignoreDefenderBoosts) {
            const baseDefStat = isSpecial ? defender.spd : defender.def;
            if (defStat > baseDefStat) {
                console.log(`[UNAWARE] ${attacker.cnName} çš„çº¯æœ´æ— è§†äº† ${defender.cnName} çš„é˜²å¾¡æå‡`);
                defStat = baseDefStat;
            }
        }
        if (defenderHandler && defenderHandler.ignoreAttackerBoosts) {
            const baseAtkStat = isSpecial ? attacker.spa : attacker.atk;
            if (atkStat > baseAtkStat) {
                console.log(`[UNAWARE] ${defender.cnName} çš„çº¯æœ´æ— è§†äº† ${attacker.cnName} çš„æ”»å‡»æå‡`);
                atkStat = baseAtkStat;
            }
        }
    }
    // === ç­–ç•¥æ¨¡å¼ï¼šç‰¹æ®Šæ”»é˜²è®¡ç®— ===
    if (handler && handler.modifyAtk) {
        atkStat = handler.modifyAtk(attacker, defender, isSpecial);
    }
    if (handler && handler.modifyDef) {
        defStat = handler.modifyDef(attacker, defender, isSpecial);
    }
    // === ç¼ä¼¤å‡åŠç‰©æ”» ===
    const ignoresBurnDrop = attacker.ability === 'Guts';
    if (!isSpecial && attacker.status === 'brn' && !ignoresBurnDrop) {
        atkStat = Math.floor(atkStat * 0.5);
    }
    // === é˜²å¾¡æ–¹å±æ€§åˆ¤å®š ===
    let defensiveTypes = defender.types || ['Normal'];
    if (defender.isTerastallized) {
        if (defender.teraType === 'Stellar') {
            defensiveTypes = defender.originalTypes || defender.types;
            console.log(`[STELLAR] ${defender.name} æ˜¯æ˜Ÿæ™¶çŠ¶æ€ï¼Œé˜²å¾¡å±æ€§å›å½’ä¸º: ${defensiveTypes.join('/')}`);
        } else {
            defensiveTypes = [defender.teraType];
        }
    }
    // å±æ€§å…‹åˆ¶
    // ã€ä¿®å¤ã€‘ç¡®ä¿ moveType æœ‰æ•ˆï¼Œä¼˜å…ˆä½¿ç”¨ move.typeï¼Œå›é€€åˆ° fullMoveData.type
    const moveType = move.type || fullMoveData.type || 'Normal';
    let effectiveness = getTypeEffectiveness(moveType, defensiveTypes, move.name);
    // === æœ¬ç³»åŠ æˆ (STAB) ===
    let stab = 1;
    if (attacker.isTerastallized) {
        const teraType = attacker.teraType;
        const originalTypes = attacker.originalTypes || [];
        const stabMoveType = moveType; // ä½¿ç”¨ä¸Šé¢å·²ä¿®å¤çš„ moveType
        if (teraType === 'Stellar') {
            if (originalTypes.includes(moveType)) {
                stab = 2.0; 
                console.log(`[STELLAR STAB] ${attacker.name} åŸç”Ÿæœ¬ç³»å¼ºåŒ– (${moveType}) -> 2.0x`);
            } else {
                stab = 1.2;
                console.log(`[STELLAR STAB] ${attacker.name} æ˜Ÿæ™¶å…¨èƒ½å¼ºåŒ– (${moveType}) -> 1.2x`);
            }
            if (move.name === 'Tera Blast') {
                stab = 2.0; 
            }
        } else {
            let teraTrackBonus = 0;
            if (moveType === teraType) {
                teraTrackBonus = 1.5;
                if (originalTypes.includes(teraType)) {
                    teraTrackBonus = 2.0;
                }
            }
            let recallTrackBonus = 0;
            if (originalTypes.includes(moveType)) {
                recallTrackBonus = 1.5;
            }
            stab = Math.max(teraTrackBonus, recallTrackBonus, 1);
            if (stab > 1) {
                console.log(`[TERA STAB] ${attacker.name} (Tera: ${teraType}, Original: ${originalTypes.join('/')}) ä½¿ç”¨ ${moveType} æ‹›å¼, STAB: ${stab}x`);
            }
        }
    } else {
        // é˜²æŠ¤ï¼šç¡®ä¿ attacker.types æ˜¯æœ‰æ•ˆæ•°ç»„ï¼Œä½¿ç”¨ä¿®å¤åçš„ moveType
        stab = (Array.isArray(attacker.types) && attacker.types.includes(moveType)) ? 1.5 : 1;
    }
    // === é€‚åº”åŠ›ç‰¹æ€§ ===
    if (!attacker.isTerastallized && stab > 1 && attacker.ability === 'Adaptability') {
        stab = 2;
    }
    // === ç”Ÿå‘½å®ç  ===
    let lifeOrbBoost = 1;
    const attackerItem = (attacker.item || '').toLowerCase().replace(/[^a-z]/g, '');
    if (attackerItem === 'lifeorb') {
        lifeOrbBoost = 1.3;
    }
    // === æ˜Ÿæ™¶å¤ªæ™¶çˆ†å‘ç‰¹åˆ¤ ===
    if (attacker.isTerastallized && attacker.teraType === 'Stellar' && move.name === 'Tera Blast') {
        if (defender.isTerastallized) {
            console.log(`[STELLAR KILLER] æ˜Ÿæ™¶çˆ†å‘å‡»ä¸­äº†å¤ªæ™¶åŒ–çš„å¯¹æ‰‹ï¼å¼ºåˆ¶æ•ˆæœæ‹”ç¾¤ã€‚`);
            effectiveness = 2.0; 
        } else {
            if (effectiveness < 1 && effectiveness > 0) {
                effectiveness = 1;
            }
        }
    }
    // === ä¼šå¿ƒä¸€å‡»åˆ¤å®š ===
    let isCrit = false;
    let commandCritTriggered = false;
    // ã€ç£¨ç º Laser Focusã€‘å¿…å®šæš´å‡»
    if (attacker.volatile && attacker.volatile.laserfocus) {
        isCrit = true;
        console.log(`[LASER FOCUS] ${attacker.cnName} çš„ç£¨ç ºä½¿æ”»å‡»å¿…å®šæš´å‡»ï¼`);
        delete attacker.volatile.laserfocus;
    } else if (fullMoveData.willCrit) {
        isCrit = true;
    } else {
        // åŸºç¡€æš´å‡»æ¦‚ç‡ï¼š40%
        let baseCritChance = 0.40;
        // AVs: Passion æš´å‡»åŠ æˆ
        // ã€çº¿æ€§æœºåˆ¶ã€‘æš´å‡»æ¦‚ç‡åŠ æˆ = (effectivePassion / 255) * 0.20
        // æ»¡å€¼ 255 æ—¶ +20% æš´å‡»ç‡ï¼ˆæ€»è®¡ 60%ï¼‰
        let passionBonus = 0;
        if (attacker.isAce && attacker.avs && attacker.avs.passion > 0) {
            const basePassion = attacker.getEffectiveAVs('passion');
            const effectivePassion = attacker.avsEvolutionBoost ? basePassion * 2 : basePassion;
            // çº¿æ€§æš´å‡»æ¦‚ç‡åŠ æˆï¼šæ»¡å€¼ +20%
            passionBonus = (Math.min(effectivePassion, 255) / 255) * 0.20;
            console.log(`[AVs] Passion æš´å‡»åŠ æˆ: +${(passionBonus * 100).toFixed(1)}% (Passion: ${basePassion}${attacker.avsEvolutionBoost ? ' x2' : ''})`);
        }
        let critChance = baseCritChance + passionBonus;
        // ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘FOCUS! æŒ‡ä»¤ï¼šæš´å‡»æ¦‚ç‡ç¿»å€
        // æ³¨æ„ï¼šåªæœ‰åœ¨å®é™…æˆ˜æ–—ï¼ˆéæ¨¡æ‹Ÿï¼‰æ—¶æ‰æ¶ˆè€—æŒ‡ä»¤
        if (attacker.commandCritActive) {
            critChance *= 2;
            critChance = Math.min(critChance, 1.0); // ä¸Šé™ 100%
            commandCritTriggered = true;
            console.log(`[COMMANDER] FOCUS! æŒ‡ä»¤æ¿€æ´»ï¼æš´å‡»æ¦‚ç‡ç¿»å€ï¼(${(critChance * 100).toFixed(1)}%)`);
            // åªåœ¨éæ¨¡æ‹Ÿæ¨¡å¼ä¸‹æ¶ˆè€—ï¼ˆisSimulation å‚æ•°ç”±è°ƒç”¨æ–¹ä¼ å…¥ï¼‰
            if (!options.isSimulation) {
                attacker.commandCritActive = false; // ä½¿ç”¨åæ¶ˆè€—
            }
        }
        // æ‹›å¼è‡ªå¸¦é«˜æš´å‡»ç‡åŠ æˆ
        const moveCritRatio = fullMoveData.critRatio || 1;
        if (moveCritRatio >= 2) {
            critChance += 0.125; // +12.5%
        }
        if (moveCritRatio >= 3) {
            critChance += 0.25; // å† +25%
        }
        critChance = Math.min(critChance, 1.0); // ä¸Šé™ 100%
        if (Math.random() < critChance) isCrit = true;
    }
    const critMod = isCrit ? 1.5 : 1;
    // ä¹±æ•°
    const random = 0.85 + Math.random() * 0.15;
    // é˜²æ­¢é™¤ä»¥0
    const finalDef = Math.max(1, defStat);
    // ä¼¤å®³å…¬å¼
    let singleHitDamage = Math.floor(
        ((2 * attacker.level / 5 + 2) * basePower * (atkStat / finalDef) / 50 + 2)
        * stab * effectiveness * critMod * random * lifeOrbBoost
    );
    if (effectiveness > 0 && singleHitDamage < 1) singleHitDamage = 1;
    if (effectiveness === 0) singleHitDamage = 0;
    // === é˜²å¾¡æ–¹ç‰¹æ€§ä¼¤å®³ä¿®æ­£ ===
    if (!ignoresAbilities && typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onDefenderModifyDamage) {
            singleHitDamage = ahDef.onDefenderModifyDamage(singleHitDamage, attacker, defender, move, effectiveness);
        }
    }
    // === åŒå¢™/æå…‰å¹•å‡ä¼¤ ===
    if (typeof battle !== 'undefined' && battle) {
        const defenderSide = (defender === battle.getPlayer?.()) ? battle.playerSide : battle.enemySide;
        if (defenderSide) {
            if (defenderSide.auroraVeil > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
            else if (!isSpecial && defenderSide.reflect > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
            else if (isSpecial && defenderSide.lightScreen > 0) {
                singleHitDamage = Math.floor(singleHitDamage * 0.5);
            }
        }
    }
    // === æŠ—æ€§æ ‘æœå‡ä¼¤ ===
    let resistBerryTriggered = false;
    let resistBerryMessage = '';
    if (typeof ItemEffects !== 'undefined' && ItemEffects.checkResistBerry && effectiveness >= 2) {
        const berryResult = ItemEffects.checkResistBerry(defender, move.type, effectiveness);
        if (berryResult.triggered) {
            singleHitDamage = Math.floor(singleHitDamage * berryResult.damageMultiplier);
            resistBerryTriggered = true;
            resistBerryMessage = berryResult.message;
            console.log(`[RESIST BERRY] ${resistBerryMessage}`);
        }
    }
    // === ç»“å®ç‰¹æ€§ Hook ===
    if (typeof AbilityHandlers !== 'undefined' && defender.ability && AbilityHandlers[defender.ability]) {
        const ahDef = AbilityHandlers[defender.ability];
        if (ahDef.onDamageHack) {
            singleHitDamage = ahDef.onDamageHack(singleHitDamage * hitCount, defender);
            return { 
                damage: singleHitDamage, 
                singleHitDamage,
                effectiveness, 
                isCrit, 
                miss: false, 
                hitCount,
                sturdyActivated: singleHitDamage === defender.currHp - 1
            };
        }
    }
    // æ€»ä¼¤å®³
    const totalDamage = singleHitDamage * hitCount;
    return { 
        damage: totalDamage, 
        singleHitDamage,
        effectiveness, 
        isCrit, 
        miss: false, 
        hitCount,
        resistBerryTriggered,
        resistBerryMessage,
        commandCritTriggered
    };
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
if (typeof window !== 'undefined') {
    window.calcDamage = calcDamage;
}
]]></file>
        <file name="battle-damage.js"><![CDATA[/**
 * ===========================================
 * BATTLE-DAMAGE.JS - ä¼¤å®³ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ä¼¤å®³è®¡ç®—ä¸åº”ç”¨
 * - å‘½ä¸­/Miss å¤„ç†
 * - ç‰¹æ€§å…ç–«æ£€æµ‹
 * - Protect å®ˆä½æ‹¦æˆª
 * - æ›¿èº«å¸æ”¶
 * - å‰¯ä½œç”¨è§¦å‘
 */
// ============================================
// ä¼¤å®³è®¡ç®—ä¸åº”ç”¨
// ============================================
/**
 * ä¼¤å®³è®¡ç®—ä¸åº”ç”¨ (å«å¤šæ®µæ”»å‡»ã€åä¼¤ã€å¸è¡€ã€èƒ½åŠ›å˜åŒ–)
 * @param {Object} attacker æ”»å‡»æ–¹
 * @param {Object} defender é˜²å¾¡æ–¹
 * @param {Object} move æ‹›å¼
 * @param {string} spriteIdRef ç›®æ ‡ç²¾çµå›¾ ID ('player-sprite' æˆ– 'enemy-sprite')
 * @returns {Object} ä¼¤å®³ç»“æœ
 */
function applyDamage(attacker, defender, move, spriteIdRef) {
    const battle = window.battle;
    // === å…³é”®ä¿®å¤ï¼šåœ¨è®¡ç®—ä¼¤å®³å‰æ£€æŸ¥ onUseï¼ˆå¦‚ Fake Out é¦–å›åˆé™åˆ¶ï¼‰ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    const isPlayerAttacking = spriteIdRef !== 'player-sprite';
    // åªå¯¹æ”»å‡»æŠ€åšå‰ç½®æ£€æŸ¥ï¼Œå˜åŒ–æŠ€çš„ onUse åœ¨åé¢å¤„ç†
    const moveCategory = move.cat || '';
    const isStatusMove = moveCategory === 'status' || move.power === 0;
    if (handler && handler.onUse && !isStatusMove) {
        let preLogs = [];
        const preCheck = handler.onUse(attacker, defender, preLogs, battle, isPlayerAttacking);
        if (preCheck && preCheck.failed) {
            preLogs.forEach(txt => log(`<span style="color:#e74c3c">${txt}</span>`));
            return { damage: 0, effectiveness: 0, miss: false, failed: true };
        }
        preLogs.forEach(txt => log(txt));
    }
    // ä½¿ç”¨ battle-engine çš„ä¼¤å®³è®¡ç®—
    const result = calcDamage(attacker, defender, move);
    // 0. å¤„ç†ç‰¹æ€§å…ç–« (æ¼‚æµ®ã€é¿é›·é’ˆç­‰)
    if (result.abilityImmune) {
        log(`<b style='color:#9b59b6'>${defender.cnName} çš„ ${result.abilityImmune} å¸æ”¶/å…ç–«äº†æ”»å‡»!</b>`);
        return result;
    }
    // 0. å¤„ç†æ¶ä½œå‰§ä¹‹å¿ƒå…ç–« (æ¶ç³»å…ç–«å˜åŒ–æŠ€)
    if (result.pranksterImmune) {
        log(`<b style='color:#8b5cf6'>${result.message || defender.cnName + ' æ˜¯æ¶å±æ€§ï¼Œå…ç–«äº†æ¶ä½œå‰§ä¹‹å¿ƒçš„æ•ˆæœï¼'}</b>`);
        return result;
    }
    // 0. å¤„ç† Protect å®ˆä½æ‹¦æˆª
    if (result.blocked) {
        log(`<b style='color:#3498db'>${defender.cnName} å®ˆä½äº†è‡ªå·±ï¼Œå…å—äº†æ”»å‡»!</b>`);
        // å®ˆä½ç±»æ‹›å¼çš„æ¥è§¦ååˆ¶æ•ˆæœ
        if (result.protectEffect) {
            log(`<b style='color:#e74c3c'>${result.protectEffect.msg}</b>`);
            updateAllVisuals();
        }
        // æ¸…é™¤å®ˆä½çŠ¶æ€ï¼ˆå·²ä½¿ç”¨ï¼‰
        if (defender.volatile) {
            defender.volatile.protect = false;
            defender.volatile.banefulBunker = false;
            defender.volatile.spikyShield = false;
            defender.volatile.kingsShield = false;
            defender.volatile.obstruct = false;
            defender.volatile.silkTrap = false;
            defender.volatile.burningBulwark = false;
        }
        // High Jump Kick / Jump Kick å¤±è´¥åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        return result;
    }
    // I. å¤„ç† MISS
    if (result.miss) {
        if (result.insightMiracle) {
            log(`<b style="color:#d4ac0d; text-shadow:0 0 5px gold;">âœ¨ ä¸å¯èƒ½çš„å¥‡è¿¹ï¼${defender.cnName} çœ‹ç©¿äº†ç»å¯¹å‘½ä¸­çš„è½¨è¿¹ï¼(Insight EX)</b>`);
        } else if (defender.commandDodgeActive) {
            // ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘DODGE! æŒ‡ä»¤æˆåŠŸé—ªé¿
            log(`<b style='color:#aaa'>ä½†æ˜¯æ”»å‡»æ²¡æœ‰å‘½ä¸­!</b>`);
            log(`<b style="color:#00cec9; text-shadow:0 0 8px #00cec9;">ğŸ‘ï¸ ${defender.cnName} å¬ä»äº†è®­ç»ƒå®¶çš„æŒ‡æŒ¥ï¼Œåä¸½åœ°é—ªé¿äº†æ”»å‡»ï¼[DODGE!]</b>`);
            defender.commandDodgeActive = false; // ä½¿ç”¨åæ¶ˆè€—
        } else if (result.insightDodge && defender.avs && defender.avs.insight >= 100) {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ”»å‡»æ²¡æœ‰å‘½ä¸­!</b>`);
            log(`<b style="color:#a78bfa">âœ¨ ${defender.cnName} å‡­å€ŸçµçŠ€æ„Ÿåº”é¢„åˆ¤äº†æ”»å‡»è½¨è¿¹! (Insight${defender.avsEvolutionBoost ? ' x2' : ''})</b>`);
        } else {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ”»å‡»æ²¡æœ‰å‘½ä¸­!</b>`);
        }
        // High Jump Kick / Jump Kick å¤±è´¥åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        return result;
    }
    // II. å˜åŒ–æŠ€ (Power=0, Status Move)
    if (result.damage === 0 && move.power === 0) {
        // æ£€æŸ¥æ˜¯å¦ä¸ºåå¼¹æŠ€èƒ½ï¼ˆCounter/Mirror Coat/Metal Burstï¼‰
        const reflectHandler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
        if (reflectHandler && reflectHandler.isReflectMove) {
            let reflectLogs = [];
            const reflectResult = reflectHandler.onUse(attacker, defender, reflectLogs, battle, spriteIdRef !== 'player-sprite');
            reflectLogs.forEach(txt => log(txt));
            if (reflectResult && reflectResult.failed) {
                return result;
            }
            if (reflectResult && reflectResult.damage > 0) {
                defender.takeDamage(reflectResult.damage);
                log(`é€ æˆäº† <b style="color:#e74c3c">${reflectResult.damage}</b> ä¼¤å®³ï¼`);
                const targetEl = document.getElementById(spriteIdRef);
                if (targetEl) {
                    targetEl.classList.remove('shake-hit-anim');
                    void targetEl.offsetWidth;
                    targetEl.classList.add('shake-hit-anim');
                    if (defender.currHp <= 0) {
                        targetEl.classList.add('fainting');
                    }
                }
                result.damage = reflectResult.damage;
                updateAllVisuals();
            }
            return result;
        }
        // å˜åŒ–æŠ€ Miss åˆ¤å®š
        if (result.miss) {
            log(`<b style='color:#aaa'>ä½†æ˜¯æ²¡æœ‰å‘½ä¸­!</b>`);
            return result;
        }
        // å¤„ç† Volatile çŠ¶æ€æŠ€èƒ½ (Taunt, Substitute ç­‰)
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyVolatileStatus) {
            const volatileResult = MoveEffects.applyVolatileStatus(attacker, defender, move);
            if (volatileResult.success) {
                volatileResult.logs.forEach(txt => log(txt));
                return result;
            } else if (volatileResult.logs.length > 0) {
                volatileResult.logs.forEach(txt => log(txt));
                return result;
            }
        }
        // å¤„ç†å˜åŒ–æŠ€çš„èƒ½åŠ›å˜åŒ–
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, 0, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        if (fxLogs.length > 0) {
            fxLogs.forEach(txt => log(txt));
        } else {
            log(`...${move.cn}! (å˜åŒ–æŠ€èƒ½)`);
        }
        result.pivot = fxResult.pivot || false;
        return result;
    }
    // === Disguise (ç”»çš®) ç‰¹æ€§å¤„ç† ===
    if (defender.disguiseBustDamage && defender.disguiseBustDamage > 0) {
        log(`<b style="color:#9b59b6">ğŸ­ ${defender.cnName} çš„ç”»çš®ç ´æŸäº†!</b>`);
        log(`<b style="color:#3498db">${defender.cnName} å…ç–«äº†è¿™æ¬¡æ”»å‡»!</b>`);
        defender.takeDamage(defender.disguiseBustDamage);
        log(`<span style="color:#e67e22">${defender.cnName} å—åˆ°äº†ç”»çš®ç ´æŸçš„ä¼¤å®³! (-${defender.disguiseBustDamage})</span>`);
        defender.disguiseBustDamage = 0;
        updateAllVisuals();
        return result;
    }
    // III. å¦‚æœæœ‰ä¼¤å®³ -> æ‰£è¡€
    const dmgCategory = (move.cat || result.category || 'physical').toLowerCase();
    if (result.damage > 0) {
        // æ£€æŸ¥æ›¿èº«æ˜¯å¦å¸æ”¶ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.checkSubstitute) {
            const subResult = MoveEffects.checkSubstitute(defender, result.damage, move);
            if (subResult.absorbed) {
                subResult.logs.forEach(txt => log(txt));
                result.damage = 0;
                updateAllVisuals();
                return result;
            }
        }
        // ã€ä¿®å¤ã€‘è®°å½•å®é™…é€ æˆçš„ä¼¤å®³ï¼ˆä¸è¶…è¿‡ç›®æ ‡å½“å‰HPï¼‰ç”¨äºæ—¥å¿—æ˜¾ç¤º
        const actualDamage = Math.min(result.damage, defender.currHp);
        defender.takeDamage(result.damage, dmgCategory);
        result.displayDamage = actualDamage; // ç”¨äºæ—¥å¿—æ˜¾ç¤ºçš„å®é™…ä¼¤å®³
        // === æ’­æ”¾æ‰“å‡»éŸ³æ•ˆ ===
        if (typeof window.playHitSFX === 'function') {
            window.playHitSFX(result.effectiveness, result.isCrit);
        }
        // Focus Sash è§¦å‘æ—¥å¿—
        if (defender.focusSashTriggered) {
            log(`<b style="color:#f1c40f">ğŸ›¡ï¸ ${defender.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼å‹‰å¼ºæ’‘ä½äº†æ”»å‡»ï¼</b>`);
            defender.focusSashTriggered = false;
        }
        // AVs: Trust (ä¿¡èµ–) é”è¡€è§¦å‘æ—¥å¿—
        if (defender.trustEndureTriggered) {
            log(`<b style="color:#e91e63">ğŸ’– ${defender.cnName} å‡­å€Ÿä¸è®­ç»ƒå®¶çš„ç¾ç»Šï¼Œç”¨è„¸æ¥ä¸‹äº†è‡´å‘½ä¸€å‡»! (Trust)</b>`);
            defender.trustEndureTriggered = false;
        }
        // Second Wind (ç¬¬äºŒæ°”æ¯) è§¦å‘æ—¥å¿—
        if (defender.secondWindActivated) {
            log(`<b style="color:#ff6b35">ğŸ”¥ ${defender.cnName} çš„ç¬¬äºŒæ°”æ¯è§‰é†’äº†!</b>`);
            log(`<b style="color:#ff6b35">ğŸ’ª å…¨å±æ€§æå‡! æ”»å‡»+1 é˜²å¾¡+1 ç‰¹æ”»+1 ç‰¹é˜²+1 é€Ÿåº¦+1!</b>`);
            defender.secondWindActivated = false;
        }
        // ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘HOLD ON! æŒ‡ä»¤è§¦å‘æ—¥å¿—
        if (defender.commandEndureTriggered) {
            log(`<b style="color:#a55eea; text-shadow:0 0 8px #a55eea;">ğŸ›¡ï¸ ${defender.cnName} åœ¨è®­ç»ƒå®¶çš„å‘¼å–Šä¸‹æ’‘ä½äº†ï¼</b>`);
            defender.commandEndureTriggered = false;
        }
        // Bond Endure (ç¾ç»ŠæŒºä½) è§¦å‘æ—¥å¿— - è¿›åŒ–æ‹¦æˆªå™¨
        if (defender.bondEndureActivated) {
            log(`<b style="color:#d4ac0d; text-shadow:0 0 8px gold;">âœ¨ ${defender.cnName} å› ä¸ºæƒ³å›åº”è®­ç»ƒå®¶çš„æœŸå¾…ï¼Œæ’‘ä½äº†ï¼</b>`);
            log(`<span style="color:#fbbf24;">ğŸ’« è¿›åŒ–çš„å…‰èŠ’æ­£åœ¨æ¶ŒåŠ¨...æŒ‰ä¸‹ [EVO] æŒ‰é’®æ¥å›åº”å®ƒçš„æ„å¿—ï¼</span>`);
            defender.bondEndureActivated = false;
            // ç«‹å³æ›´æ–° EVO æŒ‰é’®å¯è§æ€§
            if (typeof updateEvolutionButtonVisuals === 'function') {
                updateEvolutionButtonVisuals();
            }
        }
        // === HP é˜ˆå€¼æ ‘æœæ£€æŸ¥ï¼ˆæ–‡æŸšæœã€æ··ä¹±æœç­‰ï¼‰===
        // ã€ä¿®å¤ã€‘å…ˆæ£€æŸ¥æ ‘æœè§¦å‘ï¼Œä½†å»¶è¿Ÿè¾“å‡ºæ—¥å¿—ï¼Œç¡®ä¿åœ¨ä¼¤å®³æ—¥å¿—ä¹‹åæ˜¾ç¤º
        let berryLogs = [];
        let berryTriggered = false;
        let cheekPouchHeal = 0;
        if (defender.currHp > 0 && typeof ItemEffects !== 'undefined' && ItemEffects.checkHPBerry) {
            berryTriggered = ItemEffects.checkHPBerry(defender, berryLogs);
            if (berryTriggered) {
                // é¢Šå›Šç‰¹æ€§ï¼šåƒæ ‘æœæ—¶é¢å¤–å›å¤ 33% HP
                const abilityId = (defender.ability || '').toLowerCase().replace(/[^a-z]/g, '');
                if (abilityId === 'cheekpouch') {
                    cheekPouchHeal = Math.floor(defender.maxHp * 0.33);
                    defender.currHp = Math.min(defender.maxHp, defender.currHp + cheekPouchHeal);
                }
            }
        }
        // æ’­æ”¾å—å‡»åŠ¨ç”»
        const targetEl = document.getElementById(spriteIdRef);
        if (targetEl) {
            targetEl.classList.remove('shake-hit-anim');
            targetEl.classList.remove('fainting');
            void targetEl.offsetWidth;
            targetEl.classList.add('shake-hit-anim');
            if (defender.currHp <= 0) {
                targetEl.classList.add('fainting');
                setTimeout(() => {
                    targetEl.classList.remove('fainting');
                    targetEl.classList.add('fainted-hidden');
                }, 750);
            }
        }
        // æ„å»ºä¼¤å®³æ–‡æœ¬
        let infoParts = [];
        if (result.hitCount > 1) {
            infoParts.push(`<span style="color:#9b59b6">(å‘½ä¸­ ${result.hitCount} æ¬¡)</span>`);
        }
        if (result.effectiveness >= 2) infoParts.push('<b style="color:#e74c3c">(æ•ˆæœæ‹”ç¾¤!)</b>');
        else if (result.effectiveness <= 0.5 && result.effectiveness > 0) infoParts.push('(æ•ˆæœä¸å¥½...)');
        // æŠ—æ€§æ ‘æœè§¦å‘æ¶ˆæ¯
        if (result.resistBerryTriggered && result.resistBerryMessage) {
            log(`<span style="color:#27ae60">ğŸ‡ ${result.resistBerryMessage}</span>`);
        }
        if (result.isCrit) {
            infoParts.push('<b class="hl-crit">å‡»ä¸­è¦å®³!</b>');
            // ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘FOCUS! æŒ‡ä»¤è§¦å‘çš„æš´å‡»
            if (result.commandCritTriggered) {
                infoParts.push(`<b style="color:#ff6b6b; text-shadow:0 0 5px #ff6b6b;">ğŸ”¥ [FOCUS!]</b>`);
            } else if (attacker.avs && attacker.avs.passion >= 100) {
                infoParts.push(`<b style="color:#f59e0b">ğŸ”¥ (Passion${attacker.avsEvolutionBoost ? ' x2' : ''})</b>`);
            }
        }
        const infoStr = infoParts.join(' ');
        // ã€ä¿®å¤ã€‘ä½¿ç”¨ displayDamage æ˜¾ç¤ºå®é™…é€ æˆçš„ä¼¤å®³ï¼Œé¿å…æ˜¾ç¤ºè¶…è¿‡ç›®æ ‡HPçš„æ•°å€¼
        const shownDamage = result.displayDamage !== undefined ? result.displayDamage : result.damage;
        // ã€ä¿®å¤ã€‘å¦‚æœæ˜¯è‡´å‘½ä¸€å‡»ï¼ˆå‡»æ€ç›®æ ‡ï¼‰ï¼Œä¸æ˜¾ç¤ºå˜²è®½æ–‡æœ¬
        const isKillingBlow = defender.currHp <= 0;
        if (shownDamage <= 2 && result.effectiveness > 0 && !isKillingBlow) {
            log(`é€ æˆäº† <span style="color:#95a5a6">${shownDamage}</span> ä¼¤å®³... (ä»¿ä½›æ˜¯åœ¨ç»™å¯¹æ‰‹æŒ ç—’ç—’) ${infoStr}`);
        } else {
            log(`é€ æˆäº† ${shownDamage} ä¼¤å®³ ${infoStr}`);
        }
        // ã€ä¿®å¤ã€‘åœ¨ä¼¤å®³æ—¥å¿—ä¹‹åè¾“å‡ºæ ‘æœè§¦å‘æ—¥å¿—
        if (berryTriggered && berryLogs.length > 0) {
            berryLogs.forEach(txt => log(txt));
            if (cheekPouchHeal > 0) {
                log(`<span style="color:#27ae60">ğŸ¿ï¸ ${defender.cnName} çš„é¢Šå›Šå‘åŠ¨äº†ï¼é¢å¤–å›å¤äº† ${cheekPouchHeal} ç‚¹ä½“åŠ›ï¼</span>`);
            }
            updateAllVisuals();
        }
        // ã€å¼±ç‚¹ä¿é™© (Weakness Policy)ã€‘è¢«æ•ˆæœæ‹”ç¾¤æ”»å‡»åï¼Œæ”»å‡»å’Œç‰¹æ”»å„+2
        const defenderItem = (defender.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (result.effectiveness >= 2 && defenderItem === 'weaknesspolicy' && defender.currHp > 0) {
            log(`<b style="color:#e67e22">ğŸ“„ ${defender.cnName} çš„å¼±ç‚¹ä¿é™©ç”Ÿæ•ˆäº†ï¼</b>`);
            if (!defender.boosts) defender.boosts = {};
            defender.boosts.atk = Math.min(6, (defender.boosts.atk || 0) + 2);
            defender.boosts.spa = Math.min(6, (defender.boosts.spa || 0) + 2);
            log(`<span style="color:#ef4444">ğŸ’ª ${defender.cnName} çš„æ”»å‡»å¤§å¹…æå‡ï¼</span>`);
            log(`<span style="color:#a855f7">âœ¨ ${defender.cnName} çš„ç‰¹æ”»å¤§å¹…æå‡ï¼</span>`);
            defender.item = null; // æ¶ˆè€—å“
            if (typeof window !== 'undefined' && typeof window.playSFX === 'function') {
                window.playSFX('STAT_UP');
            }
            updateAllVisuals();
        }
    } else if (result.effectiveness === 0) {
        log(`<b>å¯¹å…¶æ²¡æœ‰æ•ˆæœ!</b>`);
        // High Jump Kick / Jump Kick æ‰“åˆ°å…ç–«å±æ€§æ—¶çš„åä¼¤
        if (move.name === 'High Jump Kick' || move.name === 'Jump Kick') {
            const crashDmg = Math.floor(attacker.maxHp / 2);
            attacker.takeDamage(crashDmg);
            log(`<b style='color:#e74c3c'>${attacker.cnName} å¤±å»äº†å¹³è¡¡ï¼Œæ‘”å€’å—åˆ°äº† ${crashDmg} ç‚¹ä¼¤å®³!</b>`);
        }
        result.pivot = false;
        return result;
    }
    // IV. è§¦å‘å‰¯ä½œç”¨
    // ã€ä¿®å¤ã€‘ä½¿ç”¨ actualDamageï¼ˆå®é™…é€ æˆçš„ä¼¤å®³ï¼‰è€Œä¸æ˜¯ result.damageï¼ˆç†è®ºä¼¤å®³ï¼‰
    // è¿™æ ·åä½œç”¨åŠ›è®¡ç®—æ‰ä¼šåŸºäºå®é™…ä¼¤å®³ï¼Œé¿å…é”è¡€ååä¼¤è¿‡é«˜çš„BUG
    const actualDamageForRecoil = result.displayDamage !== undefined ? result.displayDamage : result.damage;
    let pivotTriggered = false;
    if (defender.currHp > 0) {
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, actualDamageForRecoil, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        pivotTriggered = fxResult.pivot || false;
        fxLogs.forEach(txt => log(`<span style="font-size:0.95em;color:#e67e22">${txt}</span>`));
        // === ã€æ‹è½ Knock Offã€‘å¤„ç† ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyKnockOff) {
            const knockOffResult = MoveEffects.applyKnockOff(attacker, defender, move);
            knockOffResult.logs.forEach(txt => log(`<span style="color:#8b5cf6">${txt}</span>`));
        }
        // === ã€æŸç¼šæ‹›å¼ã€‘å¤„ç† (Fire Spin, Magma Storm ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyTrappingMove) {
            const trapResult = MoveEffects.applyTrappingMove(attacker, defender, move);
            trapResult.logs.forEach(txt => log(`<span style="color:#dc2626">${txt}</span>`));
        }
        // === ã€é»‘è‰²ç›®å…‰/ç¼å½±ã€‘å¤„ç† ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyMeanLook) {
            const meanLookResult = MoveEffects.applyMeanLook(attacker, defender, move);
            meanLookResult.logs.forEach(txt => log(`<span style="color:#7c3aed">${txt}</span>`));
        }
    } else {
        // é˜²å¾¡æ–¹è¢«å‡»å€’
        const fxResult = applyMoveSecondaryEffects(attacker, defender, move, actualDamageForRecoil, battle, spriteIdRef !== 'player-sprite');
        const fxLogs = Array.isArray(fxResult) ? fxResult : (fxResult.logs || []);
        pivotTriggered = fxResult.pivot || false;
        const attackerOnlyLogs = fxLogs.filter(txt => 
            txt.includes(attacker.cnName) || 
            txt.includes('åä½œç”¨åŠ›') || 
            txt.includes('å¸å–')
        );
        attackerOnlyLogs.forEach(txt => log(`<span style="font-size:0.95em;color:#e67e22">${txt}</span>`));
        // === ã€åŒå‘½ Destiny Bondã€‘åˆ¤å®š ===
        // å¦‚æœè¢«å‡»å€’çš„å®å¯æ¢¦å¤„äºåŒå‘½çŠ¶æ€ï¼Œæ”»å‡»è€…ä¹Ÿä¼šè¢«å‡»å€’
        if (defender.volatile && defender.volatile.destinyBond && attacker.isAlive()) {
            log(`<b style="color:#9b59b6">ğŸ’€ ${defender.cnName} æ‹‰ç€ ${attacker.cnName} åŒå½’äºå°½äº†ï¼</b>`);
            attacker.takeDamage(attacker.currHp);
            updateAllVisuals();
            result.destinyBondTriggered = true;
        }
    }
    // V. æ›´æ–°æ”»å‡»æ–¹è¡€æ¡
    updateAllVisuals();
    // VI. è¿”å›ç»“æœ
    result.pivot = pivotTriggered;
    return result;
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.applyDamage = applyDamage;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { applyDamage };
}
]]></file>
        <file name="battle-effects.js"><![CDATA[/**
 * ===========================================
 * BATTLE-EFFECTS.JS - æ‹›å¼å‰¯ä½œç”¨å¤„ç†
 * ===========================================
 * 
 * ä» engine/battle-engine.js è¿ç§»
 * 
 * èŒè´£:
 * - èƒ½åŠ›å˜åŒ– (Boosts)
 * - åä¼¤ (Recoil)
 * - å¸è¡€ (Drain)
 * - çŠ¶æ€å¼‚å¸¸
 * - æ¥è§¦ç±»æ‹›å¼åé¦ˆ
 * - ç‰¹æ®ŠæŠ€èƒ½æ•ˆæœ
 * 
 * ä¾èµ–: moves-data.js, move-handlers.js, move-effects.js, ability-handlers.js
 */
/**
 * å¤„ç†æŠ€èƒ½å¸¦æ¥çš„å‰¯ä½œç”¨ï¼ˆèƒ½åŠ›å‡é™ã€åä¼¤ã€å¸è¡€ï¼‰
 * @param {Pokemon} user æ”»å‡»æ–¹
 * @param {Pokemon} target å—å‡»æ–¹
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @param {number} damageDealt å®é™…é€ æˆçš„ä¼¤å®³ï¼ˆç”¨äºè®¡ç®—åä¼¤/å¸è¡€ï¼‰
 * @param {object} battle æˆ˜æ–—çŠ¶æ€
 * @param {boolean} isPlayer æ˜¯å¦ä¸ºç©å®¶
 * @returns {object} { logs: Array, pivot: boolean }
 */
function applyMoveSecondaryEffects(user, target, move, damageDealt = 0, battle = null, isPlayer = false) {
    let logs = [];
    // è·å–å®Œæ•´æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // === ç­–ç•¥æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç‰¹æ®Šå¤„ç†å™¨ ===
    const handler = (typeof getMoveHandler === 'function') ? getMoveHandler(move.name) : null;
    console.log(`[MOVE HANDLER] Looking for handler: "${move.name}", found:`, handler ? 'YES' : 'NO', handler?.onUse ? '(has onUse)' : '');
    // === onUse é’©å­ (å˜åŒ–æŠ€/å¤©æ°”/åœºåœ°ç­‰ï¼Œä»¥åŠæŠ€èƒ½å‰ç½®æ£€æŸ¥å¦‚ Fake Out) ===
    if (handler && handler.onUse) {
        console.log(`[MOVE HANDLER] Calling onUse for "${move.name}", battle:`, battle, 'isPlayer:', isPlayer);
        const result = handler.onUse(user, target, logs, battle, isPlayer);
        console.log(`[MOVE HANDLER] onUse returned, logs now:`, logs);
        if (result) {
            if (result.failed) {
                return { logs, pivot: false };
            }
            if (result.selfDestruct) {
                // è‡ªçˆ†ç±»æŠ€èƒ½å·²åœ¨ handler ä¸­å¤„ç† HP
            }
        }
    }
    // === onHit é’©å­ (å‘½ä¸­åæ•ˆæœ) ===
    let pivotTriggered = false;
    if (handler && handler.onHit) {
        const hitResult = handler.onHit(user, target, damageDealt, logs, battle);
        if (hitResult && hitResult.pivot) {
            pivotTriggered = true;
        }
    }
    // === åœºåœ°çŠ¶æ€æŠ€èƒ½å¤„ç† (sideCondition) ===
    if (fullMoveData.sideCondition && battle) {
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applySideCondition) {
            const sideLogs = MoveEffects.applySideCondition(user, move, battle);
            logs.push(...sideLogs);
        }
    }
    // èƒ½åŠ›åç§°æ˜ å°„
    const statMap = {
        atk: "æ”»å‡»", def: "é˜²å¾¡", spa: "ç‰¹æ”»", spd: "ç‰¹é˜²", spe: "é€Ÿåº¦",
        accuracy: "å‘½ä¸­ç‡", evasion: "é—ªé¿ç‡"
    };
    // å˜åŒ–å¹…åº¦æ–‡æ¡ˆ
    const getChangeText = (val) => {
        if (Math.abs(val) >= 3) return "æå¤§å¹…";
        if (Math.abs(val) === 2) return "å¤§å¹…";
        return "";
    };
    // helperï¼šä¿®æ”¹æŒ‡å®šå¯¹è±¡çš„èƒ½åŠ›
    const changeStats = (subject, boostsObj) => {
        if (!boostsObj) return;
        for (const [stat, val] of Object.entries(boostsObj)) {
            if (typeof val !== 'number') continue;
            const diff = subject.applyBoost(stat, val);
            if (diff === 0) {
                const currentBoost = subject.boosts[stat] || 0;
                if (currentBoost >= 6) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}å·²ç»æ— æ³•å†æå‡äº†!`);
                } else if (currentBoost <= -6) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}å·²ç»æ— æ³•å†é™ä½äº†!`);
                } else {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}æ— æ³•æ”¹å˜!`);
                }
            } else {
                const changeText = getChangeText(diff);
                if (diff > 0) {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}${changeText}æå‡äº†!`);
                    if (typeof window !== 'undefined' && typeof window.playSFX === 'function') window.playSFX('STAT_UP');
                } else {
                    logs.push(`${subject.cnName} çš„${statMap[stat] || stat}${changeText}ä¸‹é™äº†!`);
                    if (typeof window !== 'undefined' && typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
                }
            }
        }
    };
    // ========== 1. èƒ½åŠ›å˜åŒ– (Boosts) ==========
    const selfTargets = ['self', 'allySide', 'adjacentAlly', 'adjacentAllyOrSelf', 'allies'];
    const isTargetSelf = selfTargets.includes(fullMoveData.target);
    // 1.1 Status æ‹›å¼çš„ boosts
    if (fullMoveData.category === 'Status' && fullMoveData.boosts) {
        if (isTargetSelf) {
            changeStats(user, fullMoveData.boosts);
        } else {
            changeStats(target, fullMoveData.boosts);
        }
    }
    // 1.2 self.boostsï¼ˆå¯¹è‡ªå·±ç”Ÿæ•ˆçš„å‰¯ä½œç”¨ï¼‰
    if (fullMoveData.self && fullMoveData.self.boosts) {
        changeStats(user, fullMoveData.self.boosts);
    }
    // =========================================================
    // ã€Sheer Force å¼ºè¡Œã€‘ç‰¹æ€§æ£€æŸ¥
    // å¦‚æœæ‹›å¼æœ‰ secondary å‰¯ä½œç”¨ä¸”æ”»å‡»æ–¹æœ‰ Sheer Forceï¼Œè·³è¿‡å‰¯ä½œç”¨
    // å¨åŠ›æå‡å·²åœ¨ ability-handlers.js çš„ onBasePower ä¸­å¤„ç†
    // =========================================================
    const userAbilityId = (user.ability || '').toLowerCase().replace(/[^a-z]/g, '');
    const hasSheerForce = userAbilityId === 'sheerforce';
    const moveHasSecondary = fullMoveData.secondary || fullMoveData.secondaries;
    // Sheer Force æ¿€æ´»æ ‡è®°ï¼ˆç”¨äºç”Ÿå‘½å®ç åä¼¤å…ç–«ï¼‰
    const sheerForceActive = hasSheerForce && moveHasSecondary;
    // 1.3 Secondary Effectsï¼ˆå‡ ç‡è§¦å‘ï¼Œé€šå¸¸å¯¹æ•Œäººï¼‰
    // ã€Sheer Forceã€‘å¦‚æœç‰¹æ€§æ¿€æ´»ï¼Œè·³è¿‡æ‰€æœ‰ secondary å‰¯ä½œç”¨
    if (fullMoveData.secondary && !sheerForceActive) {
        const chance = fullMoveData.secondary.chance || 100;
        if (Math.random() * 100 < chance) {
            if (fullMoveData.secondary.boosts) {
                changeStats(target, fullMoveData.secondary.boosts);
            }
            if (fullMoveData.secondary.self && fullMoveData.secondary.self.boosts) {
                changeStats(user, fullMoveData.secondary.self.boosts);
            }
            // çŠ¶æ€å¼‚å¸¸
            if (fullMoveData.secondary.status) {
                const s = fullMoveData.secondary.status;
                if (!target.status) {
                    if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                        const result = MoveEffects.tryInflictStatus(target, s, user, battle);
                        if (result.success) {
                            if (s === 'slp') {
                                target.sleepTurns = Math.floor(Math.random() * 3) + 2;
                            }
                            logs.push(result.message);
                        }
                    } else {
                        target.status = s;
                        if (s === 'slp') {
                            target.sleepTurns = Math.floor(Math.random() * 3) + 2;
                        }
                        const statusMap = {
                            brn: "è¢«ç¼ä¼¤äº†!", psn: "ä¸­æ¯’äº†!", par: "éº»ç—¹äº†!",
                            tox: "ä¸­äº†å‰§æ¯’!", slp: "ç¡ç€äº†!", frz: "è¢«å†»ç»“äº†!"
                        };
                        const statusText = statusMap[s];
                        if (statusText) {
                            logs.push(`${target.cnName} ${statusText}`);
                        }
                    }
                }
            }
            // ç•ç¼©æ•ˆæœ
            if (fullMoveData.secondary.volatileStatus === 'flinch') {
                target.volatile = target.volatile || {};
                target.volatile.flinch = true;
                logs.push(`${target.cnName} ç•ç¼©äº†!`);
            }
        }
    }
    // 1.4 Status æ‹›å¼ç›´æ¥æ–½åŠ çŠ¶æ€
    if (fullMoveData.status) {
        const s = fullMoveData.status;
        if (!target.status) {
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const result = MoveEffects.tryInflictStatus(target, s, user, battle);
                if (result.success) {
                    if (s === 'slp') {
                        target.sleepTurns = Math.floor(Math.random() * 3) + 2;
                    }
                    logs.push(result.message);
                } else {
                    logs.push(result.message);
                }
            } else {
                target.status = s;
                if (s === 'slp') {
                    target.sleepTurns = Math.floor(Math.random() * 3) + 2;
                }
                const statusMap = {
                    brn: "è¢«ç¼ä¼¤äº†!", psn: "ä¸­æ¯’äº†!", par: "éº»ç—¹äº†!",
                    tox: "ä¸­äº†å‰§æ¯’!", slp: "ç¡ç€äº†!", frz: "è¢«å†»ç»“äº†!"
                };
                const statusText = statusMap[s];
                if (statusText) {
                    logs.push(`${target.cnName} ${statusText}`);
                }
            }
        }
    }
    // === 1.5 Protect/Detect å®ˆä½ç±»æŠ€èƒ½ ===
    const isProtectMove = fullMoveData.stallingMove || 
        (fullMoveData.volatileStatus && ['protect', 'banefulbunker', 'spikyshield', 'kingsshield', 'obstruct', 'silktrap', 'burningbulwark'].includes(fullMoveData.volatileStatus));
    if (isProtectMove) {
        user.volatile = user.volatile || {};
        user.volatile.protect = true;
        logs.push(`${user.cnName} å®ˆä½äº†è‡ªå·±!`);
    }
    // ========== 2. åä¼¤ (Recoil) ==========
    const noRecoilAbility = (typeof AbilityHandlers !== 'undefined' && user.ability && AbilityHandlers[user.ability]) 
        ? (AbilityHandlers[user.ability].noRecoil || AbilityHandlers[user.ability].noIndirectDamage) 
        : false;
    if (!noRecoilAbility) {
        if (fullMoveData.recoil && damageDealt > 0) {
            const [num, den] = fullMoveData.recoil;
            const recoilDmg = Math.max(1, Math.floor(damageDealt * num / den));
            user.takeDamage(recoilDmg);
            logs.push(`${user.cnName} å—åˆ°äº† ${recoilDmg} ç‚¹åä½œç”¨åŠ›ä¼¤å®³!`);
        } else if (damageDealt > 0) {
            const recoilPatches = (typeof RECOIL_MOVES !== 'undefined') ? RECOIL_MOVES : {};
            if (recoilPatches[move.name]) {
                const [num, den] = recoilPatches[move.name];
                const recoilDmg = Math.max(1, Math.floor(damageDealt * num / den));
                user.takeDamage(recoilDmg);
                logs.push(`${user.cnName} å—åˆ°äº† ${recoilDmg} ç‚¹åä½œç”¨åŠ›ä¼¤å®³!`);
            }
        }
        // ç”Ÿå‘½å®ç åä¼¤
        // ã€Sheer Force + Magic Guardã€‘å…ç–«ç”Ÿå‘½å®ç åä¼¤
        const userItem = (user.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (userItem === 'lifeorb' && damageDealt > 0) {
            // Sheer Force æ¿€æ´»æ—¶å…ç–«ç”Ÿå‘½å®ç åä¼¤
            // Magic Guard ä¹Ÿå…ç–«ï¼ˆå·²åœ¨ noRecoilAbility ä¸­å¤„ç†ï¼‰
            if (!sheerForceActive) {
                const lifeOrbRecoil = Math.max(1, Math.floor(user.maxHp * 0.1));
                user.takeDamage(lifeOrbRecoil);
                logs.push(`${user.cnName} å—åˆ°äº†ç”Ÿå‘½å®ç çš„åå™¬!`);
            }
        }
    }
    // ========== 3. å¸è¡€ (Drain) ==========
    if (fullMoveData.drain && damageDealt > 0) {
        const [num, den] = fullMoveData.drain;
        const healAmt = Math.max(1, Math.floor(damageDealt * num / den));
        const actualHeal = Math.min(healAmt, user.maxHp - user.currHp);
        if (actualHeal > 0) {
            user.heal(healAmt);
            logs.push(`${user.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
        }
    } else if (damageDealt > 0) {
        const drainPatches = (typeof DRAIN_MOVES !== 'undefined') ? DRAIN_MOVES : {};
        if (drainPatches[move.name]) {
            const [num, den] = drainPatches[move.name];
            const healAmt = Math.max(1, Math.floor(damageDealt * num / den));
            const actualHeal = Math.min(healAmt, user.maxHp - user.currHp);
            if (actualHeal > 0) {
                user.heal(healAmt);
                logs.push(`${user.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
        }
    }
    // ========== 4. ç‰¹æ®ŠæŠ€èƒ½æ•ˆæœ ==========
    // å¯„ç”Ÿç§å­
    if (move.name === 'Leech Seed') {
        if (!target.types.includes('Grass')) {
            target.volatile = target.volatile || {};
            target.volatile['leechseed'] = true;
            logs.push(`å¯„ç”Ÿç§å­ç§åœ¨äº† ${target.cnName} èº«ä¸Š!`);
        } else {
            logs.push(`å¯¹è‰ç³»å®å¯æ¢¦æ²¡æœ‰æ•ˆæœ!`);
        }
    }
    // å“ˆæ¬ 
    if (move.name === 'Yawn') {
        if (!target.status && !(target.volatile && target.volatile['yawn'])) {
            target.volatile = target.volatile || {};
            target.volatile['yawn'] = 2;
            logs.push(`${target.cnName} æ‰“äº†ä¸ªå¤§å¤§çš„å“ˆæ¬ ...`);
        }
    }
    // è¯…å’’ (é¬¼ç³»)
    if (move.name === 'Curse' && user.types.includes('Ghost')) {
        const selfDmg = Math.floor(user.maxHp / 2);
        user.takeDamage(selfDmg);
        target.volatile = target.volatile || {};
        target.volatile['curse'] = true;
        logs.push(`${user.cnName} å‰Šå‡äº†è‡ªå·±çš„ä½“åŠ›ï¼Œå¯¹ ${target.cnName} æ–½åŠ äº†è¯…å’’!`);
    }
    // æŸç¼šç±»æŠ€èƒ½
    if (fullMoveData.volatileStatus === 'partiallytrapped') {
        target.volatile = target.volatile || {};
        target.volatile['partiallytrapped'] = true;
        logs.push(`${target.cnName} è¢«å›°ä½äº†!`);
    }
    // ========== 5. è‡ªæˆ‘ç‰ºç‰²æŠ€èƒ½ ==========
    if (fullMoveData.selfdestruct) {
        const shouldFaint = fullMoveData.selfdestruct === 'always' || 
                           (fullMoveData.selfdestruct === 'ifHit' && damageDealt >= 0);
        if (shouldFaint) {
            user.currHp = 0;
            logs.push(`${user.cnName} å€’ä¸‹äº†!`);
            console.log(`[SELFDESTRUCT] ${user.cnName} used ${move.name} with selfdestruct: ${fullMoveData.selfdestruct}`);
        }
    }
    // ========== 6. æ¥è§¦ç±»æ‹›å¼åé¦ˆæ•ˆæœ ==========
    const isContact = fullMoveData.flags && fullMoveData.flags.contact;
    // userAbilityId å·²åœ¨ä¸Šæ–¹å®šä¹‰ï¼ˆSheer Force æ£€æŸ¥å¤„ï¼‰
    let hitCount = 1;
    if (fullMoveData.multihit) {
        if (Array.isArray(fullMoveData.multihit)) {
            const [min, max] = fullMoveData.multihit;
            if (userAbilityId === 'skilllink') {
                hitCount = max;
            } else {
                hitCount = Math.floor(Math.random() * (max - min + 1)) + min;
            }
        } else {
            hitCount = fullMoveData.multihit;
        }
    }
    if (isContact && damageDealt > 0 && target.isAlive() && typeof AbilityHandlers !== 'undefined') {
        const defenderAbility = target.ability;
        const ah = defenderAbility ? AbilityHandlers[defenderAbility] : null;
        for (let hit = 0; hit < hitCount; hit++) {
            if (!user.isAlive() || !target.isAlive()) break;
            // æ¥è§¦åä¼¤ç‰¹æ€§
            if (ah && ah.onContactDamage && user.isAlive()) {
                const result = ah.onContactDamage(user, target);
                if (result && result.damage > 0) {
                    user.takeDamage(result.damage);
                    if (hit === 0) logs.push(result.message);
                }
            }
            // æ¥è§¦çŠ¶æ€ç‰¹æ€§
            if (ah && ah.onContactStatus && user.isAlive() && !user.status) {
                const result = ah.onContactStatus(user, target);
                if (result && result.status) {
                    const statusResult = (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) 
                        ? MoveEffects.tryInflictStatus(user, result.status)
                        : { success: true };
                    if (statusResult.success) {
                        user.status = result.status;
                        logs.push(result.message);
                    }
                }
            }
            // å‡¸å‡¸å¤´ç›”
            if (target.item === 'Rocky Helmet' && user.isAlive()) {
                const helmetDmg = Math.floor(user.maxHp / 6);
                user.takeDamage(helmetDmg);
                if (hit === 0) logs.push(`${user.cnName} è¢«å‡¸å‡¸å¤´ç›”ä¼¤å®³äº†ï¼`);
            }
        }
        if (!user.isAlive()) {
            logs.push(`${user.cnName} è¢«åä¼¤å‡»å€’äº†ï¼`);
        }
    }
    // ========== 7. ç¢è£‚é“ ç”²ç­‰è¢«æ”»å‡»è§¦å‘ç‰¹æ€§ ==========
    if (damageDealt > 0 && target.isAlive() && typeof AbilityHandlers !== 'undefined') {
        const ah = target.ability ? AbilityHandlers[target.ability] : null;
        const moveCategory = fullMoveData.category || (move.cat === 'phys' ? 'Physical' : (move.cat === 'spec' ? 'Special' : 'Status'));
        const isPhysical = move.cat === 'phys' || moveCategory === 'Physical';
        if (ah && ah.onPhysicalHit && isPhysical) {
            ah.onPhysicalHit(user, target, logs);
        }
    }
    // è¿”å›æ—¥å¿—å’Œ pivot çŠ¶æ€
    return { logs, pivot: pivotTriggered };
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
if (typeof window !== 'undefined') {
    window.applyMoveSecondaryEffects = applyMoveSecondaryEffects;
}
]]></file>
        <file name="battle-switch.js"><![CDATA[/**
 * ===========================================
 * BATTLE-SWITCH.JS - æ¢äººç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - Pivot æ¢äºº (U-turn/Volt Switch)
 * - å¼ºåˆ¶æ¢äºº
 * - å€’ä¸‹å¤„ç†
 * - å…¥åœºç‰¹æ€§è§¦å‘
 */
// ============================================
// è¾…åŠ©å‡½æ•°
// ============================================
/**
 * æ£€æŸ¥æ˜¯å¦æœ‰å¯æ¢å…¥çš„å­˜æ´»å®å¯æ¢¦
 */
function hasAliveSwitch(party, currentIndex) {
    return party.some((pm, idx) => 
        idx !== currentIndex && pm && pm.isAlive && pm.isAlive() && pm.currHp > 0
    );
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// Pivot æ¢äºº
// ============================================
/**
 * å¤„ç†ç©å®¶ Pivot æ¢äººï¼ˆU-turn/Volt Switch ç­‰ï¼‰
 * ä½¿ç”¨ Promise ç­‰å¾…ç©å®¶é€‰æ‹©
 */
function handlePlayerPivot() {
    const battle = window.battle;
    console.log('[handlePlayerPivot] Starting pivot switch');
    log(`<span style="color:#3498db">é€‰æ‹©è¦æ¢å…¥çš„å®å¯æ¢¦!</span>`);
    battle.phase = 'pivot_switch';
    battle.pivotSide = 'player';
    // æ˜¾ç¤ºæ¢äººèœå•ï¼ˆä¸å¯å–æ¶ˆï¼‰
    if (typeof window.renderSwitchMenu === 'function') {
        window.renderSwitchMenu(false);
    }
    console.log('[handlePlayerPivot] Waiting for player selection...');
    return new Promise((resolve) => {
        battle.pivotResolve = resolve;
    });
}
/**
 * å¤„ç†æ•Œæ–¹ Pivot æ¢äººï¼ˆAI è‡ªåŠ¨é€‰æ‹©ï¼‰
 */
async function handleEnemyPivot(passBoosts = false) {
    const battle = window.battle;
    const currentE = battle.getEnemy();
    const p = battle.getPlayer();
    // ã€Baton Passã€‘ä¿å­˜å½“å‰èƒ½åŠ›å˜åŒ–ï¼Œç”¨äºä¼ é€’ç»™æ¢å…¥çš„å®å¯æ¢¦
    const savedBoosts = passBoosts && currentE.boosts ? { ...currentE.boosts } : null;
    if (savedBoosts) {
        console.log(`[BATON PASS] ${currentE.cnName} å‡†å¤‡ä¼ é€’èƒ½åŠ›å˜åŒ–:`, savedBoosts);
    }
    // AI é€‰æ‹©æœ€ä½³æ¢å…¥ç›®æ ‡
    let bestIndex = -1;
    let bestScore = -Infinity;
    for (let i = 0; i < battle.enemyParty.length; i++) {
        const ally = battle.enemyParty[i];
        if (!ally || i === battle.enemyActive) continue;
        if (!ally.isAlive || !ally.isAlive() || ally.currHp <= 0) continue;
        let score = 0;
        // æ£€æŸ¥ç©å®¶æœ€å¼ºæŠ€èƒ½å¯¹è¯¥å®å¯æ¢¦çš„æ•ˆæœ
        for (const pMove of p.moves) {
            const moveType = pMove.type || 'Normal';
            const eff = window.getTypeEffectiveness ? 
                window.getTypeEffectiveness(moveType, ally.types || ['Normal']) : 1;
            if (eff === 0) score += 500;
            else if (eff <= 0.5) score += 200;
            else if (eff >= 2) score -= 100;
        }
        // æ£€æŸ¥è¯¥å®å¯æ¢¦å¯¹ç©å®¶çš„å…‹åˆ¶
        for (const aMove of ally.moves || []) {
            const moveType = aMove.type || 'Normal';
            const eff = window.getTypeEffectiveness ? 
                window.getTypeEffectiveness(moveType, p.types || ['Normal']) : 1;
            if (eff >= 2) score += 150;
        }
        if (score > bestScore) {
            bestScore = score;
            bestIndex = i;
        }
    }
    // å¦‚æœæ‰¾åˆ°åˆé€‚ç›®æ ‡ï¼Œæ‰§è¡Œæ¢äºº
    if (bestIndex !== -1) {
        log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${currentE.cnName}ï¼</span>`);
        // æ¸…é™¤ Choice é”æ‹›çŠ¶æ€
        if (currentE.choiceLockedMove) {
            console.log(`[CHOICE] ${currentE.name} æ¢ä¸‹ï¼Œè§£é™¤ ${currentE.choiceLockedMove} é”å®š`);
            delete currentE.choiceLockedMove;
        }
        // å¦‚æœæ¢ä¸‹çš„å®å¯æ¢¦å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œæ¢å¤æ‹›å¼
        if (currentE.isDynamaxed && typeof window.applyDynamaxState === 'function') {
            console.log(`[SWITCH] Enemy ${currentE.name} was Dynamaxed, restoring moves`);
            window.applyDynamaxState(currentE, false);
        }
        // é‡ç½®æ¢å‡ºå®å¯æ¢¦çš„èƒ½åŠ›ç­‰çº§ï¼ˆæ— è®ºæ˜¯å¦æ¥æ£’ï¼Œæ¢å‡ºè€…éƒ½è¦é‡ç½®ï¼‰
        if (typeof currentE.resetBoosts === 'function') {
            currentE.resetBoosts();
        }
        battle.enemyActive = bestIndex;
        const newE = battle.getEnemy();
        // ã€Baton Passã€‘å°†ä¿å­˜çš„èƒ½åŠ›å˜åŒ–ä¼ é€’ç»™æ¢å…¥çš„å®å¯æ¢¦
        if (savedBoosts && newE.boosts) {
            Object.keys(savedBoosts).forEach(stat => {
                newE.boosts[stat] = (newE.boosts[stat] || 0) + savedBoosts[stat];
                // é™åˆ¶åœ¨ -6 åˆ° +6 ä¹‹é—´
                newE.boosts[stat] = Math.max(-6, Math.min(6, newE.boosts[stat]));
            });
            console.log(`[BATON PASS] ${newE.cnName} ç»§æ‰¿äº†èƒ½åŠ›å˜åŒ–:`, newE.boosts);
            log(`<span style="color:#9b59b6">${newE.cnName} ç»§æ‰¿äº†èƒ½åŠ›å˜åŒ–!</span>`);
        }
        log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
        // ã€æ ‡è®°æ¢äººã€‘ç”¨äºé‡å¤ç²¾çµå›¾ä¿®å¤
        if (typeof window.markEnemySwitch === 'function') {
            window.markEnemySwitch();
        }
        updateAllVisuals('enemy');
        await wait(500);
        triggerEntryAbilities(newE, p);
        // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
    }
}
// ============================================
// å€’ä¸‹å¤„ç†
// ============================================
/**
 * å¤„ç†æ•Œæ–¹å€’ä¸‹
 */
async function handleEnemyFainted(e) {
    if (typeof window.playSFX === 'function') window.playSFX('FAINT');
    const battle = window.battle;
    // å¦‚æœæ•Œæ–¹å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œå…ˆæ¸…ç†æå·¨åŒ–è§†è§‰æ•ˆæœ
    if (e.isDynamaxed) {
        if (e.originalName) {
            e.name = e.originalName;
            delete e.originalName;
        }
        if (typeof window.endDynamaxAnimation === 'function') {
            await window.endDynamaxAnimation(e, false);
        }
        e.isDynamaxed = false;
        delete e.preDynamaxMaxHp;
        delete e.preDynamaxCurrHp;
        if (typeof window.applyDynamaxState === 'function') {
            window.applyDynamaxState(e, false);
        }
    }
    log(`æ•Œæ–¹çš„ ${e.cnName} å€’ä¸‹äº†!`);
    // === ã€onKill é’©å­ã€‘å‡»æ€åç‰¹æ€§è§¦å‘ (Moxie, Beast Boost ç­‰) ===
    const p = battle.getPlayer();
    if (p && p.isAlive() && p.ability) {
        const abilityId = p.ability;
        if (typeof AbilityHandlers !== 'undefined' && AbilityHandlers[abilityId] && AbilityHandlers[abilityId].onKill) {
            const killLogs = [];
            AbilityHandlers[abilityId].onKill(p, killLogs);
            killLogs.forEach(msg => log(msg));
            if (typeof updateAllVisuals === 'function') {
                updateAllVisuals('player');
            }
        }
    }
    // Battle Bond (ç‰µç»Šå˜èº«) è§¦å‘æ£€æŸ¥
    if (p && p.isAlive() && typeof window.checkBattleBondTransform === 'function') {
        const bondResult = window.checkBattleBondTransform(p);
        if (bondResult && bondResult.success) {
            log(`<span style="color:#3b82f6">ğŸŒŠ ${bondResult.oldName} çš„ç‰µç»Š... å˜èº«ä¸º ${bondResult.newName}ï¼</span>`);
            updateAllVisuals('player');
            await wait(800);
        }
    }
    const battleEnd = battle.checkBattleEnd();
    if (battleEnd === 'win') {
        log("ğŸ† <b style='color:#27ae60'>æ•Œæ–¹å…¨éƒ¨æˆ˜è´¥ï¼ä½ èµ¢äº†ï¼</b>");
        const t = battle.trainer;
        if (t && t.id !== 'wild' && t.lines?.lose) {
            log(`<i>${t.name}: "${t.lines.lose}"</i>`);
        }
        setTimeout(() => {
            if (typeof window.battleEndSequence === 'function') {
                window.battleEndSequence('win');
            }
        }, 2000);
        return;
    }
    // æ•Œæ–¹æ¢äºº
    await wait(1000);
    if (battle.nextAliveEnemy()) {
        const newE = battle.getEnemy();
        log(`æ•Œæ–¹æ´¾å‡º <b>${newE.cnName}</b> (Lv.${newE.level})!`);
        // ã€æ ‡è®°æ¢äººã€‘ç”¨äºé‡å¤ç²¾çµå›¾ä¿®å¤
        if (typeof window.markEnemySwitch === 'function') {
            window.markEnemySwitch();
        }
        // === æ’­æ”¾æ•Œæ–¹æ–°å®å¯æ¢¦å«å£° ===
        if (typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(newE.name);
        }
        // æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºè‡ªåŠ¨å˜å½¢ (Primal/Crowned)
        if (typeof window.checkInitTransform === 'function' && newE.needsInitTransform) {
            console.log('[FORM] Checking enemy switch-in init transform:', newE.name);
            const result = window.checkInitTransform(newE);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                const newSpriteUrl = newE.getSprite(false);
                const preloader = new Image();
                preloader.src = newSpriteUrl;
                await wait(100);
            }
        }
        // æ£€æŸ¥æ¢å…¥çš„æ•Œæ–¹æ˜¯å¦éœ€è¦æå·¨åŒ–
        const enemyUnlocks = battle.enemyUnlocks || {};
        // ã€æ•°æ®é©±åŠ¨ã€‘æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å› å­
        const hasGMaxFactor = typeof window.getGMaxFactor === 'function' && window.getGMaxFactor(newE);
        const isNewEnemyDynamax = (newE.mechanic === 'dynamax') || 
                                   (newE.canDynamax && newE.mechanic !== 'mega' && newE.mechanic !== 'tera') ||
                                   (newE.megaTargetId && newE.megaTargetId.includes('gmax')) ||
                                   hasGMaxFactor; // è‡ªåŠ¨æ£€æµ‹ G-Max å› å­
        if (enemyUnlocks.enable_dynamax && isNewEnemyDynamax && !newE.isDynamaxed && !battle.enemyMaxUsed) {
            battle.enemyMaxUsed = true;
            const oldName = newE.cnName;
            const oldMaxHp = newE.maxHp;
            const oldCurrHp = newE.currHp;
            newE.originalName = newE.name;
            updateAllVisuals('enemy');
            await wait(600);
            log(`<b style="color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
            log(`æ•Œæ–¹çš„ ${oldName} æå·¨åŒ–äº†ï¼`);
            const spriteEl = document.getElementById('enemy-sprite');
            if (spriteEl) {
                spriteEl.classList.add('dynamax-burst');
                await wait(400);
                // æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å½¢æ€ï¼ˆmegaTargetId åŒ…å« gmaxï¼‰
                // ã€å…³é”®ã€‘é€šç”¨æå·¨åŒ– (isGenericDynamax) ä¸åˆ‡æ¢å›¾ç‰‡ï¼Œåªç”¨ CSS æ”¾å¤§
                const gmaxFormId = newE.megaTargetId;
                if (gmaxFormId && gmaxFormId.includes('gmax') && !newE.isGenericDynamax) {
                    // [BUG FIX] æ ¼å¼è½¬æ¢ï¼šcharizardgmax -> Charizard-Gmax
                    const baseName = gmaxFormId.replace(/gmax$/i, '');
                    const formattedName = baseName.charAt(0).toUpperCase() + baseName.slice(1) + '-Gmax';
                    newE.name = formattedName;
                    // ã€å¼ºåˆ¶ä¿®æ­£ã€‘G-Max å½¢æ€ä¸­æ–‡åï¼šä¼˜å…ˆç¿»è¯‘ï¼Œå›é€€æ—¶å¼ºåˆ¶åŠ "è¶…æå·¨"å‰ç¼€
                    if (window.Locale) {
                        const translatedName = window.Locale.get(formattedName);
                        // æ£€æŸ¥æ˜¯å¦æˆåŠŸç¿»è¯‘ï¼ˆç¿»è¯‘åä¸ç­‰äºåŸåï¼Œä¸”ä¸ç­‰äºåŸºç¡€å½¢æ€åï¼‰
                        const baseTranslated = window.Locale.get(baseName.charAt(0).toUpperCase() + baseName.slice(1));
                        if (translatedName !== formattedName && translatedName !== baseTranslated) {
                            // æˆåŠŸç¿»è¯‘åˆ° G-Max å½¢æ€ï¼ˆå¦‚ "è¶…æå·¨å–·ç«é¾™"ï¼‰
                            newE.cnName = translatedName;
                        } else {
                            // ç¿»è¯‘å¤±è´¥ï¼Œå¼ºåˆ¶æ·»åŠ "è¶…æå·¨"å‰ç¼€
                            newE.cnName = 'è¶…æå·¨' + baseTranslated;
                        }
                    } else {
                        newE.cnName = formattedName;
                    }
                    const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
                    const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani/${gmaxSpriteId}.gif`;
                    if (typeof window.smartLoadSprite === 'function') {
                        window.smartLoadSprite('enemy-sprite', gmaxSpriteUrl, false);
                    }
                    console.log(`[DYNAMAX] æ•Œæ–¹æ¢å…¥æå·¨åŒ–ï¼Œåˆ‡æ¢ç²¾çµå›¾: ${gmaxSpriteUrl}`);
                } else if (newE.isGenericDynamax) {
                    console.log(`[DYNAMAX] æ•Œæ–¹é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${newE.name}`);
                }
                await wait(400);
                spriteEl.classList.remove('dynamax-burst');
                spriteEl.classList.add('state-dynamax');
            }
            // ã€ç»Ÿä¸€ã€‘ä½¿ç”¨ dynamax.js çš„ activateDynamax å‡½æ•°
            if (typeof window.activateDynamax === 'function') {
                const result = window.activateDynamax(newE, { justSwitchedIn: true });
                log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${newE.dynamaxTurns}]</span>`);
            } else {
                // å›é€€é€»è¾‘ï¼ˆå¦‚æœ dynamax.js æœªåŠ è½½ï¼‰
                const hpMultiplier = 1.5;
                newE.maxHp = Math.floor(oldMaxHp * hpMultiplier);
                newE.currHp = Math.floor(oldCurrHp * hpMultiplier);
                newE.isDynamaxed = true;
                newE.dynamaxTurns = 3;
                newE.preDynamaxMaxHp = oldMaxHp;
                newE.preDynamaxCurrHp = oldCurrHp;
                newE.dynamaxJustActivated = true;
                if (typeof window.applyDynamaxState === 'function') {
                    window.applyDynamaxState(newE, true);
                }
                log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${newE.dynamaxTurns}]</span>`);
            }
            await wait(400);
        }
        updateAllVisuals('enemy');
        triggerEntryAbilities(newE, battle.getPlayer());
        // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
        // ã€æ³¨æ„ã€‘æ•Œæ–¹å€’ä¸‹æ¢äººåï¼Œä¸åœ¨è¿™é‡Œæ‰§è¡Œ executeEndPhase
        // å› ä¸º handleAttack ä¸­ä¼šåœ¨ return ä¹‹å‰æˆ–ä¹‹åç»Ÿä¸€å¤„ç†å›åˆæœ«ç»“ç®—
        // å¦‚æœåœ¨è¿™é‡Œè°ƒç”¨ executeEndPhaseï¼Œä¼šå¯¼è‡´ G-Max DOT åœ¨æ¢äººæ—¶ç«‹å³è§¦å‘
        // è€Œä¸æ˜¯ç­‰åˆ°æ•´ä¸ªå›åˆç»“æŸåè§¦å‘
        battle.locked = false;
    } else {
        log("ğŸ† <b style='color:#27ae60'>æ•Œæ–¹å…¨éƒ¨æˆ˜è´¥ï¼ä½ èµ¢äº†ï¼</b>");
        setTimeout(() => {
            if (typeof window.battleEndSequence === 'function') {
                window.battleEndSequence('win');
            }
        }, 2000);
    }
}
/**
 * å¤„ç†ç©å®¶å€’ä¸‹
 */
async function handlePlayerFainted(p) {
    if (typeof window.playSFX === 'function') window.playSFX('FAINT');
    const battle = window.battle;
    // å¦‚æœå¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œå…ˆæ¸…ç†æå·¨åŒ–è§†è§‰æ•ˆæœ
    if (p.isDynamaxed) {
        if (p.originalName) {
            p.name = p.originalName;
            delete p.originalName;
        }
        if (typeof window.endDynamaxAnimation === 'function') {
            await window.endDynamaxAnimation(p, true);
        }
        p.isDynamaxed = false;
        delete p.preDynamaxMaxHp;
        delete p.preDynamaxCurrHp;
        if (typeof window.applyDynamaxState === 'function') {
            window.applyDynamaxState(p, false);
        }
    }
    log(`<b style="color:red">ç³Ÿç³•! ${p.cnName} å¤±å»äº†æˆ˜æ–—èƒ½åŠ›!</b>`);
    // === ã€ä¿®å¤ã€‘æ£€æŸ¥æ•Œæ–¹æ˜¯å¦ä¹ŸåŒæ—¶å€’ä¸‹ï¼ˆåŒæ€åœºæ™¯ï¼šé—ªç„°å†²é”‹/å¤§çˆ†ç‚¸ç­‰ï¼‰===
    const e = battle.getEnemy();
    if (e && !e.isAlive()) {
        log(`æ•Œæ–¹çš„ ${e.cnName} å€’ä¸‹äº†!`);
        // æ£€æŸ¥æˆ˜æ–—æ˜¯å¦ç»“æŸ
        const battleEnd = battle.checkBattleEnd();
        if (battleEnd === 'win') {
            log("ğŸ† <b style='color:#27ae60'>æ•Œæ–¹å…¨éƒ¨æˆ˜è´¥ï¼ä½ èµ¢äº†ï¼</b>");
            const t = battle.trainer;
            if (t && t.id !== 'wild' && t.lines?.lose) {
                log(`<i>${t.name}: "${t.lines.lose}"</i>`);
            }
            setTimeout(() => {
                if (typeof window.battleEndSequence === 'function') {
                    window.battleEndSequence('win');
                }
            }, 2000);
            return;
        }
        // æ•Œæ–¹æ¢äºº
        await wait(500);
        if (battle.nextAliveEnemy()) {
            const newE = battle.getEnemy();
            log(`æ•Œæ–¹æ´¾å‡º <b>${newE.cnName}</b> (Lv.${newE.level})!`);
            if (typeof window.markEnemySwitch === 'function') {
                window.markEnemySwitch();
            }
            // åŠ è½½æ–°æ•Œæ–¹ç²¾çµå›¾
            const newSpriteUrl = newE.getSprite(false);
            if (typeof window.smartLoadSprite === 'function') {
                window.smartLoadSprite('enemy-sprite', newSpriteUrl, true);
            }
            // æ’­æ”¾å«å£°
            if (typeof window.playPokemonCry === 'function') {
                window.playPokemonCry(newE.name);
            }
            if (typeof updateAllVisuals === 'function') {
                updateAllVisuals();
            }
            // ã€åŒæ€æ ‡è®°ã€‘æ ‡è®°æ•Œæ–¹åˆšæ¢äººï¼Œç­‰ç©å®¶æ¢äººå®Œæˆåè§¦å‘å…¥åœºç‰¹æ€§
            battle.enemyJustSwitchedInDoubleKO = true;
        }
    } else if (e && e.isAlive() && e.ability) {
        // === ã€onKill é’©å­ã€‘æ•Œæ–¹å‡»æ€åç‰¹æ€§è§¦å‘ (Moxie, Beast Boost ç­‰) ===
        const abilityId = e.ability;
        if (typeof AbilityHandlers !== 'undefined' && AbilityHandlers[abilityId] && AbilityHandlers[abilityId].onKill) {
            const killLogs = [];
            AbilityHandlers[abilityId].onKill(e, killLogs);
            killLogs.forEach(msg => log(msg));
            if (typeof updateAllVisuals === 'function') {
                updateAllVisuals('enemy');
            }
        }
    }
    await wait(500);
    // ã€å…³é”®ä¿®å¤ã€‘ç­‰å¾…å¼ºåˆ¶æ¢äººå®Œæˆï¼Œè€Œä¸æ˜¯ç«‹å³è¿”å›
    if (typeof window.checkPlayerDefeatOrForceSwitch === 'function') {
        const result = await window.checkPlayerDefeatOrForceSwitch();
        console.log('[handlePlayerFainted] Force switch completed with result:', result);
    }
}
// ============================================
// å…¥åœºç‰¹æ€§
// ============================================
/**
 * è§¦å‘å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰)
 */
function triggerEntryAbilities(pokemon, opponent) {
    const battle = window.battle;
    if (!pokemon || !opponent) return;
    if (typeof AbilityHandlers === 'undefined') return;
    const h = AbilityHandlers[pokemon.ability];
    if (h && h.onStart) {
        let logs = [];
        h.onStart(pokemon, opponent, logs, battle);
        logs.forEach(t => log(t));
        updateAllVisuals();
    }
}
// ============================================
// æ¢äººæ ¡éªŒï¼ˆæŠ“äººæœºåˆ¶ï¼‰
// ============================================
/**
 * æ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥æ¢äººï¼ˆè€ƒè™‘æŠ“äººç‰¹æ€§å’ŒçŠ¶æ€ï¼‰
 * @returns {Object} { canSwitch: boolean, reason?: string }
 */
function canPlayerSwitch() {
    const battle = window.battle;
    if (!battle) return { canSwitch: true };
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!p || !p.isAlive || !p.isAlive()) return { canSwitch: true };
    // ä½¿ç”¨å…¨å±€çš„ checkCanSwitch å‡½æ•°
    if (typeof window.checkCanSwitch === 'function') {
        return window.checkCanSwitch(p, e, battle);
    }
    return { canSwitch: true };
}
/**
 * æ£€æŸ¥æ•Œæ–¹æ˜¯å¦å¯ä»¥æ¢äººï¼ˆè€ƒè™‘æŠ“äººç‰¹æ€§å’ŒçŠ¶æ€ï¼‰
 * @returns {Object} { canSwitch: boolean, reason?: string }
 */
function canEnemySwitch() {
    const battle = window.battle;
    if (!battle) return { canSwitch: true };
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!e || !e.isAlive || !e.isAlive()) return { canSwitch: true };
    // ä½¿ç”¨å…¨å±€çš„ checkCanSwitch å‡½æ•°
    if (typeof window.checkCanSwitch === 'function') {
        return window.checkCanSwitch(e, p, battle);
    }
    return { canSwitch: true };
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.hasAliveSwitch = hasAliveSwitch;
    window.handlePlayerPivot = handlePlayerPivot;
    window.handleEnemyPivot = handleEnemyPivot;
    window.handleEnemyFainted = handleEnemyFainted;
    window.handlePlayerFainted = handlePlayerFainted;
    window.triggerEntryAbilities = triggerEntryAbilities;
    window.canPlayerSwitch = canPlayerSwitch;
    window.canEnemySwitch = canEnemySwitch;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        hasAliveSwitch,
        handlePlayerPivot,
        handleEnemyPivot,
        handleEnemyFainted,
        handlePlayerFainted,
        triggerEntryAbilities,
        canPlayerSwitch,
        canEnemySwitch
    };
}
]]></file>
        <file name="battle-turns.js"><![CDATA[/**
 * ===========================================
 * BATTLE-TURNS.JS - å›åˆæ‰§è¡Œ
 * ===========================================
 * 
 * èŒè´£:
 * - æ‰§è¡Œç©å®¶å›åˆ
 * - æ‰§è¡Œæ•Œæ–¹å›åˆ
 * - ç‹¬ç«‹æ•Œæ–¹å›åˆ (æ¢äººå)
 * - Z/Max æ‹›å¼ä½¿ç”¨æ ‡è®°
 */
// ============================================
// è¾…åŠ©å‡½æ•°
// ============================================
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°è§†è§‰
 */
function updateAllVisuals(forceSpriteAnim) {
    if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
        window.updateAllVisuals(forceSpriteAnim);
    }
}
// ============================================
// å›åˆå¼€å§‹å¤„ç†
// ============================================
/**
 * å›åˆå¼€å§‹æ—¶çš„ç»Ÿä¸€å¤„ç†
 * - é€’å‡é£æ ¼å†·å´
 * - å…¶ä»–å›åˆå¼€å§‹é’©å­
 */
function onTurnStart() {
    const battle = window.battle;
    if (!battle) return;
    // ã€å¤æ­¦ç³»ç»Ÿã€‘å›åˆå¼€å§‹æ—¶é€’å‡å†·å´
    if (battle.playerStyleCooldown > 0) {
        battle.playerStyleCooldown--;
        console.log(`[STYLES] ç©å®¶é£æ ¼å†·å´é€’å‡: ${battle.playerStyleCooldown + 1} -> ${battle.playerStyleCooldown}`);
        if (typeof window.updateStyleButtonCooldown === 'function') {
            window.updateStyleButtonCooldown();
        }
    }
    if (battle.enemyStyleCooldown > 0) {
        battle.enemyStyleCooldown--;
        console.log(`[STYLES] æ•Œæ–¹é£æ ¼å†·å´é€’å‡: ${battle.enemyStyleCooldown + 1} -> ${battle.enemyStyleCooldown}`);
    }
}
// ============================================
// ç©å®¶å›åˆæ‰§è¡Œ
// ============================================
/**
 * æ‰§è¡Œç©å®¶å›åˆ
 * @param {Object} p ç©å®¶å®å¯æ¢¦
 * @param {Object} e æ•Œæ–¹å®å¯æ¢¦
 * @param {Object} move æ‹›å¼
 * @returns {Object} åŒ…å« pivot æ ‡è®°çš„ç»“æœ
 */
async function executePlayerTurn(p, e, move) {
    const battle = window.battle;
    // çŠ¶æ€é˜»æ–­æ£€æµ‹
    if (typeof window.checkCanMove === 'function') {
        const check = window.checkCanMove(p);
        if (check.msg) {
            log(`<span style="color:#e67e22">${check.msg}</span>`);
        }
        if (!check.can) {
            await wait(500);
            return { pivot: false };
        }
    }
    // === ç‰¹æ€§ onBeforeMove é’©å­ (æ‡’æƒ°ã€å˜å¹»è‡ªå¦‚ç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && p.ability) {
        const abilityHandler = AbilityHandlers[p.ability];
        if (abilityHandler && abilityHandler.onBeforeMove) {
            const beforeMoveLogs = [];
            const canMove = abilityHandler.onBeforeMove(p, move, beforeMoveLogs);
            beforeMoveLogs.forEach(txt => log(txt));
            if (canMove === false) {
                await wait(500);
                return { pivot: false };
            }
        }
    }
    // === ç¡¬ç›´æ£€æŸ¥ (ç ´åå…‰çº¿/çˆ†ç‚¸çƒˆç„°ç­‰) ===
    // ã€ä¿®å¤ã€‘åœ¨è¾“å‡º"ä½¿ç”¨äº†xxx"ä¹‹å‰æ£€æŸ¥ï¼Œé¿å…è¯¯å¯¼æ€§æ—¥å¿—
    if (p.mustRecharge) {
        log(`<span style="color:#e74c3c">${p.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!</span>`);
        p.mustRecharge = false;
        await wait(500);
        return { pivot: false };
    }
    log(`[${p.cnName}] ä½¿ç”¨äº† <b>${move.cn}</b>!`);
    await wait(600);
    const result = applyDamage(p, e, move, 'enemy-sprite');
    // è®°å½•æœ¬å›åˆä½¿ç”¨çš„æŠ€èƒ½
    p.lastMoveUsed = move.name;
    // =========================================================
    // Z-Move / Max Move ä½¿ç”¨æ ‡è®° (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
    // =========================================================
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æµ‹å¹¶æ ‡è®° Z æ‹›å¼ä½¿ç”¨
    const isZMove = moveData.isZ || 
        (moveData.pp === 1 && moveData.basePower >= 100 && moveData.isNonstandard === 'Past') ||
        (move.name || '').length > 25;
    if (isZMove && !battle.playerZUsed) {
        battle.playerZUsed = true;
        console.log(`[Z-MOVE] ç©å®¶ä½¿ç”¨äº† Z æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<div style="padding:8px; border:2px solid gold; background:linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,255,255,0.9)); text-align:center; border-radius:8px; margin:5px 0;">`);
        log(`<b style="font-size:1.1rem; background: linear-gradient(90deg, #a855f7, #ec4899); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">âœ¨ Z-POWER UNLEASHED âœ¨</b>`);
        log(`<div style="color:#666; font-size:0.85em; margin-top:4px;">å…¨åŠ›çš„å§¿æ€... ZåŠ›é‡å·²é‡Šæ”¾ï¼</div>`);
        log(`</div>`);
        const stage = document.querySelector('.battle-stage');
        if (stage) {
            stage.classList.add('shake-hit-anim');
            setTimeout(() => stage.classList.remove('shake-hit-anim'), 500);
        }
    }
    // æ£€æµ‹å¹¶æ ‡è®°æå·¨æ‹›å¼ä½¿ç”¨
    const isMaxMove = moveData.isMax || 
        (move.name || '').startsWith('Max ') || (move.name || '').startsWith('G-Max ');
    if (isMaxMove && !battle.playerMaxUsed) {
        battle.playerMaxUsed = true;
        console.log(`[MAX MOVE] ç©å®¶ä½¿ç”¨äº†æå·¨æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<div style="padding:8px; border:2px solid #e11d48; background:linear-gradient(135deg, rgba(225,29,72,0.1), rgba(255,255,255,0.9)); text-align:center; border-radius:8px; margin:5px 0;">`);
        log(`<b style="font-size:1.1rem; color:#e11d48;">ğŸ’¥ MAX POWER ğŸ’¥</b>`);
        log(`<div style="color:#666; font-size:0.85em; margin-top:4px;">æå·¨ä¹‹åŠ›å€¾æ³»è€Œå‡ºï¼</div>`);
        log(`</div>`);
    }
    updateAllVisuals();
    // === æ£€æŸ¥å±æœº BGM åˆ‡æ¢ (é¦†ä¸»æˆ˜ä¸“ç”¨) ===
    if (typeof checkCrisisBgm === 'function') {
        checkCrisisBgm();
    }
    return { pivot: result?.pivot || false };
}
// ============================================
// æ•Œæ–¹å›åˆæ‰§è¡Œ
// ============================================
/**
 * æ‰§è¡Œæ•Œæ–¹å›åˆ
 * @param {Object} e æ•Œæ–¹å®å¯æ¢¦
 * @param {Object} p ç©å®¶å®å¯æ¢¦
 * @param {Object} move æ‹›å¼
 * @returns {Object} åŒ…å« pivot æ ‡è®°çš„ç»“æœ
 */
async function executeEnemyTurn(e, p, move) {
    const battle = window.battle;
    console.log('[executeEnemyTurn] Starting:', { 
        enemy: e?.cnName, 
        player: p?.cnName, 
        move: move?.name || move?.cn 
    });
    if (!e || !e.isAlive()) {
        console.log('[executeEnemyTurn] Enemy invalid or dead');
        return { pivot: false };
    }
    // å¦‚æœæ²¡æœ‰æ‹›å¼ï¼ˆæ•Œæ–¹æ¢äººåœºæ™¯ï¼‰ï¼Œè·³è¿‡æ”»å‡»
    if (!move) {
        console.log('[executeEnemyTurn] No move provided, skipping');
        return { pivot: false };
    }
    await wait(800);
    // çŠ¶æ€é˜»æ–­æ£€æµ‹
    if (typeof window.checkCanMove === 'function') {
        const check = window.checkCanMove(e);
        if (check.msg) {
            log(`<span style="color:#e67e22">${check.msg}</span>`);
        }
        if (!check.can) {
            return { pivot: false };
        }
    }
    // === ç‰¹æ€§ onBeforeMove é’©å­ (æ‡’æƒ°ã€å˜å¹»è‡ªå¦‚ç­‰) ===
    if (typeof AbilityHandlers !== 'undefined' && e.ability) {
        const abilityHandler = AbilityHandlers[e.ability];
        if (abilityHandler && abilityHandler.onBeforeMove) {
            const beforeMoveLogs = [];
            const canMove = abilityHandler.onBeforeMove(e, move, beforeMoveLogs);
            beforeMoveLogs.forEach(txt => log(txt));
            if (canMove === false) {
                return { pivot: false };
            }
        }
    }
    // === ç¡¬ç›´æ£€æŸ¥ (ç ´åå…‰çº¿/çˆ†ç‚¸çƒˆç„°ç­‰) ===
    // ã€ä¿®å¤ã€‘åœ¨è¾“å‡º"ä½¿å‡ºxxx"ä¹‹å‰æ£€æŸ¥ï¼Œé¿å…è¯¯å¯¼æ€§æ—¥å¿—
    if (e.mustRecharge) {
        log(`<span style="color:#e74c3c">${e.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!</span>`);
        e.mustRecharge = false;
        return { pivot: false };
    }
    const moveName = move.cn || move.name || 'Unknown';
    log(`[${e.cnName}] ä½¿å‡º <b>${moveName}</b>!`);
    await wait(500);
    const result = applyDamage(e, p, move, 'player-sprite');
    // è®°å½•æœ¬å›åˆä½¿ç”¨çš„æŠ€èƒ½
    e.lastMoveUsed = move.name;
    // =========================================================
    // Choice é“å…·é”æ‹›ï¼ˆè®²ç©¶å¤´å¸¦/çœ¼é•œ/å›´å·¾ï¼‰
    // =========================================================
    const eItem = e.item || '';
    const eIsChoiceItem = eItem.includes('Choice') || eItem.includes('è®²ç©¶');
    if (eIsChoiceItem && !e.choiceLockedMove) {
        e.choiceLockedMove = move.name;
        console.log(`[CHOICE] ${e.name} è¢« ${eItem} é”å®šåœ¨ ${move.name}`);
    }
    // =========================================================
    // Z-Move / Max Move ä½¿ç”¨æ ‡è®° (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
    // =========================================================
    const eMoveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const eMoveData = (typeof MOVES !== 'undefined' && MOVES[eMoveId]) ? MOVES[eMoveId] : {};
    // æ£€æµ‹å¹¶æ ‡è®° Z æ‹›å¼ä½¿ç”¨
    const eIsZMove = eMoveData.isZ || move.isZ ||
        (eMoveData.pp === 1 && eMoveData.basePower >= 100 && eMoveData.isNonstandard === 'Past');
    if (eIsZMove && !battle.enemyZUsed) {
        battle.enemyZUsed = true;
        console.log(`[Z-MOVE] æ•Œæ–¹ä½¿ç”¨äº† Z æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
        log(`<b style="color:#fbbf24; text-shadow: 0 0 10px #fbbf24;">âœ¨ Z-POWER UNLEASHED âœ¨</b>`);
        log(`<span style="color:#fbbf24">${e.cnName} é‡Šæ”¾äº†å…¨éƒ¨çš„ Z åŠ›é‡ï¼</span>`);
    }
    // æ£€æµ‹å¹¶æ ‡è®°æå·¨æ‹›å¼ä½¿ç”¨
    const eIsMaxMove = eMoveData.isMax || 
        (move.name || '').startsWith('Max ') || (move.name || '').startsWith('G-Max ');
    if (eIsMaxMove && !battle.enemyMaxUsed) {
        battle.enemyMaxUsed = true;
        console.log(`[MAX MOVE] æ•Œæ–¹ä½¿ç”¨äº†æå·¨æ‹›å¼: ${move.name}ï¼Œæœ¬åœºä¸å¯å†ç”¨`);
    }
    updateAllVisuals();
    console.log('[executeEnemyTurn] Completed');
    return { 
        pivot: result?.pivot || false,
        passBoosts: result?.passBoosts || false  // ã€Baton Passã€‘ä¼ é€’èƒ½åŠ›å˜åŒ–æ ‡è®°
    };
}
// ============================================
// ç‹¬ç«‹æ•Œæ–¹å›åˆ
// ============================================
/**
 * ç‹¬ç«‹æ•Œæ–¹å›åˆ (ç”¨äºæ¢äººåæ•Œæ–¹æ”»å‡»)
 */
async function enemyTurn() {
    const battle = window.battle;
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!e || !e.isAlive()) {
        battle.locked = false;
        return;
    }
    // è·å–æ•Œæ–¹ AI å†³ç­–
    let move = null;
    let enemyAction = null;
    if (typeof window.getAiAction === 'function') {
        enemyAction = window.getAiAction(e, p, battle.aiDifficulty || 'normal', battle.enemyParty, {
            turnCount: battle.turnCount || 1
        });
    }
    // å¤„ç† AI æ¢äººå†³ç­–
    if (enemyAction && enemyAction.type === 'switch' && typeof enemyAction.index === 'number') {
        const switchTarget = battle.enemyParty[enemyAction.index];
        if (switchTarget && switchTarget.isAlive() && switchTarget !== e) {
            log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${e.cnName}ï¼</span>`);
            if (e.choiceLockedMove) {
                console.log(`[CHOICE] ${e.name} æ¢ä¸‹ï¼Œè§£é™¤ ${e.choiceLockedMove} é”å®š`);
                delete e.choiceLockedMove;
            }
            if (e.isDynamaxed && typeof window.applyDynamaxState === 'function') {
                console.log(`[SWITCH] Enemy ${e.name} was Dynamaxed, restoring moves`);
                window.applyDynamaxState(e, false);
            }
            if (typeof e.resetBoosts === 'function') {
                e.resetBoosts();
            }
            battle.enemyActive = enemyAction.index;
            const newE = battle.getEnemy();
            log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
            // ã€æ ‡è®°æ¢äººã€‘ç”¨äºé‡å¤ç²¾çµå›¾ä¿®å¤
            if (typeof window.markEnemySwitch === 'function') {
                window.markEnemySwitch();
            }
            // æ£€æŸ¥è¿›åœºå˜å½¢
            if (typeof window.checkInitTransform === 'function' && newE.needsInitTransform) {
                const result = window.checkInitTransform(newE);
                if (result) {
                    log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                }
            }
            updateAllVisuals('enemy');
            if (typeof window.triggerEntryAbilities === 'function') {
                window.triggerEntryAbilities(newE, p);
            }
            // ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³
            if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
                const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
                hazardLogs.forEach(msg => log(msg));
                if (hazardLogs.length > 0) updateAllVisuals();
            }
            battle.locked = false;
            return;
        }
    }
    // æ™®é€šæ”»å‡»
    if (enemyAction && enemyAction.move) {
        move = enemyAction.move;
    }
    // å›é€€åˆ°æ—§ AI
    if (!move && typeof window.getAiMove === 'function') {
        move = window.getAiMove(e, p, battle.aiDifficulty || 'normal');
    }
    if (!move) {
        move = e.moves[Math.floor(Math.random() * e.moves.length)];
    }
    // æ‰§è¡Œæ•Œæ–¹å›åˆ
    await executeEnemyTurn(e, p, move);
    // æ£€æŸ¥ç©å®¶æ˜¯å¦å€’ä¸‹
    if (!p.isAlive()) {
        if (typeof window.handlePlayerFainted === 'function') {
            await window.handlePlayerFainted(p);
        }
        // ã€ä¿®å¤ã€‘ç©å®¶å€’ä¸‹æ¢äººåï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆæ•Œæ–¹æå·¨åŒ– tick ç­‰ï¼‰
        const newP = battle.getPlayer();
        const currentE = battle.getEnemy();
        if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
            if (typeof window.executeEndPhase === 'function') {
                await window.executeEndPhase(newP, currentE);
            }
        }
        return;
    }
    battle.locked = false;
}
// ============================================
// å›åˆç»“æŸçŠ¶æ€ç»“ç®—
// ============================================
/**
 * å›åˆç»“æŸæ—¶çš„çŠ¶æ€ä¼¤å®³/å›å¤ç»“ç®—
 * @param {Pokemon} poke è¦ç»“ç®—çš„å®å¯æ¢¦
 * @param {Pokemon} opponent å¯¹æ‰‹å®å¯æ¢¦ï¼ˆç”¨äºå¯„ç”Ÿç§å­å¸è¡€ï¼‰
 * @param {boolean} isPlayerPoke æ˜¯å¦ä¸ºç©å®¶æ–¹çš„å®å¯æ¢¦ï¼ˆAVs æ•ˆæœåªå¯¹ç©å®¶æ–¹ç”Ÿæ•ˆï¼‰
 * @returns {Array} logs
 */
function getEndTurnStatusLogs(poke, opponent, isPlayerPoke = false) {
    let logs = [];
    if (!poke || !poke.isAlive()) return logs;
    // ----------------------------------------
    // 1. ç¼ä¼¤ (Burn): æ‰£ 1/16 HP
    // ----------------------------------------
    if (poke.status === 'brn') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 16));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°ç¼ä¼¤çš„ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 2. ä¸­æ¯’ (Poison): æ‰£ 1/8 HP
    // ----------------------------------------
    if (poke.status === 'psn') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°æ¯’ç´ çš„ä¼¤å®³! (-${dmg})`);
    }
    // å‰§æ¯’ (Toxic): ç´¯åŠ ä¼¤å®³ (ç®€åŒ–ä¸º 1/8)
    if (poke.status === 'tox') {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°å‰§æ¯’çš„ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 3. å¯„ç”Ÿç§å­ (Leech Seed): è¢«å¯¹æ–¹å¸è¡€ 1/8
    // ----------------------------------------
    if (poke.volatile && poke.volatile['leechseed'] && opponent && opponent.isAlive()) {
        const drain = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(drain);
        opponent.heal(drain);
        logs.push(`${poke.cnName} çš„ä½“åŠ›è¢«å¯„ç”Ÿç§å­å¸å–äº†! (-${drain})`);
    }
    // ----------------------------------------
    // 4. æŸç¼šçŠ¶æ€ (Bind / Whirlpool / Fire Spin) -> æ‰£ 1/8
    // ----------------------------------------
    if (poke.volatile && poke.volatile['partiallytrapped']) {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 8));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å› æŸç¼šè€Œå—åˆ°ä¼¤å®³! (-${dmg})`);
    }
    // ----------------------------------------
    // 5. è¯…å’’ (Curse - Ghostä½¿ç”¨): æ¯å›åˆæ‰£ 1/4
    // ----------------------------------------
    if (poke.volatile && poke.volatile['curse']) {
        const dmg = Math.max(1, Math.floor(poke.maxHp / 4));
        poke.takeDamage(dmg);
        logs.push(`${poke.cnName} å—åˆ°äº†è¯…å’’! (-${dmg})`);
    }
    // ----------------------------------------
    // 6. å“ˆæ¬  (Yawn): å€’è®¡æ—¶ï¼Œæ—¶é—´åˆ°ç¡ç€
    // ----------------------------------------
    if (poke.volatile && poke.volatile['yawn']) {
        poke.volatile['yawn'] -= 1;
        if (poke.volatile['yawn'] <= 0) {
            if (!poke.status) {
                poke.status = 'slp';
                poke.sleepTurns = Math.floor(Math.random() * 3) + 2;
                delete poke.volatile['yawn'];
                logs.push(`${poke.cnName} çš„ç¡æ„è¢­æ¥äº†! -> ç¡ç€äº†!`);
            } else {
                delete poke.volatile['yawn'];
            }
        } else {
            logs.push(`${poke.cnName} æ›´åŠ å›°å€¦äº†...`);
        }
    }
    // ----------------------------------------
    // 7. æ°´æµç¯ (Aqua Ring): æ¯å›åˆå›å¤ 1/16 HP
    // ----------------------------------------
    if (poke.volatile && poke.volatile.aquaring) {
        const heal = Math.max(1, Math.floor(poke.maxHp / 16));
        poke.heal(heal);
        logs.push(`${poke.cnName} çš„æ°´æµç¯æ¢å¤äº†ä½“åŠ›! (+${heal})`);
    }
    // ----------------------------------------
    // 8. æ‰æ ¹ (Ingrain): æ¯å›åˆå›å¤ 1/16 HP
    // ----------------------------------------
    if (poke.volatile && poke.volatile.ingrain) {
        const heal = Math.max(1, Math.floor(poke.maxHp / 16));
        poke.heal(heal);
        logs.push(`${poke.cnName} ä»åœ°é¢å¸æ”¶äº†å…»åˆ†! (+${heal})`);
    }
    // ----------------------------------------
    // 9. å¤©æ°”ä¼¤å®³ (Weather Damage)
    // ----------------------------------------
    const battle = window.battle;
    const currentWeather = battle ? battle.weather : null;
    const pokeAbility = (poke.ability || '').toLowerCase().replace(/[^a-z]/g, '');
    const hasMagicGuard = pokeAbility === 'magicguard';
    const hasOvercoat = pokeAbility === 'overcoat';
    if (currentWeather && !hasMagicGuard && !hasOvercoat) {
        if (currentWeather === 'sandstorm') {
            const immuneToSand = poke.types && (poke.types.includes('Rock') || poke.types.includes('Ground') || poke.types.includes('Steel'));
            const sandAbilityImmune = ['sandveil', 'sandforce', 'sandrush'].includes(pokeAbility);
            if (!immuneToSand && !sandAbilityImmune) {
                const dmg = Math.max(1, Math.floor(poke.maxHp / 16));
                poke.takeDamage(dmg);
                logs.push(`${poke.cnName} å—åˆ°æ²™æš´çš„ä¼¤å®³! (-${dmg})`);
            }
        }
        if (currentWeather === 'hail') {
            const immuneToHail = poke.types && poke.types.includes('Ice');
            const hailAbilityImmune = ['icebody', 'snowcloak', 'slushrush'].includes(pokeAbility);
            if (!immuneToHail && !hailAbilityImmune) {
                const dmg = Math.max(1, Math.floor(poke.maxHp / 16));
                poke.takeDamage(dmg);
                logs.push(`${poke.cnName} å—åˆ°å†°é›¹çš„ä¼¤å®³! (-${dmg})`);
            }
        }
    }
    // =====================================================
    // === AVs: Devotion (çŒ®èº«) - çŠ¶æ€æ²»æ„ˆ + æ®‹è¡€å›å¤ ===
    // =====================================================
    // ã€çº¿æ€§æœºåˆ¶ã€‘æ¦‚ç‡ = (effectiveDevotion / 255) * 0.35
    // æ»¡å€¼ 255 æ—¶çº¦ 35% æ¦‚ç‡ï¼Œ100 æ—¶çº¦ 14% æ¦‚ç‡
    // åªæœ‰ã€ç©å®¶æ–¹ã€‘çš„ isAce=true å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
    if (isPlayerPoke && poke.isAce && poke.avs && poke.avs.devotion > 0) {
        const baseDevotion = poke.getEffectiveAVs ? poke.getEffectiveAVs('devotion') : poke.avs.devotion;
        const effectiveDevotion = poke.avsEvolutionBoost ? baseDevotion * 2 : baseDevotion;
        const hpRatio = poke.currHp / poke.maxHp;
        const isCritical = hpRatio <= 0.30;
        // çº¿æ€§æ¦‚ç‡è®¡ç®—ï¼šæ»¡å€¼ 35%ï¼Œæœ€ä½ 5%
        const baseChance = Math.max(0.05, (effectiveDevotion / 255) * 0.35);
        // åˆå§‹åŒ–å…¨å±€è§¦å‘æ ‡è®°
        if (!poke.avsTriggered) poke.avsTriggered = {};
        if (poke.devotionStatusTriggered === undefined) poke.devotionStatusTriggered = -1;
        const currentTurn = battle && battle.turn ? battle.turn : 0;
        // ã€è§¦å‘æ¡ä»¶ 1ã€‘æœ‰å¼‚å¸¸çŠ¶æ€ â†’ æ¸…é™¤å¼‚å¸¸ + å›å¤ 15% HP
        if (poke.status && poke.devotionStatusTriggered !== currentTurn) {
            if (Math.random() < baseChance) {
                const oldStatus = poke.status;
                poke.status = null;
                poke.sleepTurns = 0;
                const healAmount = Math.floor(poke.maxHp * 0.15);
                poke.heal(healAmount);
                logs.push(`<b style="color:#e91e63">ğŸ’• ${poke.cnName} ä¸ºäº†ä¸è®©è®­ç»ƒå®¶æ‹…å¿ƒï¼Œæ²»å¥½äº†è‡ªå·±çš„${oldStatus}ï¼å›å¤äº† ${healAmount} HPï¼(Devotion: ${baseDevotion}${poke.avsEvolutionBoost ? ' x2' : ''})</b>`);
                poke.devotionStatusTriggered = currentTurn;
                console.log(`[AVs] Devotion çŠ¶æ€æ²»æ„ˆè§¦å‘ (Chance: ${Math.round(baseChance * 100)}%, Devotion: ${baseDevotion})`);
            }
        }
        // ã€è§¦å‘æ¡ä»¶ 2ã€‘æ®‹è¡€ï¼ˆâ‰¤30%ï¼‰â†’ å›å¤ 35% HPï¼ˆå…¨å±€åªèƒ½è§¦å‘ä¸€æ¬¡ï¼‰
        if (isCritical && !poke.avsTriggered.devotionCritical) {
            const criticalChance = Math.min(0.60, baseChance + 0.15);
            if (Math.random() < criticalChance) {
                const healAmount = Math.floor(poke.maxHp * 0.35);
                poke.heal(healAmount);
                logs.push(`<b style="color:#e91e63">ğŸ’• ${poke.cnName} çš„çŒ®èº«ä¹‹å¿ƒæ¿€å‘äº†ç”Ÿå‘½åŠ›ï¼å›å¤äº† ${healAmount} HPï¼[å±æœºçˆ†å‘] (Devotion: ${baseDevotion}${poke.avsEvolutionBoost ? ' x2' : ''})</b>`);
                poke.avsTriggered.devotionCritical = true;
                console.log(`[AVs] Devotion å±æœºçˆ†å‘è§¦å‘ (Chance: ${Math.round(criticalChance * 100)}%, Devotion: ${baseDevotion})`);
            }
        }
    }
    return logs;
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.onTurnStart = onTurnStart;
    window.executePlayerTurn = executePlayerTurn;
    window.executeEnemyTurn = executeEnemyTurn;
    window.enemyTurn = enemyTurn;
    window.getEndTurnStatusLogs = getEndTurnStatusLogs;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        executePlayerTurn,
        executeEnemyTurn,
        enemyTurn
    };
}
]]></file>
    </directory>
    <directory name="data">
        <directory name="bgm"/>
        <directory name="sfx"/>
        <file name="move-constants.js"><![CDATA[/**
 * =============================================
 * MOVE CONSTANTS - æ‹›å¼ç¡¬ç¼–ç æ•°æ®
 * =============================================
 * 
 * æœ¬æ–‡ä»¶å­˜æ”¾æ‰€æœ‰æ‹›å¼ç›¸å…³çš„ç¡¬ç¼–ç æ•°æ®ï¼Œ
 * ä½œä¸º MOVES æ•°æ®åº“çš„è¡¥å……/åå¤‡ã€‚
 * 
 * battle-engine.js ä¸­çš„æ ¸å¿ƒé€»è¾‘ä¼šä¼˜å…ˆè¯»å– MOVES æ•°æ®ï¼Œ
 * å¦‚æœ MOVES ä¸­æ²¡æœ‰å¯¹åº”æ•°æ®ï¼Œåˆ™ä½¿ç”¨è¿™é‡Œçš„ç¡¬ç¼–ç ã€‚
 */
// ============================================
// 1. æ‹›å¼ä¼˜å…ˆçº§æ˜ å°„ (Priority Map)
// ============================================
// ç”¨äº getMovePriority() å‡½æ•°çš„åå¤‡æ•°æ®
const PRIORITY_MAP = {
    // +5
    'Helping Hand': 5,
    // +4 (å®ˆä½ç±»)
    'Protect': 4, 
    'Detect': 4, 
    'Endure': 4, 
    'Magic Coat': 4, 
    'Snatch': 4,
    'King\'s Shield': 4, 
    'Spiky Shield': 4, 
    'Baneful Bunker': 4, 
    'Obstruct': 4, 
    'Silk Trap': 4,
    // +3
    'Fake Out': 3, 
    'Quick Guard': 3, 
    'Wide Guard': 3, 
    'Crafty Shield': 3,
    // +2
    'Extreme Speed': 2, 
    'Feint': 2, 
    'First Impression': 2, 
    'Accelerock': 2,
    // +1 (å¸¸è§å…ˆåˆ¶æŠ€)
    'Aqua Jet': 1, 
    'Bullet Punch': 1, 
    'Ice Shard': 1, 
    'Mach Punch': 1,
    'Quick Attack': 1, 
    'Shadow Sneak': 1, 
    'Sucker Punch': 1, 
    'Vacuum Wave': 1,
    'Water Shuriken': 1, 
    'Jet Punch': 1, 
    'Grassy Glide': 1,
    // -1
    'Vital Throw': -1,
    // -3
    'Focus Punch': -3,
    // -4
    'Avalanche': -4, 
    'Revenge': -4,
    // -5
    'Counter': -5, 
    'Mirror Coat': -5,
    // -6
    'Circle Throw': -6, 
    'Dragon Tail': -6, 
    'Roar': -6, 
    'Whirlwind': -6,
    // -7
    'Trick Room': -7
};
// ============================================
// 2. åä¼¤æŠ€èƒ½æ˜ å°„ (Recoil Moves)
// ============================================
// æ ¼å¼: { æ‹›å¼å: [åˆ†å­, åˆ†æ¯] } è¡¨ç¤ºåä¼¤ = ä¼¤å®³ * åˆ†å­/åˆ†æ¯
const RECOIL_MOVES = {
    'Brave Bird': [1, 3],
    'Double-Edge': [1, 3],
    'Flare Blitz': [1, 3],
    'Head Smash': [1, 2],
    'Wood Hammer': [1, 3],
    'Take Down': [1, 4],
    'Wild Charge': [1, 4],
    'Volt Tackle': [1, 3],
    'Submission': [1, 4],
    'Wave Crash': [1, 3],
    'Light of Ruin': [1, 2],
    'Head Charge': [1, 4]
};
// ============================================
// 3. å¸è¡€æŠ€èƒ½æ˜ å°„ (Drain Moves)
// ============================================
// æ ¼å¼: { æ‹›å¼å: [åˆ†å­, åˆ†æ¯] } è¡¨ç¤ºå›å¤ = ä¼¤å®³ * åˆ†å­/åˆ†æ¯
const DRAIN_MOVES = {
    'Giga Drain': [1, 2],
    'Drain Punch': [1, 2],
    'Horn Leech': [1, 2],
    'Absorb': [1, 2],
    'Mega Drain': [1, 2],
    'Leech Life': [1, 2],
    'Draining Kiss': [3, 4],
    'Oblivion Wing': [3, 4],
    'Parabolic Charge': [1, 2],
    'Dream Eater': [1, 2],
    'Bitter Blade': [1, 2],
    'Bouncy Bubble': [1, 2]
};
// ============================================
// 4. æŸç¼šç±»æŠ€èƒ½ (Trapping Moves)
// ============================================
// è¿™äº›æŠ€èƒ½ä¼šè®©ç›®æ ‡è¿›å…¥ partiallytrapped çŠ¶æ€
const TRAPPING_MOVES = [
    'Fire Spin',
    'Whirlpool',
    'Bind',
    'Wrap',
    'Sand Tomb',
    'Magma Storm',
    'Infestation',
    'Clamp',
    'Snap Trap',
    'Thunder Cage'
];
// ============================================
// 5. å¿…å®šæš´å‡»æŠ€èƒ½ (Always Crit Moves)
// ============================================
const ALWAYS_CRIT_MOVES = [
    'Surging Strikes',
    'Wicked Blow',
    'Frost Breath',
    'Storm Throw',
    'Zippy Zap',
    'Flower Trick'
];
// ============================================
// 6. AI è¯„åˆ†ç”¨ - å¼ºåŒ–æŠ€èƒ½åˆ—è¡¨ (Boost Moves)
// ============================================
const AI_BOOST_MOVES = [
    'Swords Dance',
    'Calm Mind',
    'Dragon Dance',
    'Nasty Plot',
    'Quiver Dance',
    'Shell Smash',
    'Bulk Up',
    'Hone Claws',
    'Work Up',
    'Agility',
    'Rock Polish',
    'Autotomize',
    'Coil',
    'Shift Gear',
    'Cotton Guard',
    'Iron Defense',
    'Amnesia',
    'Acid Armor',
    'Barrier',
    'Cosmic Power',
    'Defend Order',
    'Stockpile'
];
// ============================================
// 7. AI è¯„åˆ†ç”¨ - çŠ¶æ€æŠ€èƒ½åˆ—è¡¨ (Status Inflict Moves)
// ============================================
const AI_STATUS_MOVES = [
    'Thunder Wave',
    'Will-O-Wisp',
    'Toxic',
    'Spore',
    'Sleep Powder',
    'Hypnosis',
    'Sing',
    'Stun Spore',
    'Glare',
    'Nuzzle',
    'Lovely Kiss',
    'Dark Void',
    'Grass Whistle',
    'Yawn'
];
// ============================================
// 8. AI è¯„åˆ†ç”¨ - ç¡çœ æŠ€èƒ½åˆ—è¡¨ (Sleep Moves)
// ============================================
const AI_SLEEP_MOVES = [
    'Spore',
    'Sleep Powder',
    'Hypnosis',
    'Sing',
    'Lovely Kiss',
    'Dark Void',
    'Grass Whistle'
];
// ============================================
// 9. AI è¯„åˆ†ç”¨ - éº»ç—¹æŠ€èƒ½åˆ—è¡¨ (Paralyze Moves)
// ============================================
const AI_PARALYZE_MOVES = [
    'Thunder Wave',
    'Glare',
    'Stun Spore',
    'Nuzzle'
];
// ============================================
// 10. AI è¯„åˆ†ç”¨ - å›å¤æŠ€èƒ½åˆ—è¡¨ (Heal Moves)
// ============================================
const AI_HEAL_MOVES = [
    'Recover',
    'Roost',
    'Soft-Boiled',
    'Slack Off',
    'Moonlight',
    'Morning Sun',
    'Synthesis',
    'Wish',
    'Rest',
    'Milk Drink',
    'Shore Up',
    'Strength Sap',
    'Jungle Healing',
    'Life Dew'
];
// ============================================
// 11. AI è¯„åˆ†ç”¨ - å®ˆä½æŠ€èƒ½åˆ—è¡¨ (Protect Moves)
// ============================================
const AI_PROTECT_MOVES = [
    'Protect',
    'Detect',
    'King\'s Shield',
    'Spiky Shield',
    'Baneful Bunker',
    'Obstruct',
    'Silk Trap',
    'Max Guard'
];
// ============================================
// 12. å®å¯æ¢¦å½¢æ€åç¼€ (Form Suffixes)
// ============================================
// ç”¨äº extractBaseFormId() å‡½æ•°
const FORM_SUFFIXES = [
    'starter',      // æ­æ¡£å½¢æ€ (Let's Go)
    'gmax',         // æå·¨åŒ–
    'megax', 'megay', 'mega',  // Megaè¿›åŒ–
    'alola', 'galar', 'hisui', 'paldea',  // åœ°åŒºå½¢æ€
    'therian', 'incarnate',  // çµå…½/åŒ–èº«
    'origin', 'altered',     // èµ·æº/å¦ä¸€å½¢æ€
    'crowned', 'hero',       // ç‹å† /è‹±é›„
    'eternamax',    // æ— æå·¨åŒ–
    'primal',       // åŸå§‹å›å½’
    'ultra',        // ç©¶æ
    'ash',          // å°æ™ºç‰ˆ
    'totem',        // éœ¸ä¸»
    'cosplay', 'phd', 'libre', 'popstar', 'rockstar', 'belle', // çš®å¡ä¸˜æ¢è£…
    'original', 'hoenn', 'sinnoh', 'unova', 'kalos', 'partner', 'world'  // å¸½å­çš®å¡ä¸˜
];
// ============================================
// 13. é»˜è®¤åå¤‡æ‹›å¼ (Fallback Moves)
// ============================================
const FALLBACK_MOVES = [
    'Tackle',
    'Quick Attack',
    'Ember',
    'Water Gun',
    'Vine Whip'
];
// ============================================
// 14. è¶…æå·¨åŒ–å› å­é€ŸæŸ¥è¡¨ (G-Max Species Data)
// ============================================
// Key: å®å¯æ¢¦ Species ID (å°å†™æ— ç¬¦å·)
// Value: { move: ä¸“å±æ‹›å¼å, type: è§¦å‘å±æ€§, cn: ä¸­æ–‡æ‹›å¼å }
const GMAX_SPECIES_DATA = {
    // ================= å…³éƒ½åœ°åŒº (Gen 1) =================
    'venusaur':         { move: 'G-Max Vine Lash',    type: 'Grass',    cn: 'è¶…æå·¨ç°é£é­ç­' },   // å¦™è›™èŠ±
    'charizard':        { move: 'G-Max Wildfire',     type: 'Fire',     cn: 'è¶…æå·¨æ·±æ¸Šç­ç„°' },   // å–·ç«é¾™
    'blastoise':        { move: 'G-Max Cannonade',    type: 'Water',    cn: 'è¶…æå·¨æ°´ç‚®è½°ç­' },   // æ°´ç®­é¾Ÿ
    'butterfree':       { move: 'G-Max Befuddle',     type: 'Bug',      cn: 'è¶…æå·¨è¶å½±è›Šæƒ‘' },   // å·´å¤§è¶
    'pikachu':          { move: 'G-Max Volt Crash',   type: 'Electric', cn: 'è¶…æå·¨ä¸‡é›·è½°é¡¶' },   // çš®å¡ä¸˜
    'meowth':           { move: 'G-Max Gold Rush',    type: 'Normal',   cn: 'è¶…æå·¨ç‰¹å¤§é‡‘å¸' },   // å–µå–µ
    'machamp':          { move: 'G-Max Chi Strike',   type: 'Fighting', cn: 'è¶…æå·¨ä¼šå¿ƒä¸€å‡»' },   // æ€ªåŠ›
    'gengar':           { move: 'G-Max Terror',       type: 'Ghost',    cn: 'è¶…æå·¨å¹»å½±å¹½é­‚' },   // è€¿é¬¼
    'kingler':          { move: 'G-Max Foam Burst',   type: 'Water',    cn: 'è¶…æå·¨æ¿€æ¼©æ³¡æ¶¡' },   // å·¨é’³èŸ¹
    'lapras':           { move: 'G-Max Resonance',    type: 'Ice',      cn: 'è¶…æå·¨æå…‰æ—‹å¾‹' },   // æ‹‰æ™®æ‹‰æ–¯ (å†°ç³»è§¦å‘)
    'eevee':            { move: 'G-Max Cuddle',       type: 'Normal',   cn: 'è¶…æå·¨çƒ­æƒ…æ‹¥æŠ±' },   // ä¼Šå¸ƒ
    'snorlax':          { move: 'G-Max Replenish',    type: 'Normal',   cn: 'è¶…æå·¨èµ„æºå†ç”Ÿ' },   // å¡æ¯”å…½
    // ================= åˆä¼—åœ°åŒº (Gen 5) =================
    'garbodor':         { move: 'G-Max Malodor',      type: 'Poison',   cn: 'è¶…æå·¨è‡­æ°”å†²å¤©' },   // ç°å°˜å±±
    // ================= é˜¿ç½—æ‹‰åœ°åŒº (Gen 7) =================
    'melmetal':         { move: 'G-Max Meltdown',     type: 'Steel',    cn: 'è¶…æå·¨æ¶²é‡‘ç†”å‡»' },   // ç¾å½•æ¢…å¡”
    // ================= ä¼½å‹’å°”åœ°åŒº (Gen 8) =================
    'rillaboom':        { move: 'G-Max Drum Solo',    type: 'Grass',    cn: 'è¶…æå·¨ç‹‚æ“‚ä¹±æ‰“' },   // è½°æ“‚é‡‘åˆšçŒ©
    'cinderace':        { move: 'G-Max Fireball',     type: 'Fire',     cn: 'è¶…æå·¨ç ´é˜µç«çƒ' },   // é—ªç„°ç‹ç‰Œ
    'inteleon':         { move: 'G-Max Hydrosnipe',   type: 'Water',    cn: 'è¶…æå·¨ç‹™å‡»ç¥å°„' },   // åƒé¢é¿å½¹
    'corviknight':      { move: 'G-Max Wind Rage',    type: 'Flying',   cn: 'è¶…æå·¨æ—‹é£è¢­å·' },   // é’¢é“ é¸¦
    'orbeetle':         { move: 'G-Max Gravitas',     type: 'Psychic',  cn: 'è¶…æå·¨å¤©é“ä¸ƒæ˜Ÿ' },   // ä»¥æ¬§è·¯æ™®
    'drednaw':          { move: 'G-Max Stonesurge',   type: 'Water',    cn: 'è¶…æå·¨å²©é˜µä»¥å¾…' },   // æš´å™¬é¾Ÿ
    'coalossal':        { move: 'G-Max Volcalith',    type: 'Rock',     cn: 'è¶…æå·¨ç‚çŸ³å–·å‘' },   // å·¨ç‚­å±±
    'flapple':          { move: 'G-Max Tartness',     type: 'Grass',    cn: 'è¶…æå·¨é…¸ä¸æºœä¸¢' },   // è‹¹è£¹é¾™
    'appletun':         { move: 'G-Max Sweetness',    type: 'Grass',    cn: 'è¶…æå·¨ç¼æµ†ç‰æ¶²' },   // ä¸°èœœé¾™
    'sandaconda':       { move: 'G-Max Sandblast',    type: 'Ground',   cn: 'è¶…æå·¨æ²™å°˜æ¼«å¤©' },   // æ²™èºèŸ’
    'toxtricity':       { move: 'G-Max Stun Shock',   type: 'Electric', cn: 'è¶…æå·¨å¼‚æ¯’ç”µåœº' },   // é¢¤å¼¦è¾èˆ (é«˜è°ƒ)
    'toxtricitylowkey': { move: 'G-Max Stun Shock',   type: 'Electric', cn: 'è¶…æå·¨å¼‚æ¯’ç”µåœº' },   // é¢¤å¼¦è¾èˆ (ä½è°ƒ)
    'centiskorch':      { move: 'G-Max Centiferno',   type: 'Fire',     cn: 'è¶…æå·¨ç™¾ç«ç„šé‡' },   // ç„šç„°èš£
    'hatterene':        { move: 'G-Max Smite',        type: 'Fairy',    cn: 'è¶…æå·¨å¤©è°´é›·è¯›' },   // å¸ƒè‰å§†æ¸©
    'grimmsnarl':       { move: 'G-Max Snooze',       type: 'Dark',     cn: 'è¶…æå·¨ç¡é­”é™ä¸´' },   // é•¿æ¯›å·¨é­”
    'alcremie':         { move: 'G-Max Finale',       type: 'Fairy',    cn: 'è¶…æå·¨å¹¸ç¦åœ†æ»¡' },   // éœœå¥¶ä»™
    'copperajah':       { move: 'G-Max Steelsurge',   type: 'Steel',    cn: 'è¶…æå·¨é’¢é“é˜µæ³•' },   // å¤§ç‹é“œè±¡
    'duraludon':        { move: 'G-Max Depletion',    type: 'Dragon',   cn: 'è¶…æå·¨åŠ£åŒ–è¡°å˜' },   // é“é’¢é¾™
    // ================= æ­¦é“ç†Šå¸ˆ (Urshifu) =================
    'urshifu':             { move: 'G-Max One Blow',   type: 'Dark',    cn: 'è¶…æå·¨å¤ºå‘½ä¸€å‡»' },   // ä¸€å‡»æµ (é»˜è®¤)
    'urshifusinglestrike': { move: 'G-Max One Blow',   type: 'Dark',    cn: 'è¶…æå·¨å¤ºå‘½ä¸€å‡»' },   // ä¸€å‡»æµ
    'urshifurapidstrike':  { move: 'G-Max Rapid Flow', type: 'Water',   cn: 'è¶…æå·¨æµæ°´è¿å‡»' }    // è¿å‡»æµ
};
// ============================================
// 15. é€šç”¨æå·¨æ‹›å¼æ˜ å°„è¡¨ (Generic Max Moves by Type)
// ============================================
const GENERIC_MAX_BY_TYPE = {
    'Normal':   'Max Strike',
    'Fire':     'Max Flare',
    'Water':    'Max Geyser',
    'Electric': 'Max Lightning',
    'Grass':    'Max Overgrowth',
    'Ice':      'Max Hailstorm',
    'Fighting': 'Max Knuckle',
    'Poison':   'Max Ooze',
    'Ground':   'Max Quake',
    'Flying':   'Max Airstream',
    'Psychic':  'Max Mindstorm',
    'Bug':      'Max Flutterby',
    'Rock':     'Max Rockfall',
    'Ghost':    'Max Phantasm',
    'Dragon':   'Max Wyrmwind',
    'Dark':     'Max Darkness',
    'Steel':    'Max Steelspike',
    'Fairy':    'Max Starfall'
};
// ============================================
// 16. é€šç”¨æå·¨æ‹›å¼ä¸­æ–‡åæ˜ å°„
// ============================================
const GENERIC_MAX_CN = {
    'Max Strike':    'æå·¨æ”»å‡»',
    'Max Flare':     'æå·¨ç«çˆ†',
    'Max Geyser':    'æå·¨æ°´æµ',
    'Max Lightning': 'æå·¨é—ªç”µ',
    'Max Overgrowth':'æå·¨è‰åŸ',
    'Max Hailstorm': 'æå·¨å¯’å†°',
    'Max Knuckle':   'æå·¨æ‹³æ–—',
    'Max Ooze':      'æå·¨é…¸æ¯’',
    'Max Quake':     'æå·¨å¤§åœ°',
    'Max Airstream': 'æå·¨é£å†²',
    'Max Mindstorm': 'æå·¨è¶…èƒ½',
    'Max Flutterby': 'æå·¨è™«è›Š',
    'Max Rockfall':  'æå·¨å²©çŸ³',
    'Max Phantasm':  'æå·¨å¹½é­‚',
    'Max Wyrmwind':  'æå·¨é¾™éª‘',
    'Max Darkness':  'æå·¨æ¶éœ¸',
    'Max Steelspike':'æå·¨é’¢é“',
    'Max Starfall':  'æå·¨å¦–ç²¾',
    'Max Guard':     'æå·¨é˜²å£'
};
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€ (Export to Window)
// ============================================
if (typeof window !== 'undefined') {
    window.MOVE_CONSTANTS = {
        PRIORITY_MAP,
        RECOIL_MOVES,
        DRAIN_MOVES,
        TRAPPING_MOVES,
        ALWAYS_CRIT_MOVES,
        AI_BOOST_MOVES,
        AI_STATUS_MOVES,
        AI_SLEEP_MOVES,
        AI_PARALYZE_MOVES,
        AI_HEAL_MOVES,
        AI_PROTECT_MOVES,
        FORM_SUFFIXES,
        FALLBACK_MOVES,
        GMAX_SPECIES_DATA,
        GENERIC_MAX_BY_TYPE,
        GENERIC_MAX_CN
    };
    // ä¹Ÿå•ç‹¬å¯¼å‡ºå¸¸ç”¨çš„
    window.PRIORITY_MAP = PRIORITY_MAP;
    window.RECOIL_MOVES = RECOIL_MOVES;
    window.DRAIN_MOVES = DRAIN_MOVES;
    window.TRAPPING_MOVES = TRAPPING_MOVES;
    window.ALWAYS_CRIT_MOVES = ALWAYS_CRIT_MOVES;
    window.FORM_SUFFIXES = FORM_SUFFIXES;
    window.GMAX_SPECIES_DATA = GMAX_SPECIES_DATA;
    window.GENERIC_MAX_BY_TYPE = GENERIC_MAX_BY_TYPE;
    window.GENERIC_MAX_CN = GENERIC_MAX_CN;
}
]]></file>
        <file name="moves-data.js"><![CDATA[/**
 * Pokemon Showdown Moves Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/moves.ts
 * 
 * æ³¨æ„: å‡½æ•°å›è°ƒã€condition å—å·²è¢«ç§»é™¤ï¼Œä»…ä¿ç•™é™æ€æ•°æ®
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="moves-data.js"></script>
 *   console.log(MOVES.thunderbolt.basePower); // 90
 */
const MOVES = {
	"10000000voltthunderbolt": {
		num: 719,
		accuracy: true,
		basePower: 195,
		category: "Special",
		isNonstandard: "Past",
		name: "10,000,000 Volt Thunderbolt",
		pp: 1,
		priority: 0,
		flags: {},
		isZ: "pikashuniumz",
		critRatio: 3,
		secondary: null,
		target: "normal",
		type: "Electric",
		contestType: "Cool",
	},
	absorb: {
		num: 71,
		accuracy: 100,
		basePower: 20,
		category: "Special",
		name: "Absorb",
		pp: 25,
		priority: 0,
		flags: { protect: 1, mirror: 1, heal: 1, metronome: 1 },
		drain: [1, 2],
		secondary: null,
		target: "normal",
		type: "Grass",
		contestType: "Clever",
	},
	accelerock: {
		num: 709,
		accuracy: 100,
		basePower: 40,
		category: "Physical",
		name: "Accelerock",
		pp: 20,
		priority: 1,
		flags: { contact: 1, protect: 1, mirror: 1, metronome: 1 },
		secondary: null,
		target: "normal",
		type: "Rock",
		contestType: "Cool",
	},
	acid: {
		num: 51,
		accuracy: 100,
		basePower: 40,
		category: "Special",
		name: "Acid",
		pp: 30,
		priority: 0,
		flags: { protect: 1, mirror: 1, metronome: 1 },
		secondary: {
			chance: 10,
			boosts: {
				spd: -1,
			},
		},
		target: "allAdjacentFoes",
		type: "Poison",
		contestType: "Clever",
	},
	acidarmor: {
		num: 151,
		accuracy: true,
		basePower: 0,
		category: "Status",
		name: "Acid Armor",
		pp: 20,
		priority: 0,
		flags: { snatch: 1, metronome: 1 },
		boosts: {
			def: 2,
		},
		secondary: null,
		target: "self",
		type: "Poison",
		zMove: { effect: 'clearnegativeboost' },
		contestType: "Tough",
	},
	aciddownpour: {
		num: 628,
[... truncated: only first 100 lines included ...]
]]></file>
        <file name="pokedex-data.js"><![CDATA[/**
 * Pokemon Showdown Pokedex Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/pokedex.ts
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="pokedex-data.js"></script>
 *   console.log(POKEDEX.pikachu.baseStats);
 */
const POKEDEX = {
	bulbasaur: {
		num: 1,
		name: "Bulbasaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 45, atk: 49, def: 49, spa: 65, spd: 65, spe: 45 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 0.7,
		weightkg: 6.9,
		color: "Green",
		evos: ["Ivysaur"],
		eggGroups: ["Monster", "Grass"],
	},
	ivysaur: {
		num: 2,
		name: "Ivysaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 60, atk: 62, def: 63, spa: 80, spd: 80, spe: 60 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 1,
		weightkg: 13,
		color: "Green",
		prevo: "Bulbasaur",
		evoLevel: 16,
		evos: ["Venusaur"],
		eggGroups: ["Monster", "Grass"],
	},
	venusaur: {
		num: 3,
		name: "Venusaur",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 82, def: 83, spa: 100, spd: 100, spe: 80 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 2,
		weightkg: 100,
		color: "Green",
		prevo: "Ivysaur",
		evoLevel: 32,
		eggGroups: ["Monster", "Grass"],
		otherFormes: ["Venusaur-Mega"],
		formeOrder: ["Venusaur", "Venusaur-Mega"],
		canGigantamax: "G-Max Vine Lash",
	},
	venusaurmega: {
		num: 3,
		name: "Venusaur-Mega",
		baseSpecies: "Venusaur",
		forme: "Mega",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 100, def: 123, spa: 122, spd: 120, spe: 80 },
		abilities: { 0: "Thick Fat" },
		heightm: 2.4,
		weightkg: 155.5,
		color: "Green",
		eggGroups: ["Monster", "Grass"],
		requiredItem: "Venusaurite",
	},
	venusaurgmax: {
		num: 3,
		name: "Venusaur-Gmax",
		baseSpecies: "Venusaur",
		forme: "Gmax",
		types: ["Grass", "Poison"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 80, atk: 82, def: 83, spa: 100, spd: 100, spe: 80 },
		abilities: { 0: "Overgrow", H: "Chlorophyll" },
		heightm: 24,
		weightkg: 0,
		color: "Green",
		eggGroups: ["Monster", "Grass"],
		changesFrom: "Venusaur",
	},
	charmander: {
		num: 4,
		name: "Charmander",
		types: ["Fire"],
		genderRatio: { M: 0.875, F: 0.125 },
		baseStats: { hp: 39, atk: 52, def: 43, spa: 60, spd: 50, spe: 65 },
		abilities: { 0: "Blaze", H: "Solar Power" },
		heightm: 0.6,
		weightkg: 8.5,
		color: "Red",
		evos: ["Charmeleon"],
		eggGroups: ["Monster", "Dragon"],
	},
	charmeleon: {
[... truncated: only first 100 lines included ...]
]]></file>
        <file name="trainer-avs.js"><![CDATA[/**
 * =============================================
 * TRAINER AVs PROFILES - è®­ç»ƒå®¶æƒ…æ„ŸåŠªåŠ›å€¼é…ç½®
 * =============================================
 * 
 * æ´›è¿ªäºšç‰¹åŒº (Rhodia Region) ä¸“å±ç³»ç»Ÿ
 * å—ç¥é¦”ç²‰é›¾ (Ambrosia) å½±å“ï¼Œæ¯ä½è®­ç»ƒå®¶éƒ½æœ‰ç‹¬ç‰¹çš„ AVs å€¾å‘
 * 
 * å››å¤§ç»´åº¦ï¼š
 * - Trust (ä¿¡èµ–): é˜²å®ˆå‘ï¼Œè‡´å‘½ä¼¤å®³æ—¶é”è¡€
 * - Passion (æ¿€æƒ…): è¿›æ”»å‘ï¼Œæš´å‡»ç‡æå‡
 * - Insight (çµçŠ€): å›é¿å‘ï¼Œé—ªé¿ç‡æå‡
 * - Devotion (çŒ®èº«): å›å¤å‘ï¼Œå›åˆæœ«æ²»æ„ˆå¼‚å¸¸
 */
const TRAINER_AVS_PROFILES = {
    // =====================================================
    // éœ“è™¹å•†ä¸šåŒº (Neon District) - ç”µ/æ¯’
    // é¦†ä¸»: Iono & Roxie
    // ä¸“ç²¾: Passion (æ¿€æƒ…)
    // =====================================================
    'iono': {
        name: 'Iono',
        cnName: 'å¥‡æ ‘',
        district: 'Neon',
        specialty: 'Passion',
        description: 'ç›´æ’­å¥³ç‹çš„æˆ˜æ–—é£æ ¼å¦‚åŒå¥¹çš„èŠ‚ç›®ä¸€æ ·çƒ­çƒˆåˆºæ¿€',
        aura: {
            name: 'Adrenaline Rush',
            effect: 'å…¨é˜Ÿæš´å‡»ç‡æå‡ï¼Œå‡»æ€åé€Ÿåº¦+1'
        },
        defaultAVs: {
            trust: 80,
            passion: 220,    // ä¸“ç²¾
            insight: 120,
            devotion: 60
        }
    },
    'roxie': {
        name: 'Roxie',
        cnName: 'éœç±³åŠ ',
        district: 'Neon',
        specialty: 'Passion',
        description: 'æ‘‡æ»šå¥³å­©çš„æ¯’ç³»æ”»åŠ¿å¦‚åŒå¥¹çš„éŸ³ä¹ä¸€æ ·ç‹‚æš´',
        aura: {
            name: 'Toxic Rush',
            effect: 'æ¯’ç³»æ‹›å¼æš´å‡»ç‡é¢å¤–+1'
        },
        defaultAVs: {
            trust: 60,
            passion: 200,    // ä¸“ç²¾
            insight: 100,
            devotion: 80
        }
    },
    // =====================================================
    // ç¹èŠ±æµ·æ»¨åŒº (Bloom District) - è‰/æ°´
    // é¦†ä¸»: Erika & Nessa
    // ä¸“ç²¾: Devotion (çŒ®èº«)
    // =====================================================
    'erika': {
        name: 'Erika',
        cnName: 'è‰ä½³',
        district: 'Bloom',
        specialty: 'Devotion',
        description: 'ä¼˜é›…çš„èŠ±é“å¤§å¸ˆï¼Œå¥¹çš„å®å¯æ¢¦å¦‚åŒèŠ±æœµèˆ¬åšéŸ§',
        aura: {
            name: 'Floral Blessing',
            effect: 'å›å¤æŠ€èƒ½æ•ˆæœ+20%ï¼Œå¼‚å¸¸çŠ¶æ€æŠ—æ€§æå‡'
        },
        defaultAVs: {
            trust: 120,
            passion: 60,
            insight: 80,
            devotion: 220    // ä¸“ç²¾
        }
    },
    'nessa': {
        name: 'Nessa',
        cnName: 'éœ²ç’ƒå¨œ',
        district: 'Bloom',
        specialty: 'Devotion',
        description: 'è¶…æ¨¡å…¼é¦†ä¸»ï¼Œå¥¹çš„æ°´ç³»å®å¯æ¢¦æ‹¥æœ‰æƒŠäººçš„æ¢å¤åŠ›',
        aura: {
            name: 'Tidal Recovery',
            effect: 'æ°´ç³»å®å¯æ¢¦æ¯å›åˆæ¢å¤å°‘é‡HP'
        },
        defaultAVs: {
            trust: 100,
            passion: 80,
            insight: 100,
            devotion: 200    // ä¸“ç²¾
        }
    },
    // =====================================================
    // æš—å½±æ—§è¡—åŒº (Shadow District) - æ¶/å¹½çµ
    // é¦†ä¸»: Marnie & Hex Maniac
    // ä¸“ç²¾: Insight (çµçŠ€)
    // =====================================================
    'marnie': {
        name: 'Marnie',
        cnName: 'ç›ä¿',
        district: 'Shadow',
        specialty: 'Insight',
        description: 'å†·é™çš„æš—ç³»ä½¿è€…ï¼Œæ€»èƒ½é¢„åˆ¤å¯¹æ‰‹çš„è¡ŒåŠ¨',
        aura: {
            name: 'Dark Foresight',
            effect: 'AIé¢„è¯»å‡†ç¡®ç‡æå‡ï¼Œæ›´å®¹æ˜“ä½¿ç”¨æ­£ç¡®çš„ä¿æŠ¤/æ¢äºº'
        },
        defaultAVs: {
            trust: 100,
            passion: 100,
            insight: 220,    // ä¸“ç²¾
            devotion: 80
        }
    },
    'hexmaniac': {
        name: 'Hex Maniac',
        cnName: 'çµå¼‚è¿·',
        district: 'Shadow',
        specialty: 'Insight',
        description: 'ç¥ç§˜çš„çµåª’ï¼Œå¥¹çš„å¹½çµç³»å®å¯æ¢¦å¦‚åŒå¹»å½±èˆ¬éš¾ä»¥æ•æ‰',
        aura: {
            name: 'Phantom Sense',
            effect: 'å¹½çµç³»å®å¯æ¢¦é—ªé¿ç‡é¢å¤–æå‡'
        },
        defaultAVs: {
            trust: 60,
            passion: 80,
            insight: 200,    // ä¸“ç²¾
            devotion: 100
        }
    },
    // =====================================================
    // æè¯£ç«æŠ€åŒº (Apex District) - æ ¼æ–—/å…¨èƒ½
    // é¦†ä¸»: Bea & Cynthia
    // ä¸“ç²¾: å…¨ç»´åº¦ (Total Trust)
    // =====================================================
    'bea': {
        name: 'Bea',
        cnName: 'å½©è±†',
        district: 'Apex',
        specialty: 'Balanced',
        description: 'ç©ºæ‰‹é“å¤§å¸ˆï¼Œè¿½æ±‚æè‡´çš„æˆ˜æ–—è‰ºæœ¯',
        aura: {
            name: 'Fighting Spirit',
            effect: 'æ ¼æ–—ç³»å®å¯æ¢¦æ‹¥æœ‰ Second Windï¼ˆé¦–æ¬¡æ¿’æ­»æ—¶é”è¡€+å…¨å±æ€§+1ï¼‰'
        },
        defaultAVs: {
            trust: 180,
            passion: 180,
            insight: 160,
            devotion: 160
        },
        // ç‰¹æ®Šæœºåˆ¶ï¼šSecond Wind
        secondWind: true
    },
    'cynthia': {
        name: 'Cynthia',
        cnName: 'ç«¹å…°',
        district: 'Apex',
        specialty: 'Total',
        description: 'ç¥å¥¥å† å†›ï¼Œä¼ è¯´ä¸­çš„æœ€å¼ºè®­ç»ƒå®¶',
        aura: {
            name: 'Champion\'s Resolve',
            effect: 'ç‹ç‰Œå®å¯æ¢¦æ‹¥æœ‰ Second Windï¼ˆé¦–æ¬¡æ¿’æ­»æ—¶é”è¡€+å…¨å±æ€§+1ï¼‰'
        },
        defaultAVs: {
            trust: 200,
            passion: 200,
            insight: 200,
            devotion: 200
        },
        // ç‰¹æ®Šæœºåˆ¶ï¼šSecond Wind (ä»…é™ç‹ç‰Œ)
        secondWind: true,
        aceOnly: true
    },
    // =====================================================
    // ç®¡ç†ä¸ç§‘ç ”äººå‘˜
    // =====================================================
    'lusamine': {
        name: 'Lusamine',
        cnName: 'éœ²èç±³å¥ˆ',
        role: 'Executive Director',
        description: 'ä»¥å¤ªåŸºé‡‘ä¼šæ‰§è¡Œè‘£äº‹ï¼Œå¯¹å®å¯æ¢¦æœ‰ç€æ‰­æ›²çš„çˆ±',
        defaultAVs: {
            trust: 60,
            passion: 120,
            insight: 160,
            devotion: 240    // æç«¯çš„çŒ®èº«
        }
    },
    'sonia': {
        name: 'Sonia',
        cnName: 'ç´¢å¦®äºš',
        role: 'Chief Researcher',
        description: 'é¦–å¸­åšå£«ï¼Œè´Ÿè´£å¾¡ä¸‰å®¶é€‰æ‹©å’ŒåˆæœŸå¼•å¯¼',
        defaultAVs: {
            trust: 140,
            passion: 80,
            insight: 180,
            devotion: 100
        }
    },
    // =====================================================
    // ç‰¹é‚€ä»£è¡¨
    // =====================================================
    'gloria': {
        name: 'Gloria',
        cnName: 'ä¼˜è‰',
        role: 'Camping Expert',
        description: 'éœ²è¥æŠ€æœ¯ä¸å’–å–±æ–™ç†æ¨å¹¿å¤§ä½¿',
        defaultAVs: {
            trust: 160,
            passion: 120,
            insight: 100,
            devotion: 140
        }
    },
    'rosa': {
        name: 'Rosa',
        cnName: 'æ¢…ä¾',
        role: 'Idol Trainer',
        description: 'å¶åƒè‰ºäººä¸ç»ƒä¹ ç”Ÿå¯¼å¸ˆ',
        defaultAVs: {
            trust: 200,
            passion: 100,
            insight: 80,
            devotion: 180
        }
    },
    'dawn': {
        name: 'Dawn',
        cnName: 'å°å…‰',
        role: 'Contest Judge',
        description: 'åä¸½å¤§èµ›å¸¸é©»è¯„å§”',
        defaultAVs: {
            trust: 140,
            passion: 140,
            insight: 140,
            devotion: 140
        }
    },
    'serena': {
        name: 'Serena',
        cnName: 'ç‘Ÿè•¾å¨œ',
        role: 'Media Queen',
        description: 'çŸ­è§†é¢‘ä¸æ–°åª’ä½“å¥³ç‹',
        defaultAVs: {
            trust: 120,
            passion: 160,
            insight: 120,
            devotion: 120
        }
    },
    // =====================================================
    // æ´—ç¿ æ—¶ç©ºéš¾æ°‘
    // =====================================================
    'irida': {
        name: 'Irida',
        cnName: 'ä¼Šè•¾è¾¾',
        role: 'Pearl Clan Leader',
        description: 'çç å›¢é¦–é¢†ï¼Œä¸å®å¯æ¢¦æœ‰ç€åŸå§‹çš„é»˜å¥‘',
        defaultAVs: {
            trust: 180,
            passion: 80,
            insight: 200,
            devotion: 120
        }
    },
    'akari': {
        name: 'Akari',
        cnName: 'å°ç…§',
        role: 'Refugee Coordinator',
        description: 'æ—¶ç©ºéš¾æ°‘æ¥å¾…å¤„ä¸»ä»»',
        defaultAVs: {
            trust: 160,
            passion: 100,
            insight: 160,
            devotion: 140
        }
    }
};
/**
 * è·å–è®­ç»ƒå®¶çš„ AVs é…ç½®
 * @param {string} trainerId - è®­ç»ƒå®¶ID
 * @returns {object|null} AVs é…ç½®å¯¹è±¡
 */
function getTrainerAVsProfile(trainerId) {
    if (!trainerId) return null;
    const id = trainerId.toLowerCase().replace(/[^a-z0-9]/g, '');
    return TRAINER_AVS_PROFILES[id] || null;
}
/**
 * ä¸ºå®å¯æ¢¦åº”ç”¨è®­ç»ƒå®¶çš„ AVs é…ç½®
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {string} trainerId - è®­ç»ƒå®¶ID
 * @param {boolean} isAce - æ˜¯å¦ä¸ºç‹ç‰Œå®å¯æ¢¦
 */
function applyTrainerAVs(pokemon, trainerId, isAce = false) {
    const profile = getTrainerAVsProfile(trainerId);
    if (!profile || !pokemon) return;
    // åº”ç”¨é»˜è®¤ AVs
    if (profile.defaultAVs) {
        pokemon.avs = { ...profile.defaultAVs };
    }
    // Second Wind ç‰¹æ®Šæœºåˆ¶ï¼ˆä»…é™ Apex åŒºé¦†ä¸»ï¼‰
    if (profile.secondWind) {
        if (!profile.aceOnly || isAce) {
            pokemon.hasSecondWind = true;
        }
    }
}
// å¯¼å‡º
if (typeof window !== 'undefined') {
    window.TRAINER_AVS_PROFILES = TRAINER_AVS_PROFILES;
    window.getTrainerAVsProfile = getTrainerAVsProfile;
    window.applyTrainerAVs = applyTrainerAVs;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        TRAINER_AVS_PROFILES,
        getTrainerAVsProfile,
        applyTrainerAVs
    };
}
]]></file>
        <file name="trainer-data.js"><![CDATA[/* 
 * è§’è‰²: å°ä¼˜ (Gloria)
 * èº«ä»½: ä¼½å‹’å°”å† å†› / å’–å–±å¤§å¸ˆ
 */
const GLORIA_DATA = {
    // ã€Tier 4 - æå·¨åŒ–å…¨å¼€Â·å† å†›æ¨¡å¼ã€‘
    4: {
        "unlocks": {
            "enable_bond": false,
            "enable_styles": false,
            "enable_insight": false,
            "enable_mega": false,
            "enable_z_move": false,
            "enable_dynamax": true, // Galar æ ¸å¿ƒæœºåˆ¶
            "enable_tera": false
        },
        "party": [
            {
                "name": "Zacian-Crowned", 
                "lv": 99, 
                "gender": "N", 
                // è‹å“æœ¬èº«æ— æ³•æå·¨åŒ–ï¼Œæ‰€ä»¥ä¸è®¾ç½® mechanic
                "nature": "Adamant", 
                "ability": "Intrepid Sword", 
                "item": "Rusted Sword", 
                "isAce": true, 
                "stats_meta": {
                    "is_perfect": true, // å‡è®¾å¼•æ“æ”¯æŒæˆ–ä¿ç•™ ivs å†™æ³•
                    "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
                    "ev_level": 252
                },
                "moves": [
                    "Behemoth Blade", // å·¨å…½æ–©ï¼šé’ˆå¯¹æå·¨åŒ–åŒå€ä¼¤å®³
                    "Play Rough",     // å¬‰é—¹ï¼šä»¥æœ¬ç³»è¾“å‡ºè¦†ç›–é¾™/æ ¼æ–—
                    "Close Combat",   // è¿‘èº«æˆ˜ï¼šé’¢é“/æ™®é€šæ‰“å‡»é¢
                    "Swords Dance"    // å‰‘èˆï¼šä¸€æ—¦è®©å®ƒå¼ºåŒ–ä¸€æ¬¡ï¼Œå°±æ˜¯æ¨é˜ŸèŠ‚å¥
                ],
                // ç‹ç‰Œæ»¡é…æƒ…æ„Ÿå€¼ï¼šä¸ä»…æœ‰è¾“å‡º(Passion)è¿˜æœ‰æ— æ•Œçš„å›é¿(Insight)ä¸è€æ€§(Trust)
                "friendship": { "trust": 255, "passion": 255, "insight": 200, "devotion": 150 }
            },
            {
                "name": "Cinderace", 
                "lv": 97, 
                "gender": "M",
                "nature": "Jolly", 
                "ability": "Libero", // è‡ªç”±è€…ï¼šå˜æ¢å±æ€§ï¼Œæå…¶çµæ´»
                "item": "Life Orb", 
                // æ ¸å¿ƒæå·¨ä½
                "mechanic": "dynamax", 
                "mega_target": "cinderacegmax", // ç¡®ä¿é€šè¿‡ autoDetect æ‹¿åˆ° G-Max å½¢æ€
                "stats_meta": { "ev_level": 252 },
                "moves": [
                    "Pyro Ball",    // æå·¨åå˜æˆ G-Max Fireball (160å¨åŠ›+ç ´æ ¼)
                    "Bounce",       // æå·¨åå˜æˆ Max Airstream (å…¨é˜Ÿæé€Ÿï¼Œæ ¸å¿ƒæ¨é˜ŸæŠ€)
                    "High Jump Kick", // å˜æˆ Max Knuckle (å…¨é˜ŸåŠ æ”»)
                    "Court Change"    // æ¢åœºï¼šè™½ç„¶æ˜¯å˜åŒ–æŠ€ï¼Œä½†åœ¨æ™®é€šçŠ¶æ€ä¸‹å¯åå»ç©å®¶çš„å¢™/é’‰
                ],
                "avs": { "trust": 150, "passion": 230 }
            },
            {
                "name": "Rillaboom", 
                "lv": 95, 
                "gender": "M",
                "nature": "Adamant",
                "ability": "Grassy Surge", 
                "item": "Grassy Seed", // ä¸Šåœºé˜²ç‰©é˜²+1
                "mechanic": "dynamax",
                "mega_target": "rillaboomgmax", // å³ä½¿ä¸æ˜¯ACEï¼Œå¦‚æœä½œä¸ºæœ€åä¸€åªä¸Šåœºä¹Ÿèƒ½G-Max
                "stats_meta": { "ev_level": 252 },
                "moves": [
                    "Grassy Glide", // é’è‰æ»‘æ¢¯ï¼šåœºåœ°ä¸‹å…ˆåˆ¶
                    "Drum Beating", // æ§é€Ÿ
                    "High Horsepower", // è¡¥ç›²æ‰“ç«/ç”µ
                    "U-turn"         // çµæ´»è½®è½¬
                ]
            },
            {
                "name": "Urshifu-Rapid-Strike", 
                "lv": 94, 
                "gender": "M",
                "nature": "Jolly", // åŠ é€Ÿåº¦
                "ability": "Unseen Fist", 
                "item": "Focus Sash", // æ°”è…°é˜²æ­¢è¢«ç©å®¶çš„ Flying æ‹›å¼ç¡®ä¸€ï¼Œä¿è¯è¾“å‡º
                "mechanic": "dynamax",
                "mega_target": "urshifurapidstrikegmax",
                "stats_meta": { "ev_level": 252 },
                "moves": [
                    "Surging Strikes", // å¿…æš´å‡»
                    "Close Combat", 
                    "Ice Punch",      // å†°æ‹³ï¼šé’ˆå¯¹å¤„ç†ä¸äº†çš„é£è¡Œ/è‰/é¾™ç³»
                    "Aqua Jet"        // å…ˆåˆ¶æ”¶å‰²
                ]
            },
            {
                "name": "Corviknight", 
                "lv": 94, 
                "gender": "M",
                "nature": "Impish", // åŠ ç‰©é˜²ï¼Œå‡ç‰¹æ”»
                "ability": "Mirror Armor", 
                "item": "Leftovers", 
[... truncated: only first 100 lines included ...]
]]></file>
    </directory>
    <directory name="engine">
        <file name="ability-handlers.js"><![CDATA[/**
 * =============================================
 * ABILITY HANDLERS - ç‰¹æ€§å¤„ç†å™¨
 * =============================================
 * 
 * ä»…æ”¶å½• Top 25 + å¸¸è§ RP ç‰¹æ€§ã€‚
 * ä½¿ç”¨ Hook ç³»ç»Ÿæ³¨å…¥åˆ° battle-engine.js çš„å„ä¸ªç¯èŠ‚ã€‚
 */
// ç®€å•çš„è¾…åŠ©å·¥å…·
function isPinching(poke) {
    return poke.currHp > 0 && poke.currHp <= poke.maxHp / 3;
}
const AbilityHandlers = {
    // ============================================
    // A. æš´åŠ›æ•°å€¼ä¿®æ­£
    // ============================================
    // ã€å¤§åŠ›å£«/ç‘œä¼½ä¹‹åŠ›ã€‘ç‰©æ”»ç¿»å€
    'Huge Power': { onModifyStat: (stats) => stats.atk *= 2 },
    'Pure Power': { onModifyStat: (stats) => stats.atk *= 2 },
    // ã€æŠ€æœ¯é«˜æ‰‹ã€‘ä½å¨åŠ›(<=60)æ‹›å¼ x1.5
    'Technician': {
        onBasePower: (power, attacker, defender, move) => {
            if (power <= 60) return power * 1.5;
            return power;
        }
    },
    // ã€é€‚åº”åŠ›ã€‘æœ¬ç³»åŠ æˆä» 1.5 -> 2.0
    'Adaptability': {
        // è¿™ä¸€æ¡æ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬é€šè¿‡ä¿®æ”¹ stab å€ç‡å®ç°ï¼Œéœ€åœ¨ calcDamage é‡Œç‰¹åˆ«åˆ¤æ–­
        onModifySTAB: (stab) => 2
    },
    // ã€æœ‰è‰²çœ¼é•œã€‘æ•ˆæœä¸å¥½(X0.5)æ—¶å˜ä¸ºæ­£å¸¸(X1)
    'Tinted Lens': {
        onModifyEffectiveness: (eff) => {
            if (eff < 1 && eff > 0) return eff * 2;
            return eff;
        }
    },
    // ============================================
    // B. å¾¡ä¸‰å®¶ä¸“å± - ç»å¢ƒçˆ†å‘ (çº¢è¡€å˜èº«)
    // ============================================
    'Blaze': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Fire' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Torrent': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Water' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Overgrow': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Grass' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    'Swarm': {
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Bug' && isPinching(attacker)) return power * 1.5;
            return power;
        }
    },
    // ============================================
    // C. ç‰¹æ®Šé˜²å¾¡/å¼€çœ¼
    // ============================================
    // ã€æ¼‚æµ®ã€‘å…ç–«åœ°é¢
    'Levitate': {
        onImmunity: (atkType) => atkType === 'Ground',
        groundImmune: true
    },
    // ã€å¼•ç«ã€‘å…ç–«ç«ç³»+å¨åŠ›æå‡50%
    'Flash Fire': {
        onImmunity: (atkType) => atkType === 'Fire',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Fire') {
                pokemon.flashFireBoost = true;
                logs.push(`ğŸ”¥ ${pokemon.cnName} çš„å¼•ç«ç‰¹æ€§å‘åŠ¨ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        },
        // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºï¼š(power, attacker, defender, move)
        onBasePower: (power, attacker, defender, move) => {
            if (move.type === 'Fire' && attacker.flashFireBoost) return Math.floor(power * 1.5);
            return power;
        }
    },
    // ã€è“„æ°´ã€‘å…ç–«æ°´ç³»+å›å¤1/4HP
    'Water Absorb': {
        onImmunity: (atkType) => atkType === 'Water',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Water') {
                const heal = Math.floor(pokemon.maxHp / 4);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
                logs.push(`ğŸ’§ ${pokemon.cnName} çš„è“„æ°´å›å¤äº† ${heal} HPï¼`);
                return { absorbed: true, heal };
            }
            return { absorbed: false };
        }
    },
    // ã€é¿é›·é’ˆã€‘å…ç–«ç”µç³»+ç‰¹æ”»+1
    'Lightning Rod': {
        onImmunity: (atkType) => atkType === 'Electric',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Electric') {
                if (pokemon.applyBoost) pokemon.applyBoost('spa', 1);
                logs.push(`âš¡ ${pokemon.cnName} çš„é¿é›·é’ˆå‘åŠ¨ï¼ç‰¹æ”»æå‡ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        }
    },
    // ã€è“„ç”µã€‘å…ç–«ç”µç³»+å›å¤1/4HP
    'Volt Absorb': {
        onImmunity: (atkType) => atkType === 'Electric',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Electric') {
                const heal = Math.floor(pokemon.maxHp / 4);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
                logs.push(`âš¡ ${pokemon.cnName} çš„è“„ç”µå›å¤äº† ${heal} HPï¼`);
                return { absorbed: true, heal };
            }
            return { absorbed: false };
        }
    },
    // ã€ç”µæ°”å¼•æ“ã€‘å…ç–«ç”µç³»+é€Ÿåº¦+1
    'Motor Drive': {
        onImmunity: (atkType) => atkType === 'Electric',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Electric') {
                if (pokemon.applyBoost) pokemon.applyBoost('spe', 1);
                logs.push(`âš¡ ${pokemon.cnName} çš„ç”µæ°”å¼•æ“å‘åŠ¨ï¼é€Ÿåº¦æå‡ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        }
    },
    // ã€é£Ÿè‰ã€‘å…ç–«è‰ç³»+æ”»å‡»+1
    'Sap Sipper': {
        onImmunity: (atkType) => atkType === 'Grass',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Grass') {
                if (pokemon.applyBoost) pokemon.applyBoost('atk', 1);
                logs.push(`ğŸŒ¿ ${pokemon.cnName} çš„é£Ÿè‰å‘åŠ¨ï¼æ”»å‡»æå‡ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        }
    },
    // ã€å¼•æ°´ã€‘å…ç–«æ°´ç³»+ç‰¹æ”»+1
    'Storm Drain': {
        onImmunity: (atkType) => atkType === 'Water',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Water') {
                if (pokemon.applyBoost) pokemon.applyBoost('spa', 1);
                logs.push(`ğŸ’§ ${pokemon.cnName} çš„å¼•æ°´å‘åŠ¨ï¼ç‰¹æ”»æå‡ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        }
    },
    // ã€å¹²ç‡¥çš®è‚¤ã€‘å…ç–«æ°´ç³»å›å¤ï¼Œç«ç³»x1.25
    'Dry Skin': {
        onImmunity: (atkType) => atkType === 'Water',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Water') {
                const heal = Math.floor(pokemon.maxHp / 4);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
                logs.push(`ğŸ’§ ${pokemon.cnName} çš„å¹²ç‡¥çš®è‚¤å›å¤äº† ${heal} HPï¼`);
                return { absorbed: true, heal };
            }
            return { absorbed: false };
        },
        // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºï¼š(damage, attacker, defender, move, effectiveness)
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            return move.type === 'Fire' ? Math.floor(damage * 1.25) : damage;
        }
    },
    // ã€ç¥å¥‡é³ç‰‡ã€‘å¼‚å¸¸çŠ¶æ€æ—¶é˜²å¾¡ x1.5 (æ­¤å¤„ç®€åŒ–ä¸ºç‰©é˜²)
    'Marvel Scale': {
        onModifyStat: (stats, poke) => { 
            if (poke.status) stats.def = Math.floor(stats.def * 1.5); 
        }
    },
    // ã€åšç¡¬/ç»“å®ã€‘æ»¡è¡€æ—¶è‡³å°‘ä¿ç•™1è¡€
    'Sturdy': {
        onDamageHack: (damage, defender) => {
            if (defender.currHp === defender.maxHp && damage >= defender.currHp) {
                return defender.currHp - 1; // é”è¡€1
            }
            return damage;
        }
    },
    // ã€ç¥å¥‡å®ˆæŠ¤ã€‘é¬¼è‰ï¼šåªèƒ½è¢«æ•ˆæœç»ä½³çš„æ‹›å¼æ‰“ä¸­
    'Wonder Guard': {
        onTryHit: (attacker, defender, move, effectiveness) => {
            // åªæœ‰æ•ˆæœç»ä½³ï¼ˆ>1ï¼‰çš„æ‹›å¼æ‰èƒ½å‘½ä¸­
            if (effectiveness <= 1) {
                return { blocked: true, message: `${defender.cnName} çš„ç¥å¥‡å®ˆæŠ¤è®©æ”»å‡»æ— æ•ˆäº†ï¼` };
            }
            return { blocked: false };
        },
        wonderGuard: true // æ ‡è®°ï¼šéœ€è¦åœ¨ä¼¤å®³è®¡ç®—æ—¶æ£€æŸ¥
    },
    // ã€åšè„‚è‚ªã€‘å‡åŠç«/å†°ä¼¤å®³
    'Thick Fat': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (move.type === 'Fire' || move.type === 'Ice') {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ã€æ¯›çš®å¤§è¡£ã€‘ç‰©é˜²ç¿»å€
    'Fur Coat': {
        onModifyStat: (stats) => stats.def *= 2
    },
    // ã€æ»¤é•œ/åšç¡¬å²©çŸ³ã€‘å…‹åˆ¶ä¼¤å®³å‡å°‘25%
    'Filter': {
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            if (effectiveness > 1) return Math.floor(damage * 0.75);
            return damage;
        }
    },
    'Solid Rock': {
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            if (effectiveness > 1) return Math.floor(damage * 0.75);
            return damage;
        }
    },
    // ã€å¤šé‡é³ç‰‡ã€‘æ»¡è¡€æ—¶ä¼¤å®³å‡åŠ
    'Multiscale': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (defender.currHp === defender.maxHp) {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ã€æš—å½±ç›¾ç‰Œã€‘æ»¡è¡€æ—¶ä¼¤å®³å‡åŠ
    'Shadow Shield': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            if (defender.currHp === defender.maxHp) {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ============================================
    // æ¥è§¦ç±»æ‹›å¼åé¦ˆç‰¹æ€§ (Contact Move Reactions)
    // æ³¨æ„ï¼šè¿™äº›ç‰¹æ€§åªåœ¨æ¥è§¦ç±»æ‹›å¼å‘½ä¸­æ—¶è§¦å‘
    // ============================================
    // ã€ç²—ç³™çš®è‚¤ã€‘æ¥è§¦æ—¶åä¼¤1/8
    'Rough Skin': {
        onContactDamage: (attacker, defender) => {
            return { damage: Math.floor(attacker.maxHp / 8), message: `${attacker.cnName} è¢«ç²—ç³™çš®è‚¤ä¼¤å®³äº†ï¼` };
        }
    },
    // ã€é“åˆºã€‘æ¥è§¦æ—¶åä¼¤1/8
    'Iron Barbs': {
        onContactDamage: (attacker, defender) => {
            return { damage: Math.floor(attacker.maxHp / 8), message: `${attacker.cnName} è¢«é“åˆºä¼¤å®³äº†ï¼` };
        }
    },
    // ã€é™ç”µã€‘æ¥è§¦æ—¶30%éº»ç—¹
    'Static': {
        onContactStatus: (attacker, defender) => {
            if (Math.random() < 0.3) return { status: 'par', message: `${attacker.cnName} è¢«é™ç”µéº»ç—¹äº†ï¼` };
            return null;
        }
    },
    // ã€ç«ç„°èº«èº¯ã€‘æ¥è§¦æ—¶30%ç¼ä¼¤
    'Flame Body': {
        onContactStatus: (attacker, defender) => {
            if (Math.random() < 0.3) return { status: 'brn', message: `${attacker.cnName} è¢«ç«ç„°èº«èº¯ç¼ä¼¤äº†ï¼` };
            return null;
        }
    },
    // ã€æ¯’åˆºã€‘æ¥è§¦æ—¶30%ä¸­æ¯’
    'Poison Point': {
        onContactStatus: (attacker, defender) => {
            if (Math.random() < 0.3) return { status: 'psn', message: `${attacker.cnName} è¢«æ¯’åˆºæ¯’åˆ°äº†ï¼` };
            return null;
        }
    },
    // ã€å¯çˆ±è¿·äººã€‘æ¥è§¦æ—¶30%ç€è¿·
    'Cute Charm': {
        onContactVolatile: (attacker, defender) => {
            if (Math.random() < 0.3 && attacker.gender !== defender.gender) {
                return { volatile: 'attract', message: `${attacker.cnName} è¢«è¿·ä½äº†ï¼` };
            }
            return null;
        }
    },
    // ã€ç¢è£‚é“ ç”²ã€‘è¢«ç‰©ç†æ”»å‡»æ—¶é˜²å¾¡-1é€Ÿåº¦+2
    'Weak Armor': {
        onPhysicalHit: (attacker, defender, logs) => {
            if (defender.applyBoost) {
                defender.applyBoost('def', -1);
                defender.applyBoost('spe', 2);
            }
            logs.push(`${defender.cnName} çš„ç¢è£‚é“ ç”²å‘åŠ¨ï¼é˜²å¾¡ä¸‹é™ï¼Œé€Ÿåº¦å¤§å¹…æå‡ï¼`);
        }
    },
    // ============================================
    // D. å…¥åœºæ•ˆæœ (Intimidate / Weather)
    // ============================================
    // ã€å¨å“ã€‘
    'Intimidate': {
        onStart: (self, enemy, logs) => {
            if (!enemy || !enemy.isAlive()) return;
            // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æœ‰é˜²æ­¢ä¸‹é™çš„ç‰¹æ€§
            const safe = ['Clear Body', 'White Smoke', 'Full Metal Body', 'Inner Focus', 'Oblivious', 'Hyper Cutter', 'Scrappy', 'Own Tempo'];
            if (enemy.ability && safe.includes(enemy.ability)) {
                logs.push(`(å¯¹æ–¹çš„ ${enemy.ability} å…ç–«äº†å¨å“!)`);
                return;
            }
            if (typeof enemy.applyBoost === 'function') {
                enemy.applyBoost('atk', -1);
                logs.push(`${self.cnName} çš„å¨å“è®©å¯¹æ‰‹ç¨å¾®é€€ç¼©äº†! (æ”»å‡»é™ä½)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
            }
        }
    },
    // ã€é™é›¨ã€‘
    'Drizzle': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'raindance';
            logs.push(`ğŸŒ§ï¸ ${self.cnName} å¸¦æ¥äº†é™é›¨!`);
        }
    },
    // ã€æ—¥ç…§ã€‘
    'Drought': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'sunnyday';
            logs.push(`â˜€ï¸ ${self.cnName} è®©é˜³å…‰å˜å¾—å¼ºçƒˆäº†!`);
        }
    },
    // ã€æ‰¬æ²™ã€‘
    'Sand Stream': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'sandstorm';
            logs.push(`ğŸŒªï¸ ${self.cnName} æ‰¬èµ·äº†æ²™æš´!`);
        }
    },
    // ã€é™é›ªã€‘
    'Snow Warning': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.weather = 'snow';
            logs.push(`â„ï¸ ${self.cnName} è®©å¤©ç©ºå¼€å§‹ä¸‹é›ªäº†!`);
        }
    },
    // ã€ç”µæ°”åˆ¶é€ è€…ã€‘
    'Electric Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'electricterrain';
            logs.push(`âš¡ ${self.cnName} è„šä¸‹ç”µæµæ¶ŒåŠ¨!`);
        }
    },
    // ã€ç²¾ç¥åˆ¶é€ è€…ã€‘
    'Psychic Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'psychicterrain';
            logs.push(`ğŸ”® ${self.cnName} è„šä¸‹å¥‡å¦™çš„æ„Ÿè§‰è”“å»¶å¼€æ¥!`);
        }
    },
    // ã€é’è‰åˆ¶é€ è€…ã€‘
    'Grassy Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'grassyterrain';
            logs.push(`ğŸŒ¿ ${self.cnName} è„šä¸‹é’è‰èŒ‚ç››!`);
        }
    },
    // ã€è–„é›¾åˆ¶é€ è€…ã€‘
    'Misty Surge': {
        onStart: (self, enemy, logs, battle) => {
            if (battle) battle.terrain = 'mistyterrain';
            logs.push(`ğŸŒ«ï¸ ${self.cnName} è„šä¸‹è–„é›¾å¼¥æ¼«!`);
        }
    },
    // ============================================
    // E. æœºåˆ¶æ€ª
    // ============================================
    // ã€å˜å¹»è‡ªå¦‚ / åˆ©è´ç½—ã€‘
    'Protean': {
        onBeforeMove: (user, move, logs) => {
            if (move.type && move.type !== 'Normal' && !user.types.includes(move.type)) {
                if (user.types[0] !== move.type) { 
                    user.types = [move.type];
                    logs.push(`[å˜å¹»è‡ªå¦‚] ${user.cnName} å˜æˆäº† ${move.type} å±æ€§!`);
                }
            }
        }
    },
    'Libero': {
        onBeforeMove: (user, move, logs) => {
            if (move.type && user.types[0] !== move.type) {
                user.types = [move.type];
                logs.push(`[åˆ©è´ç½—] ${user.cnName} å˜æˆäº† ${move.type} å±æ€§!`);
            }
        }
    },
    // ã€å¼‚å…½æå‡ã€‘å‡»æ€åæå‡æœ€é«˜èƒ½åŠ›
    'Beast Boost': {
        onKill: (attacker, logs) => {
            // æ‰¾æœ€é«˜åŸºç¡€èƒ½åŠ›
            const stats = ['atk', 'def', 'spa', 'spd', 'spe'];
            let best = 'atk';
            let bestVal = attacker.atk || 0;
            for (const s of stats) {
                if (attacker[s] > bestVal) {
                    bestVal = attacker[s];
                    best = s;
                }
            }
            if (typeof attacker.applyBoost === 'function') {
                attacker.applyBoost(best, 1);
                logs.push(`${attacker.cnName} çš„ ${best} æå‡äº†! (å¼‚å…½æå‡)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€è‡ªä¿¡è¿‡å‰©ã€‘å‡»æ€åæ”»å‡»+1
    'Moxie': {
        onKill: (attacker, logs) => {
            if (typeof attacker.applyBoost === 'function') {
                attacker.applyBoost('atk', 1);
                logs.push(`${attacker.cnName} çš„æ”»å‡»æå‡äº†! (è‡ªä¿¡è¿‡å‰©)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ============================================
    // æ‚–è°¬ç§ç‰¹æ€§ (Paradox PokÃ©mon Abilities)
    // ============================================
    // ã€å¤¸å…‹å……èƒ½ã€‘Quark Drive - æœªæ¥æ‚–è°¬ç§
    // ç”µæ°”åœºåœ°æˆ–æºå¸¦é©±åŠ²èƒ½é‡æ—¶ï¼Œæå‡æœ€é«˜èƒ½åŠ› 30%ï¼ˆé€Ÿåº¦ä¸º 50%ï¼‰
    'Quark Drive': {
        onStart: (self, enemy, logs, battle) => {
            // æ£€æŸ¥æ˜¯å¦æœ‰ç”µæ°”åœºåœ°
            const hasElectricTerrain = battle && battle.field && battle.field.terrain === 'electricterrain';
            // æ£€æŸ¥æ˜¯å¦æºå¸¦é©±åŠ²èƒ½é‡
            const hasBoosterEnergy = self.item === 'Booster Energy';
            if (hasElectricTerrain || hasBoosterEnergy) {
                // æ‰¾æœ€é«˜èƒ½åŠ›
                const stats = { atk: self.atk, def: self.def, spa: self.spa, spd: self.spd, spe: self.spe };
                let bestStat = 'atk';
                let bestValue = 0;
                for (const [stat, val] of Object.entries(stats)) {
                    if (val > bestValue) {
                        bestValue = val;
                        bestStat = stat;
                    }
                }
                // æ ‡è®°æ¿€æ´»çŠ¶æ€
                self.quarkDriveActive = true;
                self.quarkDriveStat = bestStat;
                // æ¶ˆè€—é©±åŠ²èƒ½é‡ï¼ˆå¦‚æœæ˜¯é€šè¿‡é“å…·æ¿€æ´»ï¼‰
                if (hasBoosterEnergy && !hasElectricTerrain) {
                    self.item = null;
                    logs.push(`${self.cnName} æ¶ˆè€—äº†é©±åŠ²èƒ½é‡ï¼`);
                }
                const statNames = { atk: 'æ”»å‡»', def: 'é˜²å¾¡', spa: 'ç‰¹æ”»', spd: 'ç‰¹é˜²', spe: 'é€Ÿåº¦' };
                logs.push(`<b style="color:#f1c40f">âš¡ ${self.cnName} çš„å¤¸å…‹å……èƒ½å¯åŠ¨äº†ï¼${statNames[bestStat]}æå‡ï¼</b>`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        },
        onModifyStat: (stats, poke) => {
            if (poke.quarkDriveActive && poke.quarkDriveStat) {
                const stat = poke.quarkDriveStat;
                const multiplier = (stat === 'spe') ? 1.5 : 1.3;
                stats[stat] = Math.floor(stats[stat] * multiplier);
            }
        }
    },
    // ã€å¤ä»£æ´»æ€§ã€‘Protosynthesis - å¤ä»£æ‚–è°¬ç§
    // å¤§æ™´å¤©æˆ–æºå¸¦é©±åŠ²èƒ½é‡æ—¶ï¼Œæå‡æœ€é«˜èƒ½åŠ› 30%ï¼ˆé€Ÿåº¦ä¸º 50%ï¼‰
    'Protosynthesis': {
        onStart: (self, enemy, logs, battle) => {
            // æ£€æŸ¥æ˜¯å¦æœ‰å¤§æ™´å¤©
            const hasSun = battle && (battle.weather === 'sunnyday' || battle.weather === 'desolateland');
            // æ£€æŸ¥æ˜¯å¦æºå¸¦é©±åŠ²èƒ½é‡
            const hasBoosterEnergy = self.item === 'Booster Energy';
            if (hasSun || hasBoosterEnergy) {
                // æ‰¾æœ€é«˜èƒ½åŠ›
                const stats = { atk: self.atk, def: self.def, spa: self.spa, spd: self.spd, spe: self.spe };
                let bestStat = 'atk';
                let bestValue = 0;
                for (const [stat, val] of Object.entries(stats)) {
                    if (val > bestValue) {
                        bestValue = val;
                        bestStat = stat;
                    }
                }
                // æ ‡è®°æ¿€æ´»çŠ¶æ€
                self.protosynthesisActive = true;
                self.protosynthesisstat = bestStat;
                // æ¶ˆè€—é©±åŠ²èƒ½é‡ï¼ˆå¦‚æœæ˜¯é€šè¿‡é“å…·æ¿€æ´»ï¼‰
                if (hasBoosterEnergy && !hasSun) {
                    self.item = null;
                    logs.push(`${self.cnName} æ¶ˆè€—äº†é©±åŠ²èƒ½é‡ï¼`);
                }
                const statNames = { atk: 'æ”»å‡»', def: 'é˜²å¾¡', spa: 'ç‰¹æ”»', spd: 'ç‰¹é˜²', spe: 'é€Ÿåº¦' };
                logs.push(`<b style="color:#e67e22">â˜€ï¸ ${self.cnName} çš„å¤ä»£æ´»æ€§å¯åŠ¨äº†ï¼${statNames[bestStat]}æå‡ï¼</b>`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        },
        onModifyStat: (stats, poke) => {
            if (poke.protosynthesisActive && poke.protosynthesisstat) {
                const stat = poke.protosynthesisstat;
                const multiplier = (stat === 'spe') ? 1.5 : 1.3;
                stats[stat] = Math.floor(stats[stat] * multiplier);
            }
        }
    },
    // ã€åŠ é€Ÿã€‘å›åˆç»“æŸé€Ÿåº¦+1
    'Speed Boost': {
        onEndTurn: (pokemon, logs) => {
            if (pokemon.boosts && pokemon.boosts.spe < 6) {
                if (typeof pokemon.applyBoost === 'function') {
                    pokemon.applyBoost('spe', 1);
                    logs.push(`${pokemon.cnName} çš„é€Ÿåº¦æå‡äº†! (åŠ é€Ÿ)`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
                }
            }
        }
    },
    // ã€æ…¢å¯åŠ¨ã€‘å‡ºåœº5å›åˆå†…ï¼Œæ”»å‡»å‡åŠï¼Œé€Ÿåº¦å‡åŠ (é›·å‰å¥‡å¡æ–¯ä¸“å±)
    'Slow Start': {
        // è¿›åœºæ—¶åˆå§‹åŒ–è®¡æ•°å™¨
        onStart: (self, enemy, logs) => {
            self.slowStartTurns = 0;
            self.isSlowStarting = true;
            logs.push(`<b style="color:#636e72">${self.cnName} çš„æ…¢å¯åŠ¨ï¼ä¾ç„¶æ²¡èƒ½æ‹¿å‡ºçœŸæœ¬äº‹ï¼</b>`);
        },
        // å®æ—¶ä¿®æ”¹é¢æ¿æ•°å€¼
        onModifyStat: (stats, poke) => {
            if (poke.isSlowStarting) {
                stats.atk = Math.floor(stats.atk * 0.5);
                stats.spe = Math.floor(stats.spe * 0.5);
            }
        },
        // å›åˆç»“æŸï¼šè®¡æ•°å™¨é€’å¢ + è§£é™¤å°å°åˆ¤æ–­
        onEndTurn: (pokemon, logs) => {
            if (pokemon.isSlowStarting) {
                pokemon.slowStartTurns = (pokemon.slowStartTurns || 0) + 1;
                if (pokemon.slowStartTurns >= 5) {
                    pokemon.isSlowStarting = false;
                    pokemon.slowStartTurns = 0;
                    logs.push(`<b style="color:#e91e63; font-size:1.1em">ğŸ”¥ ${pokemon.cnName} ç»ˆäºæ‹¿å‡ºäº†çœŸæœ¬äº‹ï¼</b>`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
                } else {
                    logs.push(`<span style="color:#aaa">${pokemon.cnName} è¿˜æ²¡æœ‰æ‹¿å‡ºçœŸæœ¬äº‹... (${pokemon.slowStartTurns}/5)</span>`);
                }
            }
        }
    },
    // ã€æ‡’æƒ°ã€‘æ¯éš”ä¸€å›åˆæ‰èƒ½è¡ŒåŠ¨ (è¯·å‡ç‹ä¸“å±)
    'Truant': {
        onStart: (self, enemy, logs) => {
            // è¿›åœºæ—¶é‡ç½®çŠ¶æ€ï¼Œç¬¬ä¸€å›åˆå¯ä»¥è¡ŒåŠ¨
            self.truantNextTurn = false;
        },
        // è¡ŒåŠ¨å‰æ£€æŸ¥ï¼šå¦‚æœæ˜¯ä¼‘æ¯å›åˆåˆ™è·³è¿‡
        onBeforeMove: (self, move, logs) => {
            if (self.truantNextTurn) {
                logs.push(`<b style="color:#95a5a6">${self.cnName} æ­£åœ¨å·æ‡’ï¼</b>`);
                self.truantNextTurn = false; // ä¸‹å›åˆå¯ä»¥è¡ŒåŠ¨
                return false; // ç¦æ­¢è¡ŒåŠ¨
            } else {
                self.truantNextTurn = true; // ä¸‹å›åˆä¼‘æ¯
                return true; // å…è®¸è¡ŒåŠ¨
            }
        }
    },
    // ã€æ…¢å‡ºã€‘æ°¸è¿œæœ€åè¡ŒåŠ¨ (ä¼˜å…ˆåº¦ -6)
    // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºç»Ÿä¸€ä¸ºï¼š(priority, user, target, move)
    'Stall': {
        onModifyPriority: (priority, user, target, move) => {
            // è¿”å›ä¸€ä¸ªæä½çš„ä¼˜å…ˆåº¦ä¿®æ­£ï¼Œç¡®ä¿æœ€åè¡ŒåŠ¨
            return -6;
        }
    },
    // ã€å†ç”ŸåŠ›ã€‘æ¢ä¸‹æ—¶å›å¤1/3è¡€
    'Regenerator': {
        onSwitchOut: (pokemon) => {
            if (pokemon.currHp < pokemon.maxHp && pokemon.currHp > 0) {
                const heal = Math.floor(pokemon.maxHp / 3);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
            }
        }
    },
    // ã€é“æ‹³ã€‘æ‹³å¤´ç±»æ‹›å¼å¨åŠ›x1.2
    'Iron Fist': {
        onBasePower: (power, attacker, defender, move) => {
            const punchMoves = ['Bullet Punch', 'Comet Punch', 'Dizzy Punch', 'Drain Punch', 
                'Dynamic Punch', 'Fire Punch', 'Focus Punch', 'Hammer Arm', 'Ice Punch', 
                'Mach Punch', 'Mega Punch', 'Meteor Mash', 'Power-Up Punch', 'Shadow Punch', 
                'Sky Uppercut', 'Thunder Punch', 'Close Combat'];
            if (punchMoves.includes(move.name)) {
                return Math.floor(power * 1.2);
            }
            return power;
        }
    },
    // ã€å¼ºå£®ä¹‹é¢šã€‘å’¬ç±»æ‹›å¼å¨åŠ›x1.5
    'Strong Jaw': {
        onBasePower: (power, attacker, defender, move) => {
            const biteMoves = ['Bite', 'Crunch', 'Fire Fang', 'Ice Fang', 'Thunder Fang', 
                'Poison Fang', 'Psychic Fangs', 'Hyper Fang', 'Jaw Lock', 'Fishious Rend'];
            if (biteMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ã€ç¡¬çˆªã€‘æ¥è§¦ç±»æ‹›å¼å¨åŠ›x1.3
    'Tough Claws': {
        onBasePower: (power, attacker, defender, move) => {
            // ç®€åŒ–ï¼šç‰©ç†æ‹›å¼å¤§å¤šæ˜¯æ¥è§¦ç±»
            if (move.cat === 'phys' || move.category === 'Physical') {
                return Math.floor(power * 1.3);
            }
            return power;
        }
    },
    // ã€è›®åŠ›ã€‘æ”»å‡»åé™ä½è‡ªèº«æ”»é˜²
    'Sheer Force': {
        // å–æ¶ˆå‰¯ä½œç”¨ä½†å¨åŠ›x1.3ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
        onBasePower: (power, attacker, defender, move) => {
            // å¦‚æœæ‹›å¼æœ‰å‰¯ä½œç”¨ï¼Œå¨åŠ›x1.3
            if (move.secondary || move.secondaries) {
                return Math.floor(power * 1.3);
            }
            return power;
        }
    },
    // ã€æ²™ä¹‹åŠ›ã€‘æ²™æš´ä¸­å²©/åœ°/é’¢å¨åŠ›x1.3
    'Sand Force': {
        onBasePower: (power, attacker, defender, move, battle) => {
            if (battle && battle.weather === 'sandstorm') {
                if (['Rock', 'Ground', 'Steel'].includes(move.type)) {
                    return Math.floor(power * 1.3);
                }
            }
            return power;
        }
    },
    // ã€ç‹™å‡»æ‰‹ã€‘æš´å‡»ä¼¤å®³x1.5
    'Sniper': {
        onCritDamage: (damage) => Math.floor(damage * 1.5)
    },
    // ã€å¤©æ©ã€‘å‰¯ä½œç”¨æ¦‚ç‡ç¿»å€ (ç®€åŒ–ï¼šä¸å®ç°)
    'Serene Grace': {},
    // ã€æ¸…é™¤ä¹‹èº¯ã€‘å…ç–«èƒ½åŠ›ä¸‹é™
    'Clear Body': {
        onTryBoost: (boost, pokemon, source) => {
            // é˜»æ­¢è´Ÿé¢èƒ½åŠ›å˜åŒ–
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    'White Smoke': {
        onTryBoost: (boost, pokemon, source) => {
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    'Full Metal Body': {
        onTryBoost: (boost, pokemon, source) => {
            if (boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    // ============================================
    // F. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - æ‹›å¼å¤§å¸ˆç±»
    // ============================================
    // ã€é”‹é”ã€‘åˆ‡å‰²ç±»æ‹›å¼å¨åŠ›x1.5
    'Sharpness': {
        onBasePower: (power, attacker, defender, move) => {
            const slicingMoves = ['Air Cutter', 'Air Slash', 'Aqua Cutter', 'Behemoth Blade', 
                'Cross Poison', 'Cut', 'Fury Cutter', 'Kowtow Cleave', 'Leaf Blade', 
                'Night Slash', 'Psycho Cut', 'Razor Leaf', 'Razor Shell', 'Sacred Sword', 
                'Secret Sword', 'Slash', 'Solar Blade', 'Stone Axe', 'X-Scissor', 'Ceaseless Edge'];
            if (slicingMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ã€è¶…çº§å‘å°„å™¨ã€‘æ³¢å¯¼/æ³¢åŠ¨ç±»æ‹›å¼å¨åŠ›x1.5
    'Mega Launcher': {
        onBasePower: (power, attacker, defender, move) => {
            const pulseMoves = ['Aura Sphere', 'Dark Pulse', 'Dragon Pulse', 'Heal Pulse', 
                'Origin Pulse', 'Terrain Pulse', 'Water Pulse'];
            if (pulseMoves.includes(move.name)) {
                return Math.floor(power * 1.5);
            }
            return power;
        }
    },
    // ============================================
    // G. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - æŠ—æ€§/çŠ¶æ€ç±»
    // ============================================
    // ã€éš”éŸ³ã€‘å…ç–«å£°éŸ³æ‹›å¼
    'Soundproof': {
        onImmunity: (atkType, move) => {
            const soundMoves = ['Boomburst', 'Bug Buzz', 'Chatter', 'Clanging Scales', 
                'Clangorous Soul', 'Clangorous Soulblaze', 'Confide', 'Disarming Voice', 
                'Echoed Voice', 'Eerie Spell', 'Grass Whistle', 'Growl', 'Heal Bell', 
                'Hyper Voice', 'Metal Sound', 'Noble Roar', 'Overdrive', 'Parting Shot', 
                'Perish Song', 'Relic Song', 'Roar', 'Round', 'Screech', 'Shadow Panic', 
                'Sing', 'Snarl', 'Snore', 'Sparkling Aria', 'Supersonic', 'Uproar'];
            if (move && soundMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ã€æ¯…åŠ›ã€‘å¼‚å¸¸çŠ¶æ€ä¸‹ç‰©æ”»x1.5
    'Guts': {
        onModifyStat: (stats, poke) => { 
            if (poke.status) stats.atk = Math.floor(stats.atk * 1.5); 
        }
    },
    // ============================================
    // å£°éŸ³ç³»ç‰¹æ€§ (Sound-based Abilities)
    // ============================================
    // ã€æ¹¿æ¶¦ä¹‹å£°ã€‘å£°éŸ³æ‹›å¼å˜ä¸ºæ°´å±æ€§
    'Liquid Voice': {
        onModifyMove: (move, attacker) => {
            const soundMoves = ['Boomburst', 'Bug Buzz', 'Chatter', 'Clanging Scales', 
                'Clangorous Soul', 'Disarming Voice', 'Echoed Voice', 'Eerie Spell', 
                'Growl', 'Hyper Voice', 'Metal Sound', 'Noble Roar', 'Overdrive', 
                'Parting Shot', 'Relic Song', 'Round', 'Screech', 'Sing', 'Snarl', 
                'Snore', 'Sparkling Aria', 'Supersonic', 'Uproar', 'Torch Song'];
            if (soundMoves.includes(move.name)) {
                move.type = 'Water';
            }
        }
    },
    // ã€æ¹¿æ¶¦ä¹‹å£° Proã€‘å£°éŸ³æ‹›å¼å˜ä¸ºæ°´å±æ€§ + å¨åŠ›x1.3 (RPG é­”æ”¹ç‰ˆ)
    // ã€ä¿®å¤ã€‘ä½¿ç”¨ _liquidVoiceApplied æ ‡è®°é˜²æ­¢å¨åŠ›ç´¯ç§¯
    'Liquid Voice Pro': {
        onModifyMove: (move, attacker) => {
            const soundMoves = ['Boomburst', 'Bug Buzz', 'Chatter', 'Clanging Scales', 
                'Clangorous Soul', 'Disarming Voice', 'Echoed Voice', 'Eerie Spell', 
                'Growl', 'Hyper Voice', 'Metal Sound', 'Noble Roar', 'Overdrive', 
                'Parting Shot', 'Relic Song', 'Round', 'Screech', 'Sing', 'Snarl', 
                'Snore', 'Sparkling Aria', 'Supersonic', 'Uproar', 'Torch Song'];
            if (soundMoves.includes(move.name)) {
                move.type = 'Water';
                // ã€å…³é”®ä¿®å¤ã€‘åªåœ¨é¦–æ¬¡åº”ç”¨æ—¶ä¿®æ”¹å¨åŠ›ï¼Œé˜²æ­¢ç´¯ç§¯
                if (!move._liquidVoiceApplied) {
                    const originalPower = move._originalBasePower || move.basePower || move.power || 0;
                    move._originalBasePower = originalPower; // ä¿å­˜åŸå§‹å¨åŠ›
                    move.basePower = Math.floor(originalPower * 1.3);
                    move.power = move.basePower;
                    move._liquidVoiceApplied = true;
                }
            }
        }
    },
    // ã€è½¯å¼±ã€‘åŠè¡€ä»¥ä¸‹æ”»å‡»/ç‰¹æ”»å‡åŠ
    'Defeatist': {
        onModifyStat: (stats, poke) => {
            if (poke.currHp <= poke.maxHp / 2) {
                stats.atk = Math.floor(stats.atk * 0.5);
                stats.spa = Math.floor(stats.spa * 0.5);
            }
        }
    },
    // ============================================
    // H. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å¤©æ°”åŠ é€Ÿç±»
    // ============================================
    // ã€å¶ç»¿ç´ ã€‘æ™´å¤©é€Ÿåº¦ç¿»å€
    'Chlorophyll': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'sunnyday' || battle.weather === 'desolateland')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‚ æ¸¸è‡ªå¦‚ã€‘é›¨å¤©é€Ÿåº¦ç¿»å€
    'Swift Swim': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'raindance' || battle.weather === 'primordialsea')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‹¨æ²™ã€‘æ²™æš´é€Ÿåº¦ç¿»å€
    'Sand Rush': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && battle.weather === 'sandstorm') {
                stats.spe *= 2;
            }
        }
    },
    // ã€æ‹¨é›ªã€‘é›ªå¤©é€Ÿåº¦ç¿»å€
    'Slush Rush': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'snow' || battle.weather === 'hail')) {
                stats.spe *= 2;
            }
        }
    },
    // ã€å¤ªé˜³ä¹‹åŠ›ã€‘æ™´å¤©ç‰¹æ”»x1.5
    'Solar Power': {
        onModifyStat: (stats, poke, battle) => {
            if (battle && (battle.weather === 'sunnyday' || battle.weather === 'desolateland')) {
                stats.spa = Math.floor(stats.spa * 1.5);
            }
        }
    },
    // ============================================
    // I. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å¸æ”¶ç³»
    // ============================================
    // ã€é£ŸåœŸã€‘è¢«åœ°é¢æ‰“å›è¡€1/4HPï¼ˆå¤§ç‹é“œè±¡ï¼‰
    'Earth Eater': {
        onImmunity: (atkType) => atkType === 'Ground',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Ground') {
                const heal = Math.floor(pokemon.maxHp / 4);
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
                logs.push(`ğŸŒ ${pokemon.cnName} çš„é£ŸåœŸå›å¤äº† ${heal} HPï¼`);
                return { absorbed: true, heal };
            }
            return { absorbed: false };
        }
    },
    // ã€ç„¦é¦™èº«èº¯ã€‘è¢«ç«ç³»æ‰“é˜²å¾¡+2ï¼ˆéº»èŠ±çŠ¬ï¼‰
    'Well-Baked Body': {
        onImmunity: (atkType) => atkType === 'Fire',
        onAbsorbHit: (pokemon, move, logs) => {
            if (move.type === 'Fire') {
                if (pokemon.applyBoost) pokemon.applyBoost('def', 2);
                logs.push(`ğŸ”¥ ${pokemon.cnName} çš„ç„¦é¦™èº«èº¯å‘åŠ¨ï¼é˜²å¾¡å¤§å¹…æå‡ï¼`);
                return { absorbed: true };
            }
            return { absorbed: false };
        }
    },
    // ã€æ¹¿æ°”ã€‘ç¦æ­¢è‡ªçˆ†/å¤§çˆ†ç‚¸
    'Damp': {
        preventExplosion: true
    },
    // ============================================
    // J. ç¬¬äºŒæ¢¯é˜Ÿè¡¥å…… - å…ç–«ç±»
    // ============================================
    // ã€çŸ³å¤´è„‘è¢‹ã€‘ä¸å—åä¼¤
    'Rock Head': {
        noRecoil: true
    },
    // ã€é­”æ³•é˜²å®ˆã€‘ä¸å—å¤©æ°”/çŠ¶æ€ä¼¤å®³ (ç®€åŒ–)
    'Magic Guard': {
        noIndirectDamage: true
    },
    // ã€æ¯’ç–—ã€‘ä¸­æ¯’æ—¶å›å¤HPè€Œéå—ä¼¤
    'Poison Heal': {
        onStatusDamage: (pokemon, status) => {
            if (status === 'psn' || status === 'tox') {
                // å›å¤ 1/8 HP
                const healAmount = Math.max(1, Math.floor(pokemon.maxHp / 8));
                if (typeof pokemon.heal === 'function') {
                    pokemon.heal(healAmount);
                } else {
                    pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + healAmount);
                }
                return { 
                    blocked: true, 
                    healed: true,
                    message: `<span style="color:#4cd137">ğŸ’š ${pokemon.cnName} çš„æ¯’ç–—ç‰¹æ€§å‘åŠ¨ï¼Œå›å¤äº† ${healAmount} ç‚¹ä½“åŠ›!</span>`
                };
            }
            return { blocked: false };
        }
    },
    // ã€æ¯…åŠ›ã€‘å¼‚å¸¸çŠ¶æ€æ—¶é€Ÿåº¦x1.5 (Quick Feet)
    // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºï¼š(stats, poke, battle)
    'Quick Feet': {
        onModifyStat: (stats, poke, battle) => {
            if (poke.status) {
                stats.spe = Math.floor(stats.spe * 1.5);
            }
        }
    },
    // æ³¨æ„ï¼šMarvel Scale å·²åœ¨ç¬¬ 192 è¡Œå®šä¹‰ï¼Œæ­¤å¤„åˆ é™¤é‡å¤å®šä¹‰
    // ã€ä¸æœè¾“ã€‘è¢«é™èƒ½åŠ›æ—¶æ”»å‡»+2
    'Defiant': {
        onAfterStatDrop: (pokemon, stat, stages, logs) => {
            if (typeof pokemon.applyBoost === 'function') {
                pokemon.applyBoost('atk', 2);
                logs.push(`${pokemon.cnName} çš„æ”»å‡»å¤§å¹…æå‡äº†! (ä¸æœè¾“)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€ç«äº‰å¿ƒã€‘è¢«é™èƒ½åŠ›æ—¶ç‰¹æ”»+2
    'Competitive': {
        onAfterStatDrop: (pokemon, stat, stages, logs) => {
            if (typeof pokemon.applyBoost === 'function') {
                pokemon.applyBoost('spa', 2);
                logs.push(`${pokemon.cnName} çš„ç‰¹æ”»å¤§å¹…æå‡äº†! (ç«äº‰å¿ƒ)`);
                if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            }
        }
    },
    // ã€ç²¾ç¥åŠ›ã€‘å…ç–«ç•ç¼©
    'Inner Focus': {
        noFlinch: true
    },
    // ã€æˆ‘è¡Œæˆ‘ç´ ã€‘å…ç–«æ··ä¹±
    'Own Tempo': {
        noConfusion: true
    },
    // ã€æŸ”è½¯ã€‘å…ç–«éº»ç—¹
    'Limber': {
        onImmunityStatus: (status) => status === 'par'
    },
    // ã€å…ç–«ã€‘å…ç–«ä¸­æ¯’
    'Immunity': {
        onImmunityStatus: (status) => status === 'psn' || status === 'tox'
    },
    // ã€æ°´ä¹‹é¢çº±ã€‘å…ç–«çƒ§ä¼¤
    'Water Veil': {
        onImmunityStatus: (status) => status === 'brn'
    },
    // ã€ç†”å²©é“ ç”²ã€‘å…ç–«å†°å†»
    'Magma Armor': {
        onImmunityStatus: (status) => status === 'frz'
    },
    // ã€ä¸çœ ã€‘å…ç–«ç¡çœ 
    'Insomnia': {
        onImmunityStatus: (status) => status === 'slp'
    },
    'Vital Spirit': {
        onImmunityStatus: (status) => status === 'slp'
    },
    // ã€ç²‰å½©æŠ¤å¹•ã€‘å…ç–«ä¸­æ¯’ï¼ˆä¼½å‹’å°”å°ç«é©¬/çƒˆç„°é©¬ï¼‰
    'Pastel Veil': {
        onImmunityStatus: (status) => status === 'psn' || status === 'tox',
        onStart: (pokemon, logs) => {
            // å…¥åœºæ—¶æ²»æ„ˆå·±æ–¹ä¸­æ¯’çŠ¶æ€
            if (pokemon.status === 'psn' || pokemon.status === 'tox') {
                pokemon.status = null;
                logs.push(`${pokemon.cnName} çš„ç²‰å½©æŠ¤å¹•æ²»æ„ˆäº†ä¸­æ¯’çŠ¶æ€!`);
            }
        }
    },
    // ã€æ´å‡€ä¹‹ç›ã€‘å…ç–«æ‰€æœ‰å¼‚å¸¸çŠ¶æ€ï¼ˆç›çŸ³å·¨çµï¼‰
    'Purifying Salt': {
        onImmunityStatus: () => true, // å…ç–«æ‰€æœ‰å¼‚å¸¸çŠ¶æ€
        // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºï¼š(damage, attacker, defender, move, effectiveness)
        onDefenderModifyDamage: (damage, attacker, defender, move, effectiveness) => {
            // å¹½çµç³»æ‹›å¼ä¼¤å®³å‡åŠ
            if (move.type === 'Ghost') {
                return Math.floor(damage * 0.5);
            }
            return damage;
        }
    },
    // ã€ç»å¯¹ç¡çœ ã€‘è§†ä¸ºç¡çœ çŠ¶æ€ï¼ˆæ ‘æ•å°¾ç†Šï¼‰
    'Comatose': {
        onImmunityStatus: () => true, // æ— æ³•è¢«è¦†ç›–å…¶ä»–çŠ¶æ€
        alwaysAsleep: true // è§†ä¸ºç¡çœ çŠ¶æ€
    },
    // ã€ç•Œé™ç›¾å£³ã€‘HP > 50% æ—¶å…ç–«å¼‚å¸¸çŠ¶æ€ï¼ˆå°é™¨æ˜Ÿï¼‰
    'Shields Down': {
        onImmunityStatus: (status, pokemon) => {
            return pokemon && pokemon.currHp > pokemon.maxHp / 2;
        }
    },
    // ã€å¶å­é˜²å®ˆã€‘å¤§æ™´å¤©æ—¶å…ç–«å¼‚å¸¸çŠ¶æ€
    'Leaf Guard': {
        onImmunityStatus: (status, pokemon, battle) => {
            const weather = battle?.weather || (typeof window.battle !== 'undefined' ? window.battle.weather : null);
            return weather === 'sun' || weather === 'harshsun';
        }
    },
    // ã€è…èš€ã€‘å¯ä»¥è®©é’¢/æ¯’ç³»ä¸­æ¯’ï¼ˆå¤œç›—ç«èœ¥ã€ç„°åèœ¥ï¼‰
    'Corrosion': {
        canPoisonAny: true // æ ‡è®°ï¼šå¯ä»¥è®©ä»»ä½•å±æ€§ä¸­æ¯’
    },
    // ã€é³ç²‰ã€‘å…ç–«ç²‰å°˜ç±»æ‹›å¼
    'Overcoat': {
        onImmunity: (atkType, move) => {
            const powderMoves = ['Cotton Spore', 'Poison Powder', 'Powder', 'Rage Powder', 
                'Sleep Powder', 'Spore', 'Stun Spore'];
            if (move && powderMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ã€é˜²å¼¹ã€‘å…ç–«çƒç±»æ‹›å¼
    'Bulletproof': {
        onImmunity: (atkType, move) => {
            const ballMoves = ['Acid Spray', 'Aura Sphere', 'Barrage', 'Beak Blast', 
                'Bullet Seed', 'Egg Bomb', 'Electro Ball', 'Energy Ball', 'Focus Blast', 
                'Gyro Ball', 'Ice Ball', 'Magnet Bomb', 'Mist Ball', 'Mud Bomb', 
                'Octazooka', 'Pollen Puff', 'Pyro Ball', 'Rock Blast', 'Rock Wrecker', 
                'Searing Shot', 'Seed Bomb', 'Shadow Ball', 'Sludge Bomb', 'Weather Ball', 'Zap Cannon'];
            if (move && ballMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ============================================
    // K. ç”»çš® (Disguise) - Mimikyu ä¸“å±
    // ============================================
    // ã€ç”»çš®ã€‘ç¬¬ä¸€æ¬¡å—åˆ°æ”»å‡»ä¼¤å®³æ—¶å…ç–«ï¼Œä½†è‡ªèº«æŸå¤± 1/8 HP
    'Disguise': {
        onDefenderModifyDamage: (damage, attacker, defender, move) => {
            // å¦‚æœç”»çš®å·²ç»ç ´æŸï¼Œæ­£å¸¸å—ä¼¤
            if (defender.disguiseBroken) return damage;
            // ç”»çš®å®Œå¥½æ—¶ï¼Œå…ç–«è¿™æ¬¡ä¼¤å®³
            if (damage > 0) {
                defender.disguiseBroken = true;
                // ç”»çš®ç ´æŸåè‡ªèº«æŸå¤± 1/8 HP
                const bustDamage = Math.floor(defender.maxHp / 8);
                defender.disguiseBustDamage = bustDamage; // æ ‡è®°éœ€è¦æ‰£è¡€
                return 0; // ä¼¤å®³å˜ä¸º 0
            }
            return damage;
        }
    },
    // ============================================
    // L. æŠ“äººç‰¹æ€§ (Trapping Abilities)
    // ============================================
    // ã€è¸©å½±ã€‘å¯¹æ‰‹æ— æ³•æ¢äººï¼ˆå¹½çµç³»é™¤å¤–ï¼Œå¯¹æ–¹ä¹Ÿæ˜¯è¸©å½±åˆ™å¯é€ƒï¼‰
    'Shadow Tag': {
        isTrapping: true,
        canTrap: (self, target) => {
            // å¹½çµç³»å…ç–«
            if (target.types && target.types.includes('Ghost')) return false;
            // å¯¹æ–¹ä¹Ÿæ˜¯è¸©å½±åˆ™ä¸å›°
            if (target.ability === 'Shadow Tag') return false;
            return true;
        }
    },
    // ã€ç£åŠ›ã€‘é’¢å±æ€§æ— æ³•æ¢äºº
    'Magnet Pull': {
        isTrapping: true,
        canTrap: (self, target) => {
            // å¹½çµç³»å…ç–«
            if (target.types && target.types.includes('Ghost')) return false;
            // åªå›°ä½é’¢ç³»
            if (target.types && target.types.includes('Steel')) return true;
            return false;
        }
    },
    // ã€æ²™ç©´ã€‘åœ°é¢ä¸Šçš„å¯¹æ‰‹æ— æ³•æ¢äºº
    'Arena Trap': {
        isTrapping: true,
        canTrap: (self, target) => {
            // å¹½çµç³»å…ç–«
            if (target.types && target.types.includes('Ghost')) return false;
            // é£è¡Œç³»å…ç–«
            if (target.types && target.types.includes('Flying')) return false;
            // æ¼‚æµ®ç‰¹æ€§å…ç–«
            if (target.ability === 'Levitate') return false;
            // æ°”çƒé“å…·å…ç–«
            if (target.item === 'Air Balloon') return false;
            return true;
        }
    },
    // ============================================
    // M. æ¶ä½œå‰§ä¹‹å¿ƒ (Prankster) - ä¼˜å…ˆåº¦ä¿®æ­£
    // ============================================
    // ã€æ¶ä½œå‰§ä¹‹å¿ƒã€‘å˜åŒ–æŠ€ä¼˜å…ˆåº¦+1ï¼Œä½†å¯¹æ¶ç³»æ— æ•ˆ
    'Prankster': {
        onModifyPriority: (priority, user, target, move) => {
            // åªå¯¹å˜åŒ–æŠ€ç”Ÿæ•ˆ
            if (move.cat === 'status' || move.category === 'Status') {
                return priority + 1;
            }
            return priority;
        },
        // æ¶ç³»å…ç–«æ¶ä½œå‰§ä¹‹å¿ƒçš„å˜åŒ–æŠ€
        pranksterImmunity: true
    },
    // ============================================
    // N. çº¯æœ´ (Unaware) - å¿½ç•¥èƒ½åŠ›å˜åŒ–
    // ============================================
    // ã€çº¯æœ´ã€‘æ”»å‡»æ—¶å¿½ç•¥å¯¹æ‰‹é˜²å¾¡/ç‰¹é˜²æå‡ï¼Œé˜²å¾¡æ—¶å¿½ç•¥å¯¹æ‰‹æ”»å‡»/ç‰¹æ”»æå‡
    'Unaware': {
        ignoreDefenderBoosts: true,  // æ”»å‡»æ—¶å¿½ç•¥å¯¹æ‰‹é˜²å¾¡æå‡
        ignoreAttackerBoosts: true   // é˜²å¾¡æ—¶å¿½ç•¥å¯¹æ‰‹æ”»å‡»æå‡
    },
    // ============================================
    // O. å…¶ä»–é‡è¦ç‰¹æ€§è¡¥å……
    // ============================================
    // ã€é­”æ³•åå°„ã€‘åå¼¹å˜åŒ–æŠ€
    'Magic Bounce': {
        reflectStatus: true
    },
    // ã€ç ´æ ¼ã€‘æ— è§†å¯¹æ‰‹ç‰¹æ€§
    'Mold Breaker': {
        ignoreAbility: true
    },
    'Teravolt': {
        ignoreAbility: true
    },
    'Turboblaze': {
        ignoreAbility: true
    },
    // ============================================
    // P. é‡è¦è¡¥å…… - å…ˆåˆ¶å…ç–« & é»„é‡‘ä¹‹èº¯
    // ============================================
    // ã€é²œè‰³ä¹‹èº¯ã€‘å…ç–«å…ˆåˆ¶æ”»å‡»
    'Dazzling': {
        onTryHit: (attacker, defender, move) => {
            if (move.priority && move.priority > 0) {
                return { blocked: true, message: `${defender.cnName} çš„ç‰¹æ€§è®©å…ˆåˆ¶æ”»å‡»æ— æ•ˆäº†ï¼` };
            }
            return { blocked: false };
        }
    },
    // ã€å¥³ç‹çš„å¨ä¸¥ã€‘å…ç–«å…ˆåˆ¶æ”»å‡»
    'Queenly Majesty': {
        onTryHit: (attacker, defender, move) => {
            if (move.priority && move.priority > 0) {
                return { blocked: true, message: `${defender.cnName} çš„å¨ä¸¥è®©å¯¹æ‰‹æ— æ³•ä½¿å‡ºå…ˆåˆ¶æ‹›å¼ï¼` };
            }
            return { blocked: false };
        }
    },
    // ã€å°¾ç”²ã€‘å…ç–«å…ˆåˆ¶æ”»å‡»
    'Armor Tail': {
        onTryHit: (attacker, defender, move) => {
            if (move.priority && move.priority > 0) {
                return { blocked: true, message: `${defender.cnName} çš„é“ ç”²ä¹‹å°¾æŒ¡ä¸‹äº†å…ˆåˆ¶æ”»å‡»ï¼` };
            }
            return { blocked: false };
        }
    },
    // ã€é»„é‡‘ä¹‹èº¯ã€‘å…ç–«å˜åŒ–æ‹›å¼ (èµ›å¯Œè±ªä¸“å±)
    'Good as Gold': {
        onTryHit: (attacker, defender, move) => {
            if (move.cat === 'status' || move.category === 'Status') {
                return { blocked: true, message: `${defender.cnName} çš„é»„é‡‘ä¹‹èº¯å…ç–«äº†å˜åŒ–æ‹›å¼ï¼` };
            }
            return { blocked: false };
        }
    },
    // ã€ä¹˜é£ã€‘å…ç–«é£ç±»æ‹›å¼+æ”»å‡»+1
    'Wind Rider': {
        onImmunity: (atkType, move) => {
            const windMoves = [
                'Aeroblast', 'Air Cutter', 'Air Slash', 'Bleakwind Storm', 'Blizzard', 
                'Fairy Wind', 'Gust', 'Heat Wave', 'Hurricane', 'Icy Wind', 
                'Petal Blizzard', 'Springtide Storm', 'Tailwind', 
                'Twister', 'Whirlwind', 'Wildbolt Storm'
            ];
            if (move && windMoves.includes(move.name)) return true;
            return false;
        }
    },
    // ============================================
    // Q. è¡¥å…… - ç‰¹å®šèƒ½åŠ›ä¿æŠ¤ & æ¢äººä¿æŠ¤
    // ============================================
    // ã€æ€ªåŠ›é’³ã€‘é˜²æ­¢æ”»å‡»é™ä½
    'Hyper Cutter': {
        onTryBoost: (boost, pokemon, source, stat) => {
            if (stat === 'atk' && boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    // ã€å¥å£®èƒ¸è‚Œã€‘é˜²æ­¢é˜²å¾¡é™ä½
    'Big Pecks': {
        onTryBoost: (boost, pokemon, source, stat) => {
            if (stat === 'def' && boost < 0 && source !== pokemon) return 0;
            return boost;
        }
    },
    // ã€é”åˆ©ç›®å…‰ã€‘é˜²æ­¢å‘½ä¸­ç‡é™ä½ + å¿½ç•¥å¯¹æ–¹é—ªé¿
    'Keen Eye': {
        onTryBoost: (boost, pokemon, source, stat) => {
            if (stat === 'accuracy' && boost < 0 && source !== pokemon) return 0;
            return boost;
        },
        ignoreEvasion: true
    },
    // ã€é•œç”²ã€‘åå°„èƒ½åŠ›ä¸‹é™ç»™å¯¹æ–¹
    'Mirror Armor': {
        onTryBoost: (boost, pokemon, source, stat, logs) => {
            // å¦‚æœæ˜¯è‡ªèº«é€ æˆçš„ä¸‹é™ï¼ˆå¦‚è¿‘èº«æˆ˜ï¼‰ï¼Œä¸åå¼¹
            if (source === pokemon || !source) return boost;
            // åªæœ‰è´Ÿé¢æ•ˆæœæ‰åå¼¹
            if (boost < 0) {
                // åå¼¹ç»™å¯¹æ–¹
                if (typeof source.applyBoost === 'function') {
                    source.applyBoost(stat, boost);
                } else if (source.boosts) {
                    source.boosts[stat] = Math.max(-6, (source.boosts[stat] || 0) + boost);
                }
                if (logs && Array.isArray(logs)) {
                    logs.push(`ğŸª ${pokemon.cnName} çš„é•œç”²å°† ${stat} ä¸‹é™åå¼¹ç»™äº† ${source.cnName}ï¼`);
                }
                console.log(`[MIRROR ARMOR] ${pokemon.cnName} å°† ${stat} ä¸‹é™åå¼¹ç»™äº† ${source.cnName}!`);
                return 0; // è‡ªå·±ä¸å—å½±å“
            }
            return boost;
        }
    },
    // ã€å¸ç›˜ã€‘é˜²æ­¢è¢«å¼å«/é¾™å°¾å¼ºåˆ¶æ¢ä¸‹
    'Suction Cups': {
        preventPhazing: true
    },
    // ã€é»ç€ã€‘é˜²æ­¢é“å…·è¢«å·/è¢«æ‹è½
    'Sticky Hold': {
        preventItemTheft: true
    },
    // ã€ç²¾ç¥åŠ›ã€‘é˜²æ­¢ç•ç¼©
    'Inner Focus': {
        preventFlinch: true
    },
    // ã€æˆ‘è¡Œæˆ‘ç´ ã€‘é˜²æ­¢æ··ä¹±
    'Own Tempo': {
        onImmunityStatus: (status) => status === 'confusion'
    },
    // ã€è¿Ÿé’ã€‘é˜²æ­¢è¢«æŒ‘è¡…å’ŒæŒ‘æ‹¨
    'Oblivious': {
        preventTaunt: true,
        preventAttract: true
    }
};
// ============================================
// æ¢äººé˜»æ–­æ ¡éªŒå‡½æ•°
// ============================================
/**
 * æ ¡éªŒå½“å‰å®å¯æ¢¦æ˜¯å¦å¯ä»¥ä¸»åŠ¨æ¢äºº
 * @param {Object} pokemon - æƒ³è¦æ¢äººçš„å®å¯æ¢¦
 * @param {Object} opponent - å¯¹æ‰‹å®å¯æ¢¦
 * @param {Object} battle - æˆ˜æ–—å¯¹è±¡
 * @returns {Object} { canSwitch: boolean, reason?: string }
 */
function checkCanSwitch(pokemon, opponent, battle) {
    // 0. ç‰¹æ®ŠçŠ¶æ€ç›´æ¥æ”¾è¡Œ
    // å¦‚æœä½¿ç”¨äº† U-turn ç­‰ Pivot æ‹›å¼ï¼Œæˆ–è€…æºå¸¦æ¼‚äº®å¤–å£³ï¼Œæ— è§†ä¸€åˆ‡é”å®š
    if (pokemon.isPivoting) return { canSwitch: true };
    if (pokemon.item === 'Shed Shell') return { canSwitch: true };
    // 1. å¹½çµç³»ç‰¹æƒï¼šæƒ³èµ°å°±èµ°ï¼ˆå…­ä»£åï¼‰
    if (pokemon.types && pokemon.types.includes('Ghost')) return { canSwitch: true };
    // 2. æ£€æŸ¥è‡ªèº«çš„å¼‚å¸¸çŠ¶æ€ (Volatile)
    if (pokemon.volatile) {
        // é»‘è‰²ç›®å…‰/æŒ¡è·¯ç­‰é€ æˆçš„ cantEscape çŠ¶æ€
        if (pokemon.volatile.cantEscape) {
            return { canSwitch: false, reason: `${pokemon.cnName} è¢«å›°ä½äº†ï¼Œæ— æ³•é€ƒèµ°ï¼` };
        }
        // æŸç¼šçŠ¶æ€ï¼ˆç†”å²©é£æš´ã€ç«ç„°æ—‹æ¶¡ç­‰ï¼‰
        if (pokemon.volatile.partiallyTrapped) {
            return { canSwitch: false, reason: `${pokemon.cnName} æ­£å¤„äºæŸç¼šçŠ¶æ€ï¼Œæ— æ³•é€ƒèµ°ï¼` };
        }
    }
    // 3. æ£€æŸ¥å¯¹æ‰‹ç‰¹æ€§ (Abilities)
    if (opponent && opponent.isAlive && opponent.isAlive()) {
        const ability = opponent.ability || '';
        const handler = AbilityHandlers[ability];
        if (handler && handler.isTrapping && handler.canTrap) {
            if (handler.canTrap(opponent, pokemon)) {
                // æ ¹æ®ç‰¹æ€§è¿”å›ä¸åŒçš„æç¤º
                if (ability === 'Shadow Tag') {
                    return { canSwitch: false, reason: `${opponent.cnName} çš„è¸©å½±è®©è„šå› ä¸ºææƒ§è€Œæ— æ³•ç§»åŠ¨ï¼` };
                }
                if (ability === 'Magnet Pull') {
                    return { canSwitch: false, reason: `${opponent.cnName} çš„å¼ºåŠ›ç£åœºå¸ä½äº†é’¢å±æ€§ï¼` };
                }
                if (ability === 'Arena Trap') {
                    return { canSwitch: false, reason: `${opponent.cnName} å°é”äº†åœ°é¢ï¼Œæ— æ³•é€ƒèµ°ï¼` };
                }
                return { canSwitch: false, reason: `è¢«å¯¹æ‰‹çš„ç‰¹æ€§å›°ä½äº†ï¼` };
            }
        }
    }
    return { canSwitch: true };
}
// å¯¼å‡ºåˆ°å…¨å±€
if (typeof window !== 'undefined') {
    window.AbilityHandlers = AbilityHandlers;
    window.checkCanSwitch = checkCanSwitch;
}
]]></file>
        <file name="ai-engine.js"><![CDATA[/**
 * =============================================
 * AI ENGINE - å®å¯æ¢¦æˆ˜æ–— AI ç³»ç»Ÿ
 * =============================================
 * 
 * å››ä¸ªéš¾åº¦ç­‰çº§ï¼š
 * - easy: éšæœºé€‰æ‹©ï¼Œå¶å°”é€‰æœ€ä¼˜
 * - normal: 60% æœ€ä¼˜ï¼Œ30% æ¬¡ä¼˜ï¼Œ10% éšæœº
 * - hard: æ€»æ˜¯é€‰æ‹©å½“å‰æœ€ä¼˜æŠ€èƒ½
 * - expert: å¤§å±€è§‚ AIï¼Œä¼šæ¢äººã€é¢„åˆ¤ã€æ–©æ€è®¡ç®—
 * 
 * v2.0 é«˜çº§è½®è½¬ AI ç‰¹æ€§ï¼š
 * - æŠ˜è¿”æŠ€èƒ½æˆ˜æœ¯è¯„åˆ† (U-turn, Volt Switch ç­‰)
 * - æˆ˜ç•¥æ€§æ¢äºº (æ¸…é™¤è´Ÿé¢çŠ¶æ€/èƒ½åŠ›ä¸‹é™)
 * - é£é™©è¯„ä¼° (è„†çš®è¾“å‡ºæ‰‹æ›´æƒœå‘½)
 * - ç®€æ˜“è¯»æ¢ (é¢„æµ‹ç©å®¶å¿…æ­»æ¢äºº)
 */
const AI_DIFFICULTY = {
    EASY: 'easy',
    NORMAL: 'normal', 
    HARD: 'hard',
    EXPERT: 'expert'
};
/**
 * AI å†³ç­–ç»“æœç±»å‹
 */
const AI_ACTION_TYPE = {
    MOVE: 'move',
    SWITCH: 'switch'
};
// =============================================
// AI ç‰¹æ€§è¯„ä¼°é…ç½®ï¼ˆè½¯ç¼–ç ï¼Œæ•°æ®é©±åŠ¨ï¼‰
// =============================================
// type: é˜²å¾¡æœºåˆ¶ç±»å‹
//   - consumable_shield: ä¸€æ¬¡æ€§æŠ¤ç›¾ï¼ˆç”»çš®ã€å†°ç Œé¹…ï¼‰
//   - damage_reduction: æ»¡è¡€å‡ä¼¤ï¼ˆå¤šé‡é³ç‰‡ã€å¹»å½±é˜²å®ˆï¼‰
//   - endure_lethal: æ»¡è¡€ä¿å‘½ï¼ˆç»“å®ï¼‰
//   - immunity_conditional: æ¡ä»¶å…ç–«ï¼ˆè“„æ°´ã€é¿é›·é’ˆç­‰ï¼‰
// breakValue: æ‰“ç ´æŠ¤ç›¾çš„æˆ˜æœ¯ä»·å€¼
// condition: è§¦å‘æ¡ä»¶ï¼ˆphysical/special/full_hpï¼‰
// bustedFlag: æ£€æµ‹æŠ¤ç›¾æ˜¯å¦å·²ç ´æŸçš„å±æ€§å
const AI_ABILITY_TRAITS = {
    // ä¸€æ¬¡æ€§æŠ¤ç›¾
    'Disguise':      { type: 'consumable_shield', breakValue: 350, bustedFlag: 'disguiseBusted' },
    'Ice Face':      { type: 'consumable_shield', breakValue: 300, condition: 'physical', bustedFlag: 'iceFaceBusted' },
    // æ»¡è¡€å‡ä¼¤
    'Multiscale':    { type: 'damage_reduction', breakValue: 150, condition: 'full_hp' },
    'Shadow Shield': { type: 'damage_reduction', breakValue: 150, condition: 'full_hp' },
    // æ»¡è¡€ä¿å‘½
    'Sturdy':        { type: 'endure_lethal', breakValue: 200, condition: 'full_hp' },
    // æ¡ä»¶å…ç–«ï¼ˆè¿™äº›ä¸éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œæ­£å¸¸ä¼¤å®³è®¡ç®—ä¼šè¿”å›0ï¼‰
    'Wonder Guard':  { type: 'immunity_conditional', note: 'only_supereffective' },
    'Levitate':      { type: 'immunity_conditional', note: 'ground_immune' },
    'Volt Absorb':   { type: 'immunity_conditional', note: 'electric_immune' },
    'Water Absorb':  { type: 'immunity_conditional', note: 'water_immune' },
    'Flash Fire':    { type: 'immunity_conditional', note: 'fire_immune' },
};
// åå¼ºåŒ–æŠ€èƒ½åˆ—è¡¨ï¼ˆé¢å¯¹é«˜å¨èƒæ—¶ä¼˜å…ˆä½¿ç”¨ï¼‰
const AI_COUNTER_MOVES = ['Haze', 'Clear Smog', 'Roar', 'Whirlwind', 'Dragon Tail', 'Circle Throw', 'Topsy-Turvy', 'Spectral Thief'];
/**
 * è·å– AI å†³ç­–ï¼ˆç»Ÿä¸€å…¥å£ï¼‰
 * @param {Pokemon} aiPoke - AI å½“å‰å®å¯æ¢¦
 * @param {Pokemon} playerPoke - ç©å®¶å½“å‰å®å¯æ¢¦
 * @param {string} difficulty - éš¾åº¦ç­‰çº§
 * @param {Pokemon[]} aiParty - AI é˜Ÿä¼ï¼ˆç”¨äºæ¢äººå†³ç­–ï¼‰
 * @param {object} battleContext - æˆ˜æ–—ä¸Šä¸‹æ–‡ï¼ˆå›åˆæ•°ã€å·²ç”¨ Mega ç­‰ï¼‰
 * @returns {object} { type: 'move'|'switch', move?: Move, index?: number, reasoning?: string }
 */
function getAiAction(aiPoke, playerPoke, difficulty = 'hard', aiParty = [], battleContext = {}) {
    if (!aiPoke || !playerPoke) return null;
    const normalizedDiff = (difficulty || 'hard').toLowerCase();
    switch (normalizedDiff) {
        case 'expert':
            return getExpertAiAction(aiPoke, playerPoke, aiParty, battleContext);
        case 'hard': {
            // ã€v2.1ã€‘Hard éš¾åº¦ä¹Ÿæ”¯æŒé£æ ¼é€‰æ‹©
            const hardMove = getHardAiMove(aiPoke, playerPoke, aiParty);
            let chosenStyle = null;
            if (hardMove) {
                const mergedMove = getMergedMoveData(hardMove);
                chosenStyle = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
            }
            return { type: AI_ACTION_TYPE.MOVE, move: hardMove, style: chosenStyle };
        }
        case 'normal': {
            // ã€v2.1ã€‘Normal éš¾åº¦ä¹Ÿæ”¯æŒé£æ ¼é€‰æ‹©ï¼ˆæ¦‚ç‡è¾ƒä½ï¼‰
            const normalMove = getNormalAiMove(aiPoke, playerPoke, aiParty);
            let chosenStyle = null;
            if (normalMove && Math.random() < 0.5) { // 50% æ¦‚ç‡å°è¯•é£æ ¼
                const mergedMove = getMergedMoveData(normalMove);
                chosenStyle = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
            }
            return { type: AI_ACTION_TYPE.MOVE, move: normalMove, style: chosenStyle };
        }
        case 'easy':
        default:
            return { type: AI_ACTION_TYPE.MOVE, move: getEasyAiMove(aiPoke, playerPoke, aiParty) };
    }
}
/* =============================================================
 *  åŸºç¡€ AIï¼šEasy éš¾åº¦
 *  80% éšæœºé€‰æ‹©ï¼Œ20% é€‰æœ€ä¼˜
 * ============================================================= */
function getEasyAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    // 80% æ¦‚ç‡éšæœºé€‰
    if (Math.random() < 0.8) {
        return attacker.moves[Math.floor(Math.random() * attacker.moves.length)];
    }
    // 20% æ¦‚ç‡é€‰æœ€ä¼˜
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    // ä½†å³ä½¿é€‰æœ€ä¼˜ï¼Œä¹Ÿå¯èƒ½é€‰æ¬¡ä¼˜
    if (rankedMoves.length > 1 && Math.random() < 0.5) {
        return rankedMoves[1].move;
    }
    return rankedMoves[0].move;
}
/* =============================================================
 *  æ™®é€š AIï¼šNormal éš¾åº¦
 *  60% æœ€ä¼˜ï¼Œ30% æ¬¡ä¼˜ï¼Œ10% ç¬¬ä¸‰ä¼˜æˆ–éšæœº
 * ============================================================= */
function getNormalAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    const roll = Math.random();
    if (roll < 0.6 || rankedMoves.length === 1) {
        return rankedMoves[0].move;
    }
    if (roll < 0.9 && rankedMoves.length > 1) {
        return rankedMoves[1].move;
    }
    return rankedMoves[Math.min(2, rankedMoves.length - 1)].move;
}
/* =============================================================
 *  å›°éš¾ AIï¼šHard éš¾åº¦
 *  æ€»æ˜¯é€‰æ‹©å½“å‰è¯„åˆ†æœ€é«˜çš„æŠ€èƒ½
 * ============================================================= */
function getHardAiMove(attacker, defender, aiParty = null) {
    if (!attacker?.moves || attacker.moves.length === 0) return null;
    const rankedMoves = rankMovesByScore(attacker, defender, aiParty);
    if (rankedMoves.length === 0) return attacker.moves[0];
    // ã€ä¿®å¤ã€‘æå·¨åŒ–æ—¶ï¼Œå¦‚æœæœ€é«˜åˆ†æ‹›å¼æ˜¯å…ç–«çš„æ”»å‡»æ‹›å¼ï¼ˆ-9999ï¼‰ï¼Œä¼˜å…ˆé€‰æ‹© Max Guard
    // Max Guard æ˜¯å˜åŒ–æŠ€è½¬æ¢çš„æå·¨æ‹›å¼ï¼Œè‡³å°‘èƒ½ä¿æŠ¤è‡ªå·±
    if (attacker.isDynamaxed && rankedMoves[0].score <= -9000) {
        // æ‰¾åˆ° Max Guardï¼ˆå˜åŒ–æŠ€è½¬æ¢çš„æå·¨æ‹›å¼ï¼‰
        const maxGuard = rankedMoves.find(r => r.move.name === 'Max Guard');
        if (maxGuard) {
            console.log(`[AI FIX] æå·¨åŒ–çŠ¶æ€ä¸‹æ‰€æœ‰æ”»å‡»æ‹›å¼å¯¹ç›®æ ‡å…ç–«ï¼Œé€‰æ‹© Max Guard`);
            return maxGuard.move;
        }
        // å¦‚æœæ²¡æœ‰ Max Guardï¼Œé€‰æ‹©è¯„åˆ†æœ€é«˜çš„éæ”»å‡»æ‹›å¼
        const nonAttack = rankedMoves.find(r => r.score > -9000);
        if (nonAttack) {
            console.log(`[AI FIX] æå·¨åŒ–çŠ¶æ€ä¸‹æ”»å‡»æ‹›å¼å…ç–«ï¼Œé€‰æ‹©: ${nonAttack.move.name}`);
            return nonAttack.move;
        }
    }
    return rankedMoves[0].move;
}
// æ¢äººå†·å´è¿½è¸ªï¼ˆé˜²æ­¢è¿ç»­æ¢äººï¼‰
let lastSwitchTurn = -999;
// æŠ˜è¿”æŠ€èƒ½åˆ—è¡¨
const PIVOT_MOVES = ['U-turn', 'Volt Switch', 'Flip Turn', 'Parting Shot', 'Teleport', 'Baton Pass'];
/**
 * =======================================================
 * [AI è¡¥ä¸] å¤æ­¦æµæ´¾è¯„ä¼°å™¨ (Style Evaluator)
 * æå‡ AI ä½¿ç”¨ è¿…ç–¾ (Agile) / åˆšçŒ› (Strong) çš„é¢‘ç‡
 * =======================================================
 * @param {Pokemon} aiPoke - AI å½“å‰å®å¯æ¢¦
 * @param {Pokemon} playerPoke - ç©å®¶å½“å‰å®å¯æ¢¦
 * @param {object} baseMove - åŸºç¡€æ‹›å¼
 * @returns {string|null} 'agile' | 'strong' | null
 */
/**
 * AI é£æ ¼ä¼˜åŒ– v3.1 - å¹³è¡¡åšå¼ˆæ¨¡å‹
 * 
 * âš¡ è¿…ç–¾ (Agile): ä¼˜å…ˆåº¦ +1ï¼Œé™ä½å¨åŠ›å’Œå‘½ä¸­
 *   - åœºæ™¯Aï¼ˆé€Ÿåº¦å¿«ï¼‰: å¨åŠ› 0.75x, å‘½ä¸­ 0.9x
 *   - åœºæ™¯Bï¼ˆé€Ÿåº¦æ…¢ï¼‰: å¨åŠ› 0.50x, å‘½ä¸­ 0.85x
 * 
 * ğŸ’ª åˆšçŒ› (Strong): ä¼˜å…ˆåº¦ -1ï¼Œæé«˜å¨åŠ›
 *   - åœºæ™¯Aï¼ˆé€Ÿåº¦æ…¢ï¼‰: å¨åŠ› 1.3x, å‘½ä¸­ 0.8x
 *   - åœºæ™¯Bï¼ˆé€Ÿåº¦å¿«ï¼‰: å¨åŠ› 1.3x, å‘½ä¸­ä¸å˜ï¼ˆå–å…ˆæ‰‹ï¼‰
 */
function tryOptimizeStyle(aiPoke, playerPoke, baseMove) {
    // === åŸºç¡€æ£€æŸ¥ ===
    const unlocks = (typeof battle !== 'undefined') ? battle.enemyUnlocks : {};
    if (unlocks && unlocks.enable_styles === false) return null;
    if (typeof battle !== 'undefined' && battle.enemyStyleCooldown > 0) {
        console.log(`[AI STYLE] å†·å´ä¸­ (${battle.enemyStyleCooldown})`);
        return null;
    }
    // å˜åŒ–æŠ€ä¸ä½¿ç”¨é£æ ¼
    const category = (baseMove.cat || baseMove.category || '').toLowerCase();
    if (category === 'status' || baseMove.power === 0) return null;
    // å…ˆåˆ¶æŠ€ä¸éœ€è¦è¿…ç–¾
    const basePriority = baseMove.priority || 0;
    // === è·å–æˆ˜æ–—æ•°æ® ===
    const normalDmgResult = simulateDamage(aiPoke, playerPoke, baseMove);
    const normalDmg = normalDmgResult.damage;
    const targetHp = playerPoke.currHp;
    const targetMaxHp = playerPoke.maxHp;
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    const mySpeed = getEffectiveSpeed(aiPoke);
    const targetSpeed = getEffectiveSpeed(playerPoke);
    const isTrickRoom = (typeof battle !== 'undefined') && battle.field && battle.field.trickRoom > 0;
    const isFaster = isTrickRoom ? (mySpeed < targetSpeed) : (mySpeed > targetSpeed);
    const isSlower = !isFaster;
    // ä¼¤å®³è®¡ç®—
    const strongDmg = Math.floor(normalDmg * 1.30);
    const agileDmgFast = Math.floor(normalDmg * 0.75);
    const agileDmgSlow = Math.floor(normalDmg * 0.50);
    // è¡€é‡ç™¾åˆ†æ¯”
    const targetHpPct = targetHp / targetMaxHp;
    const myHpPct = myHp / myMaxHp;
    console.log(`[AI STYLE] è¯„ä¼°: ${baseMove.name}, é€Ÿåº¦${isFaster ? 'å¿«' : 'æ…¢'} (${mySpeed} vs ${targetSpeed}), å¯¹æ–¹${Math.floor(targetHpPct*100)}%è¡€, æˆ‘${Math.floor(myHpPct*100)}%è¡€`);
    // =========================================================
    // ğŸ’ª åˆšçŒ›å†³ç­–
    // =========================================================
    // ã€åœºæ™¯1ã€‘æ–©æ€çº¿ï¼šæ™®é€šæ‰“ä¸æ­»ï¼ŒåˆšçŒ›èƒ½æ‰“æ­»ï¼ˆ100%è§¦å‘ï¼‰
    if (normalDmg < targetHp && strongDmg >= targetHp) {
        if (isFaster) {
            console.log(`[AI STYLE] åˆšçŒ›æ–©æ€: ${baseMove.name} (${normalDmg} -> ${strongDmg})`);
            return 'strong';
        } else {
            // é€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8xï¼Œä½†æ–©æ€çº¿å€¼å¾—èµŒ
            console.log(`[AI STYLE] åˆšçŒ›å†’é™©æ–©æ€: ${baseMove.name} (${normalDmg} -> ${strongDmg}, å‘½ä¸­0.8x)`);
            return 'strong';
        }
    }
    // ã€v3.3 ç§»é™¤åœºæ™¯2ã€‘é€Ÿåº¦å¿«æ—¶å–å…ˆæ‰‹å¤ªå±é™©ï¼Œå¦‚æœå¯¹æ–¹èƒ½æ–©æ€è‡ªå·±å°±æ˜¯è‡ªæ€
    // åªä¿ç•™æ–©æ€çº¿åœºæ™¯
    // =========================================================
    // âš¡ è¿…ç–¾å†³ç­–ï¼ˆå…ˆåˆ¶æŠ€è·³è¿‡ï¼‰
    // ã€v3.3ã€‘åªåœ¨æ–©æ€çº¿æ—¶ä½¿ç”¨è¿…ç–¾ï¼Œä¸å†æœ‰å…¶ä»–åœºæ™¯
    // =========================================================
    if (basePriority <= 0) {
        // ã€å”¯ä¸€åœºæ™¯ã€‘é€Ÿåº¦æ…¢ + è¿…ç–¾èƒ½æ–©æ€ = æŠ¢å…ˆæ”¶å‰²
        if (isSlower && agileDmgSlow >= targetHp) {
            console.log(`[AI STYLE] è¿…ç–¾æ–©æ€: ${baseMove.name} (${agileDmgSlow} >= ${targetHp})`);
            return 'agile';
        }
    }
    // é»˜è®¤ä¸ä½¿ç”¨é£æ ¼
    return null;
}
/* =============================================================
 *  ä¸“å®¶ AIï¼šExpert éš¾åº¦
 *  å¤§å±€è§‚å†³ç­–ï¼šæ–©æ€è®¡ç®— + æ¢äººåˆ¤æ–­ + çŠ¶æ€åšå¼ˆ + é«˜çº§è½®è½¬
 * ============================================================= */
function getExpertAiAction(aiPoke, playerPoke, aiParty = [], battleContext = {}) {
    if (!aiPoke || !playerPoke) return null;
    if (!aiPoke.moves || aiPoke.moves.length === 0) return null;
    const turnCount = battleContext.turnCount || 1;
    // ========================================
    // é˜¶æ®µ 0ï¼šç‰¹æ®Šé¦–å›åˆæŠ€èƒ½æ£€æŸ¥
    // ========================================
    const firstTurnMove = checkFirstTurnMoves(aiPoke, playerPoke, turnCount);
    if (firstTurnMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: firstTurnMove, reasoning: 'First turn priority move (Fake Out)' };
    }
    // ========================================
    // é˜¶æ®µ 1ï¼šæ–©æ€çº¿è®¡ç®— (Lethal Check)
    // ã€v3.2ã€‘æ”¯æŒè¿…ç–¾/åˆšçŒ›æ–©æ€
    // ========================================
    const killMove = findKillMove(aiPoke, playerPoke);
    if (killMove) {
        return { 
            type: AI_ACTION_TYPE.MOVE, 
            move: killMove.move, 
            style: killMove.style || null,
            reasoning: killMove.reasoning 
        };
    }
    // ========================================
    // é˜¶æ®µ 1.5ï¼šè¯»æ¢é¢„åˆ¤ (Prediction) [v2.0]
    // å¦‚æœç©å®¶å¿…æ­»ä¸”æ¯”æˆ‘æ…¢ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
    // ========================================
    const predictionMove = evaluatePrediction(aiPoke, playerPoke, aiParty);
    if (predictionMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: predictionMove.move, reasoning: predictionMove.reasoning };
    }
    // ========================================
    // é˜¶æ®µ 2ï¼šå¨èƒè¯„ä¼° - æˆ‘ä¼šæ­»å—ï¼Ÿ
    // ========================================
    const threatAssessment = assessThreat(aiPoke, playerPoke);
    // ========================================
    // é˜¶æ®µ 2.5ï¼šæˆ˜ç•¥æ€§æ¢äººæ£€æŸ¥ (Reset Pivoting) [v2.0]
    // æ£€æŸ¥æ˜¯å¦å› ä¸ºè´Ÿé¢çŠ¶æ€/èƒ½åŠ›ä¸‹é™éœ€è¦æ¢äºº
    // ========================================
    const needsStrategicSwitch = shouldStrategicSwitch(aiPoke);
    // ========================================
    // é˜¶æ®µ 3ï¼šæ¢äººå†³ç­– (Pivot Logic)
    // æ·»åŠ å†·å´ï¼šè‡³å°‘é—´éš” 2 å›åˆæ‰èƒ½å†æ¬¡æ¢äºº
    // ========================================
    const switchCooldown = 2;
    const canSwitch = (turnCount - lastSwitchTurn) >= switchCooldown;
    // ã€ä¿®å¤ã€‘æå·¨åŒ–çŠ¶æ€ä¸‹ç»å¯¹ç¦æ­¢æ¢äººï¼
    // æ­£ä½œè§„åˆ™ï¼šæå·¨åŒ–å®å¯æ¢¦æ¢äººä¼šç«‹åˆ»è§£é™¤æå·¨åŒ–ï¼Œè¿™æ˜¯å·¨å¤§çš„èµ„æºæµªè´¹
    if (aiPoke.isDynamaxed || (aiPoke.dynamaxTurns && aiPoke.dynamaxTurns > 0)) {
        console.log(`[AI] ${aiPoke.name} is Dynamaxed - switching FORBIDDEN`);
        // ç›´æ¥è·³è¿‡æ¢äººå†³ç­–ï¼Œè¿›å…¥æ”»å‡»å†³ç­–
        const bestMove = getHardAiMove(aiPoke, playerPoke, aiParty);
        return { type: AI_ACTION_TYPE.MOVE, move: bestMove, reasoning: 'Dynamax active - must attack' };
    }
    // ä¿®å¤ï¼šå¦‚æœæˆ‘æœ‰ä¼˜åŠ¿ï¼ˆèƒ½ç§’æ€å¯¹æ–¹æˆ–ä¼¤å®³è¿œè¶…å¯¹æ–¹ï¼‰ï¼Œä¸è¦æ¢äººï¼
    // v2.0ï¼šå³ä½¿ä¸å±é™©ï¼Œå¦‚æœçŠ¶æ€å¾ˆå·®ä¹Ÿè€ƒè™‘æ¢äºº
    const shouldConsiderSwitch = threatAssessment.amIInDanger || needsStrategicSwitch;
    if (canSwitch && shouldConsiderSwitch && 
        !threatAssessment.haveAdvantage &&  // å…³é”®ä¿®å¤ï¼šæœ‰ä¼˜åŠ¿æ—¶ä¸æ¢äºº
        aiParty && aiParty.length > 1) {
        const pivotDecision = findBestPivot(aiPoke, playerPoke, aiParty, threatAssessment);
        if (pivotDecision) {
            lastSwitchTurn = turnCount; // è®°å½•æ¢äººå›åˆ
            return pivotDecision;
        }
    }
    // ========================================
    // é˜¶æ®µ 4ï¼šçŠ¶æ€åšå¼ˆä¸å¼ºåŒ–åˆ¤æ–­
    // ========================================
    const strategicMove = evaluateStrategicMoves(aiPoke, playerPoke, threatAssessment);
    if (strategicMove) {
        return { type: AI_ACTION_TYPE.MOVE, move: strategicMove.move, reasoning: strategicMove.reasoning };
    }
    // ========================================
    // é˜¶æ®µ 5ï¼šå¸¸è§„è´ªå©ªé€‰æ‹© (Fallback to Hard AI)
    // ========================================
    const bestMove = getHardAiMove(aiPoke, playerPoke, aiParty);
    // ========================================
    // é˜¶æ®µ 6ï¼šé£æ ¼ä¼˜åŒ– (Style Optimization) [v2.1]
    // å°è¯•ä¸ºæœ€ä¼˜æ‹›å¼é™„åŠ "æµæ´¾ (Style)"
    // ========================================
    let chosenStyle = null;
    if (bestMove) {
        const mergedMove = getMergedMoveData(bestMove);
        const styleSuggestion = tryOptimizeStyle(aiPoke, playerPoke, mergedMove);
        if (styleSuggestion) {
            chosenStyle = styleSuggestion;
        }
        // ã€v3.2 ç§»é™¤ã€‘ä¸å†éšæœºä½¿ç”¨é£æ ¼ï¼Œåªåœ¨æœ‰æˆ˜æœ¯ä»·å€¼æ—¶ä½¿ç”¨
    }
    return { 
        type: AI_ACTION_TYPE.MOVE, 
        move: bestMove, 
        style: chosenStyle,
        reasoning: chosenStyle ? `Optimized via ${chosenStyle} style` : 'Standard best move calculation' 
    };
}
/* =============================================================
 *  Expert AI è¾…åŠ©å‡½æ•°
 * ============================================================= */
/**
 * æ£€æŸ¥é¦–å›åˆç‰¹æ®ŠæŠ€èƒ½ï¼ˆå¦‚ Fake Outï¼‰
 */
function checkFirstTurnMoves(aiPoke, playerPoke, turnCount) {
    // å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ turnsOnField è€Œä¸æ˜¯ turnCount
    // Fake Out åªèƒ½åœ¨å®å¯æ¢¦ä¸Šåœºåçš„ç¬¬ä¸€å›åˆä½¿ç”¨
    if ((aiPoke.turnsOnField || 0) > 0) return null;
    const fakeOutMoves = ['Fake Out', 'First Impression'];
    for (const move of aiPoke.moves) {
        if (fakeOutMoves.includes(move.name)) {
            // ç¡®ä¿èƒ½é€ æˆä¼¤å®³ï¼ˆä¸æ˜¯å…ç–«ï¼‰
            const eff = getTypeEffectivenessAI(move.type || 'Normal', playerPoke.types || ['Normal']);
            if (eff > 0) {
                return move;
            }
        }
    }
    return null;
}
/**
 * å¯»æ‰¾æ–©æ€æŠ€èƒ½
 * @returns {object|null} { move, reasoning } æˆ– null
 */
function findKillMove(aiPoke, playerPoke) {
    const targetHp = playerPoke.currHp;
    const targetMaxHp = playerPoke.maxHp;
    const mySpeed = getEffectiveSpeed(aiPoke);
    const targetSpeed = getEffectiveSpeed(playerPoke);
    const isTrickRoom = (typeof battle !== 'undefined') && battle.field && battle.field.trickRoom > 0;
    const aiFaster = isTrickRoom ? (mySpeed < targetSpeed) : (mySpeed > targetSpeed);
    // ã€è°ƒè¯•ã€‘è¾“å‡ºæ–©æ€æ£€æŸ¥ä¿¡æ¯
    console.log(`[AI KILL CHECK] ${aiPoke.name} vs ${playerPoke.name}: targetHp=${targetHp}/${targetMaxHp}, aiFaster=${aiFaster}`);
    let bestKillMove = null;
    let bestKillPriority = -999;
    // ã€ä¿®å¤ã€‘é¦–å›åˆé™åˆ¶æŠ€èƒ½åˆ—è¡¨
    const firstTurnOnlyMoves = ['Fake Out', 'First Impression', 'Mat Block'];
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        const category = (mergedMove.cat || mergedMove.category || '').toLowerCase();
        if (category === 'status' || mergedMove.power === 0) continue;
        // ã€ä¿®å¤ã€‘è·³è¿‡éé¦–å›åˆçš„é¦–å›åˆé™åˆ¶æŠ€èƒ½
        if (firstTurnOnlyMoves.includes(mergedMove.name) && (aiPoke.turnsOnField || 0) > 0) {
            continue;
        }
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        const priority = mergedMove.priority || 0;
        const normalDmg = dmgResult.damage;
        // ã€è°ƒè¯•ã€‘è¾“å‡ºæ¯ä¸ªæŠ€èƒ½çš„ä¼¤å®³
        if (normalDmg >= targetHp * 0.5) {
            console.log(`[AI KILL CHECK] ${mergedMove.name}: dmg=${normalDmg}, targetHp=${targetHp}, canKill=${normalDmg >= targetHp}`);
        }
        // ã€v3.2ã€‘è®¡ç®—è¿…ç–¾ä¼¤å®³ï¼ˆé€Ÿåº¦æ…¢æ—¶ç”¨0.5xï¼‰
        const agileDmg = Math.floor(normalDmg * 0.50);
        // èƒ½æ–©æ€
        if (normalDmg >= targetHp) {
            // é€Ÿåº¦å¿« + èƒ½ç§’ = å®Œç¾æ–©æ€
            if (aiFaster && priority >= bestKillPriority) {
                bestKillMove = { move, reasoning: 'Speed advantage kill', style: null };
                bestKillPriority = priority;
            }
            // é€Ÿåº¦æ…¢ä½†æœ‰å…ˆåˆ¶æŠ€ = å…ˆåˆ¶æ–©æ€
            else if (!aiFaster && priority > 0 && priority > bestKillPriority) {
                bestKillMove = { move, reasoning: 'Priority move kill', style: null };
                bestKillPriority = priority;
            }
            // ã€v3.4 ä¿®å¤ã€‘é€Ÿåº¦æ…¢ + æ™®é€šèƒ½æ–©æ€ + è¿…ç–¾ä¹Ÿèƒ½æ–©æ€ = ç”¨è¿…ç–¾æŠ¢å…ˆæ‰‹
            else if (!aiFaster && priority <= 0 && agileDmg >= targetHp) {
                console.log(`[AI STYLE] è¿…ç–¾æŠ¢å…ˆæ–©æ€: ${mergedMove.name} (${agileDmg} >= ${targetHp})`);
                bestKillMove = { move, reasoning: 'Agile style kill', style: 'agile' };
                bestKillPriority = 999;
            }
            // é€Ÿåº¦æ…¢æ— å…ˆåˆ¶ï¼Œè¿…ç–¾æ€ä¸æ­»ï¼ˆèµŒå¯¹é¢ä¸ç§’æˆ‘ï¼‰
            else if (!bestKillMove && normalDmg >= targetHp * 1.2) {
                bestKillMove = { move, reasoning: 'Overkill gamble', style: null };
            }
        }
        // é€Ÿåº¦æ…¢ + æ™®é€šæ€ä¸æ­» + è¿…ç–¾èƒ½æ–©æ€ = è¿…ç–¾æŠ¢å…ˆæ–©æ€
        else if (!aiFaster && priority <= 0 && agileDmg >= targetHp) {
            console.log(`[AI STYLE] è¿…ç–¾æ–©æ€æ£€æµ‹: ${mergedMove.name} (${normalDmg}*0.5=${agileDmg} >= ${targetHp})`);
            bestKillMove = { move, reasoning: 'Agile style kill', style: 'agile' };
            bestKillPriority = 999;
        }
        // ã€v3.3 ç§»é™¤åˆšçŒ›æ–©æ€ã€‘é€Ÿåº¦å¿«æ—¶ç”¨åˆšçŒ›ä¼šå–å…ˆæ‰‹ï¼Œå¤ªå±é™©
        // åˆšçŒ›åªåœ¨ tryOptimizeStyle ä¸­çš„æ–©æ€çº¿åœºæ™¯ä½¿ç”¨ï¼ˆé€Ÿåº¦æ…¢æ—¶ï¼‰
    }
    return bestKillMove;
}
/**
 * å¨èƒè¯„ä¼°ï¼šåˆ¤æ–­ AI æ˜¯å¦å¤„äºå±é™©
 * v2.0ï¼šåŠ å…¥è§’è‰²ç±»å‹åˆ¤æ–­ï¼ˆSweeper æ›´æƒœå‘½ï¼‰
 */
function assessThreat(aiPoke, playerPoke) {
    let maxIncomingDmg = 0;
    let worstPlayerMove = null;
    let worstMoveType = null;
    // æ¨¡æ‹Ÿç©å®¶æ‰€æœ‰æŠ€èƒ½å¯¹ AI çš„ä¼¤å®³
    for (const pMove of playerPoke.moves) {
        const mergedMove = getMergedMoveData(pMove);
        const dmgResult = simulateDamage(playerPoke, aiPoke, mergedMove);
        if (dmgResult.damage > maxIncomingDmg) {
            maxIncomingDmg = dmgResult.damage;
            worstPlayerMove = mergedMove;
            worstMoveType = mergedMove.type;
        }
    }
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    const hpPercent = myHp / myMaxHp;
    // === æ–°å¢ï¼šè¯„ä¼°æˆ‘çš„åå‡»èƒ½åŠ› ===
    let canKillPlayer = false;
    let myBestDamage = 0;
    let myBestMove = null;
    for (const myMove of aiPoke.moves) {
        const mergedMove = getMergedMoveData(myMove);
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        if (dmgResult.damage > myBestDamage) {
            myBestDamage = dmgResult.damage;
            myBestMove = mergedMove;
        }
        if (dmgResult.damage >= playerPoke.currHp) {
            canKillPlayer = true;
        }
    }
    // åˆ¤æ–­æ˜¯å¦æœ‰ä¼˜åŠ¿ï¼šèƒ½ç§’æ€å¯¹æ–¹ï¼Œæˆ–è€…æˆ‘çš„ä¼¤å®³è¿œè¶…å¯¹æ–¹
    const haveAdvantage = canKillPlayer || (myBestDamage > maxIncomingDmg * 1.3);
    // === v2.0ï¼šè§’è‰²ç±»å‹åˆ¤æ–­ ===
    // é«˜é€Ÿè„†çš® (Sweeper)ï¼šé€Ÿåº¦é«˜ + æ”»å‡»/ç‰¹æ”»é«˜ + é˜²å¾¡ä½
    const baseSpe = aiPoke.baseStats?.spe || aiPoke.spe || 80;
    const baseAtk = aiPoke.baseStats?.atk || aiPoke.atk || 80;
    const baseSpa = aiPoke.baseStats?.spa || aiPoke.spa || 80;
    const baseDef = aiPoke.baseStats?.def || aiPoke.def || 80;
    const baseSpd = aiPoke.baseStats?.spd || aiPoke.spd || 80;
    const isSweeper = baseSpe >= 95 && (baseAtk >= 100 || baseSpa >= 100);
    const isBulky = (baseDef + baseSpd) >= 180;
    // å±é™©é˜ˆå€¼ï¼šè„†çš®è¾“å‡ºæ‰‹æ›´æƒœå‘½
    // Sweeper: å—åˆ° 45% ä»¥ä¸Šä¼¤å®³å°±è§†ä¸ºå±é™©
    // Tank: å—åˆ° 88% ä»¥ä¸Šä¼¤å®³æ‰è§†ä¸ºå±é™©
    const dangerThreshold = isSweeper ? 0.45 : (isBulky ? 0.88 : 0.7);
    const willDieNextTurn = maxIncomingDmg >= myHp;
    const playerFaster = getEffectiveSpeed(playerPoke) > getEffectiveSpeed(aiPoke);
    // v2.0 å±é™©åˆ¤å®šï¼š
    // 1. ä¸‹å›åˆå¿…æ­»ä¸”å¯¹æ–¹é€Ÿåº¦å¿«
    // 2. æˆ–è€…å—åˆ°çš„ä¼¤å®³è¶…è¿‡è§’è‰²ç±»å‹é˜ˆå€¼ä¸”å¯¹æ–¹é€Ÿåº¦å¿«
    const significantDamage = maxIncomingDmg >= myMaxHp * dangerThreshold;
    const amIInDanger = (willDieNextTurn && playerFaster) || 
                        (significantDamage && playerFaster && hpPercent < 0.8);
    return {
        maxIncomingDmg,
        worstPlayerMove,
        worstMoveType,
        willDieNextTurn,
        playerFaster,
        amIInDanger,
        // æ–°å¢è¿”å›å€¼
        haveAdvantage,
        canKillPlayer,
        myBestDamage,
        myBestMove,
        // v2.0 è§’è‰²ç±»å‹
        isSweeper,
        isBulky,
        dangerThreshold
    };
}
/**
 * å¯»æ‰¾æœ€ä½³æ¢äººç›®æ ‡
 */
function findBestPivot(aiPoke, playerPoke, aiParty, threatAssessment) {
    const { worstPlayerMove, worstMoveType, maxIncomingDmg } = threatAssessment;
    if (!worstPlayerMove) return null;
    let bestPivotIndex = -1;
    let bestPivotScore = -Infinity;
    let bestPivotReasoning = '';
    for (let i = 0; i < aiParty.length; i++) {
        const ally = aiParty[i];
        // è·³è¿‡è‡ªå·±å’Œå·²å€’ä¸‹çš„ï¼ˆä¸¥æ ¼æ£€æŸ¥ HP > 0ï¼‰
        if (!ally) continue;
        if (ally === aiPoke) continue;
        if (typeof ally.isAlive !== 'function' || !ally.isAlive()) continue;
        if (!ally.currHp || ally.currHp <= 0) continue;
        // è®¡ç®—é˜Ÿå‹æ‰¿å—ä¼¤å®³
        const simDmg = simulateDamage(playerPoke, ally, worstPlayerMove);
        const allyHpPercent = simDmg.damage / ally.maxHp;
        // è®¡ç®—å±æ€§å…‹åˆ¶
        const eff = getTypeEffectivenessAI(worstMoveType || 'Normal', ally.types || ['Normal']);
        let pivotScore = 0;
        let reasoning = '';
        // [æˆ˜æœ¯ä¿®æ­£] é˜²æ­¢è‡ªæ€å¼æ¢äººï¼šè¢«å…‹åˆ¶ (2x+) ç›´æ¥è´Ÿåˆ†
        if (eff >= 2) {
            pivotScore = -10000; // ç»å¯¹ä¸æ¢ï¼è¿™æ˜¯é€æ­»
            reasoning = `SUICIDE SWITCH BLOCKED: ${ally.cnName || ally.name} is weak to ${worstMoveType}`;
            console.log(`[AI TACTIC] é˜»æ­¢è‡ªæ€æ¢äºº: ${ally.cnName} å¼± ${worstMoveType} (${eff}x)`);
        }
        // å…ç–« = ç»å¯¹æœ€é«˜ä¼˜å…ˆçº§ï¼ˆå¿…é¡»é€‰æ‹©å…ç–«çš„å®å¯æ¢¦ï¼‰
        else if (eff === 0) {
            pivotScore = 99999;
            reasoning = `Perfect Immunity switch to ${ally.cnName || ally.name}`;
        }
        // æŠµæŠ— (0.5x æˆ–æ›´ä½)
        else if (eff <= 0.5) {
            pivotScore = 5000 - allyHpPercent * 1000;
            reasoning = `Resist switch to ${ally.cnName || ally.name}`;
        }
        // æ™®é€šæ•ˆæœä½†ä¼¤å®³å¯æ§ (<40% HP)
        else if (allyHpPercent < 0.4) {
            pivotScore = 2000 - allyHpPercent * 1000;
            reasoning = `Safe switch to ${ally.cnName || ally.name}`;
        }
        // ä¼¤å®³è¾ƒé«˜ä½†æ¯”ç•™åœºå¥½
        else if (allyHpPercent < 0.7 && threatAssessment.willDieNextTurn) {
            pivotScore = 500 - allyHpPercent * 500;
            reasoning = `Sacrifice switch to ${ally.cnName || ally.name}`;
        }
        // [æˆ˜æœ¯ä¿®æ­£] æ™®é€šæ•ˆæœä½†ä¼šè¢«ç§’æ€ï¼Œä¹Ÿä¸æ¢
        else if (allyHpPercent >= 0.9) {
            pivotScore = -5000; // ä¼šè¢«ç§’æ€ï¼Œä¸æ¢
            reasoning = `OHKO SWITCH BLOCKED: ${ally.cnName || ally.name} would be KO'd`;
        }
        // é¢å¤–åŠ åˆ†ï¼šé˜Ÿå‹èƒ½åæ€ç©å®¶
        if (pivotScore > 0) {
            const allyKillMove = findKillMoveForAlly(ally, playerPoke);
            if (allyKillMove) {
                pivotScore += 1000;
                reasoning += ' (can revenge kill)';
            }
        }
        if (pivotScore > bestPivotScore) {
            bestPivotScore = pivotScore;
            bestPivotIndex = i;
            bestPivotReasoning = reasoning;
        }
    }
    // åªæœ‰å½“æ¢äººæ˜æ˜¾æ¯”ç•™åœºå¥½æ—¶æ‰æ¢
    // ç•™åœºç­‰æ­» vs æ¢äººèƒ½æ´»
    if (bestPivotIndex !== -1 && bestPivotScore > 0) {
        return {
            type: AI_ACTION_TYPE.SWITCH,
            index: bestPivotIndex,
            reasoning: bestPivotReasoning
        };
    }
    return null;
}
/**
 * æ£€æŸ¥é˜Ÿå‹æ˜¯å¦èƒ½åæ€
 */
function findKillMoveForAlly(ally, target) {
    if (!ally.moves) return null;
    for (const move of ally.moves) {
        const mergedMove = getMergedMoveData(move);
        const dmgResult = simulateDamage(ally, target, mergedMove);
        if (dmgResult.damage >= target.currHp) {
            return move;
        }
    }
    return null;
}
/**
 * v2.0ï¼šæˆ˜ç•¥æ€§æ¢äººæ£€æŸ¥
 * æ£€æŸ¥æ˜¯å¦å› ä¸ºè´Ÿé¢çŠ¶æ€éœ€è¦æ¢äººï¼ˆè€Œéä»…ä»…æ˜¯ä¿å‘½ï¼‰
 */
function shouldStrategicSwitch(aiPoke) {
    // 1. è¢«å¤§å¹…é™èƒ½åŠ› (æµæ˜Ÿç¾¤/è¿‘èº«æˆ˜åé—ç—‡ æˆ– è¢«å¨å“å¤šæ¬¡)
    const boosts = aiPoke.boosts || {};
    if ((boosts.atk || 0) <= -2 || (boosts.spa || 0) <= -2) {
        return true;
    }
    // 2. é€Ÿåº¦è¢«å¤§å¹…é™ä½ï¼ˆé»é»ç½‘/å²©çŸ³å°é”ï¼‰
    if ((boosts.spe || 0) <= -2) {
        return true;
    }
    // 3. å³å°†ç¡ç€ (å“ˆæ¬ )
    const volatile = aiPoke.volatile || aiPoke.volatileStatus || {};
    if (volatile.yawn || volatile.Yawn) {
        return true;
    }
    // 4. ç­äº¡ä¹‹æ­Œå€’è®¡æ—¶
    if (volatile.perishsong || volatile.PerishSong) {
        return true;
    }
    // 5. è¢«æŒ‘è¡…ä½†ä¸»è¦æ˜¯è¾…åŠ©å‹
    if (volatile.taunt || volatile.Taunt) {
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ”»å‡»æŠ€èƒ½
        const attackMoves = (aiPoke.moves || []).filter(m => {
            const cat = (m.cat || m.category || '').toLowerCase();
            return cat !== 'status';
        });
        if (attackMoves.length <= 1) {
            return true;
        }
    }
    return false;
}
/**
 * v2.0ï¼šè¯»æ¢é¢„åˆ¤
 * å¦‚æœç©å®¶å½“å‰å®å¯æ¢¦å¿…æ­»ä¸”æ¯” AI æ…¢ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
 */
function evaluatePrediction(aiPoke, playerPoke, aiParty) {
    // æ£€æŸ¥ç©å®¶æ˜¯å¦å¿…æ­»
    const playerHp = playerPoke.currHp;
    const playerMaxHp = playerPoke.maxHp;
    const playerHpPercent = playerHp / playerMaxHp;
    // ç©å®¶è¡€é‡å¤ªä½ (<= 20%) ä¸”æ¯” AI æ…¢
    if (playerHpPercent > 0.2) return null;
    const aiFaster = getEffectiveSpeed(aiPoke) > getEffectiveSpeed(playerPoke);
    if (!aiFaster) return null;
    // æ£€æŸ¥ AI æ˜¯å¦èƒ½ç§’æ€å½“å‰ç©å®¶
    let canKillCurrent = false;
    let bestKillMove = null;
    let bestKillDamage = 0;
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        const dmgResult = simulateDamage(aiPoke, playerPoke, mergedMove);
        if (dmgResult.damage >= playerHp) {
            canKillCurrent = true;
            if (dmgResult.damage > bestKillDamage) {
                bestKillDamage = dmgResult.damage;
                bestKillMove = mergedMove;
            }
        }
    }
    if (!canKillCurrent || !bestKillMove) return null;
    // ç©å®¶å¿…æ­»ï¼Œé¢„æµ‹ç©å®¶ä¼šæ¢äºº
    // é¢„è¯»é€»è¾‘ï¼šå¦‚æœæœ€ä½³æŠ€èƒ½æ˜¯å•å±æ€§å…‹åˆ¶æŠ€èƒ½ï¼Œè€ƒè™‘æ¢ä¸€ä¸ªè¦†ç›–é¢æ›´å¹¿çš„æŠ€èƒ½
    const coveragePairs = {
        'Ground': ['Ice', 'Rock', 'Water'],      // åœ°é¢è¢«é£è¡Œå…ç–«ï¼Œç”¨å†°/å²©çŸ³æ‰“
        'Electric': ['Ice', 'Grass', 'Ground'],  // ç”µè¢«åœ°é¢å…ç–«ï¼Œç”¨å†°/è‰æ‰“
        'Fighting': ['Flying', 'Psychic'],       // æ ¼æ–—è¢«å¹½çµå…ç–«ï¼Œç”¨é£è¡Œ/è¶…èƒ½æ‰“
        'Normal': ['Fighting', 'Ghost'],         // ä¸€èˆ¬è¢«å¹½çµå…ç–«
        'Poison': ['Ground', 'Psychic']          // æ¯’è¢«é’¢å…ç–«
    };
    const bestMoveType = bestKillMove.type;
    const coverageTypes = coveragePairs[bestMoveType];
    if (!coverageTypes) return null;
    // æ‰¾ä¸€ä¸ªè¦†ç›–æŠ€èƒ½
    for (const move of aiPoke.moves) {
        const mergedMove = getMergedMoveData(move);
        if (coverageTypes.includes(mergedMove.type) && (mergedMove.basePower || mergedMove.power || 0) >= 60) {
            // 50% æ¦‚ç‡ä½¿ç”¨é¢„è¯»æŠ€èƒ½ï¼ˆä¸è¦å¤ªæ¿€è¿›ï¼‰
            if (Math.random() < 0.5) {
                return {
                    move: move,
                    reasoning: `Prediction: expecting switch, using ${mergedMove.type} coverage`
                };
            }
        }
    }
    return null;
}
/**
 * è¯„ä¼°æˆ˜ç•¥æ€§æŠ€èƒ½ï¼ˆå¼ºåŒ–ã€çŠ¶æ€ã€å›å¤ï¼‰
 */
function evaluateStrategicMoves(aiPoke, playerPoke, threatAssessment) {
    const MC = (typeof MOVE_CONSTANTS !== 'undefined') ? MOVE_CONSTANTS : {};
    const myHpPercent = aiPoke.currHp / aiPoke.maxHp;
    const myHp = aiPoke.currHp;
    const myMaxHp = aiPoke.maxHp;
    // å¦‚æœå¤„äºå±é™©ï¼Œä¸è¦å¼ºåŒ–ï¼Œç›´æ¥æ‰“
    if (threatAssessment.amIInDanger) {
        console.log('[AI] amIInDanger=true, skipping strategic moves');
        return null;
    }
    // å…³é”®ä¿®å¤ï¼šå¦‚æœä¸‹å›åˆå¿…æ­»ä¸”å¯¹æ–¹é€Ÿåº¦å¿«ï¼Œç»å¯¹ä¸è¦ç”¨å¼ºåŒ–æŠ€
    // è¿™æ˜¯æœ€åçš„å®‰å…¨ç½‘ï¼Œé˜²æ­¢ AI è‡ªæ€å¼å‰‘èˆ
    if (threatAssessment.willDieNextTurn && threatAssessment.playerFaster) {
        console.log('[AI] Will die next turn to faster opponent, skipping strategic moves');
        return null;
    }
    // ã€æ–°å¢ã€‘2HKO æ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹èƒ½ä¸¤å›åˆå‡»æ€ä¸”é€Ÿåº¦æ›´å¿«ï¼Œä¸è¦å¼ºåŒ–
    // è¿™é˜²æ­¢äº†"æ»¡è¡€å‰‘èˆè¢«ç§’"çš„è‡ªæ€è¡Œä¸º
    const canBe2HKOd = threatAssessment.maxIncomingDmg * 2 >= myHp;
    if (canBe2HKOd && threatAssessment.playerFaster) {
        console.log(`[AI] Can be 2HKO'd by faster opponent (${threatAssessment.maxIncomingDmg}x2 >= ${myHp}), skipping strategic moves`);
        return null;
    }
    // ã€æ–°å¢ã€‘å±æ€§å…‹åˆ¶æ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹æœ‰ 2 å€å…‹åˆ¶æŠ€èƒ½ä¸”é€Ÿåº¦æ›´å¿«ï¼Œä¸è¦å¼ºåŒ–
    if (threatAssessment.worstMoveType && threatAssessment.playerFaster) {
        const eff = getTypeEffectivenessAI(threatAssessment.worstMoveType, aiPoke.types || ['Normal']);
        if (eff >= 2) {
            console.log(`[AI] Weak to ${threatAssessment.worstMoveType} (${eff}x) and slower, skipping strategic moves`);
            return null;
        }
    }
    let bestStrategicMove = null;
    let bestStrategicScore = 0;
    for (const move of aiPoke.moves) {
        const moveName = move.name || '';
        let score = 0;
        let reasoning = '';
        // === å¼ºåŒ–æŠ€èƒ½ ===
        // ã€ä¿®å¤ã€‘ä½¿ç”¨ moves-data.js çš„ boosts å­—æ®µæ£€æµ‹å¼ºåŒ–æŠ€ï¼Œè€Œä¸æ˜¯ç¡¬ç¼–ç åˆ—è¡¨
        const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
        const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
        const boosts = moveData.boosts || null;
        const target = moveData.target || 'normal';
        // æ£€æµ‹æ˜¯å¦æ˜¯è‡ªèº«å¼ºåŒ–æŠ€èƒ½
        const isSelfBoost = boosts && ['self', 'allySide', 'adjacentAllyOrSelf'].includes(target);
        if (isSelfBoost) {
            // ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ‰€æœ‰æ­£é¢å¼ºåŒ–æ˜¯å¦å·²æ»¡çº§ (+6)
            const currentBoosts = aiPoke.boosts || {};
            let anyBoostMaxed = false;
            for (const stat of Object.keys(boosts)) {
                if (boosts[stat] > 0 && (currentBoosts[stat] || 0) >= 6) {
                    console.log(`[AI STRATEGIC] ${aiPoke.cnName} çš„ ${stat} å·²æ»¡çº§ (+6)ï¼Œç¦æ­¢ä½¿ç”¨ ${moveName}`);
                    anyBoostMaxed = true;
                    break;
                }
            }
            if (!anyBoostMaxed) {
                // æ£€æŸ¥ç›¸å…³èƒ½åŠ›æ˜¯å¦å·²ç»å¼ºåŒ–è¶³å¤Ÿ
                const relevantBoost = aiPoke.spa > aiPoke.atk ? (currentBoosts.spa || 0) : (currentBoosts.atk || 0);
                const defBoost = currentBoosts.def || 0;
                const spdBoost = currentBoosts.spd || 0;
                // æ”»å‡»/ç‰¹æ”»å¼ºåŒ–
                if (boosts.atk > 0 || boosts.spa > 0) {
                    if (myHpPercent > 0.6 && relevantBoost < 2) {
                        score = 150;
                        reasoning = 'Setup opportunity';
                    } else if (myHpPercent > 0.4 && relevantBoost === 0) {
                        score = 80;
                        reasoning = 'Risky setup';
                    }
                }
                // é˜²å¾¡å¼ºåŒ–ï¼ˆå¦‚ Iron Defenseï¼‰
                else if (boosts.def > 0 && defBoost < 2) {
                    if (myHpPercent > 0.7) {
                        score = 80;
                        reasoning = 'Defensive setup';
                    }
                }
                // ç‰¹é˜²å¼ºåŒ–ï¼ˆå¦‚ Amnesiaï¼‰
                else if (boosts.spd > 0 && spdBoost < 2) {
                    if (myHpPercent > 0.7) {
                        score = 80;
                        reasoning = 'Special defense setup';
                    }
                }
            }
        }
        // === å›å¤æŠ€èƒ½ ===
        const healMoves = MC.AI_HEAL_MOVES || ['Recover', 'Roost', 'Soft-Boiled', 'Slack Off', 'Moonlight', 'Morning Sun', 'Synthesis'];
        if (healMoves.includes(moveName)) {
            if (myHpPercent < 0.4) {
                score = 200;
                reasoning = 'Critical heal';
            } else if (myHpPercent < 0.6) {
                score = 100;
                reasoning = 'Preventive heal';
            }
        }
        // === çŠ¶æ€æŠ€èƒ½ ===
        const statusMoves = MC.AI_STATUS_MOVES || ['Thunder Wave', 'Will-O-Wisp', 'Toxic', 'Spore'];
        if (statusMoves.includes(moveName) && !playerPoke.status) {
            // å¯¹æ‰‹æ²¡æœ‰çŠ¶æ€æ‰ç”¨
            const sleepMoves = MC.AI_SLEEP_MOVES || ['Spore', 'Sleep Powder', 'Hypnosis'];
            if (sleepMoves.includes(moveName)) {
                score = 180;
                reasoning = 'Sleep opportunity';
            } else if (moveName === 'Thunder Wave' && getEffectiveSpeed(playerPoke) > getEffectiveSpeed(aiPoke)) {
                score = 120;
                reasoning = 'Speed control';
            } else if (moveName === 'Will-O-Wisp' && playerPoke.atk > playerPoke.spa) {
                score = 110;
                reasoning = 'Physical attacker burn';
            } else if (moveName === 'Toxic') {
                score = 90;
                reasoning = 'Chip damage';
            }
        }
        if (score > bestStrategicScore) {
            bestStrategicScore = score;
            bestStrategicMove = { move, reasoning };
        }
    }
    // åªæœ‰å½“æˆ˜ç•¥åˆ†æ•°è¶³å¤Ÿé«˜æ—¶æ‰é€‰æ‹©æˆ˜ç•¥æŠ€èƒ½
    // å¦åˆ™è®©å¸¸è§„ä¼¤å®³è®¡ç®—æ¥å†³å®š
    if (bestStrategicScore >= 100) {
        return bestStrategicMove;
    }
    return null;
}
/* =============================================================
 *  é€šç”¨è¾…åŠ©å‡½æ•°
 * ============================================================= */
/**
 * å¯¹æŠ€èƒ½æŒ‰è¯„åˆ†æ’åº
 */
function rankMovesByScore(attacker, defender, aiParty = null) {
    if (!attacker?.moves) return [];
    // ã€ä¿®å¤ã€‘Choice é“å…·é”æ‹›æ£€æŸ¥
    // å¦‚æœæŒæœ‰ Choice é“å…·ä¸”å·²ç»é”å®šäº†æŠ€èƒ½ï¼Œåªèƒ½ä½¿ç”¨é‚£ä¸ªæŠ€èƒ½
    // ä½¿ç”¨ items-data.js çš„ isChoiceItem å‡½æ•°
    const item = attacker.item || '';
    const checkIsChoice = typeof window !== 'undefined' && typeof window.isChoiceItem === 'function' 
        ? window.isChoiceItem 
        : (i) => i && (i.includes('Choice') || i.includes('è®²ç©¶'));
    const hasChoiceItem = checkIsChoice(item);
    const lockedMove = attacker.choiceLockedMove;
    if (hasChoiceItem && lockedMove) {
        // æ‰¾åˆ°è¢«é”å®šçš„æŠ€èƒ½
        const locked = attacker.moves.find(m => m.name === lockedMove);
        if (locked) {
            console.log(`[AI CHOICE] ${attacker.name} è¢« ${item} é”å®šåœ¨ ${lockedMove}`);
            const mergedMove = getMergedMoveData(locked);
            return [{
                move: locked,
                score: calcMoveScore(attacker, defender, mergedMove, aiParty)
            }];
        }
    }
    return attacker.moves.map(move => {
        const mergedMove = getMergedMoveData(move);
        return {
            move,
            score: calcMoveScore(attacker, defender, mergedMove, aiParty)
        };
    }).sort((a, b) => b.score - a.score);
}
/**
 * è·å–åˆå¹¶åçš„æŠ€èƒ½æ•°æ®ï¼ˆæœ¬åœ° + MOVES æ•°æ®åº“ï¼‰
 */
function getMergedMoveData(move) {
    const id = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    let merged = {
        ...move,
        type: move.type || 'Normal',
        cat: move.cat || move.category || 'phys'
    };
    if (typeof MOVES !== 'undefined' && MOVES[id]) {
        const staticData = MOVES[id];
        merged = {
            ...staticData,
            ...move,
            type: move.type || staticData.type || 'Normal',
            basePower: move.power ?? staticData.basePower ?? 0,
            power: move.power ?? staticData.basePower ?? 0,
            priority: staticData.priority ?? move.priority ?? 0,
            cat: (move.cat || (staticData.category ? staticData.category.toLowerCase() : 'phys')),
            // ã€ä¿®å¤ã€‘ç¡®ä¿ boosts å’Œ target ä» staticData è·å–ï¼ˆç”¨äºå¼ºåŒ–æŠ€æ£€æµ‹ï¼‰
            boosts: move.boosts || staticData.boosts || null,
            target: move.target || staticData.target || 'normal'
        };
    }
    return merged;
}
/**
 * æ¨¡æ‹Ÿä¼¤å®³è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼Œç”¨äº AI å†³ç­–ï¼‰
 * ä¿æŒçº¯å‡€ï¼šè¯¥æ˜¯0å°±æ˜¯0ï¼Œä¸åœ¨è¿™é‡Œåšç‰¹æ€§é­”æ”¹
 */
function simulateDamage(attacker, defender, move) {
    // ã€å…³é”®ä¿®å¤ã€‘å‰ç½®å…ç–«æ£€æŸ¥ï¼šç¡®ä¿ AI ä¸ä¼šé€‰æ‹©å¯¹ç›®æ ‡æ— æ•ˆçš„æ‹›å¼
    // è¿™æ˜¯æœ€é«˜ä¼˜å…ˆçº§çš„æ£€æŸ¥ï¼Œå¿…é¡»åœ¨ä»»ä½•ä¼¤å®³è®¡ç®—ä¹‹å‰æ‰§è¡Œ
    const moveType = move.type || 'Normal';
    const defenderTypes = defender.types || ['Normal'];
    const preCheckEff = getTypeEffectivenessAI(moveType, defenderTypes, move.name || '');
    if (preCheckEff === 0) {
        return { damage: 0, effectiveness: 0 };
    }
    // å¦‚æœæœ‰å…¨å±€ calcDamage å‡½æ•°ï¼Œä½¿ç”¨å®ƒ
    // ä¼ å…¥ isSimulation: true é˜²æ­¢æ¶ˆè€—æŒ‡ä»¤çŠ¶æ€
    if (typeof calcDamage === 'function') {
        try {
            const result = calcDamage(attacker, defender, move, { isSimulation: true });
            return {
                damage: result.damage || result.singleHitDamage || 0,
                effectiveness: (result.effectiveness !== undefined) ? result.effectiveness : 1
            };
        } catch (e) {
            // å›é€€åˆ°ç®€åŒ–è®¡ç®—
        }
    }
    // ç®€åŒ–ä¼¤å®³è®¡ç®—
    const moveName = move.name || '';
    const category = (move.cat || move.category || '').toLowerCase();
    const isStatus = category === 'status' || move.power === 0 || move.basePower === 0;
    if (isStatus) {
        return { damage: 0, effectiveness: 1 };
    }
    const usesSpecial = category === 'spec' || category === 'special';
    let atkStat = usesSpecial ? (attacker.getStat?.('spa') || attacker.spa) : (attacker.getStat?.('atk') || attacker.atk);
    const defStat = usesSpecial ? (defender.getStat?.('spd') || defender.spd) : (defender.getStat?.('def') || defender.def);
    // çƒ§ä¼¤å‡åŠç‰©æ”»
    if (!usesSpecial && attacker.status === 'brn') {
        atkStat = Math.floor(atkStat * 0.5);
    }
    const eff = getTypeEffectivenessAI(move.type || 'Normal', defender.types || ['Normal'], moveName);
    if (eff === 0) return { damage: 0, effectiveness: 0 };
    const stab = (attacker.types || []).includes(move.type) ? 1.5 : 1.0;
    const power = move.basePower ?? move.power ?? 0;
    const level = attacker.level || 50;
    const baseDamage = ((2 * level / 5 + 2) * power * (atkStat / Math.max(1, defStat)) / 50 + 2) * stab * eff;
    return {
        damage: Math.floor(baseDamage * 0.925),
        effectiveness: eff
    };
}
/**
 * è¯„ä¼°æŠ€èƒ½çš„æˆ˜æœ¯å½±å“åŠ›ï¼ˆè½¯ç¼–ç ï¼Œæ•°æ®é©±åŠ¨ï¼‰
 * ç»¼åˆè€ƒè™‘ï¼šæŠ¤ç›¾ç ´é™¤ã€æ»¡è¡€ä¿å‘½ã€å¨èƒç­‰çº§ç­‰å› ç´ 
 * @returns {object} { totalScore, rawDamage, effectiveness, shieldBreak, threatBonus }
 */
function evaluateMoveImpact(attacker, defender, move) {
    // 1. è·å–åŸºç¡€ä¼¤å®³æ¨¡æ‹Ÿ
    const dmgResult = simulateDamage(attacker, defender, move);
    let baseScore = dmgResult.damage;
    const eff = dmgResult.effectiveness;
    // å…ç–«ç›´æ¥è¿”å›
    if (eff === 0) {
        return { totalScore: -9999, rawDamage: 0, effectiveness: 0 };
    }
    // è·å–æŠ€èƒ½åˆ†ç±»
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    const category = (fullMoveData.category || move.cat || '').toLowerCase();
    const isAttackMove = category !== 'status' && (move.power > 0 || move.basePower > 0);
    // 2. ç‰¹æ€§è¯„ä¼°ï¼ˆè½¯ç¼–ç ï¼Œä»é…ç½®è¯»å–ï¼‰
    const defAbility = defender.ability || '';
    const trait = AI_ABILITY_TRAITS[defAbility];
    let shieldBreak = false;
    if (trait && isAttackMove) {
        // === Case A: æ¶ˆè€—å‹æŠ¤ç›¾ï¼ˆç”»çš®ã€å†°ç Œé¹…ï¼‰===
        if (trait.type === 'consumable_shield') {
            const bustedFlag = trait.bustedFlag || 'shieldBusted';
            const isShieldActive = !defender[bustedFlag];
            // æ£€æŸ¥æ¡ä»¶ï¼ˆå¦‚å†°ç Œé¹…åªé˜²ç‰©ç†ï¼‰
            let conditionMet = true;
            if (trait.condition === 'physical') {
                conditionMet = category === 'physical';
            } else if (trait.condition === 'special') {
                conditionMet = category === 'special';
            }
            if (isShieldActive && conditionMet && dmgResult.damage === 0) {
                // æŠ¤ç›¾æŒ¡ä½äº†æ”»å‡»ï¼Œä½†ç ´ç›¾æœ‰æˆ˜æœ¯ä»·å€¼
                baseScore += trait.breakValue;
                shieldBreak = true;
            }
        }
        // === Case B: æ»¡è¡€å‡ä¼¤ï¼ˆå¤šé‡é³ç‰‡ï¼‰===
        else if (trait.type === 'damage_reduction' && trait.condition === 'full_hp') {
            if (defender.currHp === defender.maxHp && dmgResult.damage > 0) {
                // æ‰“ç ´æ»¡è¡€çŠ¶æ€æœ‰ä»·å€¼
                baseScore += trait.breakValue;
            }
        }
        // === Case C: æ»¡è¡€ä¿å‘½ï¼ˆç»“å®ï¼‰===
        else if (trait.type === 'endure_lethal' && trait.condition === 'full_hp') {
            if (defender.currHp === defender.maxHp && dmgResult.damage > 0) {
                baseScore += trait.breakValue;
            }
        }
    }
    // 3. é“å…·è¯„ä¼°ï¼ˆæ°”åŠ¿æŠ«å¸¦ï¼‰
    const defItem = (defender.item || '').toLowerCase().replace(/[^a-z]/g, '');
    if (defItem === 'focussash' && defender.currHp === defender.maxHp && dmgResult.damage > 0) {
        baseScore += 150; // æ‰“ç ´æ°”è…°çš„æ»¡è¡€çŠ¶æ€
    }
    // 4. å¨èƒç­‰çº§è¯„ä¼°ï¼ˆå¯¹æ‰‹å¼ºåŒ–ç¨‹åº¦ï¼‰
    let threatLevel = 0;
    const defBoosts = defender.boosts || {};
    threatLevel += Math.max(0, (defBoosts.atk || 0) - 1) * 100;
    threatLevel += Math.max(0, (defBoosts.spa || 0) - 1) * 100;
    if ((defBoosts.spe || 0) > 0) threatLevel *= 1.5;
    let threatBonus = 0;
    if (threatLevel > 100) {
        if (isAttackMove) {
            // æ”»å‡»æŠ€èƒ½åŠ åˆ†
            threatBonus = threatLevel;
            // å…‹åˆ¶æŠ€èƒ½é¢å¤–åŠ åˆ†
            if (eff >= 2) threatBonus += threatLevel;
        } else {
            // è¾…åŠ©æŠ€èƒ½ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºåå¼ºåŒ–æŠ€èƒ½
            const isCounterMove = AI_COUNTER_MOVES.includes(move.name);
            if (isCounterMove) {
                threatBonus = threatLevel * 2; // æ•‘å‘½ç¨»è‰
            } else {
                threatBonus = -Math.min(1000, threatLevel * 2); // å¤§å¹…æƒ©ç½š
            }
        }
        baseScore += threatBonus;
    }
    return {
        totalScore: baseScore,
        rawDamage: dmgResult.damage,
        effectiveness: eff,
        shieldBreak,
        threatBonus
    };
}
/**
 * è·å–æœ‰æ•ˆé€Ÿåº¦ï¼ˆè€ƒè™‘éº»ç—¹ã€é¡ºé£ç­‰ï¼‰
 */
function getEffectiveSpeed(pokemon) {
    let spe = pokemon.getStat?.('spe') || pokemon.spe || 100;
    // éº»ç—¹å‡é€Ÿ
    if (pokemon.status === 'par') {
        spe = Math.floor(spe * 0.5);
    }
    return spe;
}
/**
 * è·å–å±æ€§å…‹åˆ¶ï¼ˆä½¿ç”¨å†…ç½®è¡¨ï¼Œé¿å…å¾ªç¯è°ƒç”¨ï¼‰
 */
function getTypeEffectivenessAI(atkType, defTypes, moveName = '') {
    // ç›´æ¥ä½¿ç”¨å†…ç½®è¡¨ï¼Œä¸è°ƒç”¨ window.getTypeEffectiveness é¿å…å¾ªç¯
    const TYPE_CHART = {
        'Normal':   { weak: [],                          resist: ['Rock', 'Steel'],      immune: ['Ghost'] },
        'Fire':     { weak: ['Grass', 'Ice', 'Bug', 'Steel'], resist: ['Fire', 'Water', 'Rock', 'Dragon'], immune: [] },
        'Water':    { weak: ['Fire', 'Ground', 'Rock'],  resist: ['Water', 'Grass', 'Dragon'], immune: [] },
        'Electric': { weak: ['Water', 'Flying'],         resist: ['Electric', 'Grass', 'Dragon'], immune: ['Ground'] },
        'Grass':    { weak: ['Water', 'Ground', 'Rock'], resist: ['Fire', 'Grass', 'Poison', 'Flying', 'Bug', 'Dragon', 'Steel'], immune: [] },
        'Ice':      { weak: ['Grass', 'Ground', 'Flying', 'Dragon'], resist: ['Fire', 'Water', 'Ice', 'Steel'], immune: [] },
        'Fighting': { weak: ['Normal', 'Ice', 'Rock', 'Dark', 'Steel'], resist: ['Poison', 'Flying', 'Psychic', 'Bug', 'Fairy'], immune: ['Ghost'] },
        'Poison':   { weak: ['Grass', 'Fairy'],          resist: ['Poison', 'Ground', 'Rock', 'Ghost'], immune: ['Steel'] },
        'Ground':   { weak: ['Fire', 'Electric', 'Poison', 'Rock', 'Steel'], resist: ['Grass', 'Bug'], immune: ['Flying'] },
        'Flying':   { weak: ['Grass', 'Fighting', 'Bug'], resist: ['Electric', 'Rock', 'Steel'], immune: [] },
        'Psychic':  { weak: ['Fighting', 'Poison'],      resist: ['Psychic', 'Steel'],   immune: ['Dark'] },
        'Bug':      { weak: ['Grass', 'Psychic', 'Dark'], resist: ['Fire', 'Fighting', 'Poison', 'Flying', 'Ghost', 'Steel', 'Fairy'], immune: [] },
        'Rock':     { weak: ['Fire', 'Ice', 'Flying', 'Bug'], resist: ['Fighting', 'Ground', 'Steel'], immune: [] },
        'Ghost':    { weak: ['Psychic', 'Ghost'],        resist: ['Dark'],               immune: ['Normal'] },
        'Dragon':   { weak: ['Dragon'],                  resist: ['Steel'],              immune: ['Fairy'] },
        'Dark':     { weak: ['Psychic', 'Ghost'],        resist: ['Fighting', 'Dark', 'Fairy'], immune: [] },
        'Steel':    { weak: ['Ice', 'Rock', 'Fairy'],    resist: ['Fire', 'Water', 'Electric', 'Steel'], immune: [] },
        'Fairy':    { weak: ['Fighting', 'Dark', 'Dragon'], resist: ['Fire', 'Poison', 'Steel'], immune: [] },
    };
    const chart = TYPE_CHART[atkType];
    if (!chart) return 1;
    let multiplier = 1;
    for (const defType of defTypes) {
        if (chart.immune.includes(defType)) return 0;
        if (chart.weak.includes(defType)) multiplier *= 2;
        if (chart.resist.includes(defType)) multiplier *= 0.5;
    }
    return multiplier;
}
/**
 * æŠ€èƒ½è¯„åˆ†ï¼ˆç”¨äºæ’åºï¼‰
 * @param {Pokemon} attacker - æ”»å‡»æ–¹
 * @param {Pokemon} defender - é˜²å¾¡æ–¹
 * @param {Object} move - æŠ€èƒ½æ•°æ®
 * @param {Pokemon[]} aiParty - AI é˜Ÿä¼ï¼ˆç”¨äºæŠ˜è¿”æŠ€èƒ½æ£€æŸ¥ï¼‰
 */
function calcMoveScore(attacker, defender, move, aiParty = null) {
    if (!move) return -9999;
    const moveName = move.name || '';
    // =========================================================
    // 0. Z-Move / Max Move å…¨åœºå”¯ä¸€é™åˆ¶ (Once Per Battle)
    // è¿™äº›è¶…å¼ºæŠ€èƒ½åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œç”¨è¿‡å°±æ°¸ä¹…å°å°
    // =========================================================
    // è·å–æŠ€èƒ½æ•°æ®åˆ¤æ–­æ˜¯å¦ä¸º Z/Max æ‹›å¼
    const moveId = (moveName || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æµ‹ Z æ‹›å¼ï¼šisZ å­—æ®µ æˆ– isNonstandard === 'Past' ä¸” PP === 1
    const isZMove = moveData.isZ || 
        (moveData.pp === 1 && moveData.basePower >= 100 && moveData.isNonstandard === 'Past');
    // æ£€æµ‹æå·¨æ‹›å¼ï¼šisMax å­—æ®µ æˆ– åç§°åŒ…å« Max/G-Max
    const isMaxMove = moveData.isMax || 
        moveName.startsWith('Max ') || moveName.startsWith('G-Max ');
    // å¦‚æœæ˜¯ Z æ‹›å¼ä¸” AI å·²ç»ç”¨è¿‡ï¼Œæ°¸ä¹…å°å°
    if (isZMove && typeof battle !== 'undefined' && battle.enemyZUsed) {
        console.log(`[AI BAN] Z-Move "${moveName}" å·²ä½¿ç”¨è¿‡ï¼Œç¦æ­¢å†æ¬¡ä½¿ç”¨`);
        return -99999;
    }
    // ã€ä¿®å¤ã€‘æå·¨æ‹›å¼çš„ç¦ç”¨é€»è¾‘ï¼š
    // - å¦‚æœå½“å‰å®å¯æ¢¦å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œå¯ä»¥ä½¿ç”¨æå·¨æ‹›å¼
    // - å¦‚æœå½“å‰å®å¯æ¢¦ä¸åœ¨æå·¨åŒ–çŠ¶æ€ï¼Œä¸” AI å·²ç»ç”¨è¿‡æå·¨åŒ–ï¼Œç¦æ­¢ä½¿ç”¨æå·¨æ‹›å¼
    // ï¼ˆå› ä¸ºæå·¨åŒ–ç»“æŸåæ‹›å¼ä¼šæ¢å¤ä¸ºæ™®é€šæ‹›å¼ï¼Œä¸åº”è¯¥å‡ºç°æå·¨æ‹›å¼ï¼‰
    if (isMaxMove && typeof battle !== 'undefined') {
        // å¦‚æœå½“å‰å®å¯æ¢¦ä¸åœ¨æå·¨åŒ–çŠ¶æ€ï¼Œæå·¨æ‹›å¼ä¸åº”è¯¥å‡ºç°åœ¨æ‹›å¼åˆ—è¡¨ä¸­
        if (!attacker.isDynamaxed) {
            console.log(`[AI BAN] Max Move "${moveName}" å½“å‰æœªæå·¨åŒ–ï¼Œç¦æ­¢ä½¿ç”¨`);
            return -99999;
        }
        // æå·¨åŒ–çŠ¶æ€ä¸‹å¯ä»¥æ­£å¸¸ä½¿ç”¨æå·¨æ‹›å¼ï¼Œä¸ç¦æ­¢
    }
    // =========================================================
    // 1. å¤æ‚æŠ€èƒ½é»‘åå• (Complex Move Blacklist)
    // å¼•æ“æœªå®ç°çš„å¤æ‚æœºåˆ¶æŠ€èƒ½ï¼Œç¦æ­¢ AI ä½¿ç”¨
    // =========================================================
    const ENGINE_BANS = [
        // å»¶è¿Ÿä¼¤å®³æŠ€èƒ½ï¼ˆéœ€è¦å…¨å±€é˜Ÿåˆ—ï¼‰
        'Future Sight', 'Doom Desire',
        // åŒæ‰“ä¸“ç”¨æŠ€èƒ½
        'Ally Switch', 'Helping Hand', 'Follow Me', 'Rage Powder',
        'Wide Guard', 'Quick Guard', 'After You', 'Instruct', 'Quash',
        // é“å…·äº¤æ¢/ç§»é™¤ç±»ï¼ˆé“å…·ç³»ç»Ÿæœªå®Œå–„ï¼‰
        'Switcheroo', 'Trick', 'Bestow', 'Fling', 'Thief', 'Covet',
        // ç‰¹æ€§äº¤æ¢ç±»ï¼ˆè¿‡äºå¤æ‚ï¼‰
        'Skill Swap', 'Entrainment', 'Role Play', 'Doodle'
    ];
    if (ENGINE_BANS.includes(moveName)) {
        return -99999; // æ°¸è¿œä¸é€‰
    }
    // =========================================================
    // 2. æ¡ä»¶å‹é™åˆ¶æŠ€èƒ½æ£€æŸ¥ (Context-based Restrictions)
    // ä½¿ç”¨ moves-data.js çš„æ•°æ®é©±åŠ¨åˆ¤æ–­
    // =========================================================
    // ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ move å‚æ•°ï¼ˆå·²ç»æ˜¯ getMergedMoveData å¤„ç†è¿‡çš„ï¼‰
    // åªæœ‰å½“ move æ²¡æœ‰ boosts/target æ—¶æ‰å›é€€åˆ° moveData
    const fullMoveData = {
        ...moveData,
        ...move,
        boosts: move.boosts || moveData.boosts || null,
        target: move.target || moveData.target || 'normal'
    };
    const moveFlags = fullMoveData.flags || {};
    // =========================================================
    // ConditionChecker: æ¡ä»¶é™åˆ¶æ£€æŸ¥å™¨
    // æ£€æŸ¥æ‹›å¼åœ¨å½“å‰ç¯å¢ƒä¸‹æ˜¯å¦åˆæ³•/ç†æ™º
    // =========================================================
    // [ç±»å‹1: é¦–å›åˆé™å®šç»„] - Fake Out, First Impression, Mat Block
    const firstTurnOnlyMoves = ['Fake Out', 'First Impression', 'Mat Block'];
    if (firstTurnOnlyMoves.includes(moveName) && (attacker.turnsOnField || 0) > 0) {
        console.log(`[AI BAN] ${moveName} åªèƒ½åœ¨é¦–å›åˆä½¿ç”¨ï¼Œå½“å‰ turnsOnField=${attacker.turnsOnField}`);
        return -9999; // éé¦–å›åˆï¼Œå¿…å®šå¤±è´¥
    }
    // [ç±»å‹2: è¿å‘æƒ©ç½šç»„] - Protect, Detect, King's Shield ç­‰
    // è¿ç»­ä½¿ç”¨å®ˆä½ç±»æŠ€èƒ½æˆåŠŸç‡å¤§å¹…ä¸‹é™
    const protectMoves = ['Protect', 'Detect', 'Spiky Shield', "King's Shield", 'Baneful Bunker', 
                          'Obstruct', 'Silk Trap', 'Burning Bulwark', 'Endure', 'Wide Guard', 'Quick Guard'];
    if (protectMoves.includes(moveName)) {
        const lastMove = attacker.lastMoveUsed || '';
        if (protectMoves.includes(lastMove)) {
            console.log(`[AI BAN] ${moveName} è¿ç»­ä½¿ç”¨ï¼ŒæˆåŠŸç‡æä½ï¼Œç¦æ­¢é€‰æ‹©`);
            return -8000; // è¿ç»­ä½¿ç”¨å®ˆä½ç±»æŠ€èƒ½ï¼Œæå¤§é™ä½æƒé‡
        }
    }
    // [ç±»å‹3: å…ˆåˆ¶åšå¼ˆç»„] - Sucker Punch
    // å¦‚æœå¯¹æ‰‹ä¸Šå›åˆä½¿ç”¨å˜åŒ–æŠ€ï¼Œçªè¢­å¤§æ¦‚ç‡ä¼šå¤±è´¥
    if (moveName === 'Sucker Punch') {
        const defenderLastMove = defender.lastMoveUsed || '';
        const defenderLastMoveId = defenderLastMove.toLowerCase().replace(/[^a-z0-9]/g, '');
        const defenderLastMoveData = (typeof MOVES !== 'undefined' && MOVES[defenderLastMoveId]) ? MOVES[defenderLastMoveId] : {};
        const lastMoveCategory = (defenderLastMoveData.category || '').toLowerCase();
        // å¦‚æœå¯¹æ‰‹ä¸Šå›åˆç”¨çš„æ˜¯å˜åŒ–æŠ€ï¼Œé™ä½çªè¢­ä¼˜å…ˆçº§
        if (lastMoveCategory === 'status') {
            console.log(`[AI WARN] å¯¹æ‰‹ä¸Šå›åˆä½¿ç”¨å˜åŒ–æŠ€ ${defenderLastMove}ï¼Œçªè¢­å¯èƒ½å¤±è´¥`);
            return -500; // é™ä½ä¼˜å…ˆçº§ä½†ä¸å®Œå…¨ç¦æ­¢
        }
    }
    // [ç±»å‹4: çŠ¶æ€å†—ä½™ç»„] - çŠ¶æ€æŠ€å¯¹å·²æœ‰çŠ¶æ€/å…ç–«å±æ€§æ— æ•ˆ
    // 4a. çŠ¶æ€å¼‚å¸¸æŠ€å¯¹å·²æœ‰çŠ¶æ€çš„ç›®æ ‡æ— æ•ˆ
    const statusMoves = {
        'Thunder Wave': { immuneTypes: ['Ground', 'Electric'], status: 'par' },
        'Toxic': { immuneTypes: ['Steel', 'Poison'], status: 'tox' },
        'Poison Powder': { immuneTypes: ['Steel', 'Poison', 'Grass'], status: 'psn' },
        'Poison Gas': { immuneTypes: ['Steel', 'Poison'], status: 'psn' },
        'Will-O-Wisp': { immuneTypes: ['Fire'], status: 'brn' },
        'Hypnosis': { immuneTypes: [], status: 'slp' },
        'Sleep Powder': { immuneTypes: ['Grass'], status: 'slp' },
        'Spore': { immuneTypes: ['Grass'], status: 'slp' },
        'Stun Spore': { immuneTypes: ['Grass', 'Electric'], status: 'par' },
        'Glare': { immuneTypes: [], status: 'par' }
    };
    if (statusMoves[moveName]) {
        const { immuneTypes, status } = statusMoves[moveName];
        const defenderTypes = defender.types || [];
        // æ£€æŸ¥å±æ€§å…ç–«
        const isImmune = immuneTypes.some(t => defenderTypes.includes(t));
        if (isImmune) {
            console.log(`[AI BAN] ${moveName} å¯¹ ${defenderTypes.join('/')} å±æ€§æ— æ•ˆ`);
            return -9999;
        }
        // æ£€æŸ¥å·²æœ‰çŠ¶æ€
        if (defender.status) {
            console.log(`[AI BAN] ${moveName} å¯¹å·²æœ‰çŠ¶æ€ ${defender.status} çš„ç›®æ ‡æ— æ•ˆ`);
            return -9999;
        }
    }
    // 4b. å¤©æ°”æŠ€å¯¹å·²å­˜åœ¨çš„ç›¸åŒå¤©æ°”æ— æ•ˆ
    const weatherMoves = {
        'Rain Dance': 'RainDance',
        'Sunny Day': 'SunnyDay', 
        'Sandstorm': 'Sandstorm',
        'Hail': 'Hail',
        'Snowscape': 'Snow'
    };
    if (weatherMoves[moveName] && typeof battle !== 'undefined' && battle.field) {
        const currentWeather = battle.field.weather || '';
        if (currentWeather && currentWeather.toLowerCase().includes(weatherMoves[moveName].toLowerCase())) {
            console.log(`[AI BAN] ${moveName} å¤©æ°”å·²å­˜åœ¨ï¼Œç¦æ­¢ä½¿ç”¨`);
            return -9999;
        }
    }
    // [ç±»å‹5: HPä¾èµ–ç»„] - Explosion, Self-Destruct, Final Gambit, Destiny Bond
    const selfKOMoves = ['Explosion', 'Self-Destruct', 'Final Gambit', 'Memento', 'Healing Wish', 'Lunar Dance'];
    const hpPercentCheck = attacker.currHp / attacker.maxHp;
    if (selfKOMoves.includes(moveName)) {
        // Final Gambit ä¼¤å®³ç­‰äºè‡ªèº«å½“å‰HPï¼Œä½HPæ—¶æ¯«æ— æ„ä¹‰
        if (moveName === 'Final Gambit' && attacker.currHp < defender.currHp * 0.3) {
            console.log(`[AI BAN] Final Gambit HPè¿‡ä½ (${attacker.currHp})ï¼Œä¼¤å®³ä¸è¶³`);
            return -9000;
        }
        // å¤§çˆ†ç‚¸/è‡ªçˆ†ï¼šæ»¡è¡€ä¸”é˜Ÿä¼è¿˜æœ‰å…¶ä»–æˆå‘˜æ—¶ä¸è¦é€
        if ((moveName === 'Explosion' || moveName === 'Self-Destruct') && hpPercentCheck > 0.7) {
            const aliveCount = (aiParty || []).filter(p => p && p.currHp > 0).length;
            if (aliveCount > 1) {
                console.log(`[AI WARN] ${moveName} æ»¡è¡€ä¸”é˜Ÿä¼è¿˜æœ‰ ${aliveCount} åªï¼Œé™ä½ä¼˜å…ˆçº§`);
                return -2000; // å¤§å¹…é™ä½ä½†ä¸å®Œå…¨ç¦æ­¢
            }
        }
        // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰æ¹¿æ°”ç‰¹æ€§ï¼ˆå…ç–«çˆ†ç‚¸ï¼‰
        const defenderAbility = (defender.ability || '').toLowerCase();
        if ((moveName === 'Explosion' || moveName === 'Self-Destruct') && defenderAbility === 'damp') {
            console.log(`[AI BAN] å¯¹æ‰‹æœ‰æ¹¿æ°”ç‰¹æ€§ï¼Œ${moveName} æ— æ•ˆ`);
            return -9999;
        }
    }
    // Destiny Bond è¿ç»­ä½¿ç”¨ä¼šå¤±è´¥
    if (moveName === 'Destiny Bond' && attacker.lastMoveUsed === 'Destiny Bond') {
        console.log(`[AI BAN] Destiny Bond è¿ç»­ä½¿ç”¨å¿…å®šå¤±è´¥`);
        return -9999;
    }
    // ç¡çœ çŠ¶æ€æ‰èƒ½ç”¨çš„æŠ€èƒ½
    if (moveFlags.nosleeptalk === undefined && (moveName === 'Sleep Talk' || moveName === 'Snore')) {
        if (attacker.status !== 'slp') {
            return -5000;
        }
    }
    // éœ€è¦å¯¹æ‰‹ç¡çœ çš„æŠ€èƒ½
    if (fullMoveData.sleepUsable || moveName === 'Dream Eater') {
        if (defender.status !== 'slp') {
            return -5000;
        }
    }
    // =========================================================
    // 3. æ ¸å¿ƒæˆ˜æœ¯å¼ºåˆ¶æ‰§è¡Œ (Force Setup Logic)
    // ä½¿ç”¨ moves-data.js æ•°æ®é©±åŠ¨åˆ¤æ–­æŠ€èƒ½ç±»å‹
    // =========================================================
    const itemName = (attacker.item || '').toLowerCase().replace(/[^a-z]/g, '');
    const hasFocusSash = itemName === 'focussash';
    const hpPercent = attacker.currHp / attacker.maxHp;
    // [A] åœºåœ°æŠ€èƒ½æ£€æµ‹ (pseudoWeather ç±»)
    // Trick Room, Magic Room, Wonder Room, Gravity ç­‰
    if (fullMoveData.pseudoWeather) {
        const fieldType = fullMoveData.pseudoWeather;
        // æ£€æŸ¥åœºåœ°æ˜¯å¦å·²å¼€å¯
        if (typeof battle !== 'undefined' && battle.field && battle.field[fieldType] > 1) {
            console.log(`[AI TACTIC] ${fieldType} å·²å¼€å¯ï¼Œä¸å†ä½¿ç”¨`);
            return -9999;
        }
        // Trick Room ç‰¹æ®Šå¤„ç†ï¼šç©ºé—´é˜Ÿæ ¸å¿ƒ
        if (fieldType === 'trickroom' && (hpPercent >= 0.4 || hasFocusSash)) {
            console.log(`[AI TACTIC] ${attacker.cnName} å¿…é¡»å¼€ Trick Roomï¼`);
            return 50000;
        }
        // å…¶ä»–åœºåœ°æŠ€èƒ½
        if (hpPercent >= 0.5) {
            return 25000;
        }
    }
    // [B] åœºåœ°æŠ€èƒ½ (sideCondition ç±»)
    // åˆ†ä¸¤ç±»ï¼šå·±æ–¹åœºåœ°ï¼ˆTailwind, Reflect, Light Screen, Aurora Veilï¼‰å’Œæ•Œæ–¹åœºåœ°ï¼ˆé’‰å­ç±»ï¼‰
    if (fullMoveData.sideCondition) {
        const sideType = fullMoveData.sideCondition;
        const target = fullMoveData.target || 'foeSide';
        const isAiAttacker = typeof battle !== 'undefined' && attacker !== battle.getPlayer?.();
        // æ ¹æ® target å­—æ®µåˆ¤æ–­ä½œç”¨äºå“ªä¸€æ–¹åœºåœ°
        let targetSide = null;
        if (target === 'foeSide') {
            // é’‰å­ç±»ï¼šAI æ’’é’‰å­ä½œç”¨äºç©å®¶åœºåœ°
            targetSide = isAiAttacker ? battle.playerSide : battle.enemySide;
        } else if (target === 'allySide' || target === 'self') {
            // å·±æ–¹å¢ç›Šï¼šAI ä½¿ç”¨ä½œç”¨äºå·±æ–¹åœºåœ°
            targetSide = isAiAttacker ? battle.enemySide : battle.playerSide;
        }
        // === é’‰å­ç±»æŠ€èƒ½ï¼šæ£€æŸ¥æ˜¯å¦å·²æ»¡å±‚ ===
        if (['stealthrock', 'spikes', 'toxicspikes', 'stickyweb'].includes(sideType) && targetSide) {
            // æ£€æŸ¥å„ç±»é’‰å­çš„ä¸Šé™
            if (sideType === 'spikes' && (targetSide.spikes || 0) >= 3) {
                console.log(`[AI BAN] Spikes å·²æ»¡3å±‚ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'toxicspikes' && (targetSide.toxicspikes || targetSide.toxicSpikes || 0) >= 2) {
                console.log(`[AI BAN] Toxic Spikes å·²æ»¡2å±‚ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'stealthrock' && targetSide.stealthRock) {
                console.log(`[AI BAN] Stealth Rock å·²å­˜åœ¨ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            if (sideType === 'stickyweb' && targetSide.stickyWeb) {
                console.log(`[AI BAN] Sticky Web å·²å­˜åœ¨ï¼Œç¦æ­¢ä½¿ç”¨`);
                return -9999;
            }
            // === å…³é”®ä¿®å¤ï¼šå¯¹æ‰‹æ­£åœ¨å¼ºåŒ–æ—¶ï¼Œé™ä½æ’’é’‰å­çš„ä¼˜å…ˆçº§ ===
            // å¦‚æœå¯¹æ‰‹æ”»å‡»ç­‰çº§ >= 2ï¼Œæ’’é’‰å­å°±æ˜¯é€æ­»è¡Œä¸º
            const defenderBoosts = defender.boosts || {};
            const defenderAtkBoost = defenderBoosts.atk || 0;
            const defenderSpaBoost = defenderBoosts.spa || 0;
            if (defenderAtkBoost >= 2 || defenderSpaBoost >= 2) {
                console.log(`[AI TACTIC] å¯¹æ‰‹å·²å¼ºåŒ– (atk:${defenderAtkBoost}, spa:${defenderSpaBoost})ï¼Œæ”¾å¼ƒæ’’é’‰å­`);
                return -500; // å¤§å¹…é™ä½ä¼˜å…ˆçº§ï¼Œè½¬è€Œæ”»å‡»
            }
            // é¦–å‘æ’’é’‰ï¼šåªæœ‰è¡€é‡å¥åº·ä¸”å¯¹æ‰‹æ²¡å¼ºåŒ–æ—¶æ‰æ’’
            if (hpPercent >= 0.9) {
                console.log(`[AI TACTIC] ${attacker.cnName} é¦–å‘æ’’é’‰: ${moveName}`);
                return 2500 + Math.random() * 500;
            }
            // éé¦–å‘ä¸æ’’é’‰å­
            return -100;
        }
        // === å·±æ–¹å¢ç›Šç±»æŠ€èƒ½ ===
        if (targetSide) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆå·±æ–¹å¢ç›Šç±»ï¼‰
            const keyMap = {
                'tailwind': 'tailwind',
                'reflect': 'reflect', 
                'lightscreen': 'lightScreen',
                'auroraveil': 'auroraVeil'
            };
            const key = keyMap[sideType] || sideType;
            if (targetSide[key] > 0) {
                return -500; // å·²å­˜åœ¨ï¼Œä¸é‡å¤ä½¿ç”¨
            }
        }
        // é¡ºé£ï¼šé«˜ä¼˜å…ˆçº§
        if (sideType === 'tailwind' && hpPercent >= 0.5) {
            return 40000;
        }
        // åŒå¢™/æå…‰å¹•ï¼šé«˜ä¼˜å…ˆçº§
        if (['reflect', 'lightscreen', 'auroraveil'].includes(sideType) && hpPercent >= 0.6) {
            console.log(`[AI TACTIC] ${attacker.cnName} å¼€å¯é˜²æŠ¤å¢™: ${moveName}`);
            return 15000;
        }
    }
    // [C] å¤©æ°”æŠ€èƒ½æ£€æµ‹ (weather ç±»)
    if (fullMoveData.weather) {
        if (hpPercent >= 0.5) {
            return 30000;
        }
    }
    // [D] å‚¬çœ æŠ€èƒ½æ£€æµ‹ (status: 'slp')
    if (fullMoveData.status === 'slp') {
        if (!defender.status && (!defender.volatile || !defender.volatile.yawn)) {
            // æ ¹æ®å‘½ä¸­ç‡ç»™åˆ†ï¼š100% å‘½ä¸­çš„æ›´é«˜åˆ†
            const accuracy = fullMoveData.accuracy === true ? 100 : (fullMoveData.accuracy || 75);
            const sleepBonus = accuracy >= 100 ? 8000 : (accuracy >= 75 ? 6000 : 4000);
            console.log(`[AI TACTIC] ${attacker.cnName} å°è¯•å‚¬çœ : ${moveName} (å‘½ä¸­ç‡: ${accuracy})`);
            return sleepBonus;
        } else {
            return -500;
        }
    }
    // [E] å¼ºåŒ–æŠ€èƒ½æ£€æµ‹ (boosts ä¸” target: 'self')
    const isSelfBoost = fullMoveData.boosts && 
        ['self', 'allySide', 'adjacentAllyOrSelf'].includes(fullMoveData.target);
    // ã€è°ƒè¯•ã€‘è¾“å‡ºå¼ºåŒ–æŠ€æ£€æµ‹ä¿¡æ¯
    if (moveName === 'Iron Defense' || moveName === 'Swords Dance' || moveName === 'Calm Mind') {
        console.log(`[AI BOOST DEBUG] ${moveName}: boosts=`, fullMoveData.boosts, 'target=', fullMoveData.target, 'isSelfBoost=', isSelfBoost);
        console.log(`[AI BOOST DEBUG] attacker.boosts=`, attacker.boosts);
    }
    if (isSelfBoost) {
        const boosts = fullMoveData.boosts;
        // æ£€æŸ¥ä¸»è¦å¼ºåŒ–çš„èƒ½åŠ›
        const atkBoost = boosts.atk || 0;
        const spaBoost = boosts.spa || 0;
        const speBoost = boosts.spe || 0;
        const defBoost = boosts.def || 0;
        const spdBoost = boosts.spd || 0;
        // ã€ä¿®å¤ã€‘æ£€æŸ¥æ‰€æœ‰æ­£é¢å¼ºåŒ–æ˜¯å¦å·²æ»¡çº§ (+6)
        // å¦‚æœè¯¥æŠ€èƒ½å¼ºåŒ–çš„èƒ½åŠ›å·²ç»æ»¡çº§ï¼Œç›´æ¥è¿”å›è´Ÿåˆ†
        const currentBoosts = attacker.boosts || {};
        for (const stat of Object.keys(boosts)) {
            const boostValue = boosts[stat];
            if (boostValue > 0) { // åªæ£€æŸ¥æ­£é¢å¼ºåŒ–
                const currentValue = currentBoosts[stat] || 0;
                console.log(`[AI BOOST CHECK] ${moveName}: ${stat} boost=${boostValue}, current=${currentValue}`);
                if (currentValue >= 6) {
                    console.log(`[AI TACTIC] ${attacker.cnName} çš„ ${stat} å·²æ»¡çº§ (+6)ï¼Œç¦æ­¢ä½¿ç”¨ ${moveName}`);
                    return -9999; // æ»¡çº§åç»å¯¹ä¸èƒ½å†ç”¨
                }
            }
        }
        // ã€å…³é”®ä¿®å¤ã€‘å¨èƒæ£€æŸ¥ï¼šå¦‚æœå¯¹æ–¹é€Ÿåº¦æ›´å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½ï¼Œä¸è¦å¼ºåŒ–
        const mySpeed = getEffectiveSpeed(attacker);
        const oppSpeed = getEffectiveSpeed(defender);
        const playerFaster = oppSpeed > mySpeed;
        if (playerFaster) {
            // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æœ‰å…‹åˆ¶æŠ€èƒ½
            let hasSuper = false;
            for (const pMove of (defender.moves || [])) {
                const pMoveType = pMove.type || 'Normal';
                const eff = getTypeEffectivenessAI(pMoveType, attacker.types || ['Normal']);
                if (eff >= 2) {
                    hasSuper = true;
                    break;
                }
            }
            // å¦‚æœå¯¹æ–¹é€Ÿåº¦å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½ï¼Œå¼ºåŒ–æ˜¯è‡ªæ€è¡Œä¸º
            if (hasSuper) {
                console.log(`[AI TACTIC] ${attacker.cnName} æ”¾å¼ƒå¼ºåŒ–ï¼šå¯¹æ–¹é€Ÿåº¦å¿«ä¸”æœ‰å…‹åˆ¶æŠ€èƒ½`);
                return -500;
            }
            // å³ä½¿æ²¡æœ‰å…‹åˆ¶ï¼Œæ£€æŸ¥æ˜¯å¦ä¼šè¢« 2HKO
            let maxIncoming = 0;
            for (const pMove of (defender.moves || [])) {
                const mergedMove = getMergedMoveData(pMove);
                const dmgResult = simulateDamage(defender, attacker, mergedMove);
                if (dmgResult.damage > maxIncoming) maxIncoming = dmgResult.damage;
            }
            if (maxIncoming * 2 >= attacker.currHp) {
                console.log(`[AI TACTIC] ${attacker.cnName} æ”¾å¼ƒå¼ºåŒ–ï¼šä¼šè¢« 2HKO (${maxIncoming}x2 >= ${attacker.currHp})`);
                return -500;
            }
        }
        // æ”»å‡»/ç‰¹æ”»å¼ºåŒ–
        if (atkBoost > 0 || spaBoost > 0) {
            const relevantStat = atkBoost > 0 ? 'atk' : 'spa';
            const currentBoost = (attacker.boosts && attacker.boosts[relevantStat]) || 0;
            // å·²ç» +2 æˆ–æ›´é«˜ï¼Œåœæ­¢å¼ºåŒ–
            if (currentBoost >= 2) {
                console.log(`[AI TACTIC] ${attacker.cnName} å·²å¼ºåŒ– ${currentBoost} çº§ï¼Œåœæ­¢å¼ºåŒ–`);
                return -100;
            }
            // è¡€é‡å¥åº·æ—¶å¼ºåŒ–
            if (hpPercent >= 0.8) {
                console.log(`[AI TACTIC] ${attacker.cnName} å®‰å…¨å¼ºåŒ–: ${moveName}`);
                return 3500;
            } else if (hpPercent >= 0.5) {
                return 1500;
            }
        }
        // é€Ÿåº¦å¼ºåŒ–ï¼ˆé¾™èˆã€è¶èˆç­‰ï¼‰
        if (speBoost > 0 && (atkBoost > 0 || spaBoost > 0)) {
            if (hpPercent >= 0.7) {
                return 4000; // é¾™èˆç±»æ›´æœ‰ä»·å€¼
            }
        }
    }
    const category = (move.cat || move.category || '').toLowerCase();
    const isStatus = category === 'status' || move.power === 0 || move.basePower === 0;
    const MC = (typeof MOVE_CONSTANTS !== 'undefined') ? MOVE_CONSTANTS : {};
    // =========================================================
    // ã€Anti-Spam ä¿®æ­£ã€‘æ›¿èº« (Substitute) ç‰¹æ®Šå¤„ç†
    // é˜²æ­¢ AI æ— é™å¾ªç¯ä½¿ç”¨æ›¿èº«
    // =========================================================
    if (moveName === 'Substitute') {
        // 1. è¡€é‡è¿‡ä½ç»å¯¹ä¸ç”¨ï¼ˆ< 30%ï¼‰
        if (hpPercent < 0.30) {
            console.log(`[AI BAN] ${attacker.cnName} è¡€é‡è¿‡ä½ (${Math.round(hpPercent * 100)}%)ï¼Œç¦æ­¢ä½¿ç”¨æ›¿èº«`);
            return -9999;
        }
        // 2. å·²æœ‰æ›¿èº«ç»å¯¹ä¸ç”¨
        if (attacker.volatile && attacker.volatile.substitute && attacker.volatile.substitute > 0) {
            console.log(`[AI BAN] ${attacker.cnName} å·²æœ‰æ›¿èº«ï¼Œç¦æ­¢é‡å¤ä½¿ç”¨`);
            return -9999;
        }
        // 3. è¿ç»­ä½¿ç”¨æƒ©ç½šï¼šå¦‚æœä¸Šå›åˆç”¨äº†æ›¿èº«ï¼Œå¤§å¹…é™åˆ†
        if (attacker.lastMoveUsed === 'Substitute') {
            console.log(`[AI PENALTY] ${attacker.cnName} ä¸Šå›åˆå·²ç”¨æ›¿èº«ï¼Œé™ä½ä¼˜å…ˆçº§`);
            return -500;
        }
        // 4. è¡€é‡ä¸­ç­‰æ—¶ï¼ˆ30%-50%ï¼‰ï¼Œæ›¿èº«ä»·å€¼é™ä½
        if (hpPercent < 0.50) {
            return 20; // ä½ä¼˜å…ˆçº§
        }
        // 5. å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œä¸è¦ç”¨æ›¿èº«ï¼Œåº”è¯¥è¿›æ”»
        const defenderHpPercent = defender.currHp / defender.maxHp;
        if (defenderHpPercent < 0.30) {
            console.log(`[AI TACTIC] å¯¹æ‰‹æ®‹è¡€ï¼Œ${attacker.cnName} åº”è¯¥è¿›æ”»è€Œéæ›¿èº«`);
            return -200;
        }
        // 6. æ­£å¸¸æƒ…å†µä¸‹æ›¿èº«æ˜¯ä¸­ç­‰ä¼˜å…ˆçº§
        return 50;
    }
    // =========================================================
    // ã€é«˜é£é™©æ‹›å¼è¯„ä¼°ã€‘è…¹é¼“/ç”©è‚‰/é­‚èˆçƒˆéŸ³çˆ†ç­‰æ‰£è¡€å¼ºåŒ–æŠ€
    // =========================================================
    // ã€è…¹é¼“ã€‘æ¶ˆè€—50%HPï¼Œæ”»å‡»ç›´æ¥+6
    if (moveName === 'Belly Drum') {
        const cost = Math.floor(attacker.maxHp / 2);
        // è¡€é‡ä¸è¶³50%ï¼Œå¿…å®šå¤±è´¥
        if (attacker.currHp <= cost) {
            console.log(`[AI BAN] Belly Drumï¼šè¡€é‡ä¸è¶³ 50%ï¼Œä¼šå¤±è´¥`);
            return -99999;
        }
        // æ”»å‡»å·²æ»¡çº§
        if (attacker.boosts && attacker.boosts.atk >= 6) {
            console.log(`[AI BAN] Belly Drumï¼šæ”»å‡»å·²æ»¡çº§`);
            return -99999;
        }
        // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œç›´æ¥è¿›æ”»æ›´å¥½
        const defHpPercent = defender.currHp / defender.maxHp;
        if (defHpPercent < 0.30) {
            console.log(`[AI TACTIC] å¯¹æ‰‹æ®‹è¡€ï¼Œç›´æ¥è¿›æ”»è€Œéè…¹é¼“`);
            return -500;
        }
        // æ£€æŸ¥æ˜¯å¦ä¼šè¢«ç§’æ€ï¼ˆè…¹é¼“åå‰©ä½™50%è¡€ï¼‰
        let maxIncoming = 0;
        for (const pMove of (defender.moves || [])) {
            const mergedMove = getMergedMoveData(pMove);
            const dmgResult = simulateDamage(defender, attacker, mergedMove);
            if (dmgResult.damage > maxIncoming) maxIncoming = dmgResult.damage;
        }
        const hpAfterDrum = attacker.currHp - cost;
        if (maxIncoming >= hpAfterDrum) {
            console.log(`[AI BAN] Belly Drumï¼šè…¹é¼“åä¼šè¢«ç§’æ€ (${maxIncoming} >= ${hpAfterDrum})`);
            return -9999;
        }
        // è¡€é‡å¥åº·ä¸”å®‰å…¨æ—¶ï¼Œè…¹é¼“æ˜¯æé«˜ä»·å€¼
        if (hpPercent >= 0.80) {
            console.log(`[AI TACTIC] ${attacker.cnName} å®‰å…¨ä½¿ç”¨è…¹é¼“ï¼`);
            return 8000; // æé«˜ä¼˜å…ˆçº§
        } else if (hpPercent >= 0.55) {
            return 5000;
        }
        return 100; // é£é™©è¾ƒé«˜æ—¶é™ä½ä¼˜å…ˆçº§
    }
    // ã€ç”©è‚‰ã€‘æ¶ˆè€—50%HPï¼Œæ”»/ç‰¹æ”»/é€Ÿåº¦+2
    if (moveName === 'Fillet Away') {
        const cost = Math.floor(attacker.maxHp / 2);
        if (attacker.currHp <= cost) {
            console.log(`[AI BAN] Fillet Awayï¼šè¡€é‡ä¸è¶³ 50%ï¼Œä¼šå¤±è´¥`);
            return -99999;
        }
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èƒ½åŠ›éƒ½å·²æ»¡çº§
        const boosts = attacker.boosts || {};
        if ((boosts.atk || 0) >= 6 && (boosts.spa || 0) >= 6 && (boosts.spe || 0) >= 6) {
            console.log(`[AI BAN] Fillet Awayï¼šèƒ½åŠ›å·²æ»¡çº§`);
            return -99999;
        }
        // å¯¹æ‰‹æ®‹è¡€æ—¶ç›´æ¥è¿›æ”»
        const defHpPercent = defender.currHp / defender.maxHp;
        if (defHpPercent < 0.30) {
            return -500;
        }
        // æ£€æŸ¥æ˜¯å¦ä¼šè¢«ç§’æ€
        let maxIncoming = 0;
        for (const pMove of (defender.moves || [])) {
            const mergedMove = getMergedMoveData(pMove);
            const dmgResult = simulateDamage(defender, attacker, mergedMove);
            if (dmgResult.damage > maxIncoming) maxIncoming = dmgResult.damage;
        }
        const hpAfter = attacker.currHp - cost;
        if (maxIncoming >= hpAfter) {
            console.log(`[AI BAN] Fillet Awayï¼šä½¿ç”¨åä¼šè¢«ç§’æ€`);
            return -9999;
        }
        if (hpPercent >= 0.80) {
            return 6000;
        } else if (hpPercent >= 0.55) {
            return 4000;
        }
        return 100;
    }
    // ã€é­‚èˆçƒˆéŸ³çˆ†ã€‘æ¶ˆè€—33%HPï¼Œå…¨å±æ€§+1
    if (moveName === 'Clangorous Soul') {
        const cost = Math.floor(attacker.maxHp / 3);
        if (attacker.currHp <= cost) {
            console.log(`[AI BAN] Clangorous Soulï¼šè¡€é‡ä¸è¶³ 33%ï¼Œä¼šå¤±è´¥`);
            return -99999;
        }
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èƒ½åŠ›éƒ½å·²æ»¡çº§
        const boosts = attacker.boosts || {};
        const allMaxed = ['atk', 'def', 'spa', 'spd', 'spe'].every(s => (boosts[s] || 0) >= 6);
        if (allMaxed) {
            console.log(`[AI BAN] Clangorous Soulï¼šèƒ½åŠ›å·²æ»¡çº§`);
            return -99999;
        }
        const defHpPercent = defender.currHp / defender.maxHp;
        if (defHpPercent < 0.30) {
            return -500;
        }
        // æ£€æŸ¥æ˜¯å¦ä¼šè¢«ç§’æ€
        let maxIncoming = 0;
        for (const pMove of (defender.moves || [])) {
            const mergedMove = getMergedMoveData(pMove);
            const dmgResult = simulateDamage(defender, attacker, mergedMove);
            if (dmgResult.damage > maxIncoming) maxIncoming = dmgResult.damage;
        }
        const hpAfter = attacker.currHp - cost;
        if (maxIncoming >= hpAfter) {
            console.log(`[AI BAN] Clangorous Soulï¼šä½¿ç”¨åä¼šè¢«ç§’æ€`);
            return -9999;
        }
        if (hpPercent >= 0.70) {
            return 5000;
        } else if (hpPercent >= 0.40) {
            return 3000;
        }
        return 100;
    }
    // ã€æå‘½ã€‘é€ æˆç­‰äºè‡ªèº«å½“å‰HPçš„ä¼¤å®³ï¼Œè‡ªå·±æ¿’æ­»
    if (moveName === 'Final Gambit') {
        // åªæœ‰åœ¨èƒ½å‡»æ€å¯¹æ‰‹æ—¶æ‰ä½¿ç”¨
        if (attacker.currHp >= defender.currHp) {
            // è‡ªå·±æ®‹è¡€æ—¶æ›´æ„¿æ„æå‘½
            if (hpPercent < 0.30) {
                console.log(`[AI TACTIC] ${attacker.cnName} æ®‹è¡€æå‘½ï¼`);
                return 7000;
            }
            // èƒ½å‡»æ€ä¸”è‡ªå·±è¡€é‡ä¸é«˜
            if (hpPercent < 0.50) {
                return 4000;
            }
        }
        // ä¸èƒ½å‡»æ€æˆ–è‡ªå·±è¡€é‡å¥åº·ï¼Œä¸å€¼å¾—
        return -500;
    }
    // ã€åŒå‘½ã€‘å¦‚æœè¿™å›åˆè¢«å‡»å€’ï¼Œå‡»å€’è‡ªå·±çš„å¯¹æ‰‹ä¹Ÿä¼šå€’ä¸‹
    if (moveName === 'Destiny Bond') {
        // è¿ç»­ä½¿ç”¨ä¼šå¤±è´¥
        if (attacker.lastMoveUsed === 'Destiny Bond') {
            return -99999;
        }
        // æ®‹è¡€æ—¶åŒå‘½ä»·å€¼æé«˜
        if (hpPercent < 0.25) {
            console.log(`[AI TACTIC] ${attacker.cnName} æ®‹è¡€ä½¿ç”¨åŒå‘½ï¼`);
            return 6000;
        }
        if (hpPercent < 0.40) {
            return 3000;
        }
        // è¡€é‡å¥åº·æ—¶ä¸å€¼å¾—
        return -100;
    }
    // ã€æ²»æ„ˆä¹‹æ„¿/æ–°æœˆç¥ˆç¥·ã€‘è‡ªå·±æ¿’æ­»æ²»æ„ˆé˜Ÿå‹
    if (moveName === 'Healing Wish' || moveName === 'Lunar Dance') {
        // åªæœ‰åœ¨æ®‹è¡€ä¸”é˜Ÿä¼æœ‰å…¶ä»–å—ä¼¤æˆå‘˜æ—¶æ‰ä½¿ç”¨
        if (hpPercent < 0.25) {
            // ç®€åŒ–ï¼šæ®‹è¡€æ—¶ç»™äºˆä¸­ç­‰åˆ†æ•°
            return 2000;
        }
        // è¡€é‡å¥åº·æ—¶ä¸å€¼å¾—ç‰ºç‰²
        return -9999;
    }
    // === å˜åŒ–æŠ€è¯„åˆ† ===
    if (isStatus) {
        let statusScore = 10;
        // =========================================================
        // ã€Soft-Codedã€‘ä½¿ç”¨ MOVES æ•°æ®ä¸­çš„ volatileStatus å­—æ®µåˆ¤æ–­
        // è‡ªæˆ‘æ–½åŠ  volatile çŠ¶æ€çš„æŠ€èƒ½ï¼šå·²æœ‰çŠ¶æ€æ—¶ç¦æ­¢é‡å¤ä½¿ç”¨
        // =========================================================
        if (fullMoveData.volatileStatus && fullMoveData.target === 'self') {
            const volatileKey = fullMoveData.volatileStatus;
            // ã€ç‰¹æ®Šå¤„ç†ã€‘Stockpile æ˜¯å¯å åŠ çš„ï¼ˆæœ€å¤š3å±‚ï¼‰ï¼Œéœ€è¦ç‰¹æ®Šé€»è¾‘
            if (volatileKey === 'stockpile') {
                const currentStacks = (attacker.volatile && attacker.volatile.stockpile) || 0;
                // å·²æ»¡3å±‚ï¼Œç¦æ­¢ç»§ç»­ä½¿ç”¨
                if (currentStacks >= 3) {
                    console.log(`[AI BAN] Stockpileï¼šå·²æ»¡ ${currentStacks}/3 å±‚ï¼Œç¦æ­¢ç»§ç»­ä½¿ç”¨`);
                    return -99999;
                }
                // æ®‹è¡€æ—¶ä¸è¦è“„åŠ›ï¼ˆæµªè´¹å›åˆï¼‰
                if (hpPercent < 0.35) {
                    console.log(`[AI BAN] Stockpileï¼šæ®‹è¡€ (${Math.round(hpPercent * 100)}%) ä¸åº”ç»§ç»­è“„åŠ›`);
                    return -99999;
                }
                // å·²æœ‰2å±‚ä¸”è¡€é‡ä¸é«˜ï¼Œä¸è¦ç»§ç»­è“„åŠ›
                if (currentStacks >= 2 && hpPercent < 0.60) {
                    console.log(`[AI PENALTY] Stockpileï¼šå·²æœ‰ ${currentStacks} å±‚ä¸”è¡€é‡ä¸è¶³ï¼Œé™ä½ä¼˜å…ˆçº§`);
                    return 5;
                }
                // æ­£å¸¸æƒ…å†µä¸‹ç»™äºˆè¾ƒä½ä¼˜å…ˆçº§ï¼ˆä¸åº”è¯¥æ— è„‘è“„åŠ›ï¼‰
                return 25;
            }
            // 1. å·²æœ‰çŠ¶æ€ï¼Œç¦æ­¢é‡å¤ä½¿ç”¨
            if (attacker.volatile && attacker.volatile[volatileKey]) {
                console.log(`[AI BAN] ${moveName}ï¼šå·²æœ‰ ${volatileKey} çŠ¶æ€ï¼Œç¦æ­¢é‡å¤ä½¿ç”¨`);
                return -99999;
            }
            // 2. æŒç»­å›å¤ç±» volatile (aquaring, ingrain) åœ¨æ®‹è¡€æ—¶æ— æ„ä¹‰
            const hotVolatiles = ['aquaring', 'ingrain'];
            if (hotVolatiles.includes(volatileKey)) {
                if (hpPercent < 0.30) {
                    console.log(`[AI BAN] ${moveName}ï¼šæ®‹è¡€ (${Math.round(hpPercent * 100)}%) ä½¿ç”¨æŒç»­å›å¤æ— æ„ä¹‰`);
                    return -99999;
                }
                if (hpPercent < 0.50) {
                    console.log(`[AI PENALTY] ${moveName}ï¼šè¡€é‡ä¸è¶³ (${Math.round(hpPercent * 100)}%)ï¼Œé™ä½ä¼˜å…ˆçº§`);
                    return 5;
                }
                if (hpPercent >= 0.70) {
                    return 40;
                }
                return 15;
            }
            // 3. focusenergy: æ®‹è¡€æ—¶ä¸è¦èšæ°”
            if (volatileKey === 'focusenergy') {
                if (hpPercent < 0.30) {
                    return -100;
                }
                return 30;
            }
        }
        // =========================================================
        // ã€ç‰¹æ®Šå¤„ç†ã€‘Spit Up / Swallow éœ€è¦æ£€æŸ¥è“„åŠ›å±‚æ•°
        // =========================================================
        const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
        if (moveId === 'spitup' || moveId === 'swallow') {
            const stacks = (attacker.volatile && attacker.volatile.stockpile) || 0;
            if (stacks === 0) {
                console.log(`[AI BAN] ${moveName}ï¼šæ²¡æœ‰è“„åŠ›å±‚æ•°ï¼Œæ— æ³•ä½¿ç”¨`);
                return -99999;
            }
            // æœ‰è“„åŠ›æ—¶ï¼Œæ ¹æ®å±‚æ•°ç»™äºˆè¯„åˆ†
            if (moveId === 'spitup') {
                // å–·å‡ºï¼šå±‚æ•°è¶Šå¤šå¨åŠ›è¶Šé«˜
                return 50 + stacks * 30;
            } else {
                // åä¸‹ï¼šè¡€é‡ä½æ—¶ä¼˜å…ˆä½¿ç”¨
                if (hpPercent < 0.40) return 150;
                if (hpPercent < 0.60) return 80;
                return 30;
            }
        }
        // =========================================================
        // ã€ç‰¹æ®Šå¤„ç†ã€‘Stuff Cheeks éœ€è¦æ£€æŸ¥æ˜¯å¦æŒæœ‰æ ‘æœ
        // =========================================================
        if (moveId === 'stuffcheeks') {
            const item = attacker.item || '';
            const isBerry = item.toLowerCase().includes('berry') || item.includes('æœ');
            if (!item || !isBerry) {
                console.log(`[AI BAN] Stuff Cheeksï¼šæ²¡æœ‰æŒæœ‰æ ‘æœï¼Œæ— æ³•ä½¿ç”¨`);
                return -99999;
            }
            // æœ‰æ ‘æœæ—¶ï¼Œè¡€é‡å¥åº·æ—¶ä½¿ç”¨ä»·å€¼æ›´é«˜
            if (hpPercent > 0.70) return 80;
            if (hpPercent > 0.50) return 50;
            return 20; // æ®‹è¡€æ—¶ä¸å¤ªå€¼å¾—ç”¨
        }
        // =========================================================
        // ã€Soft-Codedã€‘å¯¹ç›®æ ‡æ–½åŠ  volatile çŠ¶æ€çš„æŠ€èƒ½
        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å·²æœ‰è¯¥çŠ¶æ€
        // =========================================================
        if (fullMoveData.volatileStatus && fullMoveData.target !== 'self') {
            const volatileKey = fullMoveData.volatileStatus;
            // ç›®æ ‡å·²æœ‰è¯¥ volatile çŠ¶æ€ï¼Œç¦æ­¢ä½¿ç”¨
            if (defender.volatile && defender.volatile[volatileKey]) {
                console.log(`[AI BAN] ${moveName}ï¼šç›®æ ‡å·²æœ‰ ${volatileKey} çŠ¶æ€`);
                return -99999;
            }
            // yawn: å¯¹æ‰‹å·²æœ‰å¼‚å¸¸çŠ¶æ€æ—¶æ— æ•ˆ
            if (volatileKey === 'yawn' && defender.status) {
                console.log(`[AI BAN] ${moveName}ï¼šå¯¹æ‰‹å·²æœ‰å¼‚å¸¸çŠ¶æ€ (${defender.status})`);
                return -99999;
            }
            // curse (å¹½çµç³»): å¯¹æ‰‹å·²è¢«è¯…å’’
            if (volatileKey === 'curse') {
                // å¹½çµç³»è¯…å’’éœ€è¦æ£€æŸ¥è‡ªèº«è¡€é‡
                if (attacker.types && attacker.types.includes('Ghost')) {
                    if (hpPercent <= 0.50) {
                        console.log(`[AI BAN] Curseï¼šè¡€é‡ä¸è¶³ 50%ï¼Œä½¿ç”¨ä¼šè‡ªæ€`);
                        return -99999;
                    }
                }
            }
            // leechseed: å¯¹è‰ç³»æ— æ•ˆ
            if (volatileKey === 'leechseed') {
                if (defender.types && defender.types.includes('Grass')) {
                    console.log(`[AI BAN] Leech Seedï¼šå¯¹æ‰‹æ˜¯è‰ç³»ï¼Œæ— æ•ˆ`);
                    return -99999;
                }
                const defHpPercent = defender.currHp / defender.maxHp;
                if (defHpPercent < 0.20) {
                    return 5;
                }
                return 50;
            }
        }
        // =========================================================
        // ã€å±æ€§å˜åŒ–æŠ€èƒ½ã€‘å®Œæ•´çš„ç±»å‹å˜åŒ–æŠ€èƒ½æ‹¦æˆªç³»ç»Ÿ
        // é˜²æ­¢ AI å¯¹å·²ç»è¾¾æˆçš„çŠ¶æ€é‡å¤ä½¿ç”¨æ— æ•ˆæŠ€èƒ½
        // =========================================================
        // 1. Transform (å˜èº«) - å¤åˆ¶å¯¹æ‰‹çš„ä¸€åˆ‡
        if (moveName === 'Transform') {
            // å¦‚æœç›®æ ‡å·²ç»å˜èº«è¿‡ï¼Œå¤±è´¥
            if (defender.isTransformed || (defender.volatile && defender.volatile.transformed)) {
                console.log(`[AI BAN] Transform: ç›®æ ‡å·²ç»å˜èº«è¿‡`);
                return -99999;
            }
            // å¦‚æœç›®æ ‡æœ‰æ›¿èº«ï¼Œå¤±è´¥
            if (defender.volatile && defender.volatile.substitute) {
                console.log(`[AI BAN] Transform: ç›®æ ‡æœ‰æ›¿èº«`);
                return -99999;
            }
            // ç™¾å˜æ€ªäº’ç›¸å¯¹è§†æ—¶é¿å…æ­»å¾ªç¯
            const attackerSpecies = (attacker.species || attacker.name || '').toLowerCase();
            const defenderSpecies = (defender.species || defender.name || '').toLowerCase();
            if (attackerSpecies.includes('ditto') && defenderSpecies.includes('ditto')) {
                console.log(`[AI BAN] Transform: ç™¾å˜æ€ªäº’ç›¸å˜èº«æ— æ„ä¹‰`);
                return -99999;
            }
            return 100; // å˜èº«æ˜¯å¼ºåŠ›æŠ€èƒ½
        }
        // 2. Conversion (çº¹ç†) - å˜æˆè‡ªå·±ç¬¬ä¸€æ‹›çš„å±æ€§
        if (moveName === 'Conversion') {
            const firstMove = attacker.moves[0];
            if (firstMove && firstMove.type) {
                const targetType = firstMove.type;
                // å¦‚æœå·²ç»æ˜¯è¯¥å±æ€§ï¼ˆå•å±æ€§ä¸”ç›¸åŒï¼‰ï¼Œç¦æ­¢ä½¿ç”¨
                if (attacker.types && attacker.types.length === 1 && attacker.types[0] === targetType) {
                    console.log(`[AI BAN] Conversion: å·²ç»æ˜¯ ${targetType} å±æ€§`);
                    return -99999;
                }
            }
            return 30;
        }
        // 3. Reflect Type (é•œé¢å±æ€§) - å¤åˆ¶å¯¹æ‰‹çš„å±æ€§
        if (moveName === 'Reflect Type') {
            const myTypes = (attacker.types || ['Normal']).slice().sort().join(',');
            const targetTypes = (defender.types || ['Normal']).slice().sort().join(',');
            // å¦‚æœå±æ€§ç»„åˆå®Œå…¨ä¸€è‡´ï¼Œå¤±è´¥
            if (myTypes === targetTypes) {
                console.log(`[AI BAN] Reflect Type: å±æ€§å·²ç›¸åŒ (${myTypes})`);
                return -99999;
            }
            return 25;
        }
        // 4. Burn Up (ç‡ƒå°½) - å¤±å»ç«å±æ€§çš„å¼ºåŠ›ç«ç³»æ”»å‡»
        if (moveName === 'Burn Up') {
            const types = attacker.types || [];
            if (!types.includes('Fire')) {
                console.log(`[AI BAN] Burn Up: ä¸å†æ˜¯ç«ç³»ï¼Œæ— æ³•ä½¿ç”¨`);
                return -99999;
            }
            // è¿™æ˜¯æ”»å‡»æŠ€èƒ½ï¼Œç”±ä¼¤å®³è®¡ç®—å¤„ç†ï¼Œè¿™é‡Œåªåšå±æ€§æ£€æŸ¥
        }
        // 5. Double Shock (ç”µå…‰åŒå‡») - å¤±å»ç”µå±æ€§çš„å¼ºåŠ›ç”µç³»æ”»å‡»
        if (moveName === 'Double Shock') {
            const types = attacker.types || [];
            if (!types.includes('Electric')) {
                console.log(`[AI BAN] Double Shock: ä¸å†æ˜¯ç”µç³»ï¼Œæ— æ³•ä½¿ç”¨`);
                return -99999;
            }
            // è¿™æ˜¯æ”»å‡»æŠ€èƒ½ï¼Œç”±ä¼¤å®³è®¡ç®—å¤„ç†
        }
        // 6. Soak (æµ¸æ°´) - æŠŠå¯¹æ‰‹å˜æˆçº¯æ°´ç³»
        if (moveName === 'Soak') {
            const types = defender.types || [];
            if (types.length === 1 && types[0] === 'Water') {
                console.log(`[AI BAN] Soak: å¯¹æ‰‹å·²ç»æ˜¯çº¯æ°´ç³»`);
                return -99999;
            }
            // å¯¹æ°´ç³»å®å¯æ¢¦ä½¿ç”¨æ„ä¹‰ä¸å¤§ï¼ˆè™½ç„¶ä¸ä¼šå¤±è´¥ï¼Œä½†æˆ˜æœ¯ä»·å€¼ä½ï¼‰
            if (types.includes('Water') && types.length === 1) {
                return 5;
            }
            return 40; // æ”¹å˜å¯¹æ‰‹å±æ€§æœ‰æˆ˜æœ¯ä»·å€¼
        }
        // 7. Magic Powder (é­”æ³•ç²‰) - æŠŠå¯¹æ‰‹å˜æˆçº¯è¶…èƒ½åŠ›ç³»
        if (moveName === 'Magic Powder') {
            const types = defender.types || [];
            if (types.length === 1 && types[0] === 'Psychic') {
                console.log(`[AI BAN] Magic Powder: å¯¹æ‰‹å·²ç»æ˜¯çº¯è¶…èƒ½åŠ›ç³»`);
                return -99999;
            }
            return 35;
        }
        // 8. Trick-or-Treat (ä¸‡åœ£å¤œ) - ç»™å¯¹æ‰‹è¿½åŠ å¹½çµå±æ€§
        if (moveName === 'Trick-or-Treat') {
            if ((defender.types || []).includes('Ghost')) {
                console.log(`[AI BAN] Trick-or-Treat: å¯¹æ‰‹å·²ç»æœ‰å¹½çµå±æ€§`);
                return -99999;
            }
            return 30;
        }
        // 9. Forest's Curse (æ£®æ—è¯…å’’) - ç»™å¯¹æ‰‹è¿½åŠ è‰å±æ€§
        if (moveName === "Forest's Curse") {
            if ((defender.types || []).includes('Grass')) {
                console.log(`[AI BAN] Forest's Curse: å¯¹æ‰‹å·²ç»æœ‰è‰å±æ€§`);
                return -99999;
            }
            return 30;
        }
        // =========================================================
        // ã€Soft-Codedã€‘å»¶è¿Ÿç”Ÿæ•ˆæŠ€èƒ½ (slotCondition æˆ–ç‰¹å®š volatileStatus)
        // æ®‹è¡€æ—¶ä½¿ç”¨æ— æ„ä¹‰
        // =========================================================
        const isDelayedEffect = fullMoveData.slotCondition || 
            (fullMoveData.volatileStatus === 'yawn') ||
            (fullMoveData.isFutureMove);
        if (isDelayedEffect && hpPercent < 0.25) {
            console.log(`[AI BAN] ${moveName}ï¼šæ®‹è¡€ä½¿ç”¨å»¶è¿ŸæŠ€èƒ½æ— æ„ä¹‰`);
            return -99999;
        }
        // Wish: è¡€é‡å¥åº·æ—¶ä¸éœ€è¦ï¼ˆä½¿ç”¨ slotCondition æ£€æµ‹ï¼‰
        if (fullMoveData.slotCondition === 'wish') {
            if (hpPercent > 0.70) {
                return 5; // è¡€é‡å¥åº·ï¼Œä¸éœ€è¦è®¸æ„¿
            }
            if (hpPercent < 0.50) {
                return 60; // è¡€é‡ä¸­ç­‰ï¼Œå¯ä»¥è®¸æ„¿
            }
        }
        // =========================================================
        // ã€Critical Fixã€‘è‡ªæˆ‘ç‰ºç‰²æŠ€èƒ½ (Memento, Healing Wish, Lunar Dance)
        // æ£€æŸ¥ selfdestruct å­—æ®µï¼Œé˜²æ­¢æ— æ•ˆä½¿ç”¨å¯¼è‡´æ­»å¾ªç¯
        // =========================================================
        if (fullMoveData.selfdestruct) {
            // Memento: é™ä½å¯¹æ‰‹æ”»å‡»å’Œç‰¹æ”»å„2çº§
            if (fullMoveData.boosts) {
                const targetBoosts = defender.boosts || {};
                let canLowerStats = false;
                // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½é™ä½ä»»ä½•å±æ€§
                for (const [stat, value] of Object.entries(fullMoveData.boosts)) {
                    const currentBoost = targetBoosts[stat] || 0;
                    // å¦‚æœå½“å‰ç­‰çº§ > -6ï¼Œè¯´æ˜è¿˜èƒ½é™ä½
                    if (value < 0 && currentBoost > -6) {
                        canLowerStats = true;
                        break;
                    }
                }
                // å¦‚æœæ‰€æœ‰ç›¸å…³å±æ€§éƒ½å·²ç»æ˜¯ -6ï¼Œç¦æ­¢ä½¿ç”¨
                if (!canLowerStats) {
                    console.log(`[AI BAN] ${moveName} æ— æ•ˆï¼šå¯¹æ‰‹å±æ€§å·²é™è‡³æœ€ä½ (atk:${targetBoosts.atk || 0}, spa:${targetBoosts.spa || 0})`);
                    return -99999;
                }
                // åªæœ‰åœ¨å¯¹æ‰‹å¨èƒå¾ˆå¤§ä¸”æˆ‘æ–¹å³å°†å€’ä¸‹æ—¶æ‰ä½¿ç”¨
                const defenderHpPercent = defender.currHp / defender.maxHp;
                const attackerHpPercent = attacker.currHp / attacker.maxHp;
                // å¯¹æ‰‹æ®‹è¡€æ—¶ä¸è¦ç”¨ï¼ˆæµªè´¹ï¼‰
                if (defenderHpPercent < 0.3) {
                    console.log(`[AI BAN] ${moveName}ï¼šå¯¹æ‰‹æ®‹è¡€ï¼Œä¸å€¼å¾—ç‰ºç‰²`);
                    return -9999;
                }
                // è‡ªå·±è¿˜å¥åº·æ—¶ä¸è¦ç”¨
                if (attackerHpPercent > 0.5) {
                    console.log(`[AI BAN] ${moveName}ï¼šè‡ªå·±è¿˜å¥åº·ï¼Œä¸åº”ç‰ºç‰²`);
                    return -9999;
                }
                // åªæœ‰åœ¨è‡ªå·±æ®‹è¡€ä¸”å¯¹æ‰‹å¼ºå¤§æ—¶æ‰è€ƒè™‘
                if (attackerHpPercent <= 0.3 && defenderHpPercent > 0.6) {
                    // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦å·²ç»è¢«å‰Šå¼±
                    const atkDebuff = targetBoosts.atk || 0;
                    const spaDebuff = targetBoosts.spa || 0;
                    if (atkDebuff <= -4 && spaDebuff <= -4) {
                        // å·²ç»å‰Šå¼±å¾—å¤Ÿå¤šäº†
                        console.log(`[AI BAN] ${moveName}ï¼šå¯¹æ‰‹å·²è¢«å……åˆ†å‰Šå¼± (atk:${atkDebuff}, spa:${spaDebuff})`);
                        return -9999;
                    }
                    // å¯ä»¥ä½¿ç”¨ï¼Œä½†ä¼˜å…ˆçº§ä¸é«˜
                    return 30;
                }
                // å…¶ä»–æƒ…å†µä¸ä½¿ç”¨
                return -9999;
            }
            // Healing Wish / Lunar Dance: åªåœ¨æœ‰åå¤‡ä¸”è‡ªå·±æ®‹è¡€æ—¶ä½¿ç”¨
            if (moveName === 'Healing Wish' || moveName === 'Lunar Dance') {
                if (hpPercent > 0.2) {
                    return -9999; // è¡€é‡è¿˜è¡Œï¼Œä¸ç‰ºç‰²
                }
                // éœ€è¦æ£€æŸ¥æ˜¯å¦æœ‰åå¤‡å®å¯æ¢¦ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
                return 20;
            }
        }
        // å¼ºåŒ–æŠ€èƒ½
        const boostMoves = MC.AI_BOOST_MOVES || ['Swords Dance', 'Calm Mind', 'Dragon Dance', 'Nasty Plot'];
        if (boostMoves.includes(moveName)) {
            const relevantBoost = attacker.spa > attacker.atk ? (attacker.boosts?.spa || 0) : (attacker.boosts?.atk || 0);
            if (relevantBoost < 2) statusScore = 80 + Math.random() * 20;
            else if (relevantBoost < 4) statusScore = 40 + Math.random() * 20;
            else statusScore = 5;
        }
        // çŠ¶æ€æŠ€èƒ½
        const statusInflict = MC.AI_STATUS_MOVES || ['Thunder Wave', 'Will-O-Wisp', 'Toxic', 'Spore'];
        const sleepMoves = MC.AI_SLEEP_MOVES || ['Spore', 'Sleep Powder', 'Hypnosis', 'Sing'];
        const paralyzeMoves = MC.AI_PARALYZE_MOVES || ['Thunder Wave', 'Glare', 'Stun Spore'];
        if (statusInflict.includes(moveName)) {
            if (!defender.status) {
                if (sleepMoves.includes(moveName)) {
                    statusScore = 70 + Math.random() * 30;
                } else if (paralyzeMoves.includes(moveName)) {
                    statusScore = defender.spe > attacker.spe ? 60 + Math.random() * 20 : 30 + Math.random() * 20;
                } else if (moveName === 'Will-O-Wisp') {
                    statusScore = defender.atk > defender.spa ? 65 + Math.random() * 20 : 25 + Math.random() * 15;
                } else if (moveName === 'Toxic') {
                    statusScore = 50 + Math.random() * 20;
                }
            } else {
                statusScore = -100;
            }
        }
        // å›å¤æŠ€èƒ½
        const healMoves = MC.AI_HEAL_MOVES || ['Recover', 'Roost', 'Soft-Boiled', 'Slack Off'];
        if (healMoves.includes(moveName)) {
            const hpPercent = attacker.currHp / attacker.maxHp;
            const defenderHpPercent = defender.currHp / defender.maxHp;
            // ã€ä¿®æ­£ã€‘å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œå¤§å¹…é™ä½å›è¡€æŠ€èƒ½ä¼˜å…ˆçº§
            if (defenderHpPercent < 0.25 && hpPercent > 0.4) {
                // å¯¹æ‰‹å¿«æ­»äº†ï¼Œæˆ‘è¿˜å¥åº·ï¼Œä¸è¦å›è¡€ï¼å»è¾“å‡ºï¼
                statusScore = -500;
            } else if (hpPercent < 0.3) {
                statusScore = 90 + Math.random() * 10;
            } else if (hpPercent < 0.5) {
                statusScore = 60 + Math.random() * 20;
            } else if (hpPercent < 0.7) {
                statusScore = 30 + Math.random() * 15;
            } else {
                statusScore = 5;
            }
        }
        // ã€æ–°å¢ã€‘åä¼¤æŠ€èƒ½é¢„æµ‹è¯„åˆ† (Mirror Coat / Counter / Metal Burst)
        const counterMoves = ['Mirror Coat', 'Counter', 'Metal Burst'];
        if (counterMoves.includes(moveName)) {
            const defenderHpPercent = defender.currHp / defender.maxHp;
            // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œåä¼¤æŠ€èƒ½æ¯«æ— æ„ä¹‰ï¼ˆå¯¹é¢å¯èƒ½ç›´æ¥æ¢äººæˆ–ç”¨å˜åŒ–æŠ€ï¼‰
            if (defenderHpPercent < 0.25) {
                return -9999;
            }
            // é¢„æµ‹å¯¹æ‰‹çš„æ”»å‡»ç±»å‹
            const defenderIsSpecialAttacker = (defender.baseStats?.spa || defender.spa || 0) > (defender.baseStats?.atk || defender.atk || 0);
            const defenderIsPhysicalAttacker = (defender.baseStats?.atk || defender.atk || 0) > (defender.baseStats?.spa || defender.spa || 0);
            // Mirror Coatï¼šåªå¯¹ç‰¹æ”»æ‰‹æœ‰æ•ˆ
            if (moveName === 'Mirror Coat') {
                if (defenderIsSpecialAttacker) {
                    // é¢„æµ‹å¯¹æ‰‹ä¼šç”¨ç‰¹æ®Šæ”»å‡»ï¼ŒMirror Coat æœ‰ä»·å€¼
                    const predictedDamage = attacker.maxHp * 0.35; // å‡è®¾å—åˆ° 35% HP ä¼¤å®³
                    const estimatedReturn = predictedDamage * 2;
                    statusScore = 40 + (estimatedReturn / defender.maxHp) * 100;
                } else if (defenderIsPhysicalAttacker) {
                    // å¯¹é¢æ˜¯ç‰©ç†æ‰‹ï¼ŒMirror Coat æ— ç”¨
                    return -9999;
                } else {
                    // ä¸ç¡®å®šï¼Œç»™ä¸ªä¸­ç­‰åˆ†æ•°
                    statusScore = 20;
                }
            }
            // Counterï¼šåªå¯¹ç‰©ç†æ‰‹æœ‰æ•ˆ
            if (moveName === 'Counter') {
                if (defenderIsPhysicalAttacker) {
                    const predictedDamage = attacker.maxHp * 0.35;
                    const estimatedReturn = predictedDamage * 2;
                    statusScore = 40 + (estimatedReturn / defender.maxHp) * 100;
                } else if (defenderIsSpecialAttacker) {
                    return -9999;
                } else {
                    statusScore = 20;
                }
            }
            // Metal Burstï¼šé€šç”¨åä¼¤ï¼Œä½†éœ€è¦åæ‰‹
            if (moveName === 'Metal Burst') {
                const attackerSpeed = attacker.spe || attacker.baseStats?.spe || 100;
                const defenderSpeed = defender.spe || defender.baseStats?.spe || 100;
                if (attackerSpeed < defenderSpeed) {
                    // æˆ‘æ¯”å¯¹æ‰‹æ…¢ï¼ŒMetal Burst æœ‰æ•ˆ
                    statusScore = 50;
                } else {
                    // æˆ‘æ¯”å¯¹æ‰‹å¿«ï¼ŒMetal Burst æ— æ•ˆ
                    return -5000;
                }
            }
        }
        // å®ˆä½ç±» - è€ƒè™‘è¿ç»­ä½¿ç”¨æƒ©ç½š
        // ã€ä¿®å¤ã€‘æ·»åŠ  Max Guardï¼ˆæå·¨åŒ–æ—¶å˜åŒ–æŠ€è½¬æ¢çš„å®ˆä½æ‹›å¼ï¼‰
        const protectMoves = MC.AI_PROTECT_MOVES || ['Protect', 'Detect', 'King\'s Shield', 'Spiky Shield', 'Baneful Bunker', 'Obstruct', 'Silk Trap', 'Max Guard'];
        if (protectMoves.includes(moveName)) {
            // æ£€æŸ¥è¿ç»­ä½¿ç”¨æƒ©ç½š
            const protectCounter = attacker.protectCounter || 0;
            if (protectCounter > 0) {
                // è¿ç»­ä½¿ç”¨æˆåŠŸç‡å¾ˆä½ï¼ŒAI åº”è¯¥é¿å…
                const successChance = Math.pow(1/3, protectCounter);
                if (successChance < 0.34) {
                    // æˆåŠŸç‡ä½äº 34%ï¼Œä¸å€¼å¾—å†’é™©
                    return -100;
                }
            }
            if (defender.status === 'psn' || defender.status === 'tox' || defender.status === 'brn') {
                statusScore = 40 + Math.random() * 30;
            } else {
                statusScore = 15 + Math.random() * 15;
            }
        }
        // é¦–å›åˆé™åˆ¶æŠ€èƒ½æ£€æŸ¥
        const firstTurnMoves = ['Fake Out', 'First Impression', 'Mat Block'];
        if (firstTurnMoves.includes(moveName)) {
            if ((attacker.turnsOnField || 0) > 0) {
                return -9999; // éé¦–å›åˆï¼Œå¿…å®šå¤±è´¥
            }
        }
        // åŒå‘½è¿ç»­ä½¿ç”¨é™åˆ¶
        if (moveName === 'Destiny Bond' && attacker.lastMoveUsed === 'Destiny Bond') {
            return -9999; // è¿ç»­ä½¿ç”¨å¿…å¤±è´¥
        }
        // åƒµç›´çŠ¶æ€æ£€æŸ¥
        if (attacker.mustRecharge) {
            return -9999; // éœ€è¦ä¼‘æ¯ï¼Œæ— æ³•è¡ŒåŠ¨
        }
        return statusScore;
    }
    // === æ”»å‡»æŠ€èƒ½è¯„åˆ†ï¼ˆä½¿ç”¨è½¯ç¼–ç çš„ evaluateMoveImpactï¼‰===
    const impact = evaluateMoveImpact(attacker, defender, move);
    const eff = impact.effectiveness;
    // å…ç–«æ—¶ç›´æ¥è¿”å›æä½åˆ†
    if (eff === 0) return -9999;
    let score = impact.totalScore;
    // =========================================================
    // ã€AI æ™ºå•†è¡¥æ­£ã€‘Contrary (å”±åè°ƒ) ç‰¹æ€§ä¸“é—¨å¢å¼º
    // è‡ªé™èƒ½åŠ›çš„æŠ€èƒ½åœ¨å”±åè°ƒä¸‹å˜æˆè‡ªæˆ‘å¼ºåŒ–
    // =========================================================
    const attackerAbility = (attacker.ability || '').toLowerCase();
    const isContrary = attackerAbility === 'contrary';
    if (isContrary) {
        // è½¯ç¼–ç ï¼šä» fullMoveData.self.boosts ä¸­æ£€æµ‹è‡ªé™èƒ½åŠ›
        const selfBoosts = fullMoveData.self?.boosts || {};
        let hasSelfDebuff = false;
        let debuffValue = 0;
        // æ£€æŸ¥æ‰€æœ‰è‡ªé™èƒ½åŠ›
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            const boost = selfBoosts[stat] || 0;
            if (boost < 0) {
                hasSelfDebuff = true;
                debuffValue += Math.abs(boost);
            }
        }
        // å¦‚æœæœ‰è‡ªé™èƒ½åŠ›ï¼Œåœ¨å”±åè°ƒä¸‹å˜æˆå¼ºåŒ–
        if (hasSelfDebuff) {
            // æ¯çº§è‡ªé™å˜æˆ +1 å¼ºåŒ–ï¼Œä»·å€¼æé«˜
            const contraryBonus = debuffValue * 800; // æ¯çº§ +800 åˆ†
            score += contraryBonus;
            console.log(`[AI CONTRARY] ${attacker.cnName} çš„ ${moveName} å› å”±åè°ƒè·å¾— +${contraryBonus} åˆ† (è‡ªé™ ${debuffValue} çº§)`);
            // ç‰¹åˆ«åŠ æˆï¼šLeaf Storm / Overheat ç­‰ -2 ç‰¹æ”»çš„æŠ€èƒ½
            if (selfBoosts.spa === -2 || selfBoosts.atk === -2) {
                score += 500; // é¢å¤–åŠ æˆï¼Œå› ä¸ºè¿™ç±»æŠ€èƒ½å¨åŠ›æœ¬èº«å°±é«˜
                console.log(`[AI CONTRARY] ${moveName} æ˜¯é¡¶çº§å¼ºåŒ–æŠ€ï¼Œé¢å¤– +500 åˆ†`);
            }
        }
    }
    // ã€åå‘é€»è¾‘ã€‘éå”±åè°ƒæ—¶ï¼Œè‡ªé™èƒ½åŠ›æŠ€èƒ½åº”è¯¥é€‚å½“å‡åˆ†
    else {
        const selfBoosts = fullMoveData.self?.boosts || {};
        let debuffPenalty = 0;
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            const boost = selfBoosts[stat] || 0;
            if (boost < 0) {
                // é™æ”»å‡»/ç‰¹æ”»æƒ©ç½šæ›´é‡
                if (stat === 'atk' || stat === 'spa') {
                    debuffPenalty += Math.abs(boost) * 100;
                } else {
                    debuffPenalty += Math.abs(boost) * 50;
                }
            }
        }
        if (debuffPenalty > 0) {
            score -= debuffPenalty;
        }
    }
    // =========================================================
    // ã€Extension 1ã€‘æ¡ä»¶å¢ä¼¤æŠ€èƒ½é€»è¾‘ (Variable Power)
    // Hex, Venoshock, Foul Play, Body Press, Gyro Ball ç­‰
    // =========================================================
    let damageMultiplier = 1.0;
    // 1.1 çŠ¶æ€æ–½åŠ å¢ä¼¤ (Facade, Hex, Venoshock, Wake-Up Slap)
    if (moveName === 'Facade' && (attacker.status === 'brn' || attacker.status === 'par' || attacker.status === 'psn' || attacker.status === 'tox')) {
        damageMultiplier = 2.0;
        if (attacker.status === 'brn') score += 1000; // çƒ§ä¼¤æ—¶ç¡¬æ’‘æ— è§†å‡åŠ
    }
    if (moveName === 'Hex' && defender.status) {
        damageMultiplier = 2.0;
        console.log(`[AI VAR] Hex å¯¹å¼‚å¸¸çŠ¶æ€ç›®æ ‡å¨åŠ›ç¿»å€`);
    }
    if (moveName === 'Venoshock' && (defender.status === 'psn' || defender.status === 'tox')) {
        damageMultiplier = 2.0;
    }
    if (moveName === 'Wake-Up Slap' && defender.status === 'slp') {
        damageMultiplier = 2.0;
    }
    if (moveName === 'Brine' && defender.currHp <= defender.maxHp / 2) {
        damageMultiplier = 2.0;
    }
    // 1.2 åˆ©ç”¨å¯¹æ‰‹å±æ€§è®¡ç®— (Foul Play / Body Press / Power Trip / Stored Power)
    if (moveName === 'Foul Play') {
        const enemyAtk = defender.atk || defender.baseStats?.atk || 50;
        const myAtk = attacker.atk || 50;
        if (enemyAtk > myAtk) {
            damageMultiplier = enemyAtk / myAtk;
            console.log(`[AI VAR] Foul Play ä½¿ç”¨å¯¹æ‰‹æ”»å‡»åŠ›: x${damageMultiplier.toFixed(1)}`);
        }
    }
    if (moveName === 'Body Press') {
        const myDef = attacker.def || 50;
        const myAtk = attacker.atk || 50;
        if (myDef > myAtk) {
            damageMultiplier = myDef / myAtk;
            console.log(`[AI VAR] Body Press ä½¿ç”¨è‡ªèº«é˜²å¾¡: x${damageMultiplier.toFixed(1)}`);
        }
    }
    if (moveName === 'Power Trip' || moveName === 'Stored Power') {
        const boosts = attacker.boosts || {};
        let totalBoosts = 0;
        for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
            totalBoosts += Math.max(0, boosts[stat] || 0);
        }
        if (totalBoosts > 0) {
            // æ¯çº§ +20 å¨åŠ›ï¼ŒåŸºç¡€ 20
            const power = 20 + totalBoosts * 20;
            damageMultiplier = power / 20;
            console.log(`[AI VAR] ${moveName} å¼ºåŒ–åŠ æˆ: ${totalBoosts}çº§ -> å¨åŠ›${power}`);
        }
    }
    // 1.3 é€Ÿåº¦ç±»æŠ€èƒ½ (Gyro Ball / Electro Ball)
    if (moveName === 'Gyro Ball') {
        const oppSpeed = getEffectiveSpeed(defender) || 1;
        const mySpeed = getEffectiveSpeed(attacker) || 1;
        const power = Math.min(150, Math.floor(25 * (oppSpeed / mySpeed)));
        if (power > (move.basePower || 80)) {
            damageMultiplier = power / (move.basePower || 80);
            console.log(`[AI VAR] Gyro Ball é€Ÿåº¦å·®è®¡ç®—: å¨åŠ›${power}`);
        }
    }
    if (moveName === 'Electro Ball') {
        const oppSpeed = getEffectiveSpeed(defender) || 1;
        const mySpeed = getEffectiveSpeed(attacker) || 1;
        const diff = mySpeed / oppSpeed;
        let power = 60;
        if (diff >= 4) power = 150;
        else if (diff >= 3) power = 120;
        else if (diff >= 2) power = 80;
        damageMultiplier = power / 60;
    }
    // 1.4 ä½“é‡ç±»æŠ€èƒ½ (Grass Knot / Low Kick / Heavy Slam / Heat Crash)
    if (moveName === 'Grass Knot' || moveName === 'Low Kick') {
        // ç®€åŒ–ï¼šå‡è®¾é‡å‹å®å¯æ¢¦å¨åŠ›æ›´é«˜
        const defenderWeight = defender.baseStats?.hp || 80; // ç”¨ HP è¿‘ä¼¼ä½“é‡
        if (defenderWeight > 100) damageMultiplier = 1.5;
        if (defenderWeight > 150) damageMultiplier = 2.0;
    }
    // 1.5 åº”ç”¨æ¡ä»¶å¢ä¼¤ä¿®æ­£
    if (damageMultiplier > 1.0) {
        const bonusDmg = impact.rawDamage * (damageMultiplier - 1);
        if ((impact.rawDamage + bonusDmg) >= defender.currHp) {
            score += 3000;
            console.log(`[AI CRITICAL] ${moveName} ç»è¿‡æ¡ä»¶ä¿®æ­£åå¯æ–©æ€!`);
        } else {
            score += Math.min(2000, bonusDmg / attacker.maxHp * 1000);
        }
    }
    // =========================================================
    // ã€Extension 2ã€‘å¤§çˆ†ç‚¸æˆ˜æœ¯é€»è¾‘ (Explosion / Self-Destruct)
    // =========================================================
    if (moveName === 'Explosion' || moveName === 'Self-Destruct' || moveName === 'Misty Explosion') {
        let enemyCount = 1;
        if (typeof battle !== 'undefined' && battle.playerParty) {
            enemyCount = battle.playerParty.filter(p => p && p.currHp > 0).length;
        }
        const canKill = impact.rawDamage >= defender.currHp;
        const myHpPct = attacker.currHp / attacker.maxHp;
        // Case A: è‡ªå·±æ®‹è¡€ï¼ˆ<15%ï¼‰ï¼ŒåºŸç‰©åˆ©ç”¨
        if (myHpPct < 0.15) {
            score += 5000;
            console.log(`[AI EXPLOSION] æ®‹è¡€è‡ªçˆ†: ${moveName} (+5000)`);
        }
        // Case B: èƒ½ç¡®æ€ä¸”å¯¹æ‰‹æ˜¯æœ€åä¸€åª -> ç»ˆç»“æ¯”èµ›
        else if (canKill && enemyCount === 1) {
            score += 10000;
            console.log(`[AI EXPLOSION] ç»ˆç»“æ¯”èµ›: ${moveName} (+10000)`);
        }
        // Case C: èƒ½æ€ä¸”å¯¹æ‰‹å¨èƒå¤§
        else if (canKill && myHpPct < 0.5) {
            score += 2000;
            console.log(`[AI EXPLOSION] ä¸€æ¢ä¸€: ${moveName} (+2000)`);
        }
        // Case D: æ»¡è¡€ä¸”æ€ä¸æ­»å¯¹æ‰‹ -> ä¸¥ç¦ä½¿ç”¨
        else {
            console.log(`[AI BAN] ${moveName} æ€ä¸æ­»äººäºèŠ‚å¥ï¼Œç¦ç”¨`);
            return -9999;
        }
    }
    // =========================================================
    // ã€Extension 3ã€‘çªè¢­é¢„åˆ¤é€»è¾‘ (Sucker Punch / Thunderclap)
    // =========================================================
    if (moveName === 'Sucker Punch' || moveName === 'Thunderclap') {
        // è¿ç»­ä½¿ç”¨æƒ©ç½š
        if (attacker.lastMoveUsed === moveName) {
            console.log(`[AI SMART] è¿ç»­çªè¢­æƒ©ç½š: ${moveName}`);
            score -= 500;
        }
        // é¢„æµ‹å¯¹æ‰‹è¡Œä¸ºï¼šå¦‚æœå¯¹æ‰‹å¨èƒå°ï¼Œå¯èƒ½ç”¨å˜åŒ–æŠ€ï¼Œçªè¢­ä¼šå¤±è´¥
        // ç®€åŒ–åˆ¤æ–­ï¼šå¯¹æ‰‹æ®‹è¡€æ—¶çªè¢­æœ‰æ•ˆï¼ˆæ”¶å‰²ï¼‰ï¼Œå¯¹æ‰‹å¥åº·ä¸”å¨èƒå°æ—¶é£é™©é«˜
        const defHpPct = defender.currHp / defender.maxHp;
        if (defHpPct < 0.2) {
            // å¯¹æ‰‹æ®‹è¡€ï¼Œçªè¢­æ”¶å‰²
            score += 1000;
            console.log(`[AI SMART] çªè¢­æ”¶å‰²æ®‹è¡€: ${moveName} (+1000)`);
        } else if (defHpPct > 0.7) {
            // å¯¹æ‰‹å¥åº·ï¼Œå¯èƒ½ä¼šç”¨å˜åŒ–æŠ€
            // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰å¼ºåŒ–/å›å¤æŠ€èƒ½å€¾å‘
            const defenderIsSetupType = (defender.spa || 0) > (defender.atk || 0) * 1.2 || 
                                        (defender.def || 0) > 100 || (defender.spd || 0) > 100;
            if (defenderIsSetupType) {
                score -= 800;
                console.log(`[AI SMART] å¯¹æ‰‹å¯èƒ½å¼ºåŒ–ï¼Œçªè¢­é£é™©é«˜: ${moveName} (-800)`);
            }
        }
    }
    // =========================================================
    // ã€Extension 4ã€‘ç¡¬ç›´/è“„åŠ›æŠ€èƒ½é£é™©è¯„ä¼°
    // =========================================================
    const rechargeMoves = ['Hyper Beam', 'Giga Impact', 'Hydro Cannon', 'Blast Burn', 'Frenzy Plant', 'Roar of Time', 'Eternabeam', 'Prismatic Laser', 'Meteor Assault'];
    const chargeMoves = ['Solar Beam', 'Solar Blade', 'Meteor Beam', 'Sky Attack', 'Skull Bash'];
    const weather = (typeof battle !== 'undefined' && battle.field) ? battle.field.weather : '';
    // 4.1 ç¡¬ç›´æŠ€èƒ½ (éœ€è¦ä¸‹å›åˆä¸èƒ½åŠ¨)
    if (rechargeMoves.includes(moveName)) {
        if (impact.rawDamage < defender.currHp) {
            // æ‰“ä¸æ­»äººï¼Œä¸‹å›åˆæ˜¯æ´»é¶å­
            score -= 8000;
            console.log(`[AI SMART] ${moveName} æ— æ³•æ–©æ€ï¼Œç¡¬ç›´é£é™©ï¼Œç¦ç”¨`);
        } else {
            // èƒ½æ‰“æ­»ï¼Œä½†ä»æœ‰é£é™©
            score -= 500;
            // ç”¨ç ´åæ­»å…‰æ€æ®‹è¡€æ˜¯æµªè´¹
            if (defender.currHp < 50) {
                score -= 5000;
                console.log(`[AI SMART] æ²¡å¿…è¦ç”¨ ${moveName} æ€æ®‹è¡€`);
            }
        }
    }
    // 4.2 è“„åŠ›æŠ€èƒ½ (Solar Beam ç­‰)
    if (chargeMoves.includes(moveName)) {
        const isSolar = moveName.includes('Solar');
        const hasSun = (weather === 'sunnyday' || weather === 'desolateland');
        const hasHerb = (attacker.item || '').toLowerCase().includes('power herb') || 
                        (attacker.item || '').includes('å¼ºåŠ›é¦™è‰');
        if (isSolar && !hasSun && !hasHerb) {
            // æ²¡æœ‰æ™´å¤©ä¹Ÿæ²¡æœ‰å¼ºåŠ›é¦™è‰ï¼Œè“„åŠ›å›åˆæ˜¯é€
            score -= 5000;
            console.log(`[AI SMART] æ™´å¤©/é¦™è‰ç¼ºå¤±ï¼Œç¦æ­¢è£¸æ‰“ ${moveName}`);
        } else if (hasSun || hasHerb) {
            // å³å‘çŠ¶æ€ï¼Œè¿™æ˜¯å¥½æŠ€èƒ½
            score += 500;
        }
        // Meteor Beam ç‰¹æ®Šå¤„ç†ï¼šè“„åŠ›æ—¶ +1 ç‰¹æ”»
        if (moveName === 'Meteor Beam' && !hasHerb) {
            // æ²¡æœ‰é¦™è‰ä½†èƒ½å¼ºåŒ–ï¼Œé£é™©é™ä½
            score -= 2000; // ä»æœ‰é£é™©ä½†ä¸æ˜¯å®Œå…¨ç¦ç”¨
        }
    }
    // =========================================================
    // ã€Extension 5ã€‘è®¾ç½®å‹æŠ€èƒ½è¯„ä¼° (Charge/Defense Curl/Laser Focus)
    // è¿™äº›æŠ€èƒ½éœ€è¦ä¸‹å›åˆæ‰èƒ½å‘æŒ¥æ•ˆæœï¼Œéœ€è¦è¯„ä¼°ä½¿ç”¨æ—¶æœº
    // =========================================================
    const setupVolatileMoves = {
        'Charge': { volatile: 'charge', benefit: 'Electric moves x2' },
        'Defense Curl': { volatile: 'defensecurl', benefit: 'Rollout/Ice Ball x2' },
        'Laser Focus': { volatile: 'laserfocus', benefit: 'Next attack crits' }
    };
    if (setupVolatileMoves[moveName]) {
        const setupInfo = setupVolatileMoves[moveName];
        const hpPercent = attacker.currHp / attacker.maxHp;
        // å·²æœ‰è¯¥çŠ¶æ€ï¼Œä¸éœ€è¦é‡å¤ä½¿ç”¨
        if (attacker.volatile && attacker.volatile[setupInfo.volatile]) {
            score -= 5000;
            console.log(`[AI SETUP] ${moveName}ï¼šå·²æœ‰ ${setupInfo.volatile} çŠ¶æ€ï¼Œç¦æ­¢é‡å¤ä½¿ç”¨`);
        }
        // æ®‹è¡€æ—¶ä¸è¦ç”¨è®¾ç½®æŠ€èƒ½
        else if (hpPercent < 0.35) {
            score -= 3000;
            console.log(`[AI SETUP] ${moveName}ï¼šæ®‹è¡€ (${Math.round(hpPercent * 100)}%) ä¸åº”ä½¿ç”¨è®¾ç½®æŠ€èƒ½`);
        }
        // Chargeï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç”µç³»æŠ€èƒ½å¯ä»¥å—ç›Š
        else if (moveName === 'Charge') {
            const hasElectricMove = attacker.moves && attacker.moves.some(m => {
                const merged = getMergedMoveData(m);
                return merged.type === 'Electric' && (merged.basePower || merged.power || 0) >= 60;
            });
            if (!hasElectricMove) {
                score -= 5000;
                console.log(`[AI SETUP] Chargeï¼šæ²¡æœ‰é«˜å¨åŠ›ç”µç³»æŠ€èƒ½ï¼Œæ— æ„ä¹‰`);
            } else if (hpPercent > 0.6) {
                score += 50; // è¡€é‡å¥åº·æ—¶å¯ä»¥è€ƒè™‘
            }
        }
        // Defense Curlï¼šæ£€æŸ¥æ˜¯å¦æœ‰ Rollout/Ice Ball
        else if (moveName === 'Defense Curl') {
            const hasRollout = attacker.moves && attacker.moves.some(m => 
                m.name === 'Rollout' || m.name === 'Ice Ball'
            );
            if (!hasRollout) {
                // æ²¡æœ‰æ»šåŠ¨/å†°çƒï¼Œå˜åœ†åªæ˜¯æ™®é€šçš„é˜²å¾¡+1
                score -= 100; // è½»å¾®æƒ©ç½šï¼Œå› ä¸ºè¿˜æœ‰é˜²å¾¡æå‡æ•ˆæœ
            } else if (hpPercent > 0.6) {
                score += 100; // æœ‰é…åˆæŠ€èƒ½æ—¶åŠ åˆ†
            }
        }
        // Laser Focusï¼šä¸‹å›åˆå¿…å®šæš´å‡»
        else if (moveName === 'Laser Focus') {
            if (hpPercent > 0.5) {
                score += 30; // è¡€é‡å¥åº·æ—¶å¯ä»¥è€ƒè™‘
            }
        }
    }
    // æ–©æ€åŠ åˆ†
    if (impact.rawDamage >= defender.currHp) score += 5000;
    // å…ˆåˆ¶æŠ€æ–©æ€åŠ åˆ†
    const priority = move.priority || 0;
    if (priority > 0 && impact.rawDamage >= defender.currHp) score += 2000;
    // ä½è¡€é‡æ—¶ä¼˜å…ˆå…ˆåˆ¶æŠ€
    const myHpPercent = attacker.currHp / attacker.maxHp;
    if (priority > 0 && myHpPercent < 0.3) score += 500;
    // =========================================================
    // ã€æ–°å¢ã€‘æ–©æ€æ¿€åŠ± (Execution Incentive)
    // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼ŒAI åº”è¯¥ä¼˜å…ˆè¾“å‡ºè€Œä¸æ˜¯å›è¡€/è¾…åŠ©
    // =========================================================
    const defenderHpPercent = defender.currHp / defender.maxHp;
    const defenderIsLowHp = defenderHpPercent < 0.25 || (defender.currHp < 100 && myHpPercent > 0.4);
    if (defenderIsLowHp) {
        // å¯¹æ‰‹æ®‹è¡€æ—¶ï¼Œæ”»å‡»æŠ€èƒ½å¤§å¹…åŠ åˆ†
        if (category !== 'status' && move.basePower > 0) {
            score += 300; // æ®‹è¡€å¿…æ€åŠ æˆ
            // å¦‚æœèƒ½æ–©æ€ï¼Œå†åŠ åˆ†
            if (impact.rawDamage >= defender.currHp) {
                score += 200; // ç¡®ä¿æ–©æ€ä¼˜å…ˆçº§æœ€é«˜
            }
        }
    }
    // å…‹åˆ¶åŠ åˆ†
    if (eff >= 2) score += 100;
    if (eff >= 4) score += 200;
    // ã€å¼ºåŒ–ã€‘æ•ˆæœä¸å¥½å‡åˆ† - æ›´ä¸¥å‰çš„æƒ©ç½š
    // AI ä¸åº”è¯¥ç”¨æ•ˆæœä¸å¥½çš„æŠ€èƒ½ï¼Œé™¤éæ²¡æœ‰æ›´å¥½çš„é€‰æ‹©
    if (eff <= 0.5 && eff > 0) score -= 200;  // ä» -50 æ”¹ä¸º -200
    if (eff <= 0.25) score -= 500;            // ä» -100 æ”¹ä¸º -500
    // ã€æ–°å¢ã€‘å¦‚æœæœ‰æ›´å¥½çš„å±æ€§å…‹åˆ¶é€‰æ‹©ï¼Œè¿›ä¸€æ­¥æƒ©ç½šæ•ˆæœä¸å¥½çš„æŠ€èƒ½
    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æŠ€èƒ½èƒ½æ‰“å‡ºæ›´å¥½çš„æ•ˆæœ
    if (eff <= 0.5 && attacker.moves && attacker.moves.length > 1) {
        for (const otherMove of attacker.moves) {
            if (otherMove === move) continue;
            const otherMerged = getMergedMoveData(otherMove);
            const otherEff = getTypeEffectivenessAI(otherMerged.type || 'Normal', defender.types || ['Normal']);
            // å¦‚æœæœ‰æ›´å¥½çš„å±æ€§å…‹åˆ¶æŠ€èƒ½ï¼Œå¤§å¹…æƒ©ç½šå½“å‰æŠ€èƒ½
            if (otherEff > eff && (otherMerged.basePower || otherMerged.power || 0) >= 60) {
                score -= 300;
                break;
            }
        }
    }
    // ========================================
    // ã€v2.1ã€‘åä¼¤æŠ€èƒ½æ™ºèƒ½è¯„ä¼° - ç¦æ­¢è‡ªæ€å¼è¢­å‡»
    // ========================================
    const recoilMoveNames = (typeof RECOIL_MOVES !== 'undefined') ? Object.keys(RECOIL_MOVES) : 
        ['Flare Blitz', 'Brave Bird', 'Double-Edge', 'Head Smash', 'Wood Hammer', 'Wild Charge', 'Take Down', 'Submission'];
    // åä¼¤æ¯”ä¾‹è¡¨ (æ‹›å¼å -> åä¼¤æ¯”ä¾‹)
    const RECOIL_RATIOS = {
        'Head Smash': 0.50,      // 50% åä¼¤
        'Light of Ruin': 0.50,   // 50% åä¼¤
        'Flare Blitz': 0.33,     // 33% åä¼¤
        'Brave Bird': 0.33,      // 33% åä¼¤
        'Double-Edge': 0.33,     // 33% åä¼¤
        'Wood Hammer': 0.33,     // 33% åä¼¤
        'Wild Charge': 0.25,     // 25% åä¼¤
        'Take Down': 0.25,       // 25% åä¼¤
        'Submission': 0.25,      // 25% åä¼¤
    };
    if (recoilMoveNames.includes(moveName)) {
        const recoilRatio = RECOIL_RATIOS[moveName] || 0.33;
        const moveDamage = impact.rawDamage || 0;
        const expectedRecoil = Math.floor(moveDamage * recoilRatio);
        // ã€æ ¸å¿ƒé€»è¾‘ã€‘å¦‚æœåä¼¤ä¼šè‡´æ­»
        if (expectedRecoil >= attacker.currHp) {
            // æ£€æŸ¥æ•Œæ–¹å‰©ä½™å­˜æ´»æ•°é‡
            let enemyAliveCount = 1; // è‡³å°‘æœ‰å½“å‰å¯¹æ‰‹
            if (typeof battle !== 'undefined' && battle.playerParty) {
                enemyAliveCount = battle.playerParty.filter(p => p && p.currHp > 0).length;
            }
            // æ£€æŸ¥è¿™ä¸€å‡»èƒ½å¦å‡»æ€å¯¹æ‰‹
            const canKill = moveDamage >= defender.currHp;
            if (canKill && enemyAliveCount <= 1) {
                // åŒå½’äºå°½ä¸”æ˜¯æœ€åä¸€åª -> å‹‡å¾€ç›´å‰ï¼
                score += 3000;
                console.log(`[AI RECOIL] åŒå½’äºå°½æ–©æ€æœ€åä¸€åª: ${moveName} (+3000)`);
            } else if (canKill && enemyAliveCount <= 2) {
                // èƒ½æ€ä½†å¯¹é¢è¿˜æœ‰2åª -> å‹‰å¼ºå¯ä»¥æ¥å—
                score -= 500;
                console.log(`[AI RECOIL] è‡ªæ€æ¢äººå¤´(å¯¹é¢å‰©${enemyAliveCount}): ${moveName} (-500)`);
            } else {
                // è‡ªæ€ä½†æ€ä¸æ‰ æˆ– å¯¹é¢è¿˜æœ‰å¾ˆå¤š -> æåˆ‘ç¦æ­¢
                score -= 8000;
                console.log(`[AI RECOIL] ç¦æ­¢è‡ªæ€å¼è¢­å‡»: ${moveName} (-8000)`);
            }
        } else if (expectedRecoil >= attacker.currHp * 0.5) {
            // åä¼¤ä¼šæ‰ä¸€åŠè¡€ä»¥ä¸Š -> è°¨æ…ä½¿ç”¨
            if (myHpPercent < 0.5) {
                score -= 400;
            }
        } else if (myHpPercent < 0.4) {
            // åŸæœ‰é€»è¾‘ï¼šä½è¡€é‡æ—¶å‡åˆ†
            score -= 200;
        }
    }
    // ========================================
    // v2.0ï¼šæŠ˜è¿”æŠ€èƒ½æˆ˜æœ¯è¯„åˆ†
    // ========================================
    if (PIVOT_MOVES.includes(moveName)) {
        // ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å­˜æ´»é˜Ÿå‹å¯ä»¥æ¢å…¥
        // å¦‚æœæ²¡æœ‰é˜Ÿå‹äº†ï¼ŒæŠ˜è¿”æ¯«æ— æ„ä¹‰ï¼Œåº”è¯¥é€‰æ‹©é«˜ä¼¤å®³æŠ€èƒ½å¯¹æ”»
        let aliveAllies = 0;
        if (aiParty && aiParty.length > 0) {
            for (const ally of aiParty) {
                if (ally && ally !== attacker && ally.isAlive && ally.isAlive()) {
                    aliveAllies++;
                }
            }
        }
        if (aliveAllies === 0) {
            // æ²¡æœ‰é˜Ÿå‹äº†ï¼ŒæŠ˜è¿”æŠ€èƒ½å¤§å¹…å‡åˆ†ï¼ˆåªä¿ç•™åŸºç¡€ä¼¤å®³ä»·å€¼ï¼‰
            console.log(`[AI PIVOT] ${attacker.name} æ²¡æœ‰å­˜æ´»é˜Ÿå‹ï¼Œ${moveName} æŠ˜è¿”æ— æ„ä¹‰ï¼Œå¤§å¹…å‡åˆ†`);
            score -= 500; // å‡åˆ†ï¼Œè®© AI é€‰æ‹©å…¶ä»–é«˜ä¼¤å®³æŠ€èƒ½
        } else {
            // æœ‰é˜Ÿå‹æ—¶ï¼Œæ­£å¸¸è®¡ç®—æŠ˜è¿”åŠ åˆ†
            // åŸºç¡€å¥–åŠ±ï¼šçµæ´»æ€§æ€»æ˜¯å¥½çš„
            score += 300;
            const attackerSpeed = getEffectiveSpeed(attacker);
            const defenderSpeed = getEffectiveSpeed(defender);
            const isFaster = attackerSpeed > defenderSpeed;
            const isSlower = attackerSpeed < defenderSpeed;
            // å…ˆæ‰‹æŠ˜è¿” (Fast Pivot)ï¼šæ”¶å‰²æ®‹è¡€åå®‰å…¨æ’¤é€€
            if (isFaster && defender.currHp < defender.maxHp * 0.15) {
                score += 1500; // ç™½å«–ä¼¤å®³åè·‘è·¯
            }
            // åæ‰‹æŠ˜è¿” (Slow Pivot)ï¼šè®©é˜Ÿå‹æ— ä¼¤ä¸Šåœºï¼Œè¿™æ˜¯ç¥æŠ€
            // å¦‚æœæˆ‘æ¯”è¾ƒè‚‰ä¸”æ¯”å¯¹æ‰‹æ…¢
            const myBulk = (attacker.def || 80) + (attacker.spd || 80);
            if (isSlower && myBulk >= 160) {
                score += 1200; // åæ‰‹å¸¦äººæ˜¯æˆ˜æœ¯æ ¸å¿ƒ
            }
            // å¦‚æœæˆ‘çŠ¶æ€ä¸å¥½ï¼ˆèƒ½åŠ›ä¸‹é™ï¼‰ï¼ŒæŠ˜è¿”æ¸…é™¤è´Ÿé¢çŠ¶æ€
            const boosts = attacker.boosts || {};
            if ((boosts.atk || 0) <= -1 || (boosts.spa || 0) <= -1 || (boosts.spe || 0) <= -1) {
                score += 800; // ç”¨æŠ˜è¿”é‡ç½®çŠ¶æ€
            }
            // Parting Shot ç‰¹æ®ŠåŠ åˆ†ï¼ˆé™å¯¹æ‰‹èƒ½åŠ›ï¼‰
            if (moveName === 'Parting Shot') {
                score += 500;
            }
        }
    }
    return score;
}
/* =============================================================
 *  Revenge Killer é€‰æ‹© - æ™ºèƒ½æ¢äººé€»è¾‘
 * ============================================================= */
/**
 * å½“ AI çš„å®å¯æ¢¦å€’ä¸‹æ—¶ï¼Œé€‰æ‹©æœ€ä½³çš„å¤ä»‡è€…ä¸Šåœº
 * @param {Pokemon[]} party - AI é˜Ÿä¼
 * @param {Pokemon} opp - ç©å®¶å½“å‰åœºä¸Šçš„å®å¯æ¢¦
 * @param {number} currentActive - å½“å‰ï¼ˆå·²å€’ä¸‹çš„ï¼‰å®å¯æ¢¦ç´¢å¼•
 * @returns {number} - æœ€ä½³é˜Ÿå‘˜çš„ indexï¼Œ-1 è¡¨ç¤ºæ²¡æœ‰å¯ç”¨çš„
 */
function getBestRevengeKiller(party, opp, currentActive = -1) {
    if (!party || !opp) return -1;
    let bestIdx = -1;
    let bestScore = -Infinity;
    party.forEach((p, i) => {
        // è·³è¿‡æ­»äº¡çš„ã€å½“å‰åœ¨åœºçš„
        if (!p || p.currHp <= 0 || !p.moves || i === currentActive) return;
        let score = 0;
        // 1. é€Ÿåº¦ä¼˜åŠ¿ (æœ€é‡è¦çš„å¤ä»‡å‡»æ€æŒ‡æ ‡)
        const mySpe = getEffectiveSpeed(p);
        const oppSpe = getEffectiveSpeed(opp);
        if (mySpe > oppSpe) score += 300;
        // 2. ä¼¤å®³æ½œåŠ› (èƒ½å¦ç§’æ€å¯¹é¢ï¼Ÿ)
        let maxDmg = 0;
        for (const m of p.moves) {
            const mergedMove = getMergedMoveData(m);
            const result = simulateDamage(p, opp, mergedMove);
            if (result.damage > maxDmg) maxDmg = result.damage;
        }
        const oppHp = opp.currHp || 1;
        const dmgPercent = maxDmg / oppHp;
        if (dmgPercent >= 1) {
            score += 500; // ç¡®ä¸€ï¼ˆç§’æ€ï¼‰ï¼æƒé‡æé«˜
        } else {
            score += dmgPercent * 200; // èƒ½æ‰“ç—›ä¹Ÿå¥½
        }
        // 3. æŠ—æ€§ (ä¼šä¸ä¼šè¢«å¯¹é¢æ‰“æ­»ï¼Ÿ)
        let incomingDmg = 0;
        let worstEff = 1;
        for (const m of opp.moves) {
            const mergedMove = getMergedMoveData(m);
            const result = simulateDamage(opp, p, mergedMove);
            if (result.damage > incomingDmg) {
                incomingDmg = result.damage;
                worstEff = result.effectiveness || 1;
            }
        }
        // ã€æ–°å¢ã€‘å±æ€§å…‹åˆ¶æ£€æŸ¥ï¼šè¢«å…‹åˆ¶çš„å®å¯æ¢¦å¤§å¹…å‡åˆ†
        if (worstEff >= 2) {
            score -= 400; // è¢«å…‹åˆ¶ï¼Œå°½é‡ä¸é€‰
            console.log(`[AI] ${p.cnName || p.name} è¢«å¯¹æ‰‹å…‹åˆ¶ (${worstEff}x)ï¼Œå‡åˆ†`);
        } else if (worstEff === 0) {
            score += 300; // å…ç–«å¯¹æ‰‹æœ€å¼ºæŠ€èƒ½ï¼ŒåŠ åˆ†
        } else if (worstEff <= 0.5) {
            score += 150; // æŠµæŠ—å¯¹æ‰‹æœ€å¼ºæŠ€èƒ½ï¼ŒåŠ åˆ†
        }
        // æˆ‘èƒ½æŒ¨å‡ ä¸‹ï¼Ÿ
        const mySurviveTurns = incomingDmg > 0 ? (p.currHp / incomingDmg) : 999;
        if (mySurviveTurns >= 2) {
            score += 200; // èƒ½åƒä¸¤å‘ï¼Œå¾ˆç¨³
        } else if (mySurviveTurns < 1) {
            score -= 300; // ä¸Šæ¥å°±æ­»ï¼Œå°½é‡ä¸é€‰
        }
        // 4. å…ˆåˆ¶æŠ€èƒ½åŠ åˆ†
        for (const m of p.moves) {
            const mergedMove = getMergedMoveData(m);
            if ((mergedMove.priority || 0) > 0 && (mergedMove.basePower || mergedMove.power || 0) > 0) {
                const result = simulateDamage(p, opp, mergedMove);
                if (result.damage >= oppHp) {
                    score += 400; // å…ˆåˆ¶æŠ€èƒ½èƒ½ç§’æ€ï¼Œæé«˜ä¼˜å…ˆçº§
                } else {
                    score += 100; // æœ‰å…ˆåˆ¶æŠ€èƒ½
                }
            }
        }
        if (score > bestScore) {
            bestScore = score;
            bestIdx = i;
        }
    });
    console.log(`[AI] getBestRevengeKiller: best index = ${bestIdx}, score = ${bestScore}`);
    return bestIdx;
}
/* =============================================================
 *  å¯¼å‡º
 * ============================================================= */
if (typeof window !== 'undefined') {
    window.AI_DIFFICULTY = AI_DIFFICULTY;
    window.AI_ACTION_TYPE = AI_ACTION_TYPE;
    window.getAiAction = getAiAction;
    window.getExpertAiAction = getExpertAiAction;
    window.getHardAiMove = getHardAiMove;
    window.getNormalAiMove = getNormalAiMove;
    window.getEasyAiMove = getEasyAiMove;
    window.getBestRevengeKiller = getBestRevengeKiller;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        AI_DIFFICULTY,
        AI_ACTION_TYPE,
        getAiAction,
        getExpertAiAction,
        getHardAiMove,
        getNormalAiMove,
        getEasyAiMove
    };
}
]]></file>
        <file name="battle-engine.js"><![CDATA[/**
 * =============================================
 * BATTLE ENGINE - æˆ˜æ–—æ ¸å¿ƒå¼•æ“
 * =============================================
 * 
 * è´Ÿè´£ï¼š
 * - å±æ€§å…‹åˆ¶è®¡ç®—
 * - Pokemon å®ä¾‹åˆ›å»º
 * - æˆ˜æ–—çŠ¶æ€ç®¡ç†
 */
// === è½¯ç¼–ç ï¼šæ™ºèƒ½æå–åŸºç¡€å½¢æ€å ===
// ç¡¬ç¼–ç æ•°æ®å·²ç§»è‡³ move-constants.js
/**
 * ä»å®å¯æ¢¦åç§°æå–åŸºç¡€å½¢æ€IDï¼ˆç”¨äºå›¾ç‰‡å›é€€ï¼‰
 * @param {string} name åŸå§‹åç§°
 * @returns {string} åŸºç¡€å½¢æ€ID
 */
function extractBaseFormId(name = '') {
    let id = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
    // ä» move-constants.js è·å–åç¼€åˆ—è¡¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨å†…ç½®åå¤‡
    const suffixes = (typeof FORM_SUFFIXES !== 'undefined') ? FORM_SUFFIXES : [
        'starter', 'gmax', 'megax', 'megay', 'mega',
        'alola', 'galar', 'hisui', 'paldea',
        'therian', 'incarnate', 'origin', 'altered',
        'crowned', 'hero', 'eternamax', 'primal', 'ultra', 'ash', 'totem'
    ];
    // å°è¯•ç§»é™¤åç¼€
    for (const suffix of suffixes) {
        if (id.endsWith(suffix)) {
            const base = id.slice(0, -suffix.length);
            if (base.length >= 3) {
                return base;
            }
        }
    }
    return id;
}
/**
 * è·å–ç²¾çµå›¾IDï¼ˆä¿ç•™æ¨ªæ ä»¥æ”¯æŒåœ°åŒºå½¢æ€å’Œç‰¹æ®Šåå­—ï¼‰
 * ä¾‹å¦‚: "Vulpix-Alola" -> "vulpix-alola", "Ho-Oh" -> "ho-oh"
 * Mega å½¢æ€ç‰¹æ®Šå¤„ç†: "Charizard-Mega-X" -> "charizardmegax" (ç´§å‡‘æ ¼å¼)
 */
function resolveSpriteId(name = '') {
    const normalized = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
    // ã€ä¿®å¤ã€‘Mega å½¢æ€ï¼šä¿ç•™æ¨ªæ ï¼ˆShowdown æ ¼å¼ï¼‰
    // Metagross-Mega -> metagross-mega
    // Charizard-Mega-X -> charizard-mega-x
    // ä¸å†ç§»é™¤æ¨ªæ ï¼Œç›´æ¥è¿”å›è§„èŒƒåŒ–åçš„åç§°
    // å…¶ä»–å½¢æ€ï¼šä¿ç•™æ¨ªæ ï¼ˆåœ°åŒºå½¢æ€ã€ç‰¹æ®Šåå­—ç­‰ï¼‰
    return normalized;
}
/**
 * è·å–å›é€€ç²¾çµå›¾IDï¼ˆæå–åŸºç¡€å½¢æ€ï¼‰
 */
function getFallbackSpriteId(name = '') {
    return extractBaseFormId(name);
}
if (typeof window !== 'undefined') {
    window.resolveSpriteId = resolveSpriteId;
    window.extractBaseFormId = extractBaseFormId;
    window.getFallbackSpriteId = getFallbackSpriteId;
}
// === æ€§æ ¼ä¿®æ­£è¡¨ ===
// æ€§æ ¼ -> { å¢ç›Šå±æ€§: 1.1, å‡ç›Šå±æ€§: 0.9 }
// æ— ä¿®æ­£æ€§æ ¼ï¼ˆè®¤çœŸã€åŠªåŠ›ç­‰ï¼‰ä¸åœ¨æ­¤è¡¨ä¸­
const NATURE_MODIFIERS = {
    // åŠ æ”»å‡»
    'Lonely':   { atk: 1.1, def: 0.9 },
    'Adamant':  { atk: 1.1, spa: 0.9 },
    'Naughty':  { atk: 1.1, spd: 0.9 },
    'Brave':    { atk: 1.1, spe: 0.9 },
    // åŠ é˜²å¾¡
    'Bold':     { def: 1.1, atk: 0.9 },
    'Impish':   { def: 1.1, spa: 0.9 },
    'Lax':      { def: 1.1, spd: 0.9 },
    'Relaxed':  { def: 1.1, spe: 0.9 },
    // åŠ ç‰¹æ”»
    'Modest':   { spa: 1.1, atk: 0.9 },
    'Mild':     { spa: 1.1, def: 0.9 },
    'Rash':     { spa: 1.1, spd: 0.9 },
    'Quiet':    { spa: 1.1, spe: 0.9 },
    // åŠ ç‰¹é˜²
    'Calm':     { spd: 1.1, atk: 0.9 },
    'Gentle':   { spd: 1.1, def: 0.9 },
    'Careful':  { spd: 1.1, spa: 0.9 },
    'Sassy':    { spd: 1.1, spe: 0.9 },
    // åŠ é€Ÿåº¦
    'Timid':    { spe: 1.1, atk: 0.9 },
    'Hasty':    { spe: 1.1, def: 0.9 },
    'Jolly':    { spe: 1.1, spa: 0.9 },
    'Naive':    { spe: 1.1, spd: 0.9 },
};
// === å±æ€§å…‹åˆ¶è¡¨ ===
// æ”»å‡»æ–¹å±æ€§ -> { è¢«å…‹åˆ¶å±æ€§: 2, æŠµæŠ—å±æ€§: 0.5, å…ç–«å±æ€§: 0 }
const TYPE_CHART = {
    'Normal':   { weak: [],                          resist: ['Rock', 'Steel'],      immune: ['Ghost'] },
    'Fire':     { weak: ['Grass', 'Ice', 'Bug', 'Steel'], resist: ['Fire', 'Water', 'Rock', 'Dragon'], immune: [] },
    'Water':    { weak: ['Fire', 'Ground', 'Rock'],  resist: ['Water', 'Grass', 'Dragon'], immune: [] },
    'Electric': { weak: ['Water', 'Flying'],         resist: ['Electric', 'Grass', 'Dragon'], immune: ['Ground'] },
    'Grass':    { weak: ['Water', 'Ground', 'Rock'], resist: ['Fire', 'Grass', 'Poison', 'Flying', 'Bug', 'Dragon', 'Steel'], immune: [] },
    'Ice':      { weak: ['Grass', 'Ground', 'Flying', 'Dragon'], resist: ['Fire', 'Water', 'Ice', 'Steel'], immune: [] },
    'Fighting': { weak: ['Normal', 'Ice', 'Rock', 'Dark', 'Steel'], resist: ['Poison', 'Flying', 'Psychic', 'Bug', 'Fairy'], immune: ['Ghost'] },
    'Poison':   { weak: ['Grass', 'Fairy'],          resist: ['Poison', 'Ground', 'Rock', 'Ghost'], immune: ['Steel'] },
    'Ground':   { weak: ['Fire', 'Electric', 'Poison', 'Rock', 'Steel'], resist: ['Grass', 'Bug'], immune: ['Flying'] },
    'Flying':   { weak: ['Grass', 'Fighting', 'Bug'], resist: ['Electric', 'Rock', 'Steel'], immune: [] },
    'Psychic':  { weak: ['Fighting', 'Poison'],      resist: ['Psychic', 'Steel'],   immune: ['Dark'] },
    'Bug':      { weak: ['Grass', 'Psychic', 'Dark'], resist: ['Fire', 'Fighting', 'Poison', 'Flying', 'Ghost', 'Steel', 'Fairy'], immune: [] },
    'Rock':     { weak: ['Fire', 'Ice', 'Flying', 'Bug'], resist: ['Fighting', 'Ground', 'Steel'], immune: [] },
    'Ghost':    { weak: ['Psychic', 'Ghost'],        resist: ['Dark'],               immune: ['Normal'] },
    'Dragon':   { weak: ['Dragon'],                  resist: ['Steel'],              immune: ['Fairy'] },
    'Dark':     { weak: ['Psychic', 'Ghost'],        resist: ['Fighting', 'Dark', 'Fairy'], immune: [] },
    'Steel':    { weak: ['Ice', 'Rock', 'Fairy'],    resist: ['Fire', 'Water', 'Electric', 'Steel'], immune: [] },
    'Fairy':    { weak: ['Fighting', 'Dark', 'Dragon'], resist: ['Fire', 'Poison', 'Steel'], immune: [] },
};
/**
 * è®¡ç®—å±æ€§å…‹åˆ¶å€ç‡
 * @param {string} atkType - æ”»å‡»æŠ€èƒ½å±æ€§
 * @param {string[]} defTypes - é˜²å¾¡æ–¹å±æ€§æ•°ç»„
 * @param {string} moveName - æŠ€èƒ½åç§°ï¼ˆç”¨äºç‰¹æ®Šå…‹åˆ¶è§„åˆ™ï¼‰
 * @returns {number} - å€ç‡ (0, 0.25, 0.5, 1, 2, 4)
 */
function getTypeEffectiveness(atkType, defTypes, moveName = '') {
    const chart = TYPE_CHART[atkType];
    if (!chart) return 1;
    // é˜²æŠ¤ï¼šç¡®ä¿ defTypes æ˜¯æœ‰æ•ˆæ•°ç»„
    if (!Array.isArray(defTypes) || defTypes.length === 0) {
        console.warn(`[TYPE EFFECTIVENESS] Invalid defTypes:`, defTypes, `for atkType:`, atkType);
        return 1;
    }
    let multiplier = 1;
    const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
    for (const defType of defTypes) {
        // === ç‰¹æ®Šå…‹åˆ¶è§„åˆ™ ===
        // Freeze-Dry (å†·å†»å¹²ç‡¥): å¯¹æ°´ç³»æ•ˆæœç»ä½³
        if (moveId === 'freezedry' && defType === 'Water') {
            multiplier *= 2;
            continue;
        }
        // Flying Press (é£èº«é‡å‹): åŒæ—¶å…·æœ‰æ ¼æ–—å’Œé£è¡Œå±æ€§
        // Thousand Arrows (åƒç®­): å¯¹é£è¡Œç³»ä¹Ÿæœ‰æ•ˆ
        if (moveId === 'thousandarrows' && defType === 'Flying') {
            // ä¸å…ç–«ï¼Œæ­£å¸¸è®¡ç®—
            continue;
        }
        if (chart.immune.includes(defType)) return 0;
        if (chart.weak.includes(defType)) multiplier *= 2;
        if (chart.resist.includes(defType)) multiplier *= 0.5;
    }
    return multiplier;
}
/**
 * å®å¯æ¢¦åç§°è§„èŒƒåŒ–å™¨ ("å®½è¿›"ç­–ç•¥)
 * å°† AI ç”Ÿæˆçš„è‡ªç„¶è¯­è¨€å½¢å®¹è¯è½¬æ¢ä¸ºæ ‡å‡†çš„ ID åç¼€
 * ä¾‹å¦‚: "Grimer-Alolan" -> "Grimer-Alola"
 * @param {string} rawName - åŸå§‹åç§°
 * @returns {string} è§„èŒƒåŒ–åçš„åç§°
 */
function normalizePokemonName(rawName) {
    if (!rawName) return '';
    let name = String(rawName).trim();
    // å¤„ç†å½¢å®¹è¯åç¼€ (Alolan -> Alola, Galarian -> Galar, etc.)
    const adjectiveMap = [
        { pattern: /-Alolan$/i, replacement: '-Alola' },
        { pattern: /\s+Alolan$/i, replacement: '-Alola' },
        { pattern: /-Galarian$/i, replacement: '-Galar' },
        { pattern: /\s+Galarian$/i, replacement: '-Galar' },
        { pattern: /-Hisuian$/i, replacement: '-Hisui' },
        { pattern: /\s+Hisuian$/i, replacement: '-Hisui' },
        { pattern: /-Paldean$/i, replacement: '-Paldea' },
        { pattern: /\s+Paldean$/i, replacement: '-Paldea' }
    ];
    for (const { pattern, replacement } of adjectiveMap) {
        if (pattern.test(name)) {
            const normalized = name.replace(pattern, replacement);
            console.log(`[PKM] [NORMALIZE] "${rawName}" -> "${normalized}"`);
            return normalized;
        }
    }
    return name;
}
/**
 * ä» Pokemon Showdown POKEDEX è·å–å®å¯æ¢¦æ•°æ® (å¸¦æ™ºèƒ½å›é€€æœºåˆ¶)
 * ç­–ç•¥: è§„èŒƒåŒ–åç§° -> ç›´æ¥æŸ¥æ‰¾ -> ä¿®æ­£åç¼€ -> å›é€€åˆ°åŸºç¡€å½¢æ€
 * @param {string} name - è‹±æ–‡å (å¦‚ 'Pikachu')
 * @returns {object|null}
 */
function getPokemonData(name) {
    if (typeof POKEDEX === 'undefined') return null;
    // === ç¬¬ä¸€æ­¥: è§„èŒƒåŒ–åç§° (å®½è¿›) ===
    const normalizedName = normalizePokemonName(name);
    let id = normalizedName.toLowerCase().replace(/[^a-z0-9]/g, '');
    // === ç¬¬äºŒæ­¥: ç›´æ¥æŸ¥æ‰¾ ===
    if (POKEDEX[id]) {
        const data = POKEDEX[id];
        return {
            name: data.name,
            types: data.types || ['Normal'],
            baseStats: data.baseStats
        };
    }
    // === ç¬¬ä¸‰æ­¥: ä¿®æ­£å¸¸è§çš„å½¢å®¹è¯åç¼€é”™è¯¯ ===
    const suffixFixes = [
        { from: 'alolan', to: 'alola' },
        { from: 'galarian', to: 'galar' },
        { from: 'hisuian', to: 'hisui' },
        { from: 'paldean', to: 'paldea' }
    ];
    for (const fix of suffixFixes) {
        if (id.endsWith(fix.from)) {
            const fixedId = id.slice(0, -fix.from.length) + fix.to;
            if (POKEDEX[fixedId]) {
                console.log(`[PKM] [SUFFIX FIX] "${id}" -> "${fixedId}"`);
                const data = POKEDEX[fixedId];
                return {
                    name: data.name,
                    types: data.types || ['Normal'],
                    baseStats: data.baseStats
                };
            }
        }
    }
    // === ç¬¬å››æ­¥: æ™ºèƒ½å›é€€åˆ°åŸºç¡€å½¢æ€ ===
    const splitChars = ['-', ' '];
    for (const splitChar of splitChars) {
        if (normalizedName.includes(splitChar)) {
            const potentialBaseName = normalizedName.split(splitChar)[0];
            if (potentialBaseName && potentialBaseName !== normalizedName) {
                const baseId = potentialBaseName.toLowerCase().replace(/[^a-z0-9]/g, '');
                if (POKEDEX[baseId]) {
                    console.log(`[PKM] [FALLBACK] Using base species "${potentialBaseName}" instead of "${normalizedName}"`);
                    const data = POKEDEX[baseId];
                    return {
                        name: data.name,
                        types: data.types || ['Normal'],
                        baseStats: data.baseStats
                    };
                }
            }
        }
    }
    // === ç¬¬äº”æ­¥: æ‰¾ä¸åˆ° ===
    console.warn(`[PKM] [NOT FOUND] Pokemon "${name}" not found in POKEDEX`);
    return null;
}
/**
 * ä» Pokemon Showdown MOVES è·å–æŠ€èƒ½æ•°æ®
 * @param {string} name - è‹±æ–‡å (å¦‚ 'Thunderbolt')
 * @returns {object} åŒ…å«æ‰€æœ‰åŸå§‹æ•°æ® + æ ‡å‡†åŒ–å­—æ®µ
 */
function getMoveData(name) {
    const id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const data = typeof MOVES !== 'undefined' ? MOVES[id] : null;
    if (!data) {
        return { name: name, type: 'Normal', power: 40, cat: 'phys', accuracy: 100 };
    }
    // === CRITICAL FIX ===
    // ä½¿ç”¨ spread operator ä¿ç•™æ‰€æœ‰åŸå§‹æ•°æ®ï¼ˆaccuracy, multihit, recoil, drain, secondary ç­‰ï¼‰
    // åŒæ—¶æ·»åŠ æ ‡å‡†åŒ–å­—æ®µä¾› API è°ƒç”¨
    // === åŠ¨æ€å¨åŠ›æŠ€èƒ½è¡¥ä¸ ===
    // è¿™äº›æŠ€èƒ½çš„ basePower åœ¨åŸæ•°æ®ä¸­æ˜¯ 0 æˆ– nullï¼ˆéœ€è¦è¿è¡Œæ—¶è®¡ç®—ï¼‰ï¼Œç»™å®ƒä»¬å›ºå®šå¨åŠ›
    const dynamicPowerPatches = {
        'gyroball': 80,         // é™€èºçƒï¼šé€Ÿåº¦å·®è®¡ç®—ï¼Œå¹³å‡çº¦80
        'electroball': 80,      // ç”µçƒï¼šé€Ÿåº¦å·®è®¡ç®—
        'grassknot': 80,        // æ‰“è‰ç»“ï¼šä½“é‡è®¡ç®—
        'lowkick': 80,          // è¸¢å€’ï¼šä½“é‡è®¡ç®—
        'heatcrash': 80,        // é«˜æ¸©é‡å‹ï¼šä½“é‡è®¡ç®—
        'heavyslam': 80,        // é‡ç£…å†²æ’ï¼šä½“é‡è®¡ç®—
        'fling': 50,            // æŠ•æ·ï¼šé“å…·å¨åŠ›
        'return': 102,          // æŠ¥æ©ï¼šæ»¡äº²å¯†åº¦
        'frustration': 102,     // è¿æ€’ï¼šæ»¡ä¸äº²å¯†
        'punishment': 70,       // æƒ©ç½šï¼šèƒ½åŠ›å˜åŒ–
        'storedpower': 80,      // è¾…åŠ©åŠ›é‡ï¼šèƒ½åŠ›å˜åŒ–
        'reversal': 100,        // ç»å¤„é€¢ç”Ÿï¼šä½è¡€é«˜å¨åŠ›
        'flail': 100,           // æŒ£æ‰ï¼šä½è¡€é«˜å¨åŠ›
        'eruption': 150,        // å–·ç«ï¼šæ»¡è¡€å¨åŠ›
        'waterspout': 150,      // å–·æ°´ï¼šæ»¡è¡€å¨åŠ›
        'crushgrip': 100,       // æ¡ç¢ï¼šå¯¹æ–¹è¡€é‡
        'wringout': 100,        // ç»ç´§ï¼šå¯¹æ–¹è¡€é‡
        'naturalgift': 80,      // è‡ªç„¶ä¹‹æ©ï¼šæ ‘æœ
        'trumpcard': 80,        // ç‹ç‰Œï¼šPP
        'spitup': 100,          // å–·å‡ºï¼šè“„åŠ›æ¬¡æ•°
        'present': 60,          // ç¤¼ç‰©ï¼šéšæœº
        'magnitude': 70,        // éœ‡çº§ï¼šéšæœº
    };
    let finalPower = data.basePower || 0;
    const moveId = id.toLowerCase();
    if (dynamicPowerPatches[moveId]) {
        finalPower = dynamicPowerPatches[moveId];
    }
    return {
        ...data, // ä¿ç•™æ‰€æœ‰é«˜çº§å±æ€§ï¼
        // æ ‡å‡†åŒ–å­—æ®µ
        name: data.name || name,
        type: data.type || 'Normal',
        power: finalPower,
        cat: data.category === 'Special' ? 'spec' : (data.category === 'Physical' ? 'phys' : 'status'),
        accuracy: (data.accuracy === true) ? true : (data.accuracy === undefined ? 100 : data.accuracy)
    };
}
/**
 * è®¡ç®—èƒ½åŠ›å€¼ (æ”¯æŒæ–°ç‰ˆ stats_meta æ ¼å¼)
 * 
 * @param {object} baseStats - { hp, atk, def, spa, spd, spe }
 * @param {number} level - ç­‰çº§
 * @param {object} options - å¯é€‰å‚æ•°
 * @param {object} options.ivs - ä¸ªä½“å€¼å¯¹è±¡ { hp, atk, def, spa, spd, spe }ï¼Œé»˜è®¤å…¨31
 * @param {number} options.ev_level - ç»Ÿä¸€åŠªåŠ›å€¼ç­‰çº§ (0~252)ï¼Œä¼šåŒæ—¶åŠ åˆ°å…­é¡¹
 * @param {string} options.nature - æ€§æ ¼åç§°ï¼Œç”¨äºä¿®æ­£èƒ½åŠ›å€¼
 * @returns {object} è®¡ç®—åçš„èƒ½åŠ›å€¼ { hp, atk, def, spa, spd, spe }
 */
function calcStats(baseStats, level, options = {}) {
    // å…¼å®¹æ—§ç‰ˆè°ƒç”¨: calcStats(baseStats, level, iv, ev)
    let ivs, evs, nature;
    if (typeof options === 'number') {
        // æ—§ç‰ˆè°ƒç”¨æ–¹å¼
        const oldIv = options;
        const oldEv = arguments[3] || 0;
        ivs = { hp: oldIv, atk: oldIv, def: oldIv, spa: oldIv, spd: oldIv, spe: oldIv };
        evs = { hp: oldEv, atk: oldEv, def: oldEv, spa: oldEv, spd: oldEv, spe: oldEv };
        nature = null;
    } else {
        // æ–°ç‰ˆè°ƒç”¨æ–¹å¼
        ivs = options.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
        // æ”¯æŒä¸‰ç§ ev_level æ ¼å¼ï¼š
        // 1. æ•°å­— (ç»Ÿä¸€å€¼): 252 -> æ‰€æœ‰é¡¹éƒ½æ˜¯ 252
        // 2. æ•°ç»„ [HP, Atk, Def, SpA, SpD, Spe]: [252, 0, 0, 252, 6, 0]
        // 3. å¯¹è±¡ { hp, atk, def, spa, spd, spe }
        const evInput = options.ev_level;
        if (Array.isArray(evInput)) {
            // æ•°ç»„æ ¼å¼: [HP, Atk, Def, SpA, SpD, Spe]
            evs = {
                hp: evInput[0] || 0,
                atk: evInput[1] || 0,
                def: evInput[2] || 0,
                spa: evInput[3] || 0,
                spd: evInput[4] || 0,
                spe: evInput[5] || 0
            };
        } else if (typeof evInput === 'object' && evInput !== null) {
            // å¯¹è±¡æ ¼å¼
            evs = evInput;
        } else {
            // æ•°å­—æ ¼å¼ (ç»Ÿä¸€å€¼)
            const evLevel = evInput !== undefined ? evInput : 0;
            evs = { hp: evLevel, atk: evLevel, def: evLevel, spa: evLevel, spd: evLevel, spe: evLevel };
        }
        nature = options.nature || null;
    }
    // è·å–æ€§æ ¼ä¿®æ­£
    const natureMod = nature ? (NATURE_MODIFIERS[nature] || {}) : {};
    // HP è®¡ç®—å…¬å¼ï¼ˆHP ä¸å—æ€§æ ¼å½±å“ï¼‰
    const calcHP = (base, iv, ev) => {
        return Math.floor((2 * base + iv + ev / 4) * level / 100) + level + 10;
    };
    // å…¶ä»–èƒ½åŠ›è®¡ç®—å…¬å¼ï¼ˆå—æ€§æ ¼å½±å“ï¼‰
    const calcOther = (base, iv, ev, statName) => {
        let val = Math.floor(((2 * base + iv + ev / 4) * level / 100 + 5));
        // åº”ç”¨æ€§æ ¼ä¿®æ­£
        if (natureMod[statName]) {
            val = Math.floor(val * natureMod[statName]);
        }
        return val;
    };
    return {
        hp: calcHP(baseStats.hp, ivs.hp || 31, evs.hp || 0),
        atk: calcOther(baseStats.atk, ivs.atk || 31, evs.atk || 0, 'atk'),
        def: calcOther(baseStats.def, ivs.def || 31, evs.def || 0, 'def'),
        spa: calcOther(baseStats.spa, ivs.spa || 31, evs.spa || 0, 'spa'),
        spd: calcOther(baseStats.spd, ivs.spd || 31, evs.spd || 0, 'spd'),
        spe: calcOther(baseStats.spe, ivs.spe || 31, evs.spe || 0, 'spe')
    };
}
/**
 * Pokemon æˆ˜æ–—å®ä¾‹
 * ä» Pokemon Showdown POKEDEX æŸ¥è¡¨åˆ›å»ºï¼Œè‡ªåŠ¨è®¡ç®—èƒ½åŠ›å€¼
 * 
 * æ”¯æŒä¸¤ç§æ„é€ æ–¹å¼ï¼š
 * 1. æ—§ç‰ˆï¼šnew Pokemon(name, level, moves)
 * 2. æ–°ç‰ˆï¼šnew Pokemon(config) å…¶ä¸­ config åŒ…å«å®Œæ•´çš„ stats_meta
 */
class Pokemon {
    constructor(nameOrConfig, level, moveNames = []) {
        // æ£€æµ‹æ˜¯å¦ä¸ºæ–°ç‰ˆé…ç½®å¯¹è±¡æ ¼å¼
        if (typeof nameOrConfig === 'object' && nameOrConfig !== null && nameOrConfig.name) {
            this._initFromConfig(nameOrConfig);
        } else {
            // æ—§ç‰ˆæ„é€ æ–¹å¼
            const name = nameOrConfig;
            const data = getPokemonData(name);
            if (!data) {
                console.warn(`Pokemon "${name}" not found in POKEDEX, using Pikachu`);
                const fallback = getPokemonData('Pikachu') || {
                    name: 'Pikachu', types: ['Electric'],
                    baseStats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 }
                };
                this._initLegacy('Pikachu', fallback.types, fallback.baseStats, level, moveNames);
            } else {
                this._initLegacy(name, data.types, data.baseStats, level, moveNames);
            }
        }
    }
    /**
     * æ–°ç‰ˆåˆå§‹åŒ–ï¼šä»å®Œæ•´é…ç½®å¯¹è±¡åˆ›å»º
     * @param {object} config - åŒ…å« name, lv, moves, gender, nature, ability, stats_meta ç­‰
     */
    _initFromConfig(config) {
        const name = config.name;
        const level = config.lv || config.level || 50;
        const moveNames = config.moves || [];
        const data = getPokemonData(name);
        if (!data) {
            console.warn(`Pokemon "${name}" not found in POKEDEX, using Pikachu`);
            const fallback = getPokemonData('Pikachu') || {
                name: 'Pikachu', types: ['Electric'],
                baseStats: { hp: 35, atk: 55, def: 40, spa: 50, spd: 50, spe: 90 }
            };
            this._initCore('Pikachu', fallback.types, fallback.baseStats, level, moveNames, config);
        } else {
            this._initCore(name, data.types, data.baseStats, level, moveNames, config);
        }
    }
    /**
     * æ—§ç‰ˆåˆå§‹åŒ–ï¼šå…¼å®¹æ—§çš„æ„é€ æ–¹å¼
     */
    _initLegacy(name, types, baseStats, level, moveNames) {
        this._initCore(name, types, baseStats, level, moveNames, {});
    }
    /**
     * æ ¸å¿ƒåˆå§‹åŒ–é€»è¾‘
     * @param {string} name - å®å¯æ¢¦åç§°
     * @param {string[]} types - å±æ€§æ•°ç»„
     * @param {object} baseStats - ç§æ—å€¼
     * @param {number} level - ç­‰çº§
     * @param {string[]} moveNames - æŠ€èƒ½åç§°æ•°ç»„
     * @param {object} config - é¢å¤–é…ç½® (gender, nature, ability, stats_meta, shiny ç­‰)
     */
    _initCore(name, types, baseStats, level, moveNames, config = {}) {
        this.name = name;
        // ä½¿ç”¨å¢å¼ºç‰ˆ Locale å·¥å…·è·å–ä¸­æ–‡åï¼ˆæ”¯æŒæ™ºèƒ½åç¼€è§£æï¼‰
        if (typeof window !== 'undefined' && window.Locale) {
            // Locale.get ç°åœ¨ä¼šè‡ªåŠ¨å¤„ç† "Zoroark-Hisui" -> "ç´¢ç½—äºšå…‹-æ´—ç¿ " è¿™ç±»è½¬æ¢
            this.cnName = window.Locale.get(name);
        } else {
            this.cnName = name;
        }
        this.types = types;
        this.baseStats = baseStats;
        this.level = level;
        // === æ–°å¢å±æ€§ï¼šæ€§åˆ«ã€æ€§æ ¼ã€ç‰¹æ€§ã€é—ªå…‰ ===
        this.gender = config.gender || null; // 'M', 'F', or null
        this.nature = config.nature || null; // æ€§æ ¼åç§°
        this.shiny = config.shiny || false;  // æ˜¯å¦é—ªå…‰
        // ç‰¹æ€§å¤„ç†ï¼šä¼˜å…ˆä½¿ç”¨é…ç½®ä¸­çš„ç‰¹æ€§ï¼Œå¦åˆ™ä» POKEDEX è·å–é»˜è®¤ç‰¹æ€§
        if (config.ability) {
            this.ability = config.ability;
        } else {
            // ä» POKEDEX è·å–é»˜è®¤ç‰¹æ€§ (ä½¿ç”¨è§„èŒƒåŒ–åç§°)
            const normalizedId = normalizePokemonName(name).toLowerCase().replace(/[^a-z0-9]/g, '');
            const pokeData = typeof POKEDEX !== 'undefined' ? POKEDEX[normalizedId] : null;
            if (pokeData && pokeData.abilities) {
                this.ability = pokeData.abilities['0'] || null;
            } else {
                this.ability = null;
            }
        }
        // === èƒ½åŠ›å€¼è®¡ç®— ===
        // ä¼˜å…ˆä½¿ç”¨ stats_meta ä¸­çš„å®Œæ•´æ•°æ®
        const statsMeta = config.stats_meta || {};
        let ivs, evLevel;
        if (statsMeta.ivs || statsMeta.ev_level !== undefined) {
            // æ–°ç‰ˆæ ¼å¼ï¼šä½¿ç”¨ stats_meta
            ivs = statsMeta.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
            evLevel = statsMeta.ev_level !== undefined ? statsMeta.ev_level : 0;
        } else {
            // æ—§ç‰ˆå…¼å®¹ï¼šåŠ¨æ€ EV è®¡ç®—é€»è¾‘
            // ç­‰çº§è¶Šé«˜ï¼Œç»å†çš„æˆ˜æ–—è¶Šå¤šï¼Œç§¯ç´¯çš„åŠªåŠ›å€¼å°±è¶Šé«˜
            // å…¬å¼ï¼šæ¯çº§ç»™ 1.5 çš„å•é¡¹ EVï¼Œä¸Šé™ 85 (6é¡¹ x 85 = 510 æ€»é‡)
            ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
            evLevel = Math.min(85, Math.floor(level * 1.5));
        }
        // ä¿å­˜åŸå§‹æ•°æ®ä»¥ä¾¿åç»­æŸ¥çœ‹/å¯¼å‡º
        this.statsMeta = {
            ivs: ivs,
            ev_level: evLevel
        };
        // è®¡ç®—èƒ½åŠ›å€¼
        const stats = calcStats(baseStats, level, {
            ivs: ivs,
            ev_level: evLevel,
            nature: this.nature
        });
        this.maxHp = stats.hp;
        this.currHp = stats.hp;
        this.atk = stats.atk;
        this.def = stats.def;
        this.spa = stats.spa;
        this.spd = stats.spd;
        this.spe = stats.spe;
        // === æˆ˜åœºèƒ½åŠ›å¢ç›Šç­‰çº§ (Stages) ===
        // èŒƒå›´ -6 åˆ° +6, é»˜è®¤ 0
        this.boosts = {
            atk: 0, def: 0, spa: 0, spd: 0, spe: 0,
            accuracy: 0, evasion: 0
        };
        // === ä¸Šåœºå›åˆæ•° (ç”¨äº Fake Out ç­‰é¦–å›åˆé™åˆ¶æŠ€èƒ½) ===
        this.turnsOnField = 0;
        // === æŠ€èƒ½ä½¿ç”¨è¿½è¸ª (ç”¨äºè¿ç»­ä½¿ç”¨é™åˆ¶) ===
        this.lastMoveUsed = null;       // ä¸Šå›åˆä½¿ç”¨çš„æŠ€èƒ½åç§°
        this.protectCounter = 0;        // è¿ç»­ä½¿ç”¨å®ˆä½ç±»æŠ€èƒ½çš„æ¬¡æ•°
        this.mustRecharge = false;      // æ˜¯å¦éœ€è¦è“„åŠ›/åƒµç›´ï¼ˆç ´åå…‰çº¿ç­‰ï¼‰
        // === çŠ¶æ€å¼‚å¸¸ç³»ç»Ÿ ===
        this.status = null;      // ä¸»è¦çŠ¶æ€: 'slp', 'par', 'brn', 'psn', 'tox', 'frz'
        this.volatile = {};      // ä¸´æ—¶çŠ¶æ€: { flinch: true, confusion: true }
        this.sleepTurns = 0;     // ç¡çœ å‰©ä½™å›åˆæ•°
        // =====================================================
        // === æƒ…æ„ŸåŠªåŠ›å€¼ (Affective Values - AVs) ===
        // === æ´›è¿ªäºšç‰¹åŒº (Rhodia Region) ä¸“å±ç³»ç»Ÿ ===
        // =====================================================
        // å—ç¥é¦”ç²‰é›¾ (Ambrosia) å½±å“ï¼Œå®å¯æ¢¦ä¸è®­ç»ƒå®¶çš„çµé­‚é“¾æ¥äº§ç”Ÿçš„åŠ ç‚¹
        // æ¯ä¸ªç»´åº¦ 0~255ï¼Œç±»ä¼¼ä¼ ç»Ÿ EVs ä½†å½±å“æˆ˜æ–—æœºåˆ¶è€Œéæ•°å€¼
        // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
        // 1. æ‰å¹³æ ¼å¼: { avs: { trust, passion, insight, devotion } }
        // 2. åµŒå¥—æ ¼å¼: { friendship: { avs: { trust, passion, insight, devotion } } }
        let avsConfig = config.avs || {};
        if (config.friendship) {
            // åµŒå¥—æ ¼å¼: friendship.avs
            if (config.friendship.avs) {
                avsConfig = config.friendship.avs;
            } else {
                // æ—§æ‰å¹³æ ¼å¼: friendship ç›´æ¥åŒ…å« trust/passion ç­‰
                avsConfig = config.friendship;
            }
        }
        // ã€è§£é”ç³»ç»Ÿã€‘enable_insight æ§åˆ¶ AVs ä¸Šé™
        // æœªè§£é”ï¼šä¸Šé™ 155
        // å·²è§£é”ï¼šä¸Šé™ 255
        // æ³¨æ„ï¼šè¿™é‡Œåªå­˜å‚¨åŸå§‹å€¼ï¼Œå®é™…æ•ˆæœè®¡ç®—æ—¶ä¼šæ ¹æ® enable_insight åŠ¨æ€è°ƒæ•´
        this.avs = {
            trust: avsConfig.trust || 0,       // ä¿¡èµ–ï¼šé˜²å®ˆå‘ï¼Œè‡´å‘½ä¼¤å®³æ—¶é”è¡€
            passion: avsConfig.passion || 0,   // æ¿€æƒ…ï¼šè¿›æ”»å‘ï¼Œæš´å‡»ç‡æå‡
            insight: avsConfig.insight || 0,   // çµçŠ€ï¼šå›é¿å‘ï¼Œé—ªé¿ç‡æå‡
            devotion: avsConfig.devotion || 0  // çŒ®èº«ï¼šå›å¤å‘ï¼Œå›åˆæœ«æ²»æ„ˆå¼‚å¸¸
        };
        console.log(`[AVS] ${this.name} loaded AVs (raw):`, this.avs);
        // çµé­‚ä¼™ä¼´æ ‡è®° (isAce) å’Œ Second Wind æœºåˆ¶
        this.isAce = config.isAce || false;
        this.hasSecondWind = config.hasSecondWind || false;
        // é¦–å‘æ ‡è®° (isLead) - æ ‡è®°è¯¥å®å¯æ¢¦æ˜¯å¦ä¸ºé¦–å‘å‡ºæˆ˜
        this.isLead = config.isLead || false;
        // === äº’æ–¥æœºåˆ¶ç³»ç»Ÿ (Mechanic Lock) ===
        // mechanic: 'mega' | 'dynamax' | 'zmove' | 'tera' | undefined
        this.mechanic = config.mechanic || null;
        // === æå·¨åŒ– (Dynamax) ç³»ç»Ÿ ===
        // canDynamax: æ˜¯å¦å¯ä»¥æå·¨åŒ–
        // å¦‚æœ mechanic === 'dynamax'ï¼Œè‡ªåŠ¨å¯ç”¨æå·¨åŒ–èƒ½åŠ›
        this.canDynamax = config.canDynamax || (this.mechanic === 'dynamax');
        this.isDynamaxed = false;      // å½“å‰æ˜¯å¦å¤„äºæå·¨åŒ–çŠ¶æ€
        this.dynamaxTurns = 0;         // æå·¨åŒ–å‰©ä½™å›åˆæ•°
        this.dynamax_moves = config.dynamax_moves || null; // æå·¨åŒ–æ—¶çš„æ‹›å¼åˆ—è¡¨
        // === Mega è¿›åŒ–ç›®æ ‡ ===
        // æ”¯æŒ mega_target æˆ– mega å­—æ®µï¼ˆç”¨äº G-Max å½¢æ€ç­‰ï¼‰
        // æ³¨æ„ï¼šè¿™é‡Œåªè®¾ç½® megaTargetIdï¼ŒcanMegaEvolve ç”± autoDetectMegaEligibility å¤„ç†
        const megaTarget = config.mega_target || config.mega;
        if (megaTarget) {
            this.megaTargetId = megaTarget;
            // ã€ä¿®å¤ã€‘åªæœ‰å½“ mechanic ä¸æ˜¯ 'mega' æ—¶ï¼Œæ‰æ ¹æ® gmax è®¾ç½® canDynamax
            // mechanic å­—æ®µæ˜¯æœ€é«˜æƒå¨ï¼Œä¸åº”è¢« mega_target åŠ«æŒ
            if (megaTarget.includes('gmax') && this.mechanic !== 'mega') {
                this.canDynamax = true;
            }
        }
        // === Z æ‹›å¼é…ç½® ===
        // z_move_config: { base_move, target_move, is_unique, trigger_text }
        this.z_move_config = config.z_move_config || null;
        // === å¤ªæ™¶åŒ– (Terastallization) ç³»ç»Ÿ ===
        // teraType: å¤ªæ™¶åŒ–åçš„å±æ€§ (é¢„è®¾å‹)
        // å¦‚æœæ²¡é…ç½®ï¼Œé»˜è®¤ fallback åˆ°ç¬¬ä¸€å±æ€§
        this.teraType = config.tera_type || config.teraType || this.types[0] || 'Normal';
        this.isTerastallized = false;       // å½“å‰æ˜¯å¦å¤„äºå¤ªæ™¶åŒ–çŠ¶æ€
        this.originalTypes = [...this.types]; // ä¿å­˜åŸå§‹å±æ€§ (ç”¨äº STAB å›æº¯)
        // canTera: æ˜¯å¦å¯ä»¥å¤ªæ™¶åŒ– (ç”± mechanic å†³å®š)
        this.canTera = (this.mechanic === 'tera');
        // === é“å…· ===
        this.item = config.item || null;
        // è°ƒè¯•æ—¥å¿—ï¼šç¡®è®¤æ–°å­—æ®µæ˜¯å¦æ­£ç¡®è§£æ
        if (this.mechanic || this.z_move_config || this.dynamax_moves || this.canDynamax || this.canTera) {
            console.log(`[MECHANIC] ${this.name} initialized with:`, {
                mechanic: this.mechanic,
                canDynamax: this.canDynamax,
                canTera: this.canTera,
                teraType: this.teraType,
                megaTargetId: this.megaTargetId,
                z_move_config: this.z_move_config,
                dynamax_moves: this.dynamax_moves,
                item: this.item
            });
        }
        // AVs è§¦å‘è®°å½•ï¼ˆæ¯åœºæˆ˜æ–—åªè§¦å‘ä¸€æ¬¡çš„æ•ˆæœï¼‰
        this.avsTriggered = {
            trustEndure: false,  // Trust é”è¡€æ˜¯å¦å·²è§¦å‘
            passionKill: false   // Passion å‡»æ€åŠ æˆæ˜¯å¦å·²è§¦å‘
        };
        const safeMoves = Array.isArray(moveNames) ? moveNames : [];
        this.moves = safeMoves.map(mn => {
            const id = (mn || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            const rawData = typeof MOVES !== 'undefined' ? MOVES[id] : null;
            let md = getMoveData(mn);
            if (!rawData) {
                const randomFallback = FALLBACK_MOVES[Math.floor(Math.random() * FALLBACK_MOVES.length)];
                md = getMoveData(randomFallback);
            }
            // ä½¿ç”¨ Locale å·¥å…·è·å–æŠ€èƒ½ä¸­æ–‡å
            const cnName = (typeof window !== 'undefined' && window.Locale) ? window.Locale.get(md.name) : md.name;
            return { name: md.name, cn: cnName, type: md.type, power: md.power || 0, cat: md.cat || 'phys' };
        });
        // å¦‚æœæ²¡ç»™æŠ€èƒ½æˆ–è¿‡æ»¤åä¸ºç©ºï¼Œç»™ä¸ªé»˜è®¤çš„
        if (this.moves.length === 0) {
            const tackleCN = (typeof window !== 'undefined' && window.Locale) ? window.Locale.get('Tackle') : 'Tackle';
            this.moves = [{ name: 'Tackle', cn: tackleCN, type: 'Normal', power: 40, cat: 'phys' }];
        }
    }
    /**
     * è·å–æœ‰æ•ˆ AVs å€¼ï¼ˆè€ƒè™‘ enable_insight / enable_styles è§£é”é™åˆ¶ï¼‰
     * @param {string} stat - AVs å±æ€§å: 'trust', 'passion', 'insight', 'devotion'
     * @returns {number} æœ‰æ•ˆçš„ AVs å€¼
     */
    getEffectiveAVs(stat) {
        if (!this.avs || !this.avs[stat]) return 0;
        const rawValue = this.avs[stat];
        // è·å–è§£é”çŠ¶æ€ï¼ˆåŒºåˆ†ç©å®¶å’Œæ•Œæ–¹ï¼‰
        // é€šè¿‡æ£€æŸ¥å½“å‰å®å¯æ¢¦æ˜¯å¦åœ¨ç©å®¶é˜Ÿä¼ä¸­æ¥åˆ¤æ–­
        let insightUnlocked = false;
        if (typeof battle !== 'undefined') {
            const isPlayerPokemon = battle.playerParty && battle.playerParty.includes(this);
            if (isPlayerPokemon) {
                // ç©å®¶å®å¯æ¢¦ï¼šæ£€æŸ¥ playerUnlocks
                const unlocks = battle.playerUnlocks || {};
                insightUnlocked = unlocks.enable_insight === true || unlocks.enable_styles === true;
            } else {
                // æ•Œæ–¹å®å¯æ¢¦ï¼šæ£€æŸ¥ enemyUnlocks
                const unlocks = battle.enemyUnlocks || {};
                insightUnlocked = unlocks.enable_insight === true || unlocks.enable_styles === true;
            }
        }
        // æœªè§£é”ï¼šä¸Šé™ 155
        // å·²è§£é”ï¼šä¸Šé™ 255ï¼Œä¸”åœ¨ 255 æ—¶æœ‰é¢å¤–åŠ æˆï¼ˆé€šè¿‡ avsEvolutionBoost æˆ–å…¶ä»–æœºåˆ¶ï¼‰
        const cap = insightUnlocked ? 255 : 155;
        const cappedValue = Math.min(rawValue, cap);
        // å¦‚æœå·²è§£é”ä¸”è¾¾åˆ°æ»¡å€¼ 255ï¼Œç»™äºˆ 1.1x åŠ æˆ
        if (insightUnlocked && rawValue >= 255) {
            return Math.floor(cappedValue * 1.1);
        }
        return cappedValue;
    }
    // è·å–ç²¾çµå›¾ URL
    getSprite(isBack = false) {
        // éå®˜æ–¹ Megaï¼šè¿”å›åŸºç¡€å½¢æ€çš„å›¾ç‰‡ URL
        if (this.isUnofficialMega && this.megaTargetId) {
            const baseSpecies = this.megaTargetId.replace(/mega.*$/i, '');
            const folder = isBack ? 'ani-back' : 'ani';
            return `https://play.pokemonshowdown.com/sprites/${folder}/${baseSpecies}.gif`;
        }
        const id = resolveSpriteId(this.name);
        let folder = isBack ? 'ani-back' : 'ani';
        // Mega å½¢æ€å¼ºåˆ¶ä½¿ç”¨æ™®é€šè‰²ï¼ˆé¿å…å¼‚è‰² Mega èµ„æºç¼ºå¤±ï¼‰
        const isMegaForm = /mega|primal/i.test(this.name);
        if (this.shiny && !isMegaForm) {
            folder += '-shiny';
        }
        return `https://play.pokemonshowdown.com/sprites/${folder}/${id}.gif`;
    }
    // è·å–å›é€€ç²¾çµå›¾ URLï¼ˆåŸºç¡€å½¢æ€ï¼‰
    getFallbackSprite(isBack = false) {
        const id = getFallbackSpriteId(this.name);
        let folder = isBack ? 'ani-back' : 'ani';
        // Mega å½¢æ€å¼ºåˆ¶ä½¿ç”¨æ™®é€šè‰²ï¼ˆé¿å…å¼‚è‰² Mega èµ„æºç¼ºå¤±ï¼‰
        const isMegaForm = /mega|primal/i.test(this.name);
        if (this.shiny && !isMegaForm) {
            folder += '-shiny';
        }
        return `https://play.pokemonshowdown.com/sprites/${folder}/${id}.gif`;
    }
    // æ˜¯å¦å­˜æ´»
    isAlive() {
        return this.currHp > 0;
    }
    // å—ä¼¤
    // @param {number} dmg - ä¼¤å®³å€¼
    // @param {string} category - ä¼¤å®³ç±»å‹ ('physical'/'special'/null)ï¼Œç”¨äº Counter/Mirror Coat
    takeDamage(dmg, category = null) {
        // === è®°å½•æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ï¼ˆç”¨äº Counter/Mirror Coatï¼‰===
        if (!this.turnData) this.turnData = {};
        if (dmg > 0 && category) {
            this.turnData.lastDamageTaken = {
                amount: dmg,
                category: category.toLowerCase()
            };
        }
        // Focus Sash (æ°”åŠ¿æŠ«å¸¦): æ»¡è¡€æ—¶ï¼Œè‡´å‘½ä¼¤å®³åªä¼šè®© HP å‰© 1
        // ä½¿ç”¨ items-data.js çš„ ItemEffects å¤„ç†å™¨
        if (typeof ItemEffects !== 'undefined' && ItemEffects.checkFocusSash) {
            if (ItemEffects.checkFocusSash(this, dmg)) {
                console.log(`[ITEM] ${this.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            }
        } else {
            // Fallback: å…¼å®¹æ—§é€»è¾‘
            const itemName = (this.item || '').toLowerCase().replace(/[^a-z]/g, '');
            if (itemName === 'focussash' && this.currHp === this.maxHp && dmg >= this.currHp) {
                this.currHp = 1;
                this.item = null;
                this.focusSashTriggered = true;
                console.log(`[ITEM] ${this.cnName} çš„æ°”åŠ¿æŠ«å¸¦å‘åŠ¨äº†ï¼`);
                return;
            }
        }
        // =====================================================
        // === AVs: Trust (ä¿¡èµ–) - Sync Guard é”è¡€æ•ˆæœ ===
        // =====================================================
        // ã€çº¿æ€§æœºåˆ¶ã€‘æ¦‚ç‡ = (effectiveTrust / 255) * 0.50
        // æ»¡å€¼ 255 æ—¶çº¦ 50% æ¦‚ç‡ï¼Œ100 æ—¶çº¦ 20% æ¦‚ç‡
        // æ¯åªå®å¯æ¢¦æ¯åœºæˆ˜æ–—åªèƒ½è§¦å‘ä¸€æ¬¡
        // åªæœ‰ isAce=true çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘ AVs è¢«åŠ¨
        if (this.isAce && this.avs && this.avs.trust > 0 && dmg >= this.currHp && !this.avsTriggered?.trustEndure) {
            const baseTrust = this.getEffectiveAVs('trust');
            const effectiveTrust = this.avsEvolutionBoost ? baseTrust * 2 : baseTrust;
            // çº¿æ€§æ¦‚ç‡ï¼šæ»¡å€¼ 50%ï¼Œæœ€ä½ 5%ï¼ˆåªè¦ trust > 0ï¼‰
            const triggerChance = Math.max(0.05, (effectiveTrust / 255) * 0.50);
            if (Math.random() < triggerChance) {
                this.currHp = 1;
                this.avsTriggered.trustEndure = true; // æ¯åœºæˆ˜æ–—åªèƒ½è§¦å‘ä¸€æ¬¡
                this.trustEndureTriggered = true; // æ ‡è®°ç”¨äºæ—¥å¿—
                console.log(`[AVs] ${this.cnName} çš„ Trust å®ˆæŠ¤å‘åŠ¨ï¼(Chance: ${Math.round(triggerChance * 100)}%, Trust: ${baseTrust}${this.avsEvolutionBoost ? ' x2' : ''})`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            }
        }
        // =====================================================
        // === Second Wind (ç¬¬äºŒæ°”æ¯) - æè¯£åŒº Boss ä¸“å± ===
        // =====================================================
        // ç‹ç‰Œå®å¯æ¢¦é¦–æ¬¡è¡€æ¡å½’é›¶æ—¶ï¼šé” 1 HP + å…¨å±æ€§ +1
        // åªæœ‰æ ‡è®°äº† hasSecondWind çš„å®å¯æ¢¦æ‰èƒ½è§¦å‘
        if (this.hasSecondWind && dmg >= this.currHp && !this.secondWindTriggered) {
            this.currHp = 1;
            this.secondWindTriggered = true;
            this.secondWindActivated = true; // æ ‡è®°ç”¨äºæ—¥å¿—å’ŒåŠ¨ç”»
            // å…¨å±æ€§ +1
            this.applyBoost('atk', 1);
            this.applyBoost('def', 1);
            this.applyBoost('spa', 1);
            this.applyBoost('spd', 1);
            this.applyBoost('spe', 1);
            console.log(`[Second Wind] ${this.cnName} çš„ç¬¬äºŒæ°”æ¯å‘åŠ¨äº†ï¼å…¨å±æ€§ +1ï¼`);
            return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
        }
        // =====================================================
        // === ã€æˆ˜æœ¯æŒ‡æŒ¥ã€‘ENDURE! æŒ‡ä»¤ - æ¦‚ç‡æŒºä½ ===
        // =====================================================
        // åŸºç¡€ 50% + Trust AVS 50%ï¼ˆæ»¡å€¼æ—¶ 100%ï¼‰
        if (this.commandEndureActive && dmg >= this.currHp) {
            let endureChance = 0.50; // åŸºç¡€ 50%
            // Trust AVS åŠ æˆï¼šæ»¡å€¼ 255 æ—¶ +50%
            if (this.isAce && this.avs && this.avs.trust > 0) {
                const baseTrust = this.getEffectiveAVs('trust');
                const effectiveTrust = this.avsEvolutionBoost ? baseTrust * 2 : baseTrust;
                const trustBonus = (Math.min(effectiveTrust, 255) / 255) * 0.50;
                endureChance += trustBonus;
                console.log(`[COMMANDER] ENDURE! Trust åŠ æˆ: +${(trustBonus * 100).toFixed(1)}% (Trust: ${baseTrust})`);
            }
            endureChance = Math.min(endureChance, 1.0); // ä¸Šé™ 100%
            const roll = Math.random();
            console.log(`[COMMANDER] ENDURE! Roll: ${(roll * 100).toFixed(1)}% vs Chance: ${(endureChance * 100).toFixed(1)}%`);
            this.commandEndureActive = false; // ä½¿ç”¨åæ¶ˆè€—
            if (roll < endureChance) {
                this.currHp = 1;
                this.commandEndureTriggered = true; // æ ‡è®°ç”¨äºæ—¥å¿—
                console.log(`[COMMANDER] ENDURE! æŒ‡ä»¤æˆåŠŸï¼${this.cnName} åœ¨è®­ç»ƒå®¶çš„å‘¼å–Šä¸‹æ’‘ä½äº†ï¼`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            } else {
                console.log(`[COMMANDER] ENDURE! æŒ‡ä»¤å¤±è´¥...${this.cnName} æ²¡èƒ½æ’‘ä½...`);
            }
        }
        // =====================================================
        // === Bond Endure (ç¾ç»ŠæŒºä½) - è¿›åŒ–æ‹¦æˆªå™¨ ===
        // =====================================================
        // å½“æ»¡è¶³è¿›åŒ–æ¡ä»¶æ—¶ï¼Œè‡´å‘½ä¼¤å®³ä¼šé”è¡€è‡³ 1 HP
        // æ¡ä»¶ï¼šisAce + æœ‰è¿›åŒ–å‹ + AVs è¾¾æ ‡ + ç­‰çº§åœ¨å®½å®¹èŒƒå›´å†… + æœ¬åœºæœªè¿›åŒ–è¿‡
        // è§¦å‘åç«‹å³æ˜¾ç¤º EVO æŒ‰é’®
        if (this.isAce && dmg >= this.currHp && !this.hasEvolvedThisBattle && !this.bondEndureTriggered) {
            const canBondEndure = this._checkBondEndureEligibility();
            if (canBondEndure) {
                this.currHp = 1;
                this.bondEndureTriggered = true;
                this.bondEndureActivated = true; // æ ‡è®°ç”¨äºæ—¥å¿—å’ŒåŠ¨ç”»
                console.log(`[Bond Endure] ${this.cnName} å› ä¸ºæƒ³å›åº”è®­ç»ƒå®¶çš„æœŸå¾…ï¼Œæ’‘ä½äº†ï¼`);
                return; // ä¸æ‰§è¡Œåç»­æ‰£è¡€
            }
        }
        this.currHp = Math.max(0, this.currHp - dmg);
    }
    /**
     * æ£€æŸ¥æ˜¯å¦æ»¡è¶³ç¾ç»ŠæŒºä½æ¡ä»¶ï¼ˆè¿›åŒ–æ‹¦æˆªï¼‰
     * @returns {boolean}
     */
    _checkBondEndureEligibility() {
        if (!this.avs) return false;
        // è®¡ç®— AVs æ€»å’Œ
        const totalAVs = (this.getEffectiveAVs('trust') || 0) + 
                         (this.getEffectiveAVs('passion') || 0) + 
                         (this.getEffectiveAVs('insight') || 0) + 
                         (this.getEffectiveAVs('devotion') || 0);
        // è·å–å®å¯æ¢¦æ•°æ®
        const baseId = this.name.toLowerCase().replace(/[^a-z0-9]/g, '');
        const data = typeof POKEDEX !== 'undefined' ? POKEDEX[baseId] : null;
        if (!data) return false;
        // å¿…é¡»æœ‰è¿›åŒ–å‹
        if (!data.evos || data.evos.length === 0) return false;
        // å·² Mega æˆ–å·²å˜èº«çš„ä¸èƒ½è§¦å‘
        if (this.isMega || this.isTransformed) return false;
        // è·å–è¿›åŒ–å‹æ•°æ®
        const nextFormName = data.evos[0];
        const nextId = nextFormName.toLowerCase().replace(/[^a-z0-9]/g, '');
        const nextData = typeof POKEDEX !== 'undefined' ? POKEDEX[nextId] : null;
        if (!nextData) return false;
        // ç­‰çº§æ£€æŸ¥ï¼ˆå…è®¸è¶Šçº§3çº§ï¼‰
        const reqLevel = Math.max(1, (nextData.evoLevel || 1) - 3);
        if (this.level < reqLevel) return false;
        // AVs é˜ˆå€¼æ£€æŸ¥
        // ä¸€é˜¶(æ— prevo): 80
        // äºŒé˜¶(æœ‰prevo): 160
        // åªæœ‰ä¸€æ¬¡è¿›åŒ–(æœ‰prevoä½†è¿›åŒ–å‹æ— evos): 140
        const isFirstStage = !data.prevo;
        const nextHasEvos = nextData.evos && nextData.evos.length > 0;
        let reqAVs;
        if (isFirstStage) {
            reqAVs = 80;  // ä¸€é˜¶æ®µ
        } else if (!nextHasEvos) {
            reqAVs = 140; // åªæœ‰ä¸€æ¬¡å‡çº§ï¼ˆäºŒé˜¶è¿›åŒ–åˆ°æœ€ç»ˆå½¢æ€ï¼‰
        } else {
            reqAVs = 160; // äºŒé˜¶æ®µï¼ˆè¿˜èƒ½ç»§ç»­è¿›åŒ–ï¼‰
        }
        if (totalAVs < reqAVs) return false;
        console.log(`[Bond Endure Check] ${this.cnName}: AVs=${totalAVs}/${reqAVs}, Level=${this.level}/${reqLevel}, Target=${nextFormName}`);
        return true;
    }
    // å›å¤
    heal(amount) {
        this.currHp = Math.min(this.maxHp, this.currHp + amount);
    }
    // === é‡ç½®èƒ½åŠ›å˜åŒ– (æ¢äººæ—¶è°ƒç”¨) ===
    resetBoosts() {
        this.boosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
        this.turnsOnField = 0;      // é‡ç½®ä¸Šåœºå›åˆæ•°
        this.lastMoveUsed = null;   // é‡ç½®ä¸Šå›åˆæŠ€èƒ½
        this.protectCounter = 0;    // é‡ç½®å®ˆä½è®¡æ•°å™¨
        this.mustRecharge = false;  // é‡ç½®åƒµç›´çŠ¶æ€
        // ã€ä¿®å¤ã€‘æ¢äººæ—¶æ¸…é™¤æå·¨åŒ–çŠ¶æ€
        // æ­£ä½œè§„åˆ™ï¼šæå·¨åŒ–å®å¯æ¢¦ä¸€æ—¦é€€åœºï¼Œæå·¨åŒ–ç«‹åˆ»è§£é™¤
        if (this.isDynamaxed) {
            console.log(`[SWITCH] Clearing Dynamax for ${this.name}`);
            this.isDynamaxed = false;
            this.dynamaxTurns = 0;
            // æ¢å¤åŸå§‹åç§°ï¼ˆG-Max å½¢æ€åç§° -> åŸºç¡€åç§°ï¼‰
            if (this.originalName) {
                console.log(`[SWITCH] Restoring name: ${this.name} -> ${this.originalName}`);
                this.name = this.originalName;
                delete this.originalName;
            }
            // æ¢å¤ HPï¼ˆå¦‚æœä¹‹å‰ä¹˜äº† 1.5 å€ï¼‰
            if (this.preDynamaxMaxHp) {
                // æŒ‰æ¯”ä¾‹æ¢å¤ HP
                const hpRatio = this.currHp / this.maxHp;
                this.maxHp = this.preDynamaxMaxHp;
                this.currHp = Math.max(1, Math.floor(this.maxHp * hpRatio));
                this.preDynamaxMaxHp = null;
                this.preDynamaxCurrHp = null;
            }
        }
        // æ¸…é™¤è“„åŠ›çŠ¶æ€ (Solar Beam, Skull Bash, etc.)
        this.isCharging = false;
        this.chargingMove = null;
        // æ¸…é™¤å…¶ä»– volatile çŠ¶æ€
        if (this.volatiles) {
            this.volatiles = {};
        }
    }
    // === åº”ç”¨èƒ½åŠ›ç­‰çº§å˜åŒ– ===
    applyBoost(statName, stage) {
        if (!this.boosts.hasOwnProperty(statName)) return 0;
        // Contrary (å”±åè°ƒ): èƒ½åŠ›å˜åŒ–åè½¬
        if (this.ability && this.ability.toLowerCase().replace(/\s/g, '') === 'contrary') {
            stage = -stage;
        }
        const oldVal = this.boosts[statName];
        this.boosts[statName] = Math.min(6, Math.max(-6, oldVal + stage));
        return this.boosts[statName] - oldVal;
    }
    // === è·å–ç»è¿‡èƒ½åŠ›ä¿®æ­£åçš„å®æˆ˜æ•°å€¼ ===
    getStat(statName) {
        // åŸºç¡€å…­å›´ (é™¤äº† HP, accuracy, evasion)
        if (['atk', 'def', 'spa', 'spd', 'spe'].includes(statName)) {
            const base = this[statName];
            const stage = this.boosts[statName];
            // æ ¸å¿ƒå…¬å¼ï¼š stage >= 0: (2 + stage) / 2; stage < 0: 2 / (2 + |stage|)
            let multiplier = 1.0;
            if (stage >= 0) multiplier = (2 + stage) / 2;
            else multiplier = 2 / (2 + Math.abs(stage));
            let val = Math.floor(base * multiplier);
            // === ç‰¹æ€§åŠ æˆ Hook (å¤§åŠ›å£«ã€æ¯›çš®å¤§è¡£ã€å¤©æ°”åŠ é€Ÿç­‰) ===
            if (typeof AbilityHandlers !== 'undefined' && this.ability && AbilityHandlers[this.ability]) {
                const ah = AbilityHandlers[this.ability];
                if (ah.onModifyStat) {
                    const shell = { atk: this.atk, def: this.def, spa: this.spa, spd: this.spd, spe: this.spe };
                    shell[statName] = val;
                    // ä¼ é€’ battle å¯¹è±¡ä»¥æ”¯æŒå¤©æ°”ç‰¹æ€§ (å¶ç»¿ç´ ã€æ‚ æ¸¸è‡ªå¦‚ç­‰)
                    const battleRef = (typeof battle !== 'undefined') ? battle : (typeof window !== 'undefined' ? window.battle : null);
                    ah.onModifyStat(shell, this, battleRef);
                    val = shell[statName];
                }
            }
            return Math.max(1, val);
        }
        // å‘½ä¸­/é—ªé¿è¿”å›ç­‰çº§å€¼ï¼Œç”±å¼•æ“è®¡ç®—æœ€ç»ˆå‘½ä¸­ç‡
        if (statName === 'accuracy' || statName === 'evasion') {
            return this.boosts[statName];
        }
        return 0;
    }
}
/**
 * =============================================
 * DAMAGE CALCULATION - å·²è¿ç§»
 * =============================================
 * 
 * calcDamage å‡½æ•°å·²è¿ç§»åˆ° -> battle/battle-calc.js
 */
/**
 * =============================================
 * MOVE SECONDARY EFFECTS - å·²è¿ç§»
 * =============================================
 * 
 * applyMoveSecondaryEffects å‡½æ•°å·²è¿ç§»åˆ° -> battle/battle-effects.js
 */
/**
 * æ ¸å¿ƒï¼šåˆ¤æ–­å½“å‰å®å¯æ¢¦èƒ½å¦è¡ŒåŠ¨
 * @param {Pokemon} pokemon
 * @param {Object} move - å¯é€‰ï¼Œè¦ä½¿ç”¨çš„æ‹›å¼ï¼ˆç”¨äºæŒ‘è¡…/å†æ¥ä¸€æ¬¡/å®šèº«æ³•æ£€æŸ¥ï¼‰
 * @returns {{ can: boolean, msg: string, forcedMove: Object|null }}
 */
function checkCanMove(pokemon, move = null) {
    // 1. ç•ç¼© (Flinch) - æœ¬å›åˆæ— æ³•è¡ŒåŠ¨ï¼Œç”¨å®Œå³æ¸…
    if (pokemon.volatile && pokemon.volatile.flinch) {
        pokemon.volatile.flinch = false;
        return { can: false, msg: `${pokemon.cnName} å› ä¸ºç•ç¼©è€Œæ— æ³•åŠ¨å¼¹!` };
    }
    // 2. ç¡çœ  (Sleep) - æ¯å›åˆå‡å°‘è®¡æ•°ï¼Œåˆ°0é†’æ¥
    if (pokemon.status === 'slp') {
        pokemon.sleepTurns--;
        if (pokemon.sleepTurns <= 0) {
            pokemon.status = null;
            return { can: true, msg: `${pokemon.cnName} é†’è¿‡æ¥äº†!` };
        }
        return { can: false, msg: `${pokemon.cnName} æ­£åœ¨ç†Ÿç¡ä¸­...` };
    }
    // 3. éº»ç—¹ (Paralysis) - 25% å‡ ç‡æ— æ³•è¡ŒåŠ¨
    if (pokemon.status === 'par') {
        if (Math.random() < 0.25) {
            return { can: false, msg: `${pokemon.cnName} å› èº«ä½“éº»ç—¹è€Œæ— æ³•è¡ŒåŠ¨!` };
        }
    }
    // 4. å†°å†» (Frozen) - 20% å‡ ç‡è§£å†»ï¼Œå¦åˆ™æ— æ³•è¡ŒåŠ¨
    if (pokemon.status === 'frz') {
        if (Math.random() < 0.2) {
            pokemon.status = null;
            return { can: true, msg: `${pokemon.cnName} çš„å†°å†»è§£é™¤äº†!` };
        }
        return { can: false, msg: `${pokemon.cnName} è¢«å†»å¾—åŠ¨å¼¹ä¸å¾—!` };
    }
    // ============================================
    // 5. æŒ¥å‘æ€§å°é”æ£€æŸ¥ (Volatile Locks)
    // ============================================
    // 5a. æŒ‘è¡… (Taunt) - æ— æ³•ä½¿ç”¨å˜åŒ–æŠ€
    if (pokemon.volatile && pokemon.volatile.taunt > 0 && move) {
        const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
        const category = fullMoveData.category || move.category || move.cat;
        if (category === 'Status') {
            return { can: false, msg: `${pokemon.cnName} å› ä¸ºæŒ‘è¡…æ— æ³•ä½¿ç”¨ ${move.cn || move.name}!` };
        }
    }
    // 5b. å†æ¥ä¸€æ¬¡ (Encore) - åªèƒ½ä½¿ç”¨è¢«é”å®šçš„æ‹›å¼
    if (pokemon.volatile && pokemon.volatile.encore > 0 && pokemon.volatile.encoreMove && move) {
        if (move.name !== pokemon.volatile.encoreMove) {
            return { 
                can: false, 
                msg: `${pokemon.cnName} è¢«å†æ¥ä¸€æ¬¡é”å®šäº†!`,
                forcedMove: pokemon.volatile.encoreMove
            };
        }
    }
    // 5c. å®šèº«æ³• (Disable) - æ— æ³•ä½¿ç”¨è¢«å°å°çš„æ‹›å¼
    if (pokemon.volatile && pokemon.volatile.disable > 0 && pokemon.volatile.disabledMove && move) {
        if (move.name === pokemon.volatile.disabledMove) {
            return { can: false, msg: `${pokemon.cnName} çš„ ${move.cn || move.name} è¢«å°å°äº†!` };
        }
    }
    return { can: true, msg: '', forcedMove: null };
}
/**
 * æ¸…é™¤å›åˆç»“æŸæ—¶çš„ä¸´æ—¶çŠ¶æ€ï¼ˆå¦‚ç•ç¼©ï¼‰
 */
function clearVolatileStatus(pokemon) {
    if (pokemon.volatile) {
        pokemon.volatile.flinch = false;
    }
}
// æ³¨æ„ï¼šapplyEntryHazards å’Œ tickVolatileStatus å·²åœ¨ move-effects.js ä¸­å®ç°
// ä½¿ç”¨ MoveEffects.applyEntryHazards å’Œ MoveEffects.tickVolatileStatus
/**
 * =============================================
 * END TURN STATUS - å·²è¿ç§»
 * =============================================
 * 
 * getEndTurnStatusLogs å‡½æ•°å·²è¿ç§»åˆ° -> battle/battle-turns.js
 */
// getMovePriority å·²è¿ç§»åˆ° move-effects.jsï¼Œä½¿ç”¨ MoveEffects.getMovePriority
if (typeof window !== 'undefined') {
    window.checkCanMove = checkCanMove;
    window.clearVolatileStatus = clearVolatileStatus;
    // getEndTurnStatusLogs å·²è¿ç§»åˆ° battle-turns.js
    // getMovePriority ä½¿ç”¨ MoveEffects.getMovePriority
    window.getMovePriority = (typeof MoveEffects !== 'undefined' && MoveEffects.getMovePriority) 
        ? MoveEffects.getMovePriority 
        : function(move) { return move?.priority || 0; };
}
/**
 * =============================================
 * MEGA EVOLUTION SYSTEM - å·²è¿ç§»
 * =============================================
 * 
 * ä»£ç å·²è¿ç§»åˆ° -> mechanics/mega-evolution.js
 * 
 * å‡½æ•°åˆ—è¡¨ï¼š
 * - autoDetectFormChangeEligibility()
 * - autoDetectMegaEligibility()
 * - performMegaEvolution()
 * - canMegaEvolve()
 * - isUnofficialMega()
 */
/**
 * æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨
 */
class BattleState {
    constructor() {
        this.playerParty = [];
        this.enemyParty = [];
        this.playerActive = 0;
        this.enemyActive = 0;
        this.phase = 'intro';
        this.trainer = null;
        this.locked = false;
        this.scriptedResult = null;
        this.aiDifficulty = 'normal';
        // Mega Evolution çŠ¶æ€
        this.playerMegaUsed = false;    // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Mega
        this.enemyMegaUsed = false;     // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Mega
        this.playerMegaArmed = false;   // ç©å®¶æ˜¯å¦å·²é¢„å¤‡ Mega (ç‚¹å‡»äº†æŒ‰é’®)
        // Z-Move / Max Move çŠ¶æ€ (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡)
        this.playerZUsed = false;       // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Z æ‹›å¼
        this.enemyZUsed = false;        // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨ Z æ‹›å¼
        this.playerMaxUsed = false;     // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨æå·¨åŒ–
        this.enemyMaxUsed = false;      // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨æå·¨åŒ–
        // å¤ªæ™¶åŒ– (Terastallization) çŠ¶æ€ (å…¨åœºåªèƒ½ç”¨ä¸€æ¬¡ï¼Œç”±ç”Ÿåˆ°æ­»)
        this.playerTeraUsed = false;    // ç©å®¶æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨å¤ªæ™¶åŒ–
        this.enemyTeraUsed = false;     // æ•Œæ–¹æœ¬åœºæ˜¯å¦å·²ä½¿ç”¨å¤ªæ™¶åŒ–
        // =========================================================
        // å…¨å±€æˆ˜åœºçŠ¶æ€ (Field Conditions)
        // =========================================================
        this.field = {
            trickRoom: 0,   // æˆæ³•ç©ºé—´å‰©ä½™å›åˆ (0=æœªå¼€å¯)
            gravity: 0,     // é‡åŠ›å‰©ä½™å›åˆ
            magicRoom: 0,   // é­”æ³•ç©ºé—´å‰©ä½™å›åˆ
            wonderRoom: 0   // å¥‡å¦™ç©ºé—´å‰©ä½™å›åˆ
        };
        // ç©å®¶ä¾§çŠ¶æ€ (Player Side)
        this.playerSide = {
            tailwind: 0,      // é¡ºé£å‰©ä½™å›åˆ
            reflect: 0,       // åå°„å£å‰©ä½™å›åˆ
            lightScreen: 0,   // å…‰å¢™å‰©ä½™å›åˆ
            auroraVeil: 0,    // æå…‰å¹•å‰©ä½™å›åˆ
            stealthRock: false,  // éšå½¢å²©
            spikes: 0,        // æ’’è±å±‚æ•° (0-3)
            toxicSpikes: 0,   // æ¯’è±å±‚æ•° (0-2)
            stickyWeb: false  // é»é»ç½‘
        };
        // æ•Œæ–¹ä¾§çŠ¶æ€ (Enemy Side)
        this.enemySide = {
            tailwind: 0,
            reflect: 0,
            lightScreen: 0,
            auroraVeil: 0,
            stealthRock: false,
            spikes: 0,
            toxicSpikes: 0,
            stickyWeb: false
        };
    }
    // å›åˆç»“æŸæ—¶é€’å‡åœºåœ°çŠ¶æ€
    tickFieldConditions() {
        const logs = [];
        // å…¨å±€åœºåœ°
        if (this.field.trickRoom > 0) {
            this.field.trickRoom--;
            if (this.field.trickRoom === 0) {
                logs.push("æ‰­æ›²çš„æ—¶ç©ºæ¢å¤äº†æ­£å¸¸ï¼");
            }
        }
        if (this.field.gravity > 0) {
            this.field.gravity--;
            if (this.field.gravity === 0) {
                logs.push("é‡åŠ›æ¢å¤äº†æ­£å¸¸ï¼");
            }
        }
        // ç©å®¶ä¾§
        if (this.playerSide.tailwind > 0) {
            this.playerSide.tailwind--;
            if (this.playerSide.tailwind === 0) {
                logs.push("æˆ‘æ–¹çš„é¡ºé£åœæ­¢äº†ï¼");
            }
        }
        if (this.playerSide.reflect > 0) {
            this.playerSide.reflect--;
            if (this.playerSide.reflect === 0) {
                logs.push("æˆ‘æ–¹çš„åå°„å£æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.playerSide.lightScreen > 0) {
            this.playerSide.lightScreen--;
            if (this.playerSide.lightScreen === 0) {
                logs.push("æˆ‘æ–¹çš„å…‰å¢™æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.playerSide.auroraVeil > 0) {
            this.playerSide.auroraVeil--;
            if (this.playerSide.auroraVeil === 0) {
                logs.push("æˆ‘æ–¹çš„æå…‰å¹•æ¶ˆå¤±äº†ï¼");
            }
        }
        // æ•Œæ–¹ä¾§
        if (this.enemySide.tailwind > 0) {
            this.enemySide.tailwind--;
            if (this.enemySide.tailwind === 0) {
                logs.push("æ•Œæ–¹çš„é¡ºé£åœæ­¢äº†ï¼");
            }
        }
        if (this.enemySide.reflect > 0) {
            this.enemySide.reflect--;
            if (this.enemySide.reflect === 0) {
                logs.push("æ•Œæ–¹çš„åå°„å£æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.enemySide.lightScreen > 0) {
            this.enemySide.lightScreen--;
            if (this.enemySide.lightScreen === 0) {
                logs.push("æ•Œæ–¹çš„å…‰å¢™æ¶ˆå¤±äº†ï¼");
            }
        }
        if (this.enemySide.auroraVeil > 0) {
            this.enemySide.auroraVeil--;
            if (this.enemySide.auroraVeil === 0) {
                logs.push("æ•Œæ–¹çš„æå…‰å¹•æ¶ˆå¤±äº†ï¼");
            }
        }
        return logs;
    }
    // ä» AI JSON åˆå§‹åŒ–æ•Œæ–¹
    loadFromJSON(json) {
        const enemyObj = json.enemy || json.trainer || {};
        const typeLabel = typeof enemyObj.type === 'string' ? enemyObj.type.trim() : '';
        const nameId = typeof enemyObj.name === 'string' ? enemyObj.name.trim() : '';
        const isWild = (typeLabel.toLowerCase() === 'wild') || (!nameId && !enemyObj.type);
        let imgId = 'wild';
        if (!isWild) {
            imgId = enemyObj.id || nameId || 'wild';
        }
        let displayName = nameId;
        if (isWild && !displayName) displayName = "Wild Pokemon";
        if (!displayName) displayName = "Unknown";
        const lines = enemyObj.lines || {};
        this.trainer = {
            name: displayName,
            title: typeLabel || '',
            id: imgId,
            lines: {
                start: lines.start || enemyObj.line || "",
                win: lines.win || "",
                lose: lines.lose || "",
                escape: lines.escape || ""
            }
        };
        this.scriptedResult = json.script || null;
        const rawDiff = (json.ai || json.difficulty || enemyObj.difficulty || '').toString().toLowerCase();
        if (rawDiff) {
            this.aiDifficulty = rawDiff;
        } else {
            this.aiDifficulty = isWild ? 'easy' : 'normal';
        }
        const trainerNameLower = (displayName || '').toLowerCase();
        if (/cynthia|red|steven|champion/.test(trainerNameLower)) {
            this.aiDifficulty = 'hard';
        }
        let rawParty = [];
        if (Array.isArray(json.party)) {
            rawParty.push(...json.party);
        }
        if (Array.isArray(enemyObj.party)) {
            rawParty.push(...enemyObj.party);
        }
        if (rawParty.length === 0 && Array.isArray(json.enemyParty)) {
            rawParty.push(...json.enemyParty);
        }
        if (rawParty.length > 6) {
            rawParty = rawParty.slice(0, 6);
        }
        const validPartyData = [];
        for (const p of rawParty) {
            const seed = (p?.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
            if (!seed) continue;
            validPartyData.push(p);
        }
        if (validPartyData.length === 0) {
            console.warn("[PKM] Warn: No valid pokemon found in enemy party. Adding fallback.");
            validPartyData.push({ name: 'Magikarp', lv: 5, moves: ['Splash'] });
        }
        // === æ•Œæ–¹è§£é”ç³»ç»Ÿ (Enemy Unlock System) ===
        // è§£æ unlocks å¯¹è±¡ï¼Œå†³å®š NPC æ˜¯å¦æœ‰èµ„æ ¼ä½¿ç”¨å„æœºåˆ¶
        // unlocks å¯ä»¥åœ¨ json.unlocks æˆ– enemyObj.unlocks ä¸­
        const enemyUnlocksRaw = json.unlocks || enemyObj.unlocks || {};
        this.enemyUnlocks = {
            enable_bond: enemyUnlocksRaw.enable_bond === true,        // ç¾ç»Šå…±é¸£ (é»˜è®¤å…³é—­)
            enable_styles: enemyUnlocksRaw.enable_styles === true,    // åˆšçŒ›/è¿…ç–¾ (é»˜è®¤å…³é—­)
            enable_insight: enemyUnlocksRaw.enable_insight === true,  // å¿ƒçœ¼/AVsçªç ´155ä¸Šé™ (é»˜è®¤å…³é—­)
            enable_mega: enemyUnlocksRaw.enable_mega === true,        // Megaè¿›åŒ– (é»˜è®¤å…³é—­)
            enable_z_move: enemyUnlocksRaw.enable_z_move === true,    // Zæ‹›å¼ (é»˜è®¤å…³é—­)
            enable_dynamax: enemyUnlocksRaw.enable_dynamax === true,  // æå·¨åŒ– (é»˜è®¤å…³é—­)
            enable_tera: enemyUnlocksRaw.enable_tera === true         // å¤ªæ™¶åŒ– (é»˜è®¤å…³é—­)
        };
        console.log('[UNLOCK] æ•Œæ–¹è§£é”çŠ¶æ€:', this.enemyUnlocks);
        // æ£€æŸ¥æ•Œæ–¹è®­ç»ƒå®¶æ˜¯å¦æœ‰ Mega æƒé™
        // ä¼˜å…ˆä½¿ç”¨ unlocks.enable_megaï¼Œå…¶æ¬¡æ£€æŸ¥ canMega å­—æ®µæˆ– Boss åç§°
        // (trainerNameLower å·²åœ¨ä¸Šé¢å®šä¹‰)
        const isBossTrainer = /cynthia|red|steven|champion|elite|leader|boss/.test(trainerNameLower);
        const enemyCanMega = this.enemyUnlocks.enable_mega || 
            (enemyObj.canMega !== false && (enemyObj.canMega === true || isBossTrainer));
        this.enemyParty = validPartyData.map(p => {
            // ä½¿ç”¨æ–°ç‰ˆæ„é€ æ–¹å¼ï¼šä¼ å…¥å®Œæ•´é…ç½®å¯¹è±¡
            const poke = new Pokemon(p);
            // ã€ä¿®å¤ã€‘å³ä½¿ enemyCanMega=falseï¼Œå¦‚æœå®å¯æ¢¦æœ‰ mechanic='dynamax'ï¼Œä¹Ÿéœ€è¦æ£€æµ‹å½¢æ€
            // autoDetectMegaEligibility ä¸ä»…å¤„ç† Megaï¼Œè¿˜å¤„ç† Dynamax/GMax å½¢æ€
            const needsFormDetection = (enemyCanMega && !isWild) || 
                poke.mechanic === 'dynamax' || 
                poke.mechanic === 'tera' ||
                poke.canDynamax;
            if (needsFormDetection) {
                console.log('[FORM] Enemy: Calling autoDetectMegaEligibility for', poke.name, 'mechanic:', poke.mechanic);
                autoDetectMegaEligibility(poke, p.mega || null);
                console.log('[FORM] Enemy after detection:', poke.name, 'canMegaEvolve:', poke.canMegaEvolve, 'canDynamax:', poke.canDynamax, 'megaTargetId:', poke.megaTargetId);
            }
            return poke;
        });
        // ã€isLead é¦–å‘é€»è¾‘ã€‘æ£€æŸ¥æ˜¯å¦æœ‰æ ‡è®°ä¸º isLead çš„å®å¯æ¢¦ï¼Œè‡ªåŠ¨å°†å…¶ç§»åˆ°ç¬¬ä¸€ä½
        const leadIndex = this.enemyParty.findIndex(p => p.isLead === true);
        if (leadIndex > 0) {
            // æ‰¾åˆ° isLead=true çš„å®å¯æ¢¦ä¸”ä¸åœ¨ç¬¬ä¸€ä½ï¼Œå°†å…¶ä¸ç¬¬ä¸€ä½äº¤æ¢
            const leadPokemon = this.enemyParty[leadIndex];
            this.enemyParty[leadIndex] = this.enemyParty[0];
            this.enemyParty[0] = leadPokemon;
            console.log(`[LEAD] Enemy: ${leadPokemon.cnName} (${leadPokemon.name}) marked as isLead, swapped to first position`);
        } else if (leadIndex === 0) {
            console.log(`[LEAD] Enemy: ${this.enemyParty[0].cnName} is already in first position with isLead=true`);
        } else {
            console.log('[LEAD] Enemy: No PokÃ©mon marked as isLead, using default order');
        }
        // ã€è°ƒè¯•ã€‘æ‰“å°æ•Œæ–¹é˜Ÿä¼åˆå§‹åŒ–çŠ¶æ€
        console.log('[ENEMY PARTY] Loaded', this.enemyParty.length, 'Pokemon:');
        this.enemyParty.forEach((p, i) => {
            console.log(`  [${i}] ${p.cnName} (${p.name}) - HP: ${p.currHp}/${p.maxHp}, isAlive: ${p.isAlive()}`);
        });
        this.enemyActive = 0;
        this.enemyMegaUsed = false;
        if (isWild && this.enemyParty.length > 0) {
            this.trainer.name = this.enemyParty[0].cnName;
        }
        this.phase = 'battle';
    }
    // è®¾ç½®ç©å®¶é˜Ÿä¼
    // ã€ä¿®å¤ã€‘canMega åªæ§åˆ¶ Mega è¿›åŒ–ï¼Œä½†æå·¨åŒ–/å¤ªæ™¶åŒ–ç­‰éœ€è¦å•ç‹¬æ£€æŸ¥
    setPlayerParty(partyData, canMega = true) {
        console.log('[MEGA] setPlayerParty called, canMega:', canMega, 'partyData:', partyData);
        this.playerParty = partyData.map(p => {
            // ä½¿ç”¨æ–°ç‰ˆæ„é€ æ–¹å¼ï¼šä¼ å…¥å®Œæ•´é…ç½®å¯¹è±¡
            // AVs åº”è¯¥åœ¨ pkm-tavern-plugin.js ä¸­å¤„ç† (AVl/AVup æ ¼å¼)
            const poke = new Pokemon(p);
            // ã€ä¿®å¤ã€‘å³ä½¿ canMega=falseï¼Œå¦‚æœå®å¯æ¢¦æœ‰ mechanic='dynamax'ï¼Œä¹Ÿéœ€è¦æ£€æµ‹å½¢æ€
            // autoDetectMegaEligibility ä¸ä»…å¤„ç† Megaï¼Œè¿˜å¤„ç† Dynamax/GMax å½¢æ€
            const needsFormDetection = canMega || 
                poke.mechanic === 'dynamax' || 
                poke.mechanic === 'tera' ||
                poke.canDynamax;
            if (needsFormDetection) {
                console.log('[FORM] Calling autoDetectMegaEligibility for', poke.name, 'with mega flag:', p.mega, 'mechanic:', poke.mechanic);
                autoDetectMegaEligibility(poke, p.mega || null);
                console.log('[FORM] After detection:', poke.name, 'canMegaEvolve:', poke.canMegaEvolve, 'canDynamax:', poke.canDynamax, 'megaTargetId:', poke.megaTargetId);
            }
            return poke;
        });
        // ã€isLead é¦–å‘é€»è¾‘ã€‘æ£€æŸ¥æ˜¯å¦æœ‰æ ‡è®°ä¸º isLead çš„å®å¯æ¢¦ï¼Œè‡ªåŠ¨å°†å…¶ç§»åˆ°ç¬¬ä¸€ä½
        const leadIndex = this.playerParty.findIndex(p => p.isLead === true);
        if (leadIndex > 0) {
            // æ‰¾åˆ° isLead=true çš„å®å¯æ¢¦ä¸”ä¸åœ¨ç¬¬ä¸€ä½ï¼Œå°†å…¶ä¸ç¬¬ä¸€ä½äº¤æ¢
            const leadPokemon = this.playerParty[leadIndex];
            this.playerParty[leadIndex] = this.playerParty[0];
            this.playerParty[0] = leadPokemon;
            console.log(`[LEAD] ${leadPokemon.cnName} (${leadPokemon.name}) marked as isLead, swapped to first position`);
        } else if (leadIndex === 0) {
            console.log(`[LEAD] ${this.playerParty[0].cnName} is already in first position with isLead=true`);
        } else {
            console.log('[LEAD] No PokÃ©mon marked as isLead, using default order');
        }
        this.playerActive = 0;
        this.playerMegaUsed = false;
    }
    // è·å–å½“å‰å‡ºæˆ˜
    getPlayer() { return this.playerParty[this.playerActive]; }
    getEnemy() { return this.enemyParty[this.enemyActive]; }
    // æ£€æŸ¥èƒœè´Ÿ
    checkBattleEnd() {
        const playerAlive = this.playerParty.some(p => p.isAlive());
        const enemyAlive = this.enemyParty.some(p => p.isAlive());
        if (!playerAlive) return 'loss';
        if (!enemyAlive) return 'win';
        return null;
    }
    // æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„æ•Œæ–¹
    nextAliveEnemy() {
        // é‡ç½®å½“å‰æ•Œæ–¹çš„èƒ½åŠ›ç­‰çº§
        const currentEnemy = this.enemyParty[this.enemyActive];
        if (currentEnemy && typeof currentEnemy.resetBoosts === 'function') {
            currentEnemy.resetBoosts();
        }
        // è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰æ•Œæ–¹å®å¯æ¢¦çš„çŠ¶æ€
        console.log('[nextAliveEnemy] Current active:', this.enemyActive);
        this.enemyParty.forEach((p, i) => {
            console.log(`[nextAliveEnemy] Enemy ${i}: ${p.cnName}, HP: ${p.currHp}/${p.maxHp}, isAlive: ${p.isAlive()}`);
        });
        // ============================================
        // æ™ºèƒ½æ¢äººï¼šExpert/Hard éš¾åº¦ä½¿ç”¨ Revenge Killer é€»è¾‘
        // ============================================
        const difficulty = this.aiDifficulty || 'hard';
        if ((difficulty === 'expert' || difficulty === 'hard') && 
            typeof window !== 'undefined' && typeof window.getBestRevengeKiller === 'function') {
            const playerPoke = this.getPlayer();
            if (playerPoke && playerPoke.isAlive()) {
                const smartIdx = window.getBestRevengeKiller(this.enemyParty, playerPoke, this.enemyActive);
                if (smartIdx !== -1 && smartIdx !== this.enemyActive && 
                    this.enemyParty[smartIdx] && this.enemyParty[smartIdx].isAlive()) {
                    console.log(`[nextAliveEnemy] Smart switch: choosing index ${smartIdx} (Revenge Killer)`);
                    this.enemyActive = smartIdx;
                    return true;
                }
            }
        }
        // Fallback: çº¿æ€§æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„
        const idx = this.enemyParty.findIndex((p, i) => i !== this.enemyActive && p.isAlive());
        console.log('[nextAliveEnemy] Found next alive at index:', idx);
        if (idx !== -1) this.enemyActive = idx;
        return idx !== -1;
    }
    // æ‰¾ä¸‹ä¸€ä¸ªå­˜æ´»çš„ç©å®¶
    nextAlivePlayer() {
        const idx = this.playerParty.findIndex((p, i) => i !== this.playerActive && p.isAlive());
        if (idx !== -1) this.playerActive = idx;
        this.phase = 'battle';
    }
}
/* =============================================================
 *  BATTLE AI - å·²è¿ç§»åˆ° ai-engine.js
 *  ä¿ç•™æ­¤æ³¨é‡Šä»¥æ ‡è®° AI é€»è¾‘çš„æ–°ä½ç½®
 * ============================================================= */
// å¯¼å‡º
window.TYPE_CHART = TYPE_CHART;
window.NATURE_MODIFIERS = NATURE_MODIFIERS;
window.getTypeEffectiveness = getTypeEffectiveness;
window.getPokemonData = getPokemonData;
window.getMoveData = getMoveData;
window.calcStats = calcStats;
window.Pokemon = Pokemon;
window.calcDamage = calcDamage;
window.applyMoveSecondaryEffects = applyMoveSecondaryEffects;
window.BattleState = BattleState;
window.checkCanMove = checkCanMove;
window.clearVolatileStatus = clearVolatileStatus;
// applyEntryHazards å’Œ tickVolatileStatus å·²åœ¨ move-effects.js ä¸­å¯¼å‡ºä¸º MoveEffects.xxx
// window.getAiMove - å·²è¿ç§»åˆ° ai-engine.js
]]></file>
        <file name="items-data.js"><![CDATA[/**
 * ===========================================
 * ITEMS-DATA.JS - é“å…·æ•°æ®åº“
 * ===========================================
 * 
 * é›†ä¸­ç®¡ç†æ‰€æœ‰é“å…·æ•°æ®ï¼Œæ¶ˆé™¤ç¡¬ç¼–ç 
 * å‚è€ƒ Showdown çš„ items.ts ç»“æ„
 * 
 * èŒè´£:
 * - é“å…·åŸºç¡€æ•°æ® (åç§°ã€ç±»å‹ã€æ•ˆæœ)
 * - é“å…·åˆ†ç±»å¸¸é‡
 * - é“å…·æ•ˆæœå¤„ç†å™¨
 */
// ============================================
// é“å…·æ•°æ®åº“
// ============================================
const ITEMS = {
    // ========== æˆ˜æ–—é“å…· (Battle Items) ==========
    // --- æ°”åŠ¿æŠ«å¸¦ (Focus Sash) ---
    focussash: {
        id: 'focussash',
        name: 'Focus Sash',
        cnName: 'æ°”åŠ¿æŠ«å¸¦',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        // æ•ˆæœ: æ»¡è¡€æ—¶ï¼Œè‡´å‘½ä¼¤å®³åªä¼šè®© HP å‰© 1
        effect: 'surviveLethal',
        description: 'å½“æŒæœ‰è€…HPæ»¡æ—¶ï¼Œå—åˆ°è‡´å‘½ä¼¤å®³ä¼šä¿ç•™1ç‚¹HPï¼ˆä¸€æ¬¡æ€§ï¼‰',
    },
    // --- è®²ç©¶ç³»åˆ— (Choice Items) ---
    choiceband: {
        id: 'choiceband',
        name: 'Choice Band',
        cnName: 'è®²ç©¶å¤´å¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { atk: 1.5 },
        isChoice: true,
        description: 'ç‰©æ”»x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    choicescarf: {
        id: 'choicescarf',
        name: 'Choice Scarf',
        cnName: 'è®²ç©¶å›´å·¾',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { spe: 1.5 },
        isChoice: true,
        description: 'é€Ÿåº¦x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    choicespecs: {
        id: 'choicespecs',
        name: 'Choice Specs',
        cnName: 'è®²ç©¶çœ¼é•œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'choiceLock',
        statBoost: { spa: 1.5 },
        isChoice: true,
        description: 'ç‰¹æ”»x1.5ï¼Œä½†åªèƒ½ä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ‹›å¼',
    },
    // --- ç”Ÿå‘½å®ç  (Life Orb) ---
    lifeorb: {
        id: 'lifeorb',
        name: 'Life Orb',
        cnName: 'ç”Ÿå‘½å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'lifeOrb',
        damageBoost: 1.3,
        recoilPercent: 0.1, // 10% æœ€å¤§HP
        description: 'æ”»å‡»ä¼¤å®³x1.3ï¼Œä½†æ¯æ¬¡æ”»å‡»æŸå¤±10%æœ€å¤§HP',
    },
    // --- å‰©é¥­ (Leftovers) ---
    leftovers: {
        id: 'leftovers',
        name: 'Leftovers',
        cnName: 'å‰©é¥­',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'endOfTurnHeal',
        healPercent: 1/16, // æ¯å›åˆæ¢å¤ 1/16 æœ€å¤§HP
        description: 'æ¯å›åˆç»“æŸæ—¶æ¢å¤1/16æœ€å¤§HP',
    },
    // --- é»‘è‰²æ·¤æ³¥ (Black Sludge) ---
    blacksludge: {
        id: 'blacksludge',
        name: 'Black Sludge',
        cnName: 'é»‘è‰²æ·¤æ³¥',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'blackSludge',
        healPercent: 1/16, // æ¯’ç³»æ¢å¤
        damagePercent: 1/8, // éæ¯’ç³»å—ä¼¤
        description: 'æ¯’å±æ€§æ¯å›åˆæ¢å¤1/16HPï¼Œéæ¯’å±æ€§æ¯å›åˆæŸå¤±1/8HP',
    },
    // --- è¿›åŒ–å¥‡çŸ³ (Eviolite) ---
    eviolite: {
        id: 'eviolite',
        name: 'Eviolite',
        cnName: 'è¿›åŒ–å¥‡çŸ³',
        category: 'held',
        consumable: false,
        fling: { basePower: 40 },
        effect: 'eviolite',
        defBoost: 1.5,
        spdBoost: 1.5,
        requiresNFE: true, // åªå¯¹æœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦æœ‰æ•ˆ
        description: 'æœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦é˜²å¾¡å’Œç‰¹é˜²x1.5',
    },
    // --- çªå‡»èƒŒå¿ƒ (Assault Vest) ---
    assaultvest: {
        id: 'assaultvest',
        name: 'Assault Vest',
        cnName: 'çªå‡»èƒŒå¿ƒ',
        category: 'held',
        consumable: false,
        fling: { basePower: 80 },
        effect: 'assaultVest',
        spdBoost: 1.5,
        disableStatus: true, // ç¦æ­¢ä½¿ç”¨å˜åŒ–æŠ€
        description: 'ç‰¹é˜²x1.5ï¼Œä½†æ— æ³•ä½¿ç”¨å˜åŒ–æŠ€',
    },
    // --- æ°”çƒ (Air Balloon) ---
    airballoon: {
        id: 'airballoon',
        name: 'Air Balloon',
        cnName: 'æ°”çƒ',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        effect: 'airBalloon',
        immunity: ['Ground'], // å…ç–«åœ°é¢
        popOnHit: true, // è¢«æ”»å‡»åç ´è£‚
        description: 'å…ç–«åœ°é¢ç³»æ‹›å¼ï¼Œè¢«æ”»å‡»åç ´è£‚',
    },
    // --- å…‰ä¹‹é»åœŸ (Light Clay) ---
    lightclay: {
        id: 'lightclay',
        name: 'Light Clay',
        cnName: 'å…‰ä¹‹é»åœŸ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'extendScreens',
        screenDuration: 8, // å£ç±»æ‹›å¼æŒç»­8å›åˆï¼ˆé»˜è®¤5ï¼‰
        description: 'åå°„å£ã€å…‰å¢™ã€æå…‰å¹•æŒç»­8å›åˆ',
    },
    // --- å‡¸å‡¸å¤´ç›” (Rocky Helmet) ---
    rockyhelmet: {
        id: 'rockyhelmet',
        name: 'Rocky Helmet',
        cnName: 'å‡¸å‡¸å¤´ç›”',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'rockyHelmet',
        contactDamage: 1/6, // æ¥è§¦æ”»å‡»è€…æŸå¤± 1/6 HP
        description: 'è¢«æ¥è§¦ç±»æ‹›å¼æ”»å‡»æ—¶ï¼Œæ”»å‡»è€…æŸå¤±1/6æœ€å¤§HP',
    },
    // --- è¾¾äººå¸¦ (Expert Belt) ---
    expertbelt: {
        id: 'expertbelt',
        name: 'Expert Belt',
        cnName: 'è¾¾äººå¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'expertBelt',
        superEffectiveBoost: 1.2, // æ•ˆæœæ‹”ç¾¤æ—¶ä¼¤å®³x1.2
        description: 'æ•ˆæœæ‹”ç¾¤çš„æ‹›å¼ä¼¤å®³x1.2',
    },
    // --- å¼±ç‚¹ä¿é™© (Weakness Policy) ---
    weaknesspolicy: {
        id: 'weaknesspolicy',
        name: 'Weakness Policy',
        cnName: 'å¼±ç‚¹ä¿é™©',
        category: 'held',
        consumable: true,
        fling: { basePower: 80 },
        effect: 'weaknessPolicy',
        boosts: { atk: 2, spa: 2 }, // è¢«å¼±ç‚¹æ”»å‡»åæ”»å‡»ç‰¹æ”»+2
        description: 'è¢«æ•ˆæœæ‹”ç¾¤çš„æ‹›å¼æ”»å‡»åï¼Œæ”»å‡»å’Œç‰¹æ”»å„+2çº§',
    },
    // --- ç«ç„°å®ç  (Flame Orb) ---
    flameorb: {
        id: 'flameorb',
        name: 'Flame Orb',
        cnName: 'ç«ç„°å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'brn' },
        effect: 'flameOrb',
        selfStatus: 'brn', // å›åˆç»“æŸæ—¶è‡ªå·±çƒ§ä¼¤
        description: 'å›åˆç»“æŸæ—¶ä½¿è‡ªå·±é™·å…¥ç¼ä¼¤çŠ¶æ€',
    },
    // --- å‰§æ¯’å®ç  (Toxic Orb) ---
    toxicorb: {
        id: 'toxicorb',
        name: 'Toxic Orb',
        cnName: 'å‰§æ¯’å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'tox' },
        effect: 'toxicOrb',
        selfStatus: 'tox', // å›åˆç»“æŸæ—¶è‡ªå·±å‰§æ¯’
        description: 'å›åˆç»“æŸæ—¶ä½¿è‡ªå·±é™·å…¥å‰§æ¯’çŠ¶æ€',
    },
    // --- åšåº•é´ (Heavy-Duty Boots) ---
    heavydutyboots: {
        id: 'heavydutyboots',
        name: 'Heavy-Duty Boots',
        cnName: 'åšåº•é´',
        category: 'held',
        consumable: false,
        fling: { basePower: 80 },
        effect: 'heavyDutyBoots',
        ignoreHazards: true, // å…ç–«å…¥åœºå±å®³ï¼ˆå²©é’‰ã€æ¯’è±ã€é»é»ç½‘ç­‰ï¼‰
        description: 'å…ç–«æ‰€æœ‰å…¥åœºå±å®³ï¼ˆéšå½¢å²©ã€æ’’è±ã€æ¯’è±ã€é»é»ç½‘ï¼‰',
    },
    // --- çº¢ç‰Œ (Red Card) ---
    redcard: {
        id: 'redcard',
        name: 'Red Card',
        cnName: 'çº¢ç‰Œ',
        category: 'held',
        consumable: true,
        fling: { basePower: 10 },
        effect: 'redCard',
        forceSwitch: true, // è¢«æ”»å‡»åå¼ºåˆ¶å¯¹æ–¹æ¢äºº
        description: 'è¢«æ”»å‡»åå¼ºåˆ¶å¯¹æ–¹æ›´æ¢å®å¯æ¢¦',
    },
    // --- é€ƒè„±æŒ‰é”® (Eject Button) ---
    ejectbutton: {
        id: 'ejectbutton',
        name: 'Eject Button',
        cnName: 'é€ƒè„±æŒ‰é”®',
        category: 'held',
        consumable: true,
        fling: { basePower: 30 },
        effect: 'ejectButton',
        selfSwitch: true, // è¢«æ”»å‡»åè‡ªå·±æ¢äºº
        description: 'è¢«æ”»å‡»åå¯ä»¥æ›´æ¢è‡ªå·±çš„å®å¯æ¢¦',
    },
    // --- æºå¸¦é€ƒè·‘åŒ… (Eject Pack) ---
    ejectpack: {
        id: 'ejectpack',
        name: 'Eject Pack',
        cnName: 'æºå¸¦é€ƒè·‘åŒ…',
        category: 'held',
        consumable: true,
        fling: { basePower: 50 },
        effect: 'ejectPack',
        switchOnStatDrop: true, // èƒ½åŠ›ä¸‹é™æ—¶æ¢äºº
        description: 'èƒ½åŠ›ä¸‹é™æ—¶å¯ä»¥æ›´æ¢å®å¯æ¢¦',
    },
    // ========== å±æ€§å¼ºåŒ–é“å…· (Type-Boosting Items) ==========
    charcoal: {
        id: 'charcoal',
        name: 'Charcoal',
        cnName: 'æœ¨ç‚­',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Fire',
        boost: 1.2,
        description: 'ç«å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    mysticwater: {
        id: 'mysticwater',
        name: 'Mystic Water',
        cnName: 'ç¥ç§˜æ°´æ»´',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Water',
        boost: 1.2,
        description: 'æ°´å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    miracleseed: {
        id: 'miracleseed',
        name: 'Miracle Seed',
        cnName: 'å¥‡è¿¹ç§å­',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Grass',
        boost: 1.2,
        description: 'è‰å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    magnet: {
        id: 'magnet',
        name: 'Magnet',
        cnName: 'ç£é“',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Electric',
        boost: 1.2,
        description: 'ç”µå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    nevermeltice: {
        id: 'nevermeltice',
        name: 'Never-Melt Ice',
        cnName: 'ä¸èå†°',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Ice',
        boost: 1.2,
        description: 'å†°å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    blackbelt: {
        id: 'blackbelt',
        name: 'Black Belt',
        cnName: 'é»‘å¸¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Fighting',
        boost: 1.2,
        description: 'æ ¼æ–—å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    poisonbarb: {
        id: 'poisonbarb',
        name: 'Poison Barb',
        cnName: 'æ¯’é’ˆ',
        category: 'held',
        consumable: false,
        fling: { basePower: 70, status: 'psn' },
        effect: 'typeBoost',
        boostedType: 'Poison',
        boost: 1.2,
        description: 'æ¯’å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    softsand: {
        id: 'softsand',
        name: 'Soft Sand',
        cnName: 'æŸ”è½¯æ²™å­',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Ground',
        boost: 1.2,
        description: 'åœ°é¢å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    sharpbeak: {
        id: 'sharpbeak',
        name: 'Sharp Beak',
        cnName: 'é”åˆ©é¸Ÿå˜´',
        category: 'held',
        consumable: false,
        fling: { basePower: 50 },
        effect: 'typeBoost',
        boostedType: 'Flying',
        boost: 1.2,
        description: 'é£è¡Œå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    twistedspoon: {
        id: 'twistedspoon',
        name: 'Twisted Spoon',
        cnName: 'å¼¯æ›²çš„æ±¤åŒ™',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Psychic',
        boost: 1.2,
        description: 'è¶…èƒ½åŠ›å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    silverpowder: {
        id: 'silverpowder',
        name: 'Silver Powder',
        cnName: 'é“¶ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Bug',
        boost: 1.2,
        description: 'è™«å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    hardstone: {
        id: 'hardstone',
        name: 'Hard Stone',
        cnName: 'ç¡¬çŸ³å¤´',
        category: 'held',
        consumable: false,
        fling: { basePower: 100 },
        effect: 'typeBoost',
        boostedType: 'Rock',
        boost: 1.2,
        description: 'å²©çŸ³å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    spelltag: {
        id: 'spelltag',
        name: 'Spell Tag',
        cnName: 'è¯…å’’ä¹‹ç¬¦',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Ghost',
        boost: 1.2,
        description: 'å¹½çµå±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    dragonfang: {
        id: 'dragonfang',
        name: 'Dragon Fang',
        cnName: 'é¾™ä¹‹ç‰™',
        category: 'held',
        consumable: false,
        fling: { basePower: 70 },
        effect: 'typeBoost',
        boostedType: 'Dragon',
        boost: 1.2,
        description: 'é¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    blackglasses: {
        id: 'blackglasses',
        name: 'Black Glasses',
        cnName: 'é»‘è‰²çœ¼é•œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Dark',
        boost: 1.2,
        description: 'æ¶å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    metalcoat: {
        id: 'metalcoat',
        name: 'Metal Coat',
        cnName: 'é‡‘å±è†œ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoost',
        boostedType: 'Steel',
        boost: 1.2,
        description: 'é’¢å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    silkscarf: {
        id: 'silkscarf',
        name: 'Silk Scarf',
        cnName: 'ä¸ç»¸å›´å·¾',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Normal',
        boost: 1.2,
        description: 'ä¸€èˆ¬å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    fairyfeather: {
        id: 'fairyfeather',
        name: 'Fairy Feather',
        cnName: 'å¦–ç²¾ä¹‹ç¾½',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'typeBoost',
        boostedType: 'Fairy',
        boost: 1.2,
        description: 'å¦–ç²¾å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    // ========== å¤ªæ™¶ç  (Tera Orbs) ==========
    teraorb: {
        id: 'teraorb',
        name: 'Tera Orb',
        cnName: 'å¤ªæ™¶ç ',
        category: 'key',
        consumable: false,
        effect: 'enableTera',
        description: 'å…è®¸å®å¯æ¢¦è¿›è¡Œå¤ªæ™¶åŒ–',
    },
    stellarteraorb: {
        id: 'stellarteraorb',
        name: 'Stellar Tera Orb',
        cnName: 'æ˜Ÿæ™¶å¤ªæ™¶ç ',
        category: 'key',
        consumable: false,
        effect: 'enableStellarTera',
        teraType: 'Stellar',
        description: 'ç‰¹æ®Šçš„å¤ªæ™¶ç ï¼Œå…è®¸å®å¯æ¢¦è¿›è¡Œæ˜Ÿæ™¶å¤ªæ™¶åŒ–ã€‚æ˜Ÿæ™¶çŠ¶æ€ä¸‹ï¼šåŸç”Ÿæœ¬ç³»æ‹›å¼2.0xåŠ æˆï¼Œéæœ¬ç³»æ‹›å¼1.2xåŠ æˆï¼Œå¤ªæ™¶çˆ†å‘å¯¹å¤ªæ™¶åŒ–ç›®æ ‡æ’å®šæ•ˆæœæ‹”ç¾¤',
    },
    // ========== ç²¾çµçƒ (PokÃ© Balls) ==========
    pokeball: {
        id: 'pokeball',
        name: 'PokÃ© Ball',
        cnName: 'ç²¾çµçƒ',
        category: 'ball',
        catchRate: 1,
        isPokeball: true,
        description: 'ç”¨äºæ•æ‰é‡ç”Ÿå®å¯æ¢¦çš„é“å…·',
    },
    greatball: {
        id: 'greatball',
        name: 'Great Ball',
        cnName: 'è¶…çº§çƒ',
        category: 'ball',
        catchRate: 1.5,
        isPokeball: true,
        description: 'æ€§èƒ½æ¯”ç²¾çµçƒå¥½ä¸€äº›çš„çƒ',
    },
    ultraball: {
        id: 'ultraball',
        name: 'Ultra Ball',
        cnName: 'é«˜çº§çƒ',
        category: 'ball',
        catchRate: 2,
        isPokeball: true,
        description: 'æ€§èƒ½éå¸¸å¥½çš„çƒ',
    },
    masterball: {
        id: 'masterball',
        name: 'Master Ball',
        cnName: 'å¤§å¸ˆçƒ',
        category: 'ball',
        catchRate: 255, // å¿…å®šæ•è·
        isPokeball: true,
        description: 'å¿…å®šèƒ½æ•æ‰åˆ°é‡ç”Ÿå®å¯æ¢¦çš„æœ€é«˜æ€§èƒ½çƒ',
    },
    premierball: {
        id: 'premierball',
        name: 'Premier Ball',
        cnName: 'çºªå¿µçƒ',
        category: 'ball',
        catchRate: 1,
        isPokeball: true,
        description: 'æŸç§çºªå¿µç”¨çš„ç¨€æœ‰çƒ',
    },
    quickball: {
        id: 'quickball',
        name: 'Quick Ball',
        cnName: 'é€Ÿåº¦çƒ',
        category: 'ball',
        catchRate: 5, // ç¬¬ä¸€å›åˆ
        catchRateLater: 1, // ä¹‹å
        isPokeball: true,
        description: 'æˆ˜æ–—å¼€å§‹æ—¶ä½¿ç”¨æ•ˆæœæ‹”ç¾¤çš„çƒ',
    },
    timerball: {
        id: 'timerball',
        name: 'Timer Ball',
        cnName: 'è®¡æ—¶çƒ',
        category: 'ball',
        // æ•è·ç‡éšå›åˆå¢åŠ 
        isPokeball: true,
        description: 'å›åˆæ•°è¶Šå¤šæ•ˆæœè¶Šå¥½çš„çƒ',
    },
    duskball: {
        id: 'duskball',
        name: 'Dusk Ball',
        cnName: 'é»‘æš—çƒ',
        category: 'ball',
        catchRate: 3, // å¤œæ™šæˆ–æ´ç©´
        catchRateDay: 1,
        isPokeball: true,
        description: 'åœ¨é»‘æš—çš„åœ°æ–¹å®¹æ˜“æ•æ‰çš„çƒ',
    },
    healball: {
        id: 'healball',
        name: 'Heal Ball',
        cnName: 'æ²»æ„ˆçƒ',
        category: 'ball',
        catchRate: 1,
        healOnCatch: true,
        isPokeball: true,
        description: 'æ•æ‰åä¼šç«‹å³æ¢å¤HPå’ŒçŠ¶æ€çš„çƒ',
    },
    netball: {
        id: 'netball',
        name: 'Net Ball',
        cnName: 'æ•ç½‘çƒ',
        category: 'ball',
        catchRate: 3.5, // æ°´/è™«å±æ€§
        catchRateOther: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰æ°´å±æ€§å’Œè™«å±æ€§å®å¯æ¢¦çš„çƒ',
    },
    diveball: {
        id: 'diveball',
        name: 'Dive Ball',
        cnName: 'æ½œæ°´çƒ',
        category: 'ball',
        catchRate: 3.5, // æ°´ä¸­
        catchRateLand: 1,
        isPokeball: true,
        description: 'åœ¨æ°´ä¸­å®¹æ˜“æ•æ‰çš„çƒ',
    },
    luxuryball: {
        id: 'luxuryball',
        name: 'Luxury Ball',
        cnName: 'è±ªåçƒ',
        category: 'ball',
        catchRate: 1,
        friendshipBoost: true,
        isPokeball: true,
        description: 'æ•æ‰åäº²å¯†åº¦æ›´å®¹æ˜“ä¸Šå‡çš„çƒ',
    },
    repeatball: {
        id: 'repeatball',
        name: 'Repeat Ball',
        cnName: 'é‡å¤çƒ',
        category: 'ball',
        catchRate: 3.5, // å·²æ•è·è¿‡çš„ç§ç±»
        catchRateNew: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰æ›¾ç»æ•æ‰è¿‡çš„å®å¯æ¢¦çš„çƒ',
    },
    beastball: {
        id: 'beastball',
        name: 'Beast Ball',
        cnName: 'ç©¶æçƒ',
        category: 'ball',
        catchRate: 5, // ç©¶æå¼‚å…½
        catchRateOther: 0.1,
        isPokeball: true,
        description: 'ç”¨äºæ•æ‰ç©¶æå¼‚å…½çš„ç‰¹æ®Šçƒ',
    },
    dreamball: {
        id: 'dreamball',
        name: 'Dream Ball',
        cnName: 'æ¢¦å¢ƒçƒ',
        category: 'ball',
        catchRate: 4, // ç¡çœ çŠ¶æ€
        catchRateAwake: 1,
        isPokeball: true,
        description: 'å®¹æ˜“æ•æ‰ç¡çœ çŠ¶æ€å®å¯æ¢¦çš„çƒ',
    },
    // ========== æ ‘æœ (Berries) ==========
    // --- å›å¤æ ‘æœ ---
    oranberry: {
        id: 'oranberry',
        name: 'Oran Berry',
        cnName: 'æ©™æ©™æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healAmount: 10,
        triggerHP: 0.5, // HP <= 50% æ—¶è§¦å‘
        naturalGift: { basePower: 80, type: 'Poison' },
        description: 'HPé™åˆ°ä¸€åŠä»¥ä¸‹æ—¶æ¢å¤10ç‚¹HP',
    },
    sitrusberry: {
        id: 'sitrusberry',
        name: 'Sitrus Berry',
        cnName: 'æ–‡æŸšæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 0.25, // æ¢å¤ 25% æœ€å¤§HP
        triggerHP: 0.5,
        naturalGift: { basePower: 80, type: 'Psychic' },
        description: 'HPé™åˆ°ä¸€åŠä»¥ä¸‹æ—¶æ¢å¤25%æœ€å¤§HP',
    },
    // --- 1/3 HP å›å¤æ ‘æœ (æ··ä¹±æ ‘æœ) ---
    figyberry: {
        id: 'figyberry',
        name: 'Figy Berry',
        cnName: 'å‹¿èŠ±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'atk', // å‡æ”»å‡»æ€§æ ¼ä¼šæ··ä¹±
        naturalGift: { basePower: 80, type: 'Bug' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡æ”»å‡»æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    wikiberry: {
        id: 'wikiberry',
        name: 'Wiki Berry',
        cnName: 'å¼‚å¥‡æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spa',
        naturalGift: { basePower: 80, type: 'Rock' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡ç‰¹æ”»æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    magoberry: {
        id: 'magoberry',
        name: 'Mago Berry',
        cnName: 'èŠ’èŠ’æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spe',
        naturalGift: { basePower: 80, type: 'Ghost' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡é€Ÿåº¦æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    aguavberry: {
        id: 'aguavberry',
        name: 'Aguav Berry',
        cnName: 'èŠ­äºšæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'spd',
        naturalGift: { basePower: 80, type: 'Dragon' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡ç‰¹é˜²æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    iapapaberry: {
        id: 'iapapaberry',
        name: 'Iapapa Berry',
        cnName: 'ä¹èŠ­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'healOnLowHP',
        healPercent: 1/3,
        triggerHP: 0.25,
        confuseNature: 'def',
        naturalGift: { basePower: 80, type: 'Dark' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ¢å¤1/3æœ€å¤§HPï¼ˆå‡é˜²å¾¡æ€§æ ¼ä¼šæ··ä¹±ï¼‰',
    },
    // --- çŠ¶æ€å›å¤æ ‘æœ ---
    cheriberry: {
        id: 'cheriberry',
        name: 'Cheri Berry',
        cnName: 'æ¨±å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'par',
        naturalGift: { basePower: 80, type: 'Fire' },
        description: 'æ²»æ„ˆéº»ç—¹çŠ¶æ€',
    },
    chestoberry: {
        id: 'chestoberry',
        name: 'Chesto Berry',
        cnName: 'é›¶ä½™æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'slp',
        naturalGift: { basePower: 80, type: 'Water' },
        description: 'æ²»æ„ˆç¡çœ çŠ¶æ€',
    },
    pechaberry: {
        id: 'pechaberry',
        name: 'Pecha Berry',
        cnName: 'æ¡ƒæ¡ƒæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'psn',
        naturalGift: { basePower: 80, type: 'Electric' },
        description: 'æ²»æ„ˆä¸­æ¯’çŠ¶æ€',
    },
    rawstberry: {
        id: 'rawstberry',
        name: 'Rawst Berry',
        cnName: 'è“è“æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'brn',
        naturalGift: { basePower: 80, type: 'Grass' },
        description: 'æ²»æ„ˆç¼ä¼¤çŠ¶æ€',
    },
    aspearberry: {
        id: 'aspearberry',
        name: 'Aspear Berry',
        cnName: 'åˆ©æœ¨æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureStatus',
        cures: 'frz',
        naturalGift: { basePower: 80, type: 'Ice' },
        description: 'æ²»æ„ˆå†°å†»çŠ¶æ€',
    },
    persimberry: {
        id: 'persimberry',
        name: 'Persim Berry',
        cnName: 'æŸ¿ä»”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureConfusion',
        naturalGift: { basePower: 80, type: 'Ground' },
        description: 'æ²»æ„ˆæ··ä¹±çŠ¶æ€',
    },
    lumberry: {
        id: 'lumberry',
        name: 'Lum Berry',
        cnName: 'æœ¨å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'cureAll',
        naturalGift: { basePower: 80, type: 'Flying' },
        description: 'æ²»æ„ˆæ‰€æœ‰å¼‚å¸¸çŠ¶æ€',
    },
    // --- åŠä¼¤æ ‘æœ (æŠ—æ€§æ ‘æœ) ---
    occaberry: {
        id: 'occaberry',
        name: 'Occa Berry',
        cnName: 'æè”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fire',
        naturalGift: { basePower: 80, type: 'Fire' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„ç«å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    passhoberry: {
        id: 'passhoberry',
        name: 'Passho Berry',
        cnName: 'ç•ªè”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Water',
        naturalGift: { basePower: 80, type: 'Water' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ°´å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    wacanberry: {
        id: 'wacanberry',
        name: 'Wacan Berry',
        cnName: 'è²è’²æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Electric',
        naturalGift: { basePower: 80, type: 'Electric' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„ç”µå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    rindoberry: {
        id: 'rindoberry',
        name: 'Rindo Berry',
        cnName: 'é¾™ç›æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Grass',
        naturalGift: { basePower: 80, type: 'Grass' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è‰å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    yacheberry: {
        id: 'yacheberry',
        name: 'Yache Berry',
        cnName: 'é›ªè²æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ice',
        naturalGift: { basePower: 80, type: 'Ice' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å†°å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chopleberry: {
        id: 'chopleberry',
        name: 'Chople Berry',
        cnName: 'ç½—å­æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fighting',
        naturalGift: { basePower: 80, type: 'Fighting' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ ¼æ–—å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    kebiaberry: {
        id: 'kebiaberry',
        name: 'Kebia Berry',
        cnName: 'è‰èš•æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Poison',
        naturalGift: { basePower: 80, type: 'Poison' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ¯’å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    shucaberry: {
        id: 'shucaberry',
        name: 'Shuca Berry',
        cnName: 'æ²™é³æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ground',
        naturalGift: { basePower: 80, type: 'Ground' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„åœ°é¢å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    cobaberry: {
        id: 'cobaberry',
        name: 'Coba Berry',
        cnName: 'å‹¿èŠ±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Flying',
        naturalGift: { basePower: 80, type: 'Flying' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é£è¡Œå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    payapaberry: {
        id: 'payapaberry',
        name: 'Payapa Berry',
        cnName: 'èŠ­ä¹æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Psychic',
        naturalGift: { basePower: 80, type: 'Psychic' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è¶…èƒ½åŠ›å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    tangaberry: {
        id: 'tangaberry',
        name: 'Tanga Berry',
        cnName: 'æ‰æ¨±æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Bug',
        naturalGift: { basePower: 80, type: 'Bug' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„è™«å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chartiberry: {
        id: 'chartiberry',
        name: 'Charti Berry',
        cnName: 'å²©è”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Rock',
        naturalGift: { basePower: 80, type: 'Rock' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å²©çŸ³å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    kasibberry: {
        id: 'kasibberry',
        name: 'Kasib Berry',
        cnName: 'å¹½çµæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Ghost',
        naturalGift: { basePower: 80, type: 'Ghost' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å¹½çµå±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    habanberry: {
        id: 'habanberry',
        name: 'Haban Berry',
        cnName: 'å“ˆå¯†æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Dragon',
        naturalGift: { basePower: 80, type: 'Dragon' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é¾™å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    colburberry: {
        id: 'colburberry',
        name: 'Colbur Berry',
        cnName: 'éœ¹éœ¹æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Dark',
        naturalGift: { basePower: 80, type: 'Dark' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„æ¶å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    babiriberry: {
        id: 'babiriberry',
        name: 'Babiri Berry',
        cnName: 'éœ¸æ¯”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Steel',
        naturalGift: { basePower: 80, type: 'Steel' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„é’¢å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    chilanberry: {
        id: 'chilanberry',
        name: 'Chilan Berry',
        cnName: 'å¥‡æœ—æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Normal',
        naturalGift: { basePower: 80, type: 'Normal' },
        description: 'å—åˆ°ä¸€èˆ¬å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    roseliberry: {
        id: 'roseliberry',
        name: 'Roseli Berry',
        cnName: 'è”·è–‡æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'resistBerry',
        resistType: 'Fairy',
        naturalGift: { basePower: 80, type: 'Fairy' },
        description: 'å—åˆ°æ•ˆæœæ‹”ç¾¤çš„å¦–ç²¾å±æ€§æ‹›å¼æ—¶ä¼¤å®³å‡åŠ',
    },
    // --- å±æœºå¼ºåŒ–æ ‘æœ (Pinch Berries) ---
    liechiberry: {
        id: 'liechiberry',
        name: 'Liechi Berry',
        cnName: 'æè”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoost',
        statBoost: { atk: 1 },
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Grass' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶æ”»å‡»+1çº§',
    },
    ganlonberry: {
        id: 'ganlonberry',
        name: 'Ganlon Berry',
        cnName: 'é¾™ç›æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoost',
        statBoost: { def: 1 },
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Ice' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶é˜²å¾¡+1çº§',
    },
    salacberry: {
        id: 'salacberry',
        name: 'Salac Berry',
        cnName: 'æ²™é³æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoost',
        statBoost: { spe: 1 },
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Fighting' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶é€Ÿåº¦+1çº§',
    },
    petayaberry: {
        id: 'petayaberry',
        name: 'Petaya Berry',
        cnName: 'é¾™ç«æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoost',
        statBoost: { spa: 1 },
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Poison' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶ç‰¹æ”»+1çº§',
    },
    apicotberry: {
        id: 'apicotberry',
        name: 'Apicot Berry',
        cnName: 'æä»”æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoost',
        statBoost: { spd: 1 },
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Ground' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶ç‰¹é˜²+1çº§',
    },
    starfberry: {
        id: 'starfberry',
        name: 'Starf Berry',
        cnName: 'æ˜Ÿæ¡ƒæœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchBoostRandom',
        boostAmount: 2, // éšæœºä¸€é¡¹+2
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Psychic' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶éšæœºä¸€é¡¹èƒ½åŠ›+2çº§',
    },
    lansatberry: {
        id: 'lansatberry',
        name: 'Lansat Berry',
        cnName: 'å…°è¨æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchCrit',
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Flying' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶è¿›å…¥èšæ°”çŠ¶æ€ï¼ˆå®¹æ˜“å‡»ä¸­è¦å®³ï¼‰',
    },
    custapberry: {
        id: 'custapberry',
        name: 'Custap Berry',
        cnName: 'é‡Šé™€æœ',
        category: 'berry',
        consumable: true,
        isBerry: true,
        effect: 'pinchPriority',
        triggerHP: 0.25,
        naturalGift: { basePower: 100, type: 'Ghost' },
        description: 'HPé™åˆ°1/4ä»¥ä¸‹æ—¶ä¸‹ä¸€æ¬¡è¡ŒåŠ¨è·å¾—å…ˆåˆ¶',
    },
    // ========== ç¥å…½ä¸“å±é“å…· ==========
    adamantorb: {
        id: 'adamantorb',
        name: 'Adamant Orb',
        cnName: 'é‡‘åˆšç‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Dialga'],
        boostedTypes: ['Steel', 'Dragon'],
        boost: 1.2,
        description: 'å¸ç‰™å¢å¡æŒæœ‰æ—¶é’¢å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    lustrousorb: {
        id: 'lustrousorb',
        name: 'Lustrous Orb',
        cnName: 'ç™½ç‰å®ç ',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Palkia'],
        boostedTypes: ['Water', 'Dragon'],
        boost: 1.2,
        description: 'å¸•è·¯å¥‡äºšæŒæœ‰æ—¶æ°´å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    griseousorb: {
        id: 'griseousorb',
        name: 'Griseous Orb',
        cnName: 'ç™½é‡‘ç‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'typeBoostSpecies',
        itemUser: ['Giratina'],
        boostedTypes: ['Ghost', 'Dragon'],
        boost: 1.2,
        forcedForme: 'Giratina-Origin',
        description: 'éª‘æ‹‰å¸çº³æŒæœ‰æ—¶å¹½çµå’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2ï¼Œå¹¶å˜ä¸ºèµ·æºå½¢æ€',
    },
    souldew: {
        id: 'souldew',
        name: 'Soul Dew',
        cnName: 'å¿ƒä¹‹æ°´æ»´',
        category: 'held',
        consumable: false,
        fling: { basePower: 30 },
        effect: 'typeBoostSpecies',
        itemUser: ['Latios', 'Latias'],
        boostedTypes: ['Psychic', 'Dragon'],
        boost: 1.2,
        description: 'æ‹‰å¸æ¬§æ–¯/æ‹‰å¸äºšæ–¯æŒæœ‰æ—¶è¶…èƒ½åŠ›å’Œé¾™å±æ€§æ‹›å¼å¨åŠ›x1.2',
    },
    // --- åŸå§‹å›å½’å®ç  ---
    redorb: {
        id: 'redorb',
        name: 'Red Orb',
        cnName: 'çº¢è‰²å®ç ',
        category: 'held',
        consumable: false,
        effect: 'primalReversion',
        itemUser: ['Groudon'],
        forcedForme: 'Groudon-Primal',
        isPrimalOrb: true,
        description: 'å›ºæ‹‰å¤šæŒæœ‰æ—¶ä¼šè¿›è¡ŒåŸå§‹å›å½’',
    },
    blueorb: {
        id: 'blueorb',
        name: 'Blue Orb',
        cnName: 'è“è‰²å®ç ',
        category: 'held',
        consumable: false,
        effect: 'primalReversion',
        itemUser: ['Kyogre'],
        forcedForme: 'Kyogre-Primal',
        isPrimalOrb: true,
        description: 'ç›–æ¬§å¡æŒæœ‰æ—¶ä¼šè¿›è¡ŒåŸå§‹å›å½’',
    },
    // --- è‹å“/è—ç›ç„¶ç‰¹ä¸“å± ---
    rustedsword: {
        id: 'rustedsword',
        name: 'Rusted Sword',
        cnName: 'è…æœ½çš„å‰‘',
        category: 'held',
        consumable: false,
        effect: 'formeChange',
        itemUser: ['Zacian'],
        forcedForme: 'Zacian-Crowned',
        description: 'è‹å“æŒæœ‰æ—¶ä¼šå˜ä¸ºå‰‘ä¹‹ç‹å½¢æ€',
    },
    rustedshield: {
        id: 'rustedshield',
        name: 'Rusted Shield',
        cnName: 'è…æœ½çš„ç›¾',
        category: 'held',
        consumable: false,
        effect: 'formeChange',
        itemUser: ['Zamazenta'],
        forcedForme: 'Zamazenta-Crowned',
        description: 'è—ç›ç„¶ç‰¹æŒæœ‰æ—¶ä¼šå˜ä¸ºç›¾ä¹‹ç‹å½¢æ€',
    },
    // ========== ä¸“å±å¼ºåŒ–é“å…· ==========
    lightball: {
        id: 'lightball',
        name: 'Light Ball',
        cnName: 'ç”µæ°”çƒ',
        category: 'held',
        consumable: false,
        fling: { basePower: 30, status: 'par' },
        effect: 'speciesBoost',
        itemUser: ['Pikachu'],
        statBoost: { atk: 2, spa: 2 },
        description: 'çš®å¡ä¸˜æŒæœ‰æ—¶æ”»å‡»å’Œç‰¹æ”»ç¿»å€',
    },
    thickclub: {
        id: 'thickclub',
        name: 'Thick Club',
        cnName: 'ç²—éª¨å¤´',
        category: 'held',
        consumable: false,
        fling: { basePower: 90 },
        effect: 'speciesBoost',
        itemUser: ['Cubone', 'Marowak', 'Marowak-Alola'],
        statBoost: { atk: 2 },
        description: 'å¡æ‹‰å¡æ‹‰/å˜å•¦å˜å•¦æŒæœ‰æ—¶æ”»å‡»ç¿»å€',
    },
    leek: {
        id: 'leek',
        name: 'Leek',
        cnName: 'å¤§è‘±',
        category: 'held',
        consumable: false,
        fling: { basePower: 60 },
        effect: 'critBoost',
        itemUser: ['Farfetchd', 'Farfetchd-Galar', 'Sirfetchd'],
        critBoost: 2,
        description: "å¤§è‘±é¸­/è‘±æ¸¸å…µæŒæœ‰æ—¶å®¹æ˜“å‡»ä¸­è¦å®³",
    },
    luckypunch: {
        id: 'luckypunch',
        name: 'Lucky Punch',
        cnName: 'å¹¸è¿æ‹³å¥—',
        category: 'held',
        consumable: false,
        fling: { basePower: 40 },
        effect: 'critBoost',
        itemUser: ['Chansey'],
        critBoost: 2,
        description: 'å‰åˆ©è›‹æŒæœ‰æ—¶å®¹æ˜“å‡»ä¸­è¦å®³',
    },
    metalpowder: {
        id: 'metalpowder',
        name: 'Metal Powder',
        cnName: 'é‡‘å±ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'speciesBoost',
        itemUser: ['Ditto'],
        statBoost: { def: 2 },
        requiresUntransformed: true,
        description: 'ç™¾å˜æ€ªï¼ˆæœªå˜èº«æ—¶ï¼‰æŒæœ‰æ—¶é˜²å¾¡ç¿»å€',
    },
    quickpowder: {
        id: 'quickpowder',
        name: 'Quick Powder',
        cnName: 'é€Ÿåº¦ç²‰',
        category: 'held',
        consumable: false,
        fling: { basePower: 10 },
        effect: 'speciesBoost',
        itemUser: ['Ditto'],
        statBoost: { spe: 2 },
        requiresUntransformed: true,
        description: 'ç™¾å˜æ€ªï¼ˆæœªå˜èº«æ—¶ï¼‰æŒæœ‰æ—¶é€Ÿåº¦ç¿»å€',
    },
};
// ============================================
// é“å…·åˆ†ç±»å¸¸é‡
// ============================================
// ä¸å¯äº¤æ¢çš„é“å…· (Trick/Switcheroo æ— æ•ˆ)
const UNSWAPPABLE_ITEMS = [
    // ç¥å…½ä¸“å±
    'rustedsword', 'rustedshield',
    'griseousorb', 'adamantorb', 'lustrousorb',
    'adamantcrystal', 'lustrousglobe', 'griseouscore',
    // ä¸“å±å¼ºåŒ–
    'souldew', 'lightball', 'thickclub', 'luckypunch', 'leek', 'stick',
    // é‚®ä»¶
    'mail',
    // åŸå§‹å›å½’
    'redorb', 'blueorb',
];
// Mega çŸ³åˆ¤å®š (ä»¥ 'ite' ç»“å°¾ä½†ä¸æ˜¯ 'eviolite')
function isMegaStone(itemId) {
    return itemId.endsWith('ite') && itemId !== 'eviolite';
}
// Z æ°´æ™¶åˆ¤å®š
function isZCrystal(itemId) {
    return itemId.endsWith('iumz') || itemId.endsWith('iniumz');
}
// æ£€æŸ¥é“å…·æ˜¯å¦å¯äº¤æ¢
function isSwappable(itemId) {
    if (!itemId) return true;
    const id = itemId.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (UNSWAPPABLE_ITEMS.includes(id)) return false;
    if (isMegaStone(id)) return false;
    if (isZCrystal(id)) return false;
    return true;
}
// ============================================
// é“å…·æ•ˆæœå¤„ç†å™¨
// ============================================
const ItemEffects = {
    /**
     * æ£€æŸ¥ Focus Sash æ•ˆæœ
     * @returns {boolean} æ˜¯å¦è§¦å‘äº†æ°”åŠ¿æŠ«å¸¦
     */
    checkFocusSash(pokemon, damage) {
        const itemId = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (itemId !== 'focussash') return false;
        if (pokemon.currHp !== pokemon.maxHp) return false;
        if (damage < pokemon.currHp) return false;
        // è§¦å‘æ•ˆæœ
        pokemon.currHp = 1;
        pokemon.item = null;
        pokemon.focusSashTriggered = true;
        return true;
    },
    /**
     * æ£€æŸ¥ Choice é“å…·é”æ‹›
     */
    isChoiceLocked(pokemon) {
        const item = pokemon.item || '';
        const itemData = getItem(item);
        return itemData && itemData.isChoice;
    },
    /**
     * è·å– Light Clay çš„å£æŒç»­å›åˆæ•°
     */
    getScreenDuration(pokemon) {
        const itemId = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
        if (itemId === 'lightclay') return 8;
        return 5;
    },
    /**
     * è·å–ç²¾çµçƒæ•è·ç‡
     */
    getBallCatchRate(ballId, context = {}) {
        const ball = ITEMS[ballId];
        if (!ball || !ball.isPokeball) return 1;
        // ç‰¹æ®Šçƒçš„æ¡ä»¶åˆ¤æ–­
        if (ballId === 'quickball' && context.turn === 1) {
            return ball.catchRate;
        }
        if (ballId === 'quickball' && context.turn > 1) {
            return ball.catchRateLater || 1;
        }
        return ball.catchRate || 1;
    },
    /**
     * æ£€æŸ¥æŠ—æ€§æ ‘æœå‡ä¼¤
     * @param {Object} pokemon - é˜²å¾¡æ–¹
     * @param {string} moveType - æ‹›å¼å±æ€§
     * @param {number} effectiveness - å±æ€§å…‹åˆ¶å€ç‡
     * @returns {Object} { triggered: boolean, damageMultiplier: number, message: string }
     */
    checkResistBerry(pokemon, moveType, effectiveness) {
        if (!pokemon.item || effectiveness < 2) return { triggered: false, damageMultiplier: 1 };
        const itemId = pokemon.item.toLowerCase().replace(/[^a-z0-9]/g, '');
        const itemData = ITEMS[itemId];
        if (!itemData || itemData.effect !== 'resistBerry') return { triggered: false, damageMultiplier: 1 };
        if (itemData.resistType !== moveType) return { triggered: false, damageMultiplier: 1 };
        // è§¦å‘æŠ—æ€§æœ
        const berryName = itemData.cnName || itemData.name;
        pokemon.item = null;
        return {
            triggered: true,
            damageMultiplier: 0.5,
            message: `${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œå‡å¼±äº†ä¼¤å®³ï¼`
        };
    },
    /**
     * æ£€æŸ¥ HP é˜ˆå€¼è§¦å‘çš„æ ‘æœ (å›å¤/å¼ºåŒ–)
     * @param {Object} pokemon - å®å¯æ¢¦
     * @param {Array} logs - æ—¥å¿—æ•°ç»„
     * @returns {boolean} æ˜¯å¦è§¦å‘äº†æ ‘æœ
     */
    checkHPBerry(pokemon, logs = []) {
        if (!pokemon.item) return false;
        const itemId = pokemon.item.toLowerCase().replace(/[^a-z0-9]/g, '');
        const itemData = ITEMS[itemId];
        if (!itemData || !itemData.isBerry) return false;
        const hpPercent = pokemon.currHp / pokemon.maxHp;
        const isGluttony = pokemon.ability && pokemon.ability.toLowerCase().replace(/[^a-z]/g, '') === 'gluttony';
        // è´ªåƒé¬¼ç‰¹æ€§ï¼šè§¦å‘çº¿æå‡åˆ° 50%
        let triggerThreshold = itemData.triggerHP || 0.25;
        if (isGluttony && triggerThreshold === 0.25) {
            triggerThreshold = 0.5;
        }
        if (hpPercent > triggerThreshold) return false;
        const berryName = itemData.cnName || itemData.name;
        // å›å¤ç±»æ ‘æœ
        if (itemData.effect === 'healOnLowHP') {
            let heal = 0;
            if (itemData.healPercent) {
                heal = Math.floor(pokemon.maxHp * itemData.healPercent);
            } else if (itemData.healAmount) {
                heal = itemData.healAmount;
            }
            if (heal > 0) {
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + heal);
                pokemon.item = null;
                logs.push(`<span style="color:#27ae60">ğŸ‡ ${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œå›å¤äº† ${heal} ç‚¹ä½“åŠ›ï¼</span>`);
                return true;
            }
        }
        // å¼ºåŒ–ç±»æ ‘æœ
        if (itemData.effect === 'pinchBoost' && itemData.statBoost) {
            pokemon.item = null;
            if (typeof pokemon.applyBoost === 'function') {
                for (const [stat, amount] of Object.entries(itemData.statBoost)) {
                    pokemon.applyBoost(stat, amount);
                }
            } else {
                if (!pokemon.boosts) pokemon.boosts = {};
                for (const [stat, amount] of Object.entries(itemData.statBoost)) {
                    pokemon.boosts[stat] = Math.min(6, (pokemon.boosts[stat] || 0) + amount);
                }
            }
            const statNames = { atk: 'æ”»å‡»', def: 'é˜²å¾¡', spa: 'ç‰¹æ”»', spd: 'ç‰¹é˜²', spe: 'é€Ÿåº¦' };
            const boostStr = Object.entries(itemData.statBoost).map(([s, a]) => `${statNames[s] || s}+${a}`).join('/');
            logs.push(`<span style="color:#f39c12">ğŸ’ ${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œ${boostStr}ï¼</span>`);
            return true;
        }
        // éšæœºå¼ºåŒ–æ ‘æœ (æ˜Ÿæ¡ƒæœ)
        if (itemData.effect === 'pinchBoostRandom') {
            pokemon.item = null;
            const stats = ['atk', 'def', 'spa', 'spd', 'spe'];
            const randomStat = stats[Math.floor(Math.random() * stats.length)];
            const amount = itemData.boostAmount || 2;
            if (typeof pokemon.applyBoost === 'function') {
                pokemon.applyBoost(randomStat, amount);
            } else {
                if (!pokemon.boosts) pokemon.boosts = {};
                pokemon.boosts[randomStat] = Math.min(6, (pokemon.boosts[randomStat] || 0) + amount);
            }
            const statNames = { atk: 'æ”»å‡»', def: 'é˜²å¾¡', spa: 'ç‰¹æ”»', spd: 'ç‰¹é˜²', spe: 'é€Ÿåº¦' };
            logs.push(`<span style="color:#f39c12">â­ ${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œ${statNames[randomStat]}+${amount}ï¼</span>`);
            return true;
        }
        // èšæ°”æ ‘æœ (å…°è¨æœ)
        if (itemData.effect === 'pinchCrit') {
            pokemon.item = null;
            if (!pokemon.volatile) pokemon.volatile = {};
            pokemon.volatile.focusenergy = true;
            logs.push(`<span style="color:#e74c3c">ğŸ”¥ ${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œè¿›å…¥äº†èšæ°”çŠ¶æ€ï¼</span>`);
            return true;
        }
        // å…ˆåˆ¶æ ‘æœ (é‡Šé™€æœ)
        if (itemData.effect === 'pinchPriority') {
            pokemon.item = null;
            if (!pokemon.volatile) pokemon.volatile = {};
            pokemon.volatile.custap = true;
            logs.push(`<span style="color:#9b59b6">âš¡ ${pokemon.cnName} åƒæ‰äº†${berryName}ï¼Œä¸‹ä¸€æ¬¡è¡ŒåŠ¨å°†è·å¾—å…ˆåˆ¶ï¼</span>`);
            return true;
        }
        return false;
    },
};
// ============================================
// å·¥å…·å‡½æ•°
// ============================================
/**
 * æ ¹æ® ID è·å–é“å…·æ•°æ®
 * @param {string} itemName - é“å…·åç§°æˆ– ID
 * @returns {Object|null} é“å…·æ•°æ®å¯¹è±¡
 */
function getItem(itemName) {
    if (!itemName) return null;
    const id = itemName.toLowerCase().replace(/[^a-z0-9]/g, '');
    return ITEMS[id] || null;
}
/**
 * æ ¹æ®é“å…·åç§°è·å– ID
 */
function getItemId(itemName) {
    if (!itemName) return null;
    return itemName.toLowerCase().replace(/[^a-z0-9]/g, '');
}
/**
 * è·å–æ‰€æœ‰ç²¾çµçƒ
 */
function getAllPokeballs() {
    return Object.values(ITEMS).filter(item => item.isPokeball);
}
/**
 * è·å–æ‰€æœ‰æ ‘æœ
 */
function getAllBerries() {
    return Object.values(ITEMS).filter(item => item.isBerry);
}
/**
 * æ£€æŸ¥æ˜¯å¦ä¸º Choice é“å…·
 */
function isChoiceItem(itemName) {
    const item = getItem(itemName);
    return item && item.isChoice;
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.ITEMS = ITEMS;
    window.UNSWAPPABLE_ITEMS = UNSWAPPABLE_ITEMS;
    window.ItemEffects = ItemEffects;
    window.getItem = getItem;
    window.getItemId = getItemId;
    window.getAllPokeballs = getAllPokeballs;
    window.getAllBerries = getAllBerries;
    window.isChoiceItem = isChoiceItem;
    window.isMegaStone = isMegaStone;
    window.isZCrystal = isZCrystal;
    window.isSwappable = isSwappable;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        ITEMS,
        UNSWAPPABLE_ITEMS,
        ItemEffects,
        getItem,
        getItemId,
        getAllPokeballs,
        getAllBerries,
        isChoiceItem,
        isMegaStone,
        isZCrystal,
        isSwappable,
    };
}
]]></file>
        <file name="move-effects.js"><![CDATA[/**
 * =============================================
 * MOVE EFFECTS - æŠ€èƒ½æ•ˆæœæ‰©å±•æ¨¡å—
 * =============================================
 * 
 * å¤„ç† moves-data.js ä¸­çš„é€šç”¨å­—æ®µï¼Œå®ç°é«˜çº§æˆ˜æ–—æœºåˆ¶ï¼š
 * - ä¼˜å…ˆçº§ (Priority)
 * - çŠ¶æ€å¼‚å¸¸ (Status Conditions)
 * - å¤©æ°”æ•ˆæœ (Weather)
 * - åœºåœ°æ•ˆæœ (Terrain)
 * - ç‰¹æ®ŠæŠ€èƒ½æ ‡è®° (Flags)
 * - å›ºå®šä¼¤å®³æŠ€èƒ½
 * - ä¸€å‡»å¿…æ€æŠ€èƒ½
 */
// ========== ä¼˜å…ˆçº§ç³»ç»Ÿ (Priority) ==========
// å†³å®šå›åˆå†…çš„è¡ŒåŠ¨é¡ºåº
/**
 * è·å–æŠ€èƒ½ä¼˜å…ˆçº§
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @param {object} user ä½¿ç”¨è€…ï¼ˆå¯é€‰ï¼Œç”¨äºç‰¹æ€§ä¿®æ­£ï¼‰
 * @param {object} target ç›®æ ‡ï¼ˆå¯é€‰ï¼Œç”¨äºæ¶ä½œå‰§ä¹‹å¿ƒå…ç–«åˆ¤å®šï¼‰
 * @returns {number} ä¼˜å…ˆçº§ (-7 ~ +5)
 */
function getMovePriority(move, user = null, target = null) {
    // ã€å¤æ­¦ç³»ç»Ÿã€‘å¦‚æœæ‹›å¼å¯¹è±¡å·²æœ‰ priority å±æ€§ï¼ˆè¢« style ä¿®æ”¹è¿‡ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
    if (typeof move.priority === 'number') {
        return move.priority;
    }
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // ä»æ•°æ®ä¸­è¯»å–ä¼˜å…ˆçº§
    let basePriority = 0;
    if (typeof fullMoveData.priority === 'number') {
        basePriority = fullMoveData.priority;
    }
    // ç¡¬ç¼–ç å¸¸è§ä¼˜å…ˆçº§æŠ€èƒ½ï¼ˆå¦‚æœæ•°æ®åº“æ²¡æœ‰ï¼‰
    if (basePriority === 0) {
        const priorityMap = {
            // +5
            'Helping Hand': 5,
            // +4
            'Protect': 4, 'Detect': 4, 'Endure': 4, 'Magic Coat': 4, 'Snatch': 4,
            'Baneful Bunker': 4, 'Spiky Shield': 4, "King's Shield": 4, 'Obstruct': 4,
            'Silk Trap': 4, 'Burning Bulwark': 4,
            // +3
            'Fake Out': 3, 'Quick Guard': 3, 'Wide Guard': 3, 'Crafty Shield': 3,
            // +2
            'Extreme Speed': 2, 'Feint': 2, 'First Impression': 2, 'Accelerock': 2,
            // +1
            'Aqua Jet': 1, 'Baby-Doll Eyes': 1, 'Bullet Punch': 1, 'Ice Shard': 1,
            'Mach Punch': 1, 'Quick Attack': 1, 'Shadow Sneak': 1, 'Sucker Punch': 1,
            'Vacuum Wave': 1, 'Water Shuriken': 1, 'Grassy Glide': 1, 'Jet Punch': 1,
            // -1
            'Vital Throw': -1,
            // -3
            'Focus Punch': -3,
            // -4
            'Avalanche': -4, 'Revenge': -4,
            // -5
            'Counter': -5, 'Mirror Coat': -5,
            // -6
            'Circle Throw': -6, 'Dragon Tail': -6, 'Roar': -6, 'Whirlwind': -6, 'Teleport': -6,
            // -7
            'Trick Room': -7
        };
        basePriority = priorityMap[move.name] || 0;
    }
    // === ã€æ¶ä½œå‰§ä¹‹å¿ƒ Pranksterã€‘ç‰¹æ€§å¤„ç† ===
    // å˜åŒ–æŠ€ä¼˜å…ˆåº¦+1ï¼Œä½†å¯¹æ¶ç³»ç›®æ ‡æ— æ•ˆ
    if (user && user.ability === 'Prankster') {
        const category = fullMoveData.category || (move.cat === 'spec' ? 'Special' : (move.cat === 'phys' ? 'Physical' : 'Status'));
        if (category === 'Status' || move.cat === 'status') {
            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦ä¸ºæ¶ç³»ï¼ˆæ¶ç³»å…ç–«æ¶ä½œå‰§ä¹‹å¿ƒçš„å˜åŒ–æŠ€ï¼‰
            if (target && target.types && target.types.includes('Dark')) {
                console.log(`[PRANKSTER] ${target.cnName} æ˜¯æ¶å±æ€§ï¼Œå…ç–«æ¶ä½œå‰§ä¹‹å¿ƒçš„å˜åŒ–æŠ€ï¼`);
                // è¿”å›ä¸€ä¸ªç‰¹æ®Šæ ‡è®°ï¼Œè®©è°ƒç”¨æ–¹çŸ¥é“æŠ€èƒ½æ— æ•ˆ
                move.pranksterBlocked = true;
            } else {
                basePriority += 1;
                console.log(`[PRANKSTER] ${user.cnName} çš„æ¶ä½œå‰§ä¹‹å¿ƒä½¿ ${move.name} ä¼˜å…ˆåº¦+1`);
            }
        }
    }
    // === ã€ç–¾é£ä¹‹ç¿¼ Gale Wingsã€‘ç‰¹æ€§å¤„ç† ===
    // æ»¡è¡€æ—¶é£è¡Œç³»æ‹›å¼ä¼˜å…ˆåº¦+1
    if (user && user.ability === 'Gale Wings' && move.type === 'Flying') {
        if (user.currHp === user.maxHp) {
            basePriority += 1;
            console.log(`[GALE WINGS] ${user.cnName} çš„ç–¾é£ä¹‹ç¿¼ä½¿é£è¡Œç³»æ‹›å¼ä¼˜å…ˆåº¦+1`);
        }
    }
    // === ã€æ…¢å‡º Stallã€‘ç‰¹æ€§å¤„ç† ===
    // æ°¸è¿œæœ€åè¡ŒåŠ¨ï¼ˆä¼˜å…ˆåº¦è®¾ä¸º -6ï¼‰
    if (user && user.ability === 'Stall') {
        basePriority = -6;
        console.log(`[STALL] ${user.cnName} çš„æ…¢å‡ºç‰¹æ€§ä½¿å…¶æ°¸è¿œæœ€åè¡ŒåŠ¨`);
    }
    // === é€šç”¨ onModifyPriority é’©å­ ===
    // ã€ä¿®å¤ã€‘å‚æ•°é¡ºåºï¼š(priority, user, target, move)
    if (user && user.ability && typeof AbilityHandlers !== 'undefined') {
        const abilityHandler = AbilityHandlers[user.ability];
        if (abilityHandler && abilityHandler.onModifyPriority) {
            // target å‚æ•°åœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­å¯èƒ½ä¸å¯ç”¨ï¼Œä¼  null
            const modifiedPriority = abilityHandler.onModifyPriority(basePriority, user, null, move);
            if (typeof modifiedPriority === 'number') {
                basePriority = modifiedPriority;
            }
        }
    }
    return basePriority;
}
/**
 * æ¯”è¾ƒä¸¤ä¸ªè¡ŒåŠ¨çš„å…ˆåé¡ºåº
 * @param {object} action1 { pokemon, move, isPlayer }
 * @param {object} action2 { pokemon, move, isPlayer }
 * @returns {number} è´Ÿæ•°=action1å…ˆï¼Œæ­£æ•°=action2å…ˆï¼Œ0=åŒé€Ÿ
 */
function compareActionOrder(action1, action2) {
    const pri1 = getMovePriority(action1.move);
    const pri2 = getMovePriority(action2.move);
    // ä¼˜å…ˆçº§é«˜çš„å…ˆåŠ¨
    if (pri1 !== pri2) {
        return pri2 - pri1;
    }
    // åŒä¼˜å…ˆçº§æ¯”é€Ÿåº¦
    const spe1 = action1.pokemon.getStat('spe');
    const spe2 = action2.pokemon.getStat('spe');
    if (spe1 !== spe2) {
        return spe2 - spe1; // é€Ÿåº¦é«˜çš„å…ˆåŠ¨
    }
    // åŒé€Ÿéšæœº
    return Math.random() < 0.5 ? -1 : 1;
}
// ========== çŠ¶æ€å¼‚å¸¸ç³»ç»Ÿ (Status Conditions) ==========
const STATUS_CONDITIONS = {
    // ä¸»è¦çŠ¶æ€ï¼ˆäº’æ–¥ï¼‰
    par: { name: 'éº»ç—¹', color: '#f1c40f', speedMod: 0.5, skipChance: 0.25 },
    brn: { name: 'ç¼ä¼¤', color: '#e74c3c', atkMod: 0.5, dotPercent: 1/16 },
    psn: { name: 'ä¸­æ¯’', color: '#9b59b6', dotPercent: 1/8 },
    tox: { name: 'å‰§æ¯’', color: '#8e44ad', dotBase: 1/16, dotIncrement: true },
    slp: { name: 'ç¡çœ ', color: '#95a5a6', skipChance: 1, duration: [1, 3] },
    frz: { name: 'å†°å†»', color: '#3498db', skipChance: 1, thawChance: 0.2 }
};
/**
 * å°è¯•ç»™ç›®æ ‡æ–½åŠ çŠ¶æ€å¼‚å¸¸
 * ã€è½¯ç¼–ç ã€‘æ”¯æŒå±æ€§å…ç–«ã€ç‰¹æ€§å…ç–«ã€è…èš€ç‰¹æ€§ã€è–„é›¾åœºåœ°ç­‰
 * @param {Pokemon} target ç›®æ ‡
 * @param {string} status çŠ¶æ€ID (par/brn/psn/tox/slp/frz)
 * @param {Pokemon} source æ¥æºï¼ˆå¯é€‰ï¼Œç”¨äºè…èš€ç‰¹æ€§åˆ¤å®šï¼‰
 * @param {object} battle æˆ˜æ–—å¯¹è±¡ï¼ˆå¯é€‰ï¼Œç”¨äºåœºåœ°åˆ¤å®šï¼‰
 * @returns {object} { success, message }
 */
function tryInflictStatus(target, status, source = null, battle = null) {
    // å·²æœ‰ä¸»è¦çŠ¶æ€åˆ™æ— æ³•æ–½åŠ 
    if (target.status) {
        return { success: false, message: `${target.cnName} å·²ç»å¤„äºå¼‚å¸¸çŠ¶æ€!` };
    }
    const targetAbility = (target.ability || '').toLowerCase().replace(/[^a-z]/g, '');
    const sourceAbility = source ? (source.ability || '').toLowerCase().replace(/[^a-z]/g, '') : '';
    // === ã€ç‰¹æ€§å…ç–«æ£€æŸ¥ã€‘ä¼˜å…ˆäºå±æ€§å…ç–« ===
    // ã€å…ç–« Immunityã€‘å®Œå…¨å…ç–«ä¸­æ¯’
    if (targetAbility === 'immunity' && (status === 'psn' || status === 'tox')) {
        return { success: false, message: `${target.cnName} çš„å…ç–«ç‰¹æ€§é˜»æ­¢äº†ä¸­æ¯’!` };
    }
    // ã€ç²‰å½©æŠ¤å¹• Pastel Veilã€‘å…ç–«ä¸­æ¯’
    if (targetAbility === 'pastelveil' && (status === 'psn' || status === 'tox')) {
        return { success: false, message: `${target.cnName} çš„ç²‰å½©æŠ¤å¹•é˜»æ­¢äº†ä¸­æ¯’!` };
    }
    // ã€æ´å‡€ä¹‹ç› Purifying Saltã€‘å…ç–«æ‰€æœ‰å¼‚å¸¸çŠ¶æ€
    if (targetAbility === 'purifyingsalt') {
        return { success: false, message: `${target.cnName} çš„æ´å‡€ä¹‹ç›é˜»æ­¢äº†å¼‚å¸¸çŠ¶æ€!` };
    }
    // ã€ç»å¯¹ç¡çœ  Comatoseã€‘è§†ä¸ºç¡çœ çŠ¶æ€ï¼Œæ— æ³•è¢«è¦†ç›–
    if (targetAbility === 'comatose') {
        return { success: false, message: `${target.cnName} å¤„äºç»å¯¹ç¡çœ çŠ¶æ€ï¼Œæ— æ³•è¢«å½±å“!` };
    }
    // ã€ç•Œé™ç›¾å£³ Shields Downã€‘HP > 50% æ—¶å…ç–«å¼‚å¸¸çŠ¶æ€
    if (targetAbility === 'shieldsdown' && target.currHp > target.maxHp / 2) {
        return { success: false, message: `${target.cnName} çš„ç•Œé™ç›¾å£³é˜»æ­¢äº†å¼‚å¸¸çŠ¶æ€!` };
    }
    // ã€æ°´å¹• Water Veilã€‘å…ç–«ç¼ä¼¤
    if (targetAbility === 'waterveil' && status === 'brn') {
        return { success: false, message: `${target.cnName} çš„æ°´å¹•é˜»æ­¢äº†ç¼ä¼¤!` };
    }
    // ã€ç†”å²©é“ ç”² Magma Armorã€‘å…ç–«å†°å†»
    if (targetAbility === 'magmaarmor' && status === 'frz') {
        return { success: false, message: `${target.cnName} çš„ç†”å²©é“ ç”²é˜»æ­¢äº†å†°å†»!` };
    }
    // ã€æŸ”è½¯ Limberã€‘å…ç–«éº»ç—¹
    if (targetAbility === 'limber' && status === 'par') {
        return { success: false, message: `${target.cnName} çš„æŸ”è½¯é˜»æ­¢äº†éº»ç—¹!` };
    }
    // ã€ä¸çœ  Insomnia / å¹²åŠ² Vital Spiritã€‘å…ç–«ç¡çœ 
    if ((targetAbility === 'insomnia' || targetAbility === 'vitalspirit') && status === 'slp') {
        return { success: false, message: `${target.cnName} æ— æ³•å…¥ç¡!` };
    }
    // ã€å¶å­é˜²å®ˆ Leaf Guardã€‘å¤§æ™´å¤©æ—¶å…ç–«å¼‚å¸¸çŠ¶æ€
    if (targetAbility === 'leafguard') {
        const currentWeather = battle?.weather || (typeof window.battle !== 'undefined' ? window.battle.weather : null);
        if (currentWeather === 'sun' || currentWeather === 'harshsun') {
            return { success: false, message: `${target.cnName} çš„å¶å­é˜²å®ˆåœ¨é˜³å…‰ä¸‹é˜»æ­¢äº†å¼‚å¸¸çŠ¶æ€!` };
        }
    }
    // === ã€è–„é›¾åœºåœ° Misty Terrainã€‘å…ç–«å¼‚å¸¸çŠ¶æ€ ===
    const currentTerrain = battle?.terrain || (typeof window.battle !== 'undefined' ? window.battle.terrain : null);
    if (currentTerrain === 'misty') {
        // æ£€æŸ¥æ˜¯å¦åœ¨åœ°é¢ä¸Šï¼ˆé£è¡Œç³»/æ¼‚æµ®ä¸å—åœºåœ°å½±å“ï¼‰
        const isGrounded = !target.types?.includes('Flying') && targetAbility !== 'levitate';
        if (isGrounded) {
            return { success: false, message: `è–„é›¾åœºåœ°ä¿æŠ¤äº† ${target.cnName}ï¼Œæ— æ³•é™·å…¥å¼‚å¸¸çŠ¶æ€!` };
        }
    }
    // === ã€å±æ€§å…ç–«æ£€æŸ¥ã€‘===
    const immunities = {
        par: ['Electric'], // ç”µç³»å…ç–«éº»ç—¹
        brn: ['Fire'],     // ç«ç³»å…ç–«ç¼ä¼¤
        psn: ['Poison', 'Steel'], // æ¯’/é’¢ç³»å…ç–«ä¸­æ¯’
        tox: ['Poison', 'Steel'],
        frz: ['Ice']       // å†°ç³»å…ç–«å†°å†»
    };
    // ã€è…èš€ Corrosionã€‘å¯ä»¥è®©é’¢/æ¯’ç³»ä¸­æ¯’
    const hasCorrosion = sourceAbility === 'corrosion';
    if (immunities[status] && target.types) {
        for (const type of target.types) {
            if (immunities[status].includes(type)) {
                // è…èš€ç‰¹æ€§å¯ä»¥æ— è§†æ¯’/é’¢ç³»å¯¹ä¸­æ¯’çš„å…ç–«
                if (hasCorrosion && (status === 'psn' || status === 'tox') && (type === 'Poison' || type === 'Steel')) {
                    console.log(`[CORROSION] ${source?.cnName} çš„è…èš€ç‰¹æ€§æ— è§†äº† ${target.cnName} çš„${type}å±æ€§å…ç–«!`);
                    continue; // è·³è¿‡è¿™ä¸ªå…ç–«æ£€æŸ¥
                }
                return { success: false, message: `${target.cnName} çš„${type}å±æ€§å…ç–«äº†è¯¥çŠ¶æ€!` };
            }
        }
    }
    // æ–½åŠ çŠ¶æ€
    target.status = status;
    target.statusTurns = 0;
    const statusInfo = STATUS_CONDITIONS[status];
    let message = `${target.cnName} ${statusInfo.name}äº†!`;
    // è…èš€ç‰¹æ€§çš„ç‰¹æ®Šæç¤º
    if (hasCorrosion && (status === 'psn' || status === 'tox')) {
        message = `${source?.cnName} çš„è…èš€ç‰¹æ€§è®© ${target.cnName} ä¸­æ¯’äº†!`;
    }
    return { success: true, message };
}
/**
 * å¤„ç†å›åˆå¼€å§‹æ—¶çš„çŠ¶æ€æ•ˆæœ
 * @param {Pokemon} pokemon 
 * @returns {object} { canMove, damage, message }
 */
function processStatusEffects(pokemon) {
    if (!pokemon.status) {
        return { canMove: true, damage: 0, message: null };
    }
    const status = pokemon.status;
    const info = STATUS_CONDITIONS[status];
    let result = { canMove: true, damage: 0, message: null };
    switch (status) {
        case 'par':
            // 25% æ¦‚ç‡æ— æ³•è¡ŒåŠ¨
            if (Math.random() < info.skipChance) {
                result.canMove = false;
                result.message = `${pokemon.cnName} å› éº»ç—¹è€Œæ— æ³•è¡ŒåŠ¨!`;
            }
            break;
        case 'slp':
            pokemon.statusTurns++;
            const sleepDuration = pokemon.sleepDuration || (Math.floor(Math.random() * 3) + 1);
            pokemon.sleepDuration = sleepDuration;
            if (pokemon.statusTurns >= sleepDuration) {
                pokemon.status = null;
                pokemon.statusTurns = 0;
                pokemon.sleepDuration = 0;
                result.message = `${pokemon.cnName} é†’æ¥äº†!`;
            } else {
                result.canMove = false;
                result.message = `${pokemon.cnName} æ­£åœ¨ç¡è§‰...`;
            }
            break;
        case 'frz':
            // 20% æ¦‚ç‡è§£å†»
            if (Math.random() < info.thawChance) {
                pokemon.status = null;
                result.message = `${pokemon.cnName} è§£å†»äº†!`;
            } else {
                result.canMove = false;
                result.message = `${pokemon.cnName} è¢«å†»ä½äº†!`;
            }
            break;
    }
    return result;
}
/**
 * å¤„ç†å›åˆç»“æŸæ—¶çš„çŠ¶æ€ä¼¤å®³
 * ã€è½¯ç¼–ç ã€‘æ”¯æŒæ¯’ç–—ã€é­”æ³•é˜²å®ˆç­‰ç‰¹æ€§
 * @param {Pokemon} pokemon 
 * @returns {object} { damage, message, healed }
 */
function processStatusDamage(pokemon) {
    if (!pokemon.status) {
        return { damage: 0, message: null, healed: false };
    }
    const status = pokemon.status;
    const abilityId = (pokemon.ability || '').toLowerCase().replace(/[^a-z]/g, '');
    let damage = 0;
    let message = null;
    // === ã€æ¯’ç–— Poison Healã€‘ç‰¹æ€§å¤„ç† ===
    // ä¸­æ¯’/å‰§æ¯’æ—¶å›å¤ 1/8 HP è€Œéå—ä¼¤
    if (abilityId === 'poisonheal' && (status === 'psn' || status === 'tox')) {
        const healAmount = Math.max(1, Math.floor(pokemon.maxHp / 8));
        if (typeof pokemon.heal === 'function') {
            pokemon.heal(healAmount);
        } else {
            pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + healAmount);
        }
        return { 
            damage: 0, 
            message: `<span style="color:#4cd137">ğŸ’š ${pokemon.cnName} çš„æ¯’ç–—ç‰¹æ€§å‘åŠ¨ï¼Œå›å¤äº† ${healAmount} ç‚¹ä½“åŠ›!</span>`,
            healed: true
        };
    }
    // === ã€é­”æ³•é˜²å®ˆ Magic Guardã€‘ç‰¹æ€§å¤„ç† ===
    // å…ç–«æ‰€æœ‰éç›´æ¥æ”»å‡»ä¼¤å®³ï¼ˆåŒ…æ‹¬çŠ¶æ€ä¼¤å®³ï¼‰
    if (abilityId === 'magicguard') {
        return { damage: 0, message: null, healed: false };
    }
    switch (status) {
        case 'brn':
            // ã€æ ¹æ€§ Guts / æ¯…åŠ›ã€‘ä¸å‡å°‘ç¼ä¼¤ä¼¤å®³ï¼Œä½†æå‡æ”»å‡»
            damage = Math.max(1, Math.floor(pokemon.maxHp / 16));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› ç¼ä¼¤å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
        case 'psn':
            damage = Math.max(1, Math.floor(pokemon.maxHp / 8));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› ä¸­æ¯’å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
        case 'tox':
            pokemon.statusTurns = (pokemon.statusTurns || 0) + 1;
            damage = Math.max(1, Math.floor(pokemon.maxHp * pokemon.statusTurns / 16));
            pokemon.takeDamage(damage);
            message = `${pokemon.cnName} å› å‰§æ¯’å—åˆ°äº† ${damage} ç‚¹ä¼¤å®³!`;
            break;
    }
    return { damage, message, healed: false };
}
// ========== æŠ€èƒ½é™„åŠ çŠ¶æ€æ•ˆæœ ==========
/**
 * å¤„ç†æŠ€èƒ½çš„çŠ¶æ€å¼‚å¸¸é™„åŠ æ•ˆæœ
 * @param {Pokemon} user æ”»å‡»æ–¹
 * @param {Pokemon} target é˜²å¾¡æ–¹
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function processMoveStatusEffects(user, target, move) {
    const logs = [];
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // === ã€è‰ç³»å…ç–«ç²‰æœ«ç±»æ‹›å¼ã€‘===
    const powderMoves = ['spore', 'sleeppowder', 'poisonpowder', 'stunspore', 'ragepowder', 'cottonspore', 'powder'];
    if (powderMoves.includes(moveId) && target.types && target.types.includes('Grass')) {
        logs.push(`${target.cnName} çš„è‰å±æ€§å…ç–«äº†ç²‰æœ«ç±»æ‹›å¼!`);
        return logs;
    }
    // === ã€è‰ç³»å…ç–«å¯„ç”Ÿç§å­ã€‘===
    if (moveId === 'leechseed' && target.types && target.types.includes('Grass')) {
        logs.push(`${target.cnName} çš„è‰å±æ€§å…ç–«äº†å¯„ç”Ÿç§å­!`);
        return logs;
    }
    // æ£€æŸ¥ secondary ä¸­çš„çŠ¶æ€æ•ˆæœ
    if (fullMoveData.secondary && fullMoveData.secondary.status) {
        const chance = fullMoveData.secondary.chance || 100;
        if (Math.random() * 100 < chance) {
            const result = tryInflictStatus(target, fullMoveData.secondary.status);
            if (result.message) logs.push(result.message);
        }
    }
    // æ£€æŸ¥å¿…å®šè§¦å‘çš„çŠ¶æ€æ•ˆæœ
    if (fullMoveData.status) {
        const result = tryInflictStatus(target, fullMoveData.status);
        if (result.message) logs.push(result.message);
    }
    // ç¡¬ç¼–ç å¸¸è§çŠ¶æ€æŠ€èƒ½
    const statusMoves = {
        'Thunder Wave': { status: 'par', chance: 100 },
        'Stun Spore': { status: 'par', chance: 100 },
        'Glare': { status: 'par', chance: 100 },
        'Nuzzle': { status: 'par', chance: 100 },
        'Will-O-Wisp': { status: 'brn', chance: 100 },
        'Toxic': { status: 'tox', chance: 100 },
        'Poison Powder': { status: 'psn', chance: 100 },
        'Poison Gas': { status: 'psn', chance: 100 },
        'Spore': { status: 'slp', chance: 100 },
        'Sleep Powder': { status: 'slp', chance: 75 },
        'Hypnosis': { status: 'slp', chance: 60 },
        'Sing': { status: 'slp', chance: 55 },
        // æ”»å‡»æŠ€èƒ½é™„å¸¦æ•ˆæœ
        'Thunderbolt': { status: 'par', chance: 10 },
        'Thunder': { status: 'par', chance: 30 },
        'Discharge': { status: 'par', chance: 30 },
        'Body Slam': { status: 'par', chance: 30 },
        'Flamethrower': { status: 'brn', chance: 10 },
        'Fire Blast': { status: 'brn', chance: 10 },
        'Scald': { status: 'brn', chance: 30 },
        'Lava Plume': { status: 'brn', chance: 30 },
        'Ice Beam': { status: 'frz', chance: 10 },
        'Blizzard': { status: 'frz', chance: 10 },
        'Sludge Bomb': { status: 'psn', chance: 30 },
        'Poison Jab': { status: 'psn', chance: 30 }
    };
    if (statusMoves[move.name] && !fullMoveData.secondary?.status) {
        const { status, chance } = statusMoves[move.name];
        if (Math.random() * 100 < chance) {
            const result = tryInflictStatus(target, status);
            if (result.success && result.message) logs.push(result.message);
        }
    }
    return logs;
}
// ========== å›ºå®šä¼¤å®³æŠ€èƒ½ ==========
/**
 * æ£€æŸ¥å¹¶è®¡ç®—å›ºå®šä¼¤å®³æŠ€èƒ½
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move 
 * @returns {object|null} { damage, message } æˆ– nullï¼ˆéå›ºå®šä¼¤å®³æŠ€èƒ½ï¼‰
 */
function checkFixedDamageMove(attacker, defender, move) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // damage å­—æ®µè¡¨ç¤ºå›ºå®šä¼¤å®³
    if (fullMoveData.damage) {
        if (fullMoveData.damage === 'level') {
            return { damage: attacker.level, message: null };
        }
        if (typeof fullMoveData.damage === 'number') {
            return { damage: fullMoveData.damage, message: null };
        }
    }
    // ç‰¹æ®Šå›ºå®šä¼¤å®³æŠ€èƒ½
    const fixedDamageMoves = {
        'Sonic Boom': 20,
        'Dragon Rage': 40,
        'Seismic Toss': 'level',
        'Night Shade': 'level',
        'Psywave': 'random', // 0.5x ~ 1.5x level
        'Super Fang': 'half', // å½“å‰HPçš„ä¸€åŠ
        'Nature\'s Madness': 'half',
        'Guardian of Alola': 'threequarters',
        'Endeavor': 'endeavor' // å°†å¯¹æ–¹HPé™åˆ°ä¸è‡ªå·±ç›¸åŒ
    };
    const fixedType = fixedDamageMoves[move.name];
    if (!fixedType) return null;
    let damage = 0;
    switch (fixedType) {
        case 'level':
            damage = attacker.level;
            break;
        case 'random':
            damage = Math.floor(attacker.level * (0.5 + Math.random()));
            break;
        case 'half':
            damage = Math.floor(defender.currHp / 2);
            break;
        case 'threequarters':
            damage = Math.floor(defender.currHp * 3 / 4);
            break;
        case 'endeavor':
            damage = Math.max(0, defender.currHp - attacker.currHp);
            break;
        default:
            if (typeof fixedType === 'number') {
                damage = fixedType;
            }
    }
    return { damage: Math.max(1, damage), message: null };
}
// ========== ä¸€å‡»å¿…æ€æŠ€èƒ½ (OHKO) ==========
/**
 * æ£€æŸ¥ä¸€å‡»å¿…æ€æŠ€èƒ½
 * @param {Pokemon} attacker 
 * @param {Pokemon} defender 
 * @param {object} move 
 * @returns {object|null} { success, damage, message } æˆ– null
 */
function checkOHKOMove(attacker, defender, move) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // ohko å­—æ®µæ ‡è®°ä¸€å‡»å¿…æ€
    if (!fullMoveData.ohko) {
        const ohkoMoves = ['Fissure', 'Horn Drill', 'Guillotine', 'Sheer Cold'];
        if (!ohkoMoves.includes(move.name)) return null;
    }
    // ç­‰çº§ä½äºå¯¹æ–¹åˆ™æ— æ•ˆ
    if (attacker.level < defender.level) {
        return { success: false, damage: 0, message: `${defender.cnName} çš„ç­‰çº§å¤ªé«˜äº†!` };
    }
    // å‘½ä¸­ç‡ = 30 + (æ”»å‡»æ–¹ç­‰çº§ - é˜²å¾¡æ–¹ç­‰çº§)
    const hitChance = 30 + (attacker.level - defender.level);
    if (Math.random() * 100 < hitChance) {
        return { 
            success: true, 
            damage: defender.currHp, 
            message: `ä¸€å‡»å¿…æ€!` 
        };
    } else {
        return { success: false, damage: 0, message: null };
    }
}
// ========== å¤©æ°”ç³»ç»Ÿ (Weather) ==========
const WEATHER_TYPES = {
    sunnyday: { name: 'å¤§æ™´å¤©', fireBoost: 1.5, waterNerf: 0.5, solarBeamCharge: false },
    raindance: { name: 'ä¸‹é›¨', waterBoost: 1.5, fireNerf: 0.5, thunderAccuracy: true },
    sandstorm: { name: 'æ²™æš´', dotTypes: ['Rock', 'Ground', 'Steel'], spDefBoost: ['Rock'] },
    hail: { name: 'å†°é›¹', dotExcept: ['Ice'], blizzardAccuracy: true },
    snow: { name: 'ä¸‹é›ª', defBoost: ['Ice'] }
};
/**
 * è·å–å¤©æ°”å¯¹æŠ€èƒ½å¨åŠ›çš„ä¿®æ­£
 * @param {string} weather å½“å‰å¤©æ°”
 * @param {string} moveType æŠ€èƒ½å±æ€§
 * @returns {number} å¨åŠ›å€ç‡
 */
function getWeatherModifier(weather, moveType) {
    if (!weather || !WEATHER_TYPES[weather]) return 1;
    const w = WEATHER_TYPES[weather];
    if (moveType === 'Fire') {
        if (w.fireBoost) return w.fireBoost;
        if (w.fireNerf) return w.fireNerf;
    }
    if (moveType === 'Water') {
        if (w.waterBoost) return w.waterBoost;
        if (w.waterNerf) return w.waterNerf;
    }
    return 1;
}
// ========== åœºåœ°ç³»ç»Ÿ (Terrain) ==========
const TERRAIN_TYPES = {
    electricterrain: { name: 'ç”µæ°”åœºåœ°', boost: 'Electric', preventSleep: true },
    grassyterrain: { name: 'é’è‰åœºåœ°', boost: 'Grass', healPercent: 1/16 },
    psychicterrain: { name: 'ç²¾ç¥åœºåœ°', boost: 'Psychic', blockPriority: true },
    mistyterrain: { name: 'è–„é›¾åœºåœ°', dragonNerf: 0.5, preventStatus: true }
};
/**
 * è·å–åœºåœ°å¯¹æŠ€èƒ½å¨åŠ›çš„ä¿®æ­£
 * @param {string} terrain å½“å‰åœºåœ°
 * @param {string} moveType æŠ€èƒ½å±æ€§
 * @param {boolean} isGrounded æ˜¯å¦æ¥åœ°
 * @returns {number} å¨åŠ›å€ç‡
 */
function getTerrainModifier(terrain, moveType, isGrounded = true) {
    if (!terrain || !isGrounded || !TERRAIN_TYPES[terrain]) return 1;
    const t = TERRAIN_TYPES[terrain];
    if (t.boost === moveType) return 1.3;
    if (moveType === 'Dragon' && t.dragonNerf) return t.dragonNerf;
    return 1;
}
// ========== æŠ€èƒ½æ ‡è®°ç³»ç»Ÿ (Flags) ==========
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦æœ‰ç‰¹å®šæ ‡è®°
 * @param {object} move 
 * @param {string} flag æ ‡è®°å
 * @returns {boolean}
 */
function hasMoveFlag(move, flag) {
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    return !!(fullMoveData.flags && fullMoveData.flags[flag]);
}
// å¸¸ç”¨æ ‡è®°è¯´æ˜
const MOVE_FLAGS = {
    contact: 'æ¥è§¦ç±»æŠ€èƒ½ï¼Œè§¦å‘æ¥è§¦ç‰¹æ€§ï¼ˆå¦‚é“åˆºã€é™ç”µï¼‰',
    protect: 'å¯è¢«å®ˆä½ç±»æŠ€èƒ½æŒ¡ä¸‹',
    mirror: 'å¯è¢«é­”æ³•åå°„åå¼¹',
    sound: 'å£°éŸ³ç±»æŠ€èƒ½ï¼Œç©¿é€æ›¿èº«',
    punch: 'æ‹³ç±»æŠ€èƒ½ï¼Œé“æ‹³ç‰¹æ€§åŠ æˆ',
    bite: 'å’¬ç±»æŠ€èƒ½ï¼Œå¼ºå£®ä¹‹é¢šç‰¹æ€§åŠ æˆ',
    bullet: 'å­å¼¹/çƒç±»æŠ€èƒ½ï¼Œé˜²å¼¹ç‰¹æ€§å…ç–«',
    pulse: 'æ³¢åŠ¨ç±»æŠ€èƒ½ï¼Œè¶…çº§å‘å°„å™¨ç‰¹æ€§åŠ æˆ',
    slicing: 'æ–©åˆ‡ç±»æŠ€èƒ½ï¼Œé”‹é”ç‰¹æ€§åŠ æˆ',
    wind: 'é£ç±»æŠ€èƒ½ï¼Œé£åŠ›å‘ç”µç‰¹æ€§è§¦å‘'
};
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦ä¸ºæ¥è§¦ç±»
 */
function isContactMove(move) {
    return hasMoveFlag(move, 'contact');
}
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å¯è¢«å®ˆä½
 */
function isProtectable(move) {
    return hasMoveFlag(move, 'protect');
}
/**
 * æ£€æŸ¥æŠ€èƒ½æ˜¯å¦ä¸ºå£°éŸ³ç±»
 */
function isSoundMove(move) {
    return hasMoveFlag(move, 'sound');
}
// ========== åœºåœ°é’‰å­ç³»ç»Ÿ (Entry Hazards) ==========
/**
 * å¤„ç†åœºåœ°çŠ¶æ€æŠ€èƒ½ (sideCondition)
 * åŒ…æ‹¬ï¼šéšå½¢å²©ã€æ’’è±ã€æ¯’è±ã€é»é»ç½‘ã€é¡ºé£ã€åŒå¢™ç­‰
 * @param {Pokemon} user ä½¿ç”¨è€…
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function applySideCondition(user, move, battle) {
    const logs = [];
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    if (!fullMoveData.sideCondition) return logs;
    const conditionId = fullMoveData.sideCondition;
    const target = fullMoveData.target || 'foeSide';
    // åˆ¤æ–­æ–½æ³•è€…æ˜¯å¦ä¸ºç©å®¶
    const isPlayerUser = battle && battle.getPlayer && (user === battle.getPlayer());
    // è·å–å—å½±å“çš„åœºåœ°ï¼ˆå®Œå…¨åŸºäº target å­—æ®µï¼Œæ— ç¡¬ç¼–ç ï¼‰
    let targetSide = null;
    let sideNameCN = "æˆ‘æ–¹";
    if (target === 'foeSide') {
        targetSide = isPlayerUser ? battle.enemySide : battle.playerSide;
        sideNameCN = isPlayerUser ? "æ•Œæ–¹" : "æˆ‘æ–¹";
    } else if (target === 'allySide' || target === 'self') {
        targetSide = isPlayerUser ? battle.playerSide : battle.enemySide;
        sideNameCN = isPlayerUser ? "æˆ‘æ–¹" : "æ•Œæ–¹";
    }
    if (!targetSide) return logs;
    // === åœºåœ°çŠ¶æ€é…ç½®ï¼ˆæ•°æ®é©±åŠ¨ï¼Œæ˜“äºæ‰©å±•ï¼‰ ===
    const SIDE_CONDITION_CONFIG = {
        // å¯å åŠ çš„é’‰å­
        'spikes': {
            type: 'stackable',
            maxLayers: 3,
            key: 'spikes',
            messages: {
                success: (layers) => `æ’’è±æ•£å¸ƒåœ¨${sideNameCN}åœºåœ°ä¸Š! (å½“å‰${layers}å±‚)`,
                failed: () => `ä½†æ˜¯æ²¡ä»€ä¹ˆæ•ˆæœ... (å·²ç»æ’’ä¸ä¸‹äº†)`
            }
        },
        'toxicspikes': {
            type: 'stackable',
            maxLayers: 2,
            key: 'toxicspikes',
            altKey: 'toxicSpikes', // æ”¯æŒé©¼å³°å‘½å
            messages: {
                success: () => `æ¯’è±æ•£å¸ƒåœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯æ²¡ä»€ä¹ˆæ•ˆæœ... (å·²ç»æ’’ä¸ä¸‹äº†)`
            }
        },
        // å¸ƒå°”å‹é’‰å­
        'stealthrock': {
            type: 'boolean',
            key: 'stealthRock',
            messages: {
                success: () => `å°–é”çš„å²©çŸ³æ‚¬æµ®åœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'stickyweb': {
            type: 'boolean',
            key: 'stickyWeb',
            messages: {
                success: () => `é»é»ç½‘é“ºè®¾åœ¨${sideNameCN}åœºåœ°ä¸Š!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        // æœ‰æ—¶é™çš„åœºåœ°çŠ¶æ€
        'tailwind': {
            type: 'timed',
            duration: 4, // å®é™…æ˜¯5å›åˆï¼ˆè®¾ç½®åç«‹å³-1ï¼‰
            key: 'tailwind',
            messages: {
                success: () => `${sideNameCN}åˆ®èµ·äº†é¡ºé£!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'reflect': {
            type: 'timed',
            duration: 5,
            key: 'reflect',
            messages: {
                success: () => `${sideNameCN}ç«–èµ·äº†åå°„å£!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'lightscreen': {
            type: 'timed',
            duration: 5,
            key: 'lightScreen',
            messages: {
                success: () => `${sideNameCN}ç«–èµ·äº†å…‰å¢™!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        },
        'auroraveil': {
            type: 'timed',
            duration: 5,
            key: 'auroraVeil',
            messages: {
                success: () => `${sideNameCN}è¢«æå…‰å¹•åŒ…å›´äº†!`,
                failed: () => `ä½†æ˜¯å¤±è´¥äº†! (å·²ç»å­˜åœ¨)`
            }
        }
    };
    const config = SIDE_CONDITION_CONFIG[conditionId];
    if (!config) {
        // æœªé…ç½®çš„ sideConditionï¼Œä½¿ç”¨é€šç”¨å¤„ç†
        console.warn(`[SIDE CONDITION] æœªé…ç½®çš„åœºåœ°çŠ¶æ€: ${conditionId}`);
        return logs;
    }
    // æ ¹æ®ç±»å‹å¤„ç†
    if (config.type === 'stackable') {
        // å¯å åŠ ç±»å‹
        const key = config.key;
        const altKey = config.altKey;
        if (!targetSide[key]) targetSide[key] = 0;
        if (altKey && !targetSide[altKey]) targetSide[altKey] = 0;
        const currentLayers = targetSide[key] || targetSide[altKey] || 0;
        if (currentLayers < config.maxLayers) {
            targetSide[key] = currentLayers + 1;
            if (altKey) targetSide[altKey] = currentLayers + 1;
            logs.push(config.messages.success(currentLayers + 1));
        } else {
            logs.push(config.messages.failed());
        }
    } else if (config.type === 'boolean') {
        // å¸ƒå°”ç±»å‹
        const key = config.key;
        if (!targetSide[key]) {
            targetSide[key] = true;
            logs.push(config.messages.success());
        } else {
            logs.push(config.messages.failed());
        }
    } else if (config.type === 'timed') {
        // æœ‰æ—¶é™ç±»å‹
        const key = config.key;
        if (!targetSide[key] || targetSide[key] <= 0) {
            targetSide[key] = config.duration;
            logs.push(config.messages.success());
        } else {
            logs.push(config.messages.failed());
        }
    }
    return logs;
}
/**
 * å®å¯æ¢¦ä¸Šåœºæ—¶ç»“ç®—åœºåœ°é’‰å­ä¼¤å®³
 * @param {Pokemon} pokemon ä¸Šåœºçš„å®å¯æ¢¦
 * @param {boolean} isPlayer æ˜¯å¦ä¸ºç©å®¶æ–¹
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function applyEntryHazards(pokemon, isPlayer, battle) {
    const logs = [];
    if (!pokemon || !battle) return logs;
    // ã€åšåº•é´ (Heavy-Duty Boots)ã€‘å…ç–«æ‰€æœ‰å…¥åœºå±å®³
    const itemId = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
    if (itemId === 'heavydutyboots') {
        console.log(`[Heavy-Duty Boots] ${pokemon.name} çš„åšåº•é´ä¿æŠ¤äº†å®ƒå…å—å…¥åœºå±å®³ï¼`);
        // å¯é€‰ï¼šä¸è¾“å‡ºæ—¥å¿—ï¼Œé™é»˜å…ç–«
        // logs.push(`${pokemon.cnName} çš„åšåº•é´ä¿æŠ¤äº†å®ƒå…å—é™·é˜±ä¼¤å®³ï¼`);
        return logs;
    }
    // è·å–å¯¹åº”çš„åœºåœ°çŠ¶æ€
    const side = isPlayer ? battle.playerSide : battle.enemySide;
    if (!side) return logs;
    const types = pokemon.types || [];
    const isFlying = types.includes('Flying');
    const hasLevitate = (pokemon.ability || '').toLowerCase() === 'levitate';
    const isGrounded = !isFlying && !hasLevitate;
    const isPoison = types.includes('Poison');
    const isSteel = types.includes('Steel');
    // === éšå½¢å²© (Stealth Rock) ===
    // å²©çŸ³ç³»ä¼¤å®³ï¼Œæ ¹æ®å±æ€§å…‹åˆ¶è®¡ç®—
    if (side.stealthRock) {
        let effectiveness = 1;
        const rockChart = { 
            weak: ['Fire', 'Ice', 'Flying', 'Bug'], 
            resist: ['Fighting', 'Ground', 'Steel'] 
        };
        for (const type of types) {
            if (rockChart.weak.includes(type)) effectiveness *= 2;
            if (rockChart.resist.includes(type)) effectiveness *= 0.5;
        }
        const damage = Math.max(1, Math.floor(pokemon.maxHp * effectiveness / 8));
        pokemon.takeDamage(damage);
        logs.push(`å°–é”çš„å²©çŸ³æ‰è¿›äº† ${pokemon.cnName}! (-${damage})`);
    }
    // === æ’’è± (Spikes) ===
    // åœ°é¢ç³»ä¼¤å®³ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    if (side.spikes && side.spikes > 0 && isGrounded) {
        const layers = side.spikes;
        const damagePercent = [0, 1/8, 1/6, 1/4][layers] || 1/4;
        const damage = Math.max(1, Math.floor(pokemon.maxHp * damagePercent));
        pokemon.takeDamage(damage);
        logs.push(`${pokemon.cnName} è¢«æ’’è±æ‰ä¼¤äº†! (-${damage})`);
    }
    // === æ¯’è± (Toxic Spikes) ===
    // æ¯’ç³»å®å¯æ¢¦è¸©ä¸Šå»ä¼šæ¸…é™¤ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    // æ³¨æ„ï¼šæ”¯æŒä¸¤ç§å‘½åæ ¼å¼ toxicspikes å’Œ toxicSpikes
    const toxicLayers = side.toxicspikes || side.toxicSpikes || 0;
    if (toxicLayers > 0 && isGrounded) {
        if (isPoison) {
            // æ¯’ç³»å®å¯æ¢¦æ¸…é™¤æ¯’è±
            side.toxicspikes = 0;
            side.toxicSpikes = 0;
            logs.push(`${pokemon.cnName} å¸æ”¶äº†æ¯’è±!`);
        } else if (!isSteel && !pokemon.status) {
            // é’¢ç³»å…ç–«ä¸­æ¯’
            if (toxicLayers >= 2) {
                pokemon.status = 'tox';
                logs.push(`${pokemon.cnName} ä¸­äº†å‰§æ¯’!`);
            } else {
                pokemon.status = 'psn';
                logs.push(`${pokemon.cnName} ä¸­æ¯’äº†!`);
            }
        }
    }
    // === é»é»ç½‘ (Sticky Web) ===
    // é€Ÿåº¦-1ï¼Œé£è¡Œ/æ¼‚æµ®å…ç–«
    if (side.stickyWeb && isGrounded) {
        if (typeof pokemon.applyBoost === 'function') {
            pokemon.applyBoost('spe', -1);
            logs.push(`${pokemon.cnName} è¢«é»é»ç½‘ç¼ ä½äº†! é€Ÿåº¦ä¸‹é™!`);
            if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
        }
    }
    return logs;
}
/**
 * æ¸…é™¤åœºåœ°é’‰å­ï¼ˆé«˜é€Ÿæ—‹è½¬ã€æ¸…é™¤æµ“é›¾ï¼‰
 * @param {boolean} isPlayer æ¸…é™¤å“ªä¸€æ–¹çš„åœºåœ°
 * @param {object} battle æˆ˜æ–—å®ä¾‹
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function clearEntryHazards(isPlayer, battle) {
    const logs = [];
    if (!battle) return logs;
    const side = isPlayer ? battle.playerSide : battle.enemySide;
    if (!side) return logs;
    let cleared = false;
    if (side.stealthRock) {
        side.stealthRock = false;
        cleared = true;
    }
    if (side.spikes) {
        side.spikes = 0;
        cleared = true;
    }
    if (side.toxicspikes) {
        side.toxicspikes = 0;
        cleared = true;
    }
    if (side.stickyWeb) {
        side.stickyWeb = false;
        cleared = true;
    }
    if (cleared) {
        logs.push(`åœºåœ°ä¸Šçš„éšœç¢ç‰©è¢«æ¸…é™¤äº†!`);
    }
    return logs;
}
// ========== Volatile çŠ¶æ€ç³»ç»Ÿ (Taunt, Substitute ç­‰) ==========
/**
 * å¤„ç† Volatile çŠ¶æ€æŠ€èƒ½
 * @param {Pokemon} user ä½¿ç”¨è€…
 * @param {Pokemon} target ç›®æ ‡
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {object} { success, logs }
 */
function applyVolatileStatus(user, target, move) {
    const logs = [];
    const moveName = move.name || '';
    // åˆå§‹åŒ– volatile å¯¹è±¡
    if (!target.volatile) target.volatile = {};
    if (!user.volatile) user.volatile = {};
    // ã€Soft-Codedã€‘é€šç”¨ volatileStatus é‡å¤æ£€æŸ¥
    const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    if (fullMoveData.volatileStatus && fullMoveData.target === 'self') {
        const volatileKey = fullMoveData.volatileStatus;
        // =========================================================
        // Volatile çŠ¶æ€åˆ†ç±»ï¼š
        // 
        // ã€å¯å åŠ ã€‘ç”± move-handlers.js å¤„ç†å±‚æ•°é€»è¾‘ï¼Œè·³è¿‡é€šç”¨æ£€æŸ¥ï¼š
        //   - stockpile: è“„åŠ›ï¼ˆæœ€å¤š3å±‚ï¼‰
        // 
        // ã€åˆ·æ–°å‹ã€‘é‡å¤ä½¿ç”¨ä¼šåˆ·æ–°å›åˆæ•°/æ•ˆæœï¼Œä¸åº”å¤±è´¥ï¼š
        //   - charge: å……ç”µï¼ˆä¸‹å›åˆç”µç³»å¨åŠ›ç¿»å€ï¼‰
        //   - laserfocus: ç£¨ç ºï¼ˆä¸‹å›åˆå¿…å®šæš´å‡»ï¼‰
        //   - defensecurl: å˜åœ†ï¼ˆæ»šåŠ¨/å†°çƒå¨åŠ›ç¿»å€ï¼‰
        // 
        // ã€ä¸å¯å åŠ ã€‘é‡å¤ä½¿ç”¨åº”è¯¥å¤±è´¥ï¼š
        //   - aquaring, ingrain, focusenergy, substitute, 
        //   - protect, endure, destinybond, imprison, etc.
        // =========================================================
        // å¯å åŠ çš„çŠ¶æ€ï¼šç”± handler å¤„ç†
        const stackableVolatiles = ['stockpile'];
        // åˆ·æ–°å‹çŠ¶æ€ï¼šé‡å¤ä½¿ç”¨ä¼šåˆ·æ–°æ•ˆæœï¼Œä¸åº”å¤±è´¥
        const refreshableVolatiles = ['charge', 'laserfocus', 'defensecurl'];
        if (stackableVolatiles.includes(volatileKey)) {
            // äº¤ç»™ handler å¤„ç†å±‚æ•°é€»è¾‘
        } else if (refreshableVolatiles.includes(volatileKey)) {
            // åˆ·æ–°å‹ï¼šå…è®¸é‡å¤ä½¿ç”¨ï¼Œä¼šåˆ·æ–°æ•ˆæœ
        } else if (user.volatile[volatileKey]) {
            // ä¸å¯å åŠ ï¼šå·²æœ‰çŠ¶æ€åˆ™å¤±è´¥
            logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${user.cnName} å·²ç»å¤„äºè¯¥çŠ¶æ€)`);
            return { success: false, logs };
        }
    }
    switch (moveName) {
        case 'Taunt':
            // æŒ‘è¡…ï¼š3å›åˆå†…æ— æ³•ä½¿ç”¨å˜åŒ–æŠ€
            if (target.volatile.taunt && target.volatile.taunt > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»å¤„äºæŒ‘è¡…çŠ¶æ€)`);
                return { success: false, logs };
            }
            target.volatile.taunt = 3;
            logs.push(`${target.cnName} é™·å…¥äº†æŒ‘è¡…çŠ¶æ€!`);
            return { success: true, logs };
        case 'Substitute':
            // æ›¿èº«ï¼šæ¶ˆè€— 1/4 HP ç”ŸæˆæŠ¤ç›¾
            const subHp = Math.floor(user.maxHp / 4);
            if (user.currHp <= subHp) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥åˆ¶é€ æ›¿èº«)`);
                return { success: false, logs };
            }
            if (user.volatile.substitute && user.volatile.substitute > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (å·²ç»æœ‰æ›¿èº«äº†)`);
                return { success: false, logs };
            }
            user.currHp -= subHp;
            user.volatile.substitute = subHp;
            logs.push(`${user.cnName} åˆ¶é€ äº†ä¸€ä¸ªæ›¿èº«! (æ¶ˆè€— ${subHp} HP)`);
            return { success: true, logs };
        case 'Encore':
            // å†æ¥ä¸€æ¬¡ï¼šå¼ºåˆ¶ä½¿ç”¨ä¸Šä¸€ä¸ªæŠ€èƒ½
            if (!target.lastMoveUsed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.encore = 3;
            target.volatile.encoreMove = target.lastMoveUsed;
            logs.push(`${target.cnName} è¢«å¼ºåˆ¶å†æ¥ä¸€æ¬¡!`);
            return { success: true, logs };
        case 'Disable':
            // å®šèº«æ³•ï¼šå°å°ä¸Šä¸€ä¸ªæŠ€èƒ½
            if (!target.lastMoveUsed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.disable = 4;
            target.volatile.disabledMove = target.lastMoveUsed;
            logs.push(`${target.cnName} çš„ ${target.lastMoveUsed} è¢«å°å°äº†!`);
            return { success: true, logs };
        case 'Torment':
            // æ— ç†å–é—¹ï¼šæ— æ³•è¿ç»­ä½¿ç”¨åŒä¸€æŠ€èƒ½
            target.volatile.torment = true;
            logs.push(`${target.cnName} é™·å…¥äº†æ— ç†å–é—¹çŠ¶æ€!`);
            return { success: true, logs };
        case 'Heal Block':
            // å›å¤å°é”
            target.volatile.healBlock = 5;
            logs.push(`${target.cnName} è¢«å°é”äº†å›å¤!`);
            return { success: true, logs };
        // ===================== æŒç»­ä¼¤å®³/å¹²æ‰°ç±» =====================
        case 'Leech Seed':
            // å¯„ç”Ÿç§å­ï¼šæ¯å›åˆå¸å– 1/8 HP
            if (target.types && target.types.includes('Grass')) {
                logs.push(`å¯¹è‰å±æ€§å®å¯æ¢¦æ— æ•ˆ!`);
                return { success: false, logs };
            }
            if (target.volatile.leechseed) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»è¢«ç§ä¸‹ç§å­äº†)`);
                return { success: false, logs };
            }
            target.volatile.leechseed = true;
            logs.push(`å¯„ç”Ÿç§å­ç§åœ¨äº† ${target.cnName} èº«ä¸Š!`);
            return { success: true, logs };
        case 'Curse':
            // è¯…å’’ï¼šåŒºåˆ†å¹½çµç³»å’Œéå¹½çµç³»
            if (user.types && user.types.includes('Ghost')) {
                // å¹½çµç³»ï¼šæ‰£ 50% HPï¼Œå¯¹æ–¹æ¯å›åˆæ‰ 1/4
                const curseCost = Math.floor(user.maxHp / 2);
                if (user.currHp <= curseCost) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥æ–½å±•è¯…å’’)`);
                    return { success: false, logs };
                }
                user.currHp -= curseCost;
                target.volatile.curse = true;
                logs.push(`${user.cnName} å‰Šå‡äº†è‡ªå·±çš„ä½“åŠ›ï¼Œå¯¹ ${target.cnName} æ–½åŠ äº†è¯…å’’!`);
                return { success: true, logs };
            } else {
                // éå¹½çµç³»ï¼šé€Ÿåº¦-1ï¼Œæ”»é˜²+1ï¼ˆç”± boosts å¤„ç†ï¼Œè¿™é‡Œåªè¿”å›æˆåŠŸï¼‰
                return { success: false, logs }; // è®©é»˜è®¤çš„ boosts å¤„ç†
            }
        case 'Yawn':
            // å“ˆæ¬ ï¼šä¸‹å›åˆç»“æŸæ—¶ç¡ç€
            if (target.status) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»æœ‰å¼‚å¸¸çŠ¶æ€äº†)`);
                return { success: false, logs };
            }
            if (target.volatile.yawn) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.yawn = 2; // 2å›åˆåç¡ç€
            logs.push(`${target.cnName} æ‰“äº†ä¸ªå“ˆæ¬ ...`);
            return { success: true, logs };
        case 'Perish Song':
            // ç­äº¡ä¹‹æ­Œï¼š3å›åˆååŒæ–¹å€’ä¸‹
            if (user.volatile.perishsong || target.volatile.perishsong) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            user.volatile.perishsong = 3;
            target.volatile.perishsong = 3;
            logs.push(`æ‰€æœ‰å¬åˆ°æ­Œå£°çš„å®å¯æ¢¦å°†åœ¨ 3 å›åˆåå€’ä¸‹!`);
            return { success: true, logs };
        case 'Destiny Bond':
            // åŒå‘½ï¼šå¦‚æœè‡ªå·±å€’ä¸‹ï¼Œå¯¹æ–¹ä¹Ÿå€’ä¸‹
            user.volatile.destinybond = true;
            logs.push(`${user.cnName} æƒ³è¦å’Œå¯¹æ‰‹åŒå½’äºå°½!`);
            return { success: true, logs };
        // ===================== æŸç¼šç±» =====================
        case 'Bind':
        case 'Wrap':
        case 'Fire Spin':
        case 'Clamp':
        case 'Whirlpool':
        case 'Sand Tomb':
        case 'Magma Storm':
        case 'Infestation':
        case 'Snap Trap':
            // æŸç¼šï¼šæ¯å›åˆæ‰£ 1/8 HPï¼ŒæŒç»­ 4-5 å›åˆ
            if (target.volatile.partiallytrapped) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»è¢«æŸç¼šäº†)`);
                return { success: false, logs };
            }
            target.volatile.partiallytrapped = 4 + Math.floor(Math.random() * 2); // 4-5 å›åˆ
            logs.push(`${target.cnName} è¢« ${moveName} æŸç¼šä½äº†!`);
            return { success: true, logs };
        // ===================== æ··ä¹±ç±» =====================
        case 'Confuse Ray':
        case 'Supersonic':
        case 'Sweet Kiss':
        case 'Teeter Dance':
        case 'Flatter':
        case 'Swagger':
            // æ··ä¹±
            if (target.volatile.confusion) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (${target.cnName} å·²ç»æ··ä¹±äº†)`);
                return { success: false, logs };
            }
            target.volatile.confusion = 2 + Math.floor(Math.random() * 4); // 2-5 å›åˆ
            logs.push(`${target.cnName} æ··ä¹±äº†!`);
            return { success: true, logs };
        // ===================== æ¥åŠ›ç±» =====================
        case 'Shed Tail':
            // æ–­å°¾ï¼šæ¶ˆè€— 50% HP åˆ¶é€ æ›¿èº«å¹¶æ¢äºº
            const shedCost = Math.ceil(user.maxHp / 2);
            if (user.currHp <= shedCost) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (HP ä¸è¶³ä»¥æ–­å°¾)`);
                return { success: false, logs };
            }
            user.currHp -= shedCost;
            // åˆ¶é€ ä¸€ä¸ª 1/4 HP çš„æ›¿èº«ç»™ä¸‹ä¸€åª
            user.volatile.shedTailSub = Math.floor(user.maxHp / 4);
            logs.push(`${user.cnName} åˆ¶é€ äº†ä¸€ä¸ªæ›¿èº«å¹¶å‡†å¤‡æ’¤é€€!`);
            return { success: true, logs, pivot: true, passSub: true };
        // ===================== å…¶ä»–å¸¸ç”¨çŠ¶æ€æŠ€ =====================
        case 'Attract':
            // ç€è¿·
            if (target.volatile.attract) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { success: false, logs };
            }
            target.volatile.attract = true;
            logs.push(`${target.cnName} ç€è¿·äº†!`);
            return { success: true, logs };
        case 'Focus Energy':
            // èšæ°”ï¼šæš´å‡»ç‡ +2 (é‡å¤æ£€æŸ¥å·²ç”±é€šç”¨é€»è¾‘å¤„ç†)
            user.volatile.focusenergy = true;
            logs.push(`${user.cnName} æ·±å‘¼å¸ï¼Œé›†ä¸­ç²¾ç¥!`);
            return { success: true, logs };
        case 'Imprison':
            // å°å°ï¼šå¯¹æ‰‹ä¸èƒ½ä½¿ç”¨ä¸è‡ªå·±ç›¸åŒçš„æ‹›å¼
            user.volatile.imprison = true;
            logs.push(`${user.cnName} å°å°äº†å¯¹æ‰‹çš„æ‹›å¼!`);
            return { success: true, logs };
        case 'Embargo':
            // æŸ¥å°ï¼šæ— æ³•ä½¿ç”¨é“å…·
            target.volatile.embargo = 5;
            logs.push(`${target.cnName} æ— æ³•ä½¿ç”¨é“å…·äº†!`);
            return { success: true, logs };
        case 'Aqua Ring':
            // æ°´æµç¯ï¼šæ¯å›åˆå›å¤ 1/16 HP (é‡å¤æ£€æŸ¥å·²ç”±é€šç”¨é€»è¾‘å¤„ç†)
            user.volatile.aquaring = true;
            logs.push(`${user.cnName} ç”¨æ°´æµç¯åŒ…è£¹ä½äº†è‡ªå·±!`);
            return { success: true, logs };
        case 'Ingrain':
            // æ‰æ ¹ï¼šæ¯å›åˆå›å¤ 1/16 HPï¼Œæ— æ³•æ¢äºº (é‡å¤æ£€æŸ¥å·²ç”±é€šç”¨é€»è¾‘å¤„ç†)
            user.volatile.ingrain = true;
            logs.push(`${user.cnName} æ‰ä¸‹äº†æ ¹!`);
            return { success: true, logs };
        default:
            return { success: false, logs };
    }
}
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥ä½¿ç”¨æŒ‡å®šæŠ€èƒ½
 * @param {Pokemon} pokemon 
 * @param {object} move 
 * @returns {object} { canUse, reason }
 */
function canUseMove(pokemon, move) {
    if (!pokemon.volatile) return { canUse: true, reason: null };
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    const category = fullMoveData.category || move.category || move.cat || 'Physical';
    // æŒ‘è¡…æ£€æŸ¥ï¼šæ— æ³•ä½¿ç”¨å˜åŒ–æŠ€
    if (pokemon.volatile.taunt && pokemon.volatile.taunt > 0) {
        if (category === 'Status' || category === 'status') {
            return { canUse: false, reason: `${pokemon.cnName} è¢«æŒ‘è¡…äº†ï¼Œæ— æ³•ä½¿ç”¨å˜åŒ–æŠ€!` };
        }
    }
    // å®šèº«æ³•æ£€æŸ¥
    if (pokemon.volatile.disable && pokemon.volatile.disable > 0) {
        if (pokemon.volatile.disabledMove === move.name) {
            return { canUse: false, reason: `${move.name} è¢«å°å°äº†!` };
        }
    }
    // å†æ¥ä¸€æ¬¡æ£€æŸ¥
    if (pokemon.volatile.encore && pokemon.volatile.encore > 0) {
        if (pokemon.volatile.encoreMove && move.name !== pokemon.volatile.encoreMove) {
            return { canUse: false, reason: `è¢«å¼ºåˆ¶ä½¿ç”¨ ${pokemon.volatile.encoreMove}!` };
        }
    }
    // æ— ç†å–é—¹æ£€æŸ¥
    if (pokemon.volatile.torment && pokemon.lastMoveUsed === move.name) {
        return { canUse: false, reason: `${pokemon.cnName} æ— æ³•è¿ç»­ä½¿ç”¨åŒä¸€æŠ€èƒ½!` };
    }
    // å°å°æ£€æŸ¥ (Imprison)ï¼šå¯¹æ‰‹ä¸èƒ½ä½¿ç”¨ä¸è‡ªå·±ç›¸åŒçš„æ‹›å¼
    // æ³¨æ„ï¼šè¿™éœ€è¦åœ¨æˆ˜æ–—ä¸­æ£€æŸ¥å¯¹æ‰‹çš„æ‹›å¼ï¼Œè¿™é‡Œåªåšæ ‡è®°æ£€æŸ¥
    if (pokemon.volatile.imprisonBlocked && pokemon.volatile.imprisonBlocked.includes(move.name)) {
        return { canUse: false, reason: `${move.name} è¢«å°å°äº†!` };
    }
    return { canUse: true, reason: null };
}
/**
 * æ£€æŸ¥æ··ä¹±çŠ¶æ€æ˜¯å¦å¯¼è‡´è‡ªä¼¤
 * @param {Pokemon} pokemon 
 * @returns {object} { confused, selfHit, damage, logs }
 */
function checkConfusion(pokemon) {
    const logs = [];
    if (!pokemon.volatile || !pokemon.volatile.confusion || pokemon.volatile.confusion <= 0) {
        return { confused: false, selfHit: false, damage: 0, logs };
    }
    logs.push(`${pokemon.cnName} æ­£å¤„äºæ··ä¹±ä¸­!`);
    // 33% æ¦‚ç‡è‡ªä¼¤
    if (Math.random() < 0.33) {
        // è‡ªä¼¤ä¼¤å®³ï¼š40 å¨åŠ›ç‰©ç†æ”»å‡»
        const selfDamage = Math.max(1, Math.floor(pokemon.atk * 40 / pokemon.def / 50 * 2));
        pokemon.currHp = Math.max(0, pokemon.currHp - selfDamage);
        logs.push(`${pokemon.cnName} åœ¨æ··ä¹±ä¸­æ”»å‡»äº†è‡ªå·±! (-${selfDamage})`);
        return { confused: true, selfHit: true, damage: selfDamage, logs };
    }
    return { confused: true, selfHit: false, damage: 0, logs };
}
/**
 * æ£€æŸ¥ç€è¿·çŠ¶æ€æ˜¯å¦é˜»æ­¢è¡ŒåŠ¨
 * @param {Pokemon} pokemon 
 * @returns {object} { attracted, immobilized, logs }
 */
function checkAttract(pokemon) {
    const logs = [];
    if (!pokemon.volatile || !pokemon.volatile.attract) {
        return { attracted: false, immobilized: false, logs };
    }
    logs.push(`${pokemon.cnName} å¯¹å¯¹æ‰‹ç€è¿·äº†!`);
    // 50% æ¦‚ç‡æ— æ³•è¡ŒåŠ¨
    if (Math.random() < 0.5) {
        logs.push(`${pokemon.cnName} å› ä¸ºç€è¿·è€Œæ— æ³•è¡ŒåŠ¨!`);
        return { attracted: true, immobilized: true, logs };
    }
    return { attracted: true, immobilized: false, logs };
}
/**
 * æ£€æŸ¥æ›¿èº«æ˜¯å¦å¸æ”¶ä¼¤å®³
 * @param {Pokemon} defender é˜²å¾¡æ–¹
 * @param {number} damage åŸå§‹ä¼¤å®³
 * @param {object} move æŠ€èƒ½æ•°æ®
 * @returns {object} { absorbed, remainingDamage, logs }
 */
function checkSubstitute(defender, damage, move) {
    const logs = [];
    if (!defender.volatile || !defender.volatile.substitute || defender.volatile.substitute <= 0) {
        return { absorbed: false, remainingDamage: damage, logs };
    }
    // å£°éŸ³ç±»æŠ€èƒ½ç©¿é€æ›¿èº«
    if (isSoundMove(move)) {
        return { absorbed: false, remainingDamage: damage, logs };
    }
    const subHp = defender.volatile.substitute;
    if (damage >= subHp) {
        // æ›¿èº«è¢«æ‰“ç ´
        defender.volatile.substitute = 0;
        logs.push(`${defender.cnName} çš„æ›¿èº«æ¶ˆå¤±äº†!`);
        // å‰©ä½™ä¼¤å®³ä¸ä¼ é€’ç»™æœ¬ä½“ï¼ˆæ›¿èº«å¸æ”¶æ‰€æœ‰ä¼¤å®³ï¼‰
        return { absorbed: true, remainingDamage: 0, logs };
    } else {
        // æ›¿èº«å¸æ”¶ä¼¤å®³
        defender.volatile.substitute -= damage;
        logs.push(`æ›¿èº«ä»£æ›¿ ${defender.cnName} æ‰¿å—äº†ä¼¤å®³! (æ›¿èº«å‰©ä½™: ${defender.volatile.substitute})`);
        return { absorbed: true, remainingDamage: 0, logs };
    }
}
/**
 * å›åˆç»“æŸæ—¶é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨
 * @param {Pokemon} pokemon 
 * @param {Pokemon} opponent - å¯¹æ‰‹ï¼ˆç”¨äºç­äº¡ä¹‹æ­Œç­‰ï¼‰
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯
 */
function tickVolatileStatus(pokemon, opponent = null) {
    const logs = [];
    if (!pokemon.volatile) return logs;
    // æŒ‘è¡…
    if (pokemon.volatile.taunt && pokemon.volatile.taunt > 0) {
        pokemon.volatile.taunt--;
        if (pokemon.volatile.taunt === 0) {
            logs.push(`${pokemon.cnName} çš„æŒ‘è¡…çŠ¶æ€è§£é™¤äº†!`);
        }
    }
    // å®šèº«æ³•
    if (pokemon.volatile.disable && pokemon.volatile.disable > 0) {
        pokemon.volatile.disable--;
        if (pokemon.volatile.disable === 0) {
            pokemon.volatile.disabledMove = null;
            logs.push(`${pokemon.cnName} çš„æŠ€èƒ½å°å°è§£é™¤äº†!`);
        }
    }
    // å†æ¥ä¸€æ¬¡
    if (pokemon.volatile.encore && pokemon.volatile.encore > 0) {
        pokemon.volatile.encore--;
        if (pokemon.volatile.encore === 0) {
            pokemon.volatile.encoreMove = null;
            logs.push(`${pokemon.cnName} çš„å†æ¥ä¸€æ¬¡çŠ¶æ€è§£é™¤äº†!`);
        }
    }
    // å›å¤å°é”
    if (pokemon.volatile.healBlock && pokemon.volatile.healBlock > 0) {
        pokemon.volatile.healBlock--;
        if (pokemon.volatile.healBlock === 0) {
            logs.push(`${pokemon.cnName} çš„å›å¤å°é”è§£é™¤äº†!`);
        }
    }
    // å“ˆæ¬  -> ç¡çœ 
    if (pokemon.volatile.yawn && pokemon.volatile.yawn > 0) {
        pokemon.volatile.yawn--;
        if (pokemon.volatile.yawn === 0) {
            if (!pokemon.status) {
                pokemon.status = 'slp';
                pokemon.sleepTurns = 0;
                logs.push(`${pokemon.cnName} ç¡ç€äº†!`);
            }
            delete pokemon.volatile.yawn;
        }
    }
    // ç­äº¡ä¹‹æ­Œ
    if (pokemon.volatile.perishsong && pokemon.volatile.perishsong > 0) {
        pokemon.volatile.perishsong--;
        logs.push(`${pokemon.cnName} çš„ç­äº¡å€’è®¡æ—¶: ${pokemon.volatile.perishsong}!`);
        if (pokemon.volatile.perishsong === 0) {
            pokemon.currHp = 0;
            logs.push(`${pokemon.cnName} å› ç­äº¡ä¹‹æ­Œå€’ä¸‹äº†!`);
        }
    }
    // æ··ä¹±
    if (pokemon.volatile.confusion && pokemon.volatile.confusion > 0) {
        pokemon.volatile.confusion--;
        if (pokemon.volatile.confusion === 0) {
            logs.push(`${pokemon.cnName} çš„æ··ä¹±è§£é™¤äº†!`);
        }
    }
    // æŸç¼š
    if (pokemon.volatile.partiallytrapped && typeof pokemon.volatile.partiallytrapped === 'number') {
        pokemon.volatile.partiallytrapped--;
        if (pokemon.volatile.partiallytrapped === 0) {
            delete pokemon.volatile.partiallytrapped;
            logs.push(`${pokemon.cnName} ä»æŸç¼šä¸­è§£è„±äº†!`);
        }
    }
    // æŸ¥å°
    if (pokemon.volatile.embargo && pokemon.volatile.embargo > 0) {
        pokemon.volatile.embargo--;
        if (pokemon.volatile.embargo === 0) {
            logs.push(`${pokemon.cnName} å¯ä»¥ä½¿ç”¨é“å…·äº†!`);
        }
    }
    // åŒå‘½ï¼ˆæ¯å›åˆé‡ç½®ï¼‰
    if (pokemon.volatile.destinybond) {
        delete pokemon.volatile.destinybond;
    }
    return logs;
}
// ========== é“å…·å›åˆæœ«æ•ˆæœ (End-Turn Item Effects) ==========
/**
 * ã€è½¯ç¼–ç ã€‘å¤„ç†å›åˆç»“æŸæ—¶çš„é“å…·æ•ˆæœ
 * æ”¯æŒå‰§æ¯’å®ç ã€ç«ç„°å®ç ç­‰è‡ªèµ‹çŠ¶æ€é“å…·
 * @param {Pokemon} pokemon 
 * @returns {Array} æ—¥å¿—æ¶ˆæ¯æ•°ç»„
 */
function processEndTurnItemEffects(pokemon) {
    const logs = [];
    if (!pokemon || !pokemon.item) return logs;
    if (typeof pokemon.isAlive === 'function' && !pokemon.isAlive()) return logs;
    // ã€è½¯ç¼–ç ã€‘ä» items-data.js è·å–é“å…·æ•°æ®
    const itemId = pokemon.item.toLowerCase().replace(/[^a-z0-9]/g, '');
    const itemData = (typeof window.getItem === 'function') ? window.getItem(pokemon.item) : null;
    if (!itemData) return logs;
    // === è‡ªèµ‹çŠ¶æ€é“å…· (Toxic Orb, Flame Orb) ===
    if (itemData.selfStatus && !pokemon.status) {
        const statusToApply = itemData.selfStatus;
        // æ£€æŸ¥å…ç–«ï¼ˆé’¢/æ¯’ç³»å…ç–«ä¸­æ¯’ï¼Œç«ç³»å…ç–«ç¼ä¼¤ï¼‰
        let immune = false;
        if ((statusToApply === 'psn' || statusToApply === 'tox') && pokemon.types) {
            if (pokemon.types.includes('Steel') || pokemon.types.includes('Poison')) {
                immune = true;
            }
        }
        if (statusToApply === 'brn' && pokemon.types && pokemon.types.includes('Fire')) {
            immune = true;
        }
        // æ£€æŸ¥ç‰¹æ€§å…ç–«
        const abilityId = (pokemon.ability || '').toLowerCase().replace(/[^a-z]/g, '');
        if (abilityId === 'immunity' && (statusToApply === 'psn' || statusToApply === 'tox')) {
            immune = true;
        }
        if (abilityId === 'waterveil' && statusToApply === 'brn') {
            immune = true;
        }
        if (!immune) {
            pokemon.status = statusToApply;
            pokemon.statusTurns = 0;
            const statusName = statusToApply === 'tox' ? 'å‰§æ¯’' : (statusToApply === 'brn' ? 'ç¼ä¼¤' : 'ä¸­æ¯’');
            const itemCnName = itemData.cnName || pokemon.item;
            logs.push(`<span style="color:#9b59b6">ğŸ’ ${pokemon.cnName} å—åˆ° ${itemCnName} çš„å½±å“ï¼Œé™·å…¥äº†${statusName}çŠ¶æ€!</span>`);
        }
    }
    // === é»‘è‰²æ·¤æ³¥ (Black Sludge) ===
    if (itemId === 'blacksludge') {
        if (pokemon.types && pokemon.types.includes('Poison')) {
            // æ¯’ç³»å›å¤ 1/16 HP
            const healAmount = Math.max(1, Math.floor(pokemon.maxHp / 16));
            if (typeof pokemon.heal === 'function') {
                pokemon.heal(healAmount);
            } else {
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + healAmount);
            }
            logs.push(`<span style="color:#4cd137">${pokemon.cnName} é€šè¿‡é»‘è‰²æ·¤æ³¥å›å¤äº† ${healAmount} ç‚¹ä½“åŠ›!</span>`);
        } else {
            // éæ¯’ç³»å—åˆ° 1/8 HP ä¼¤å®³
            const damage = Math.max(1, Math.floor(pokemon.maxHp / 8));
            pokemon.takeDamage(damage);
            logs.push(`<span style="color:#e74c3c">${pokemon.cnName} è¢«é»‘è‰²æ·¤æ³¥ä¼¤å®³äº† ${damage} ç‚¹!</span>`);
        }
    }
    // === å‰©é¥­ (Leftovers) ===
    if (itemId === 'leftovers') {
        if (pokemon.currHp < pokemon.maxHp) {
            const healAmount = Math.max(1, Math.floor(pokemon.maxHp / 16));
            if (typeof pokemon.heal === 'function') {
                pokemon.heal(healAmount);
            } else {
                pokemon.currHp = Math.min(pokemon.maxHp, pokemon.currHp + healAmount);
            }
            logs.push(`<span style="color:#4cd137">${pokemon.cnName} é€šè¿‡å‰©é¥­å›å¤äº† ${healAmount} ç‚¹ä½“åŠ›!</span>`);
        }
    }
    return logs;
}
// ========== æ‹è½æ•ˆæœ (Knock Off) ==========
/**
 * ã€è½¯ç¼–ç ã€‘æ£€æŸ¥é“å…·æ˜¯å¦å¯ä»¥è¢«æ‹è½
 * ä½¿ç”¨ items-data.js ä¸­çš„å‡½æ•°è¿›è¡Œåˆ¤å®š
 * @param {string} itemId é“å…·ID
 * @returns {boolean} æ˜¯å¦å¯ä»¥è¢«æ‹è½
 */
function canKnockOffItem(itemId) {
    if (!itemId) return false;
    const id = itemId.toLowerCase().replace(/[^a-z0-9]/g, '');
    // ã€è½¯ç¼–ç ã€‘ä½¿ç”¨ items-data.js çš„å‡½æ•°
    if (typeof window.isMegaStone === 'function' && window.isMegaStone(id)) return false;
    if (typeof window.isZCrystal === 'function' && window.isZCrystal(id)) return false;
    if (typeof window.isSwappable === 'function' && !window.isSwappable(id)) return false;
    return true;
}
/**
 * ã€è½¯ç¼–ç ã€‘å¤„ç†æ‹è½æ•ˆæœ - ç§»é™¤å¯¹æ‰‹é“å…·
 * ä½¿ç”¨ items-data.js çš„ isSwappable/isMegaStone/isZCrystal åˆ¤å®š
 * @param {Object} attacker æ”»å‡»æ–¹
 * @param {Object} defender é˜²å¾¡æ–¹
 * @param {Object} move æŠ€èƒ½æ•°æ®
 * @returns {Object} { success: boolean, logs: Array, bonusDamage: number }
 */
function applyKnockOff(attacker, defender, move) {
    const logs = [];
    let bonusDamage = 1.0;
    if (move.name !== 'Knock Off') return { success: false, logs, bonusDamage };
    // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰é“å…·
    if (defender.item && defender.item !== '') {
        // ã€è½¯ç¼–ç ã€‘ä½¿ç”¨ canKnockOffItem å‡½æ•°åˆ¤å®š
        const isUnremovable = !canKnockOffItem(defender.item);
        if (!isUnremovable) {
            const knockedItem = defender.item;
            defender.item = null;
            defender.knockedOffItem = knockedItem; // è®°å½•è¢«æ‹è½çš„é“å…·
            logs.push(`${attacker.cnName} æ‹è½äº† ${defender.cnName} çš„ ${knockedItem}ï¼`);
            bonusDamage = 1.5; // æ‹è½æœ‰é“å…·çš„å¯¹æ‰‹ä¼¤å®³ x1.5
        }
    }
    return { success: logs.length > 0, logs, bonusDamage };
}
// ========== æŸç¼šæ‹›å¼ (Trapping Moves) ==========
/**
 * ã€è½¯ç¼–ç ã€‘å¤„ç†æŸç¼šæ‹›å¼æ•ˆæœ - å›°ä½å¯¹æ‰‹å¹¶é€ æˆæŒç»­ä¼¤å®³
 * ä½¿ç”¨ moves-data.js ä¸­çš„ volatileStatus: 'partiallytrapped' æ ‡è®°åˆ¤å®š
 * @param {Object} attacker æ”»å‡»æ–¹
 * @param {Object} defender é˜²å¾¡æ–¹
 * @param {Object} move æŠ€èƒ½æ•°æ®
 * @returns {Object} { success: boolean, logs: Array }
 */
function applyTrappingMove(attacker, defender, move) {
    const logs = [];
    // ã€è½¯ç¼–ç ã€‘ä» moves-data.js è¯»å–æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æŸ¥æ˜¯å¦ä¸ºæŸç¼šæ‹›å¼ï¼ˆé€šè¿‡ volatileStatus å­—æ®µåˆ¤å®šï¼‰
    const isTrappingMove = fullMoveData.volatileStatus === 'partiallytrapped';
    if (!isTrappingMove) return { success: false, logs };
    // å¹½çµç³»å…ç–«æŸç¼š
    if (defender.types && defender.types.includes('Ghost')) {
        return { success: false, logs };
    }
    // å·²ç»è¢«æŸç¼šåˆ™ä¸é‡å¤æ–½åŠ 
    if (defender.volatile && defender.volatile.partiallyTrapped) {
        return { success: false, logs };
    }
    // åˆå§‹åŒ– volatile
    if (!defender.volatile) defender.volatile = {};
    // æ–½åŠ æŸç¼šçŠ¶æ€
    const turns = Math.random() < 0.5 ? 4 : 5; // 4-5 å›åˆ
    defender.volatile.partiallyTrapped = turns;
    defender.volatile.trappedBy = attacker;
    defender.volatile.trapDamage = 1/8; // æ ‡å‡†æŸç¼šä¼¤å®³
    // ã€è½¯ç¼–ç ã€‘è·å–æŠ€èƒ½ä¸­æ–‡åï¼ˆä»ç¿»è¯‘ç³»ç»Ÿæˆ–ä½¿ç”¨åŸåï¼‰
    const moveCnName = (typeof window.Locale !== 'undefined' && window.Locale.get) 
        ? window.Locale.get(move.name) 
        : move.name;
    defender.volatile.trapMove = moveCnName;
    logs.push(`${defender.cnName} è¢« ${moveCnName} å›°ä½äº†ï¼`);
    return { success: true, logs };
}
/**
 * ã€è½¯ç¼–ç ã€‘å¤„ç†é»‘è‰²ç›®å…‰/æŒ¡è·¯ç­‰ç¡¬æ§æ‹›å¼
 * é€šè¿‡æ£€æŸ¥ moves-data.js ä¸­çš„ flags æˆ– onHit å­—æ®µåˆ¤å®š
 * @param {Object} attacker æ”»å‡»æ–¹
 * @param {Object} defender é˜²å¾¡æ–¹
 * @param {Object} move æŠ€èƒ½æ•°æ®
 * @returns {Object} { success: boolean, logs: Array }
 */
function applyMeanLook(attacker, defender, move) {
    const logs = [];
    // ã€è½¯ç¼–ç ã€‘ä» moves-data.js è¯»å–æŠ€èƒ½æ•°æ®
    const moveId = (move.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const fullMoveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : {};
    // æ£€æŸ¥æ˜¯å¦ä¸ºæŠ“äººæ‹›å¼ï¼ˆé€šè¿‡å¤šç§æ–¹å¼åˆ¤å®šï¼‰
    // 1. æ£€æŸ¥ flags ä¸­æ˜¯å¦æœ‰ trap æ ‡è®°
    // 2. æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥çš„æŠ“äººæ‹›å¼ï¼ˆä½œä¸ºåå¤‡ï¼‰
    const knownTrapMoves = ['meanlook', 'block', 'spiderweb', 'anchorshot', 'spiritshackle', 'jawlock'];
    const isTrapMove = (fullMoveData.flags && fullMoveData.flags.trap) || knownTrapMoves.includes(moveId);
    if (!isTrapMove) return { success: false, logs };
    // å¹½çµç³»å…ç–«
    if (defender.types && defender.types.includes('Ghost')) {
        logs.push(`${defender.cnName} æ˜¯å¹½çµå±æ€§ï¼Œä¸å—å½±å“ï¼`);
        return { success: false, logs };
    }
    // åˆå§‹åŒ– volatile
    if (!defender.volatile) defender.volatile = {};
    // æ–½åŠ æ— æ³•é€ƒèµ°çŠ¶æ€
    defender.volatile.cantEscape = true;
    defender.volatile.trappedBy = attacker;
    // ã€è½¯ç¼–ç ã€‘è·å–æŠ€èƒ½ä¸­æ–‡å
    const moveCnName = (typeof window.Locale !== 'undefined' && window.Locale.get) 
        ? window.Locale.get(move.name) 
        : move.name;
    logs.push(`${defender.cnName} è¢« ${moveCnName} å›°ä½ï¼Œæ— æ³•é€ƒèµ°äº†ï¼`);
    // Jaw Lock ç‰¹æ®Šå¤„ç†ï¼šåŒæ–¹éƒ½è¢«å›°ä½
    if (moveId === 'jawlock') {
        if (!attacker.volatile) attacker.volatile = {};
        attacker.volatile.cantEscape = true;
        logs.push(`${attacker.cnName} ä¹Ÿå› ç´§å’¬ä¸æ”¾è€Œæ— æ³•é€ƒèµ°ï¼`);
    }
    return { success: true, logs };
}
/**
 * å¤„ç†æŸç¼šçŠ¶æ€çš„å›åˆç»“æŸä¼¤å®³
 * @param {Object} pokemon å®å¯æ¢¦
 * @returns {Object} { damage: number, logs: Array }
 */
function processTrappingDamage(pokemon) {
    const logs = [];
    let damage = 0;
    if (!pokemon.volatile || !pokemon.volatile.partiallyTrapped) {
        return { damage, logs };
    }
    // è®¡ç®—æŸç¼šä¼¤å®³
    const trapDamage = pokemon.volatile.trapDamage || 1/8;
    damage = Math.floor(pokemon.maxHp * trapDamage);
    if (damage < 1) damage = 1;
    const trapMove = pokemon.volatile.trapMove || 'æŸç¼š';
    logs.push(`${pokemon.cnName} å—åˆ°äº† ${trapMove} çš„ä¼¤å®³ï¼`);
    return { damage, logs };
}
// ========== å¯¼å‡º ==========
window.MoveEffects = {
    // ä¼˜å…ˆçº§
    getMovePriority,
    compareActionOrder,
    // çŠ¶æ€å¼‚å¸¸
    STATUS_CONDITIONS,
    tryInflictStatus,
    processStatusEffects,
    processStatusDamage,
    processMoveStatusEffects,
    // ç‰¹æ®Šä¼¤å®³
    checkFixedDamageMove,
    checkOHKOMove,
    // å¤©æ°”/åœºåœ°
    WEATHER_TYPES,
    TERRAIN_TYPES,
    getWeatherModifier,
    getTerrainModifier,
    // æŠ€èƒ½æ ‡è®°
    MOVE_FLAGS,
    hasMoveFlag,
    isContactMove,
    isProtectable,
    isSoundMove,
    // åœºåœ°é’‰å­
    applySideCondition,
    applyEntryHazards,
    clearEntryHazards,
    // Volatile çŠ¶æ€ (Taunt, Substitute ç­‰)
    applyVolatileStatus,
    canUseMove,
    checkConfusion,
    checkAttract,
    checkSubstitute,
    tickVolatileStatus,
    // é“å…·å›åˆæœ«æ•ˆæœ
    processEndTurnItemEffects,
    // æ‹è½æ•ˆæœ
    applyKnockOff,
    canKnockOffItem,
    // æŸç¼šæ‹›å¼
    applyTrappingMove,
    applyMeanLook,
    processTrappingDamage
};
console.log('[PKM] MoveEffects æ¨¡å—å·²åŠ è½½');
]]></file>
        <file name="move-handlers.js"><![CDATA[/**
 * =============================================
 * MOVE HANDLERS - æŠ€èƒ½å¤„ç†å™¨ (ç­–ç•¥æ¨¡å¼)
 * =============================================
 * 
 * æœ¬æ–‡ä»¶ä½¿ç”¨ç­–ç•¥æ¨¡å¼å¤„ç†ç‰¹æ®ŠæŠ€èƒ½é€»è¾‘ï¼Œ
 * é¿å…åœ¨ battle-engine.js ä¸­å †ç§¯å¤§é‡ if-elseã€‚
 * 
 * æ¯ä¸ªæŠ€èƒ½å¯ä»¥æ³¨å†Œä»¥ä¸‹é’©å­ï¼š
 * - basePowerCallback: åŠ¨æ€è®¡ç®—å¨åŠ›
 * - damageCallback: å®Œå…¨è‡ªå®šä¹‰ä¼¤å®³è®¡ç®—
 * - onHit: å‘½ä¸­åçš„é¢å¤–æ•ˆæœ
 * - onMiss: æœªå‘½ä¸­æ—¶çš„æ•ˆæœ
 * - onUse: ä½¿ç”¨æ—¶çš„æ•ˆæœï¼ˆè“„åŠ›ç­‰ï¼‰
 * - modifyAtk: ä¿®æ”¹æ”»å‡»åŠ›è®¡ç®—
 * - modifyDef: ä¿®æ”¹é˜²å¾¡åŠ›è®¡ç®—
 */
const MoveHandlers = {
    // ============================================
    // 1. å›ºå®šä¼¤å®³æŠ€èƒ½ (Fixed Damage Moves)
    // ============================================
    'Night Shade': {
        damageCallback: (attacker, defender) => {
            return attacker.level;
        },
        description: 'é€ æˆç­‰äºä½¿ç”¨è€…ç­‰çº§çš„å›ºå®šä¼¤å®³'
    },
    'Seismic Toss': {
        damageCallback: (attacker, defender) => {
            return attacker.level;
        },
        description: 'é€ æˆç­‰äºä½¿ç”¨è€…ç­‰çº§çš„å›ºå®šä¼¤å®³'
    },
    'Psywave': {
        damageCallback: (attacker, defender) => {
            // ä¼¤å®³ = ç­‰çº§ Ã— (0.5 ~ 1.5) éšæœº
            const multiplier = 0.5 + Math.random();
            return Math.floor(attacker.level * multiplier);
        },
        description: 'é€ æˆç­‰çº§ç›¸å…³çš„éšæœºä¼¤å®³'
    },
    'Dragon Rage': {
        damageCallback: (attacker, defender) => {
            return 40; // å›ºå®š 40 ç‚¹ä¼¤å®³
        },
        description: 'å›ºå®šé€ æˆ 40 ç‚¹ä¼¤å®³'
    },
    'Sonic Boom': {
        damageCallback: (attacker, defender) => {
            return 20; // å›ºå®š 20 ç‚¹ä¼¤å®³
        },
        description: 'å›ºå®šé€ æˆ 20 ç‚¹ä¼¤å®³'
    },
    'Super Fang': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp / 2));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP ä¸€åŠçš„ä¼¤å®³'
    },
    'Nature\'s Madness': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp / 2));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP ä¸€åŠçš„ä¼¤å®³'
    },
    'Guardian of Alola': {
        damageCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(defender.currHp * 0.75));
        },
        description: 'é€ æˆç›®æ ‡å½“å‰ HP 75% çš„ä¼¤å®³'
    },
    // ============================================
    // 2. åŠ¨æ€å¨åŠ›æŠ€èƒ½ (Dynamic Power Moves)
    // ============================================
    'Gyro Ball': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 25 Ã— (ç›®æ ‡é€Ÿåº¦ / è‡ªå·±é€Ÿåº¦) + 1ï¼Œæœ€é«˜ 150
            const userSpeed = Math.max(1, attacker.getStat('spe'));
            const targetSpeed = Math.max(1, defender.getStat('spe'));
            const power = Math.floor(25 * targetSpeed / userSpeed) + 1;
            return Math.min(150, power);
        },
        description: 'é€Ÿåº¦è¶Šæ…¢å¨åŠ›è¶Šé«˜'
    },
    'Electro Ball': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ›æ ¹æ®é€Ÿåº¦æ¯”å€¼
            const userSpeed = Math.max(1, attacker.getStat('spe'));
            const targetSpeed = Math.max(1, defender.getStat('spe'));
            const ratio = userSpeed / targetSpeed;
            if (ratio >= 4) return 150;
            if (ratio >= 3) return 120;
            if (ratio >= 2) return 80;
            if (ratio >= 1) return 60;
            return 40;
        },
        description: 'é€Ÿåº¦è¶Šå¿«å¨åŠ›è¶Šé«˜'
    },
    'Grass Knot': {
        basePowerCallback: (attacker, defender) => {
            // æ ¹æ®ç›®æ ‡ä½“é‡ï¼ˆç®€åŒ–ï¼šç”¨ HP åŸºç¡€å€¼æ¨¡æ‹Ÿï¼‰
            const weight = defender.maxHp; // ç®€åŒ–å¤„ç†
            if (weight >= 200) return 120;
            if (weight >= 150) return 100;
            if (weight >= 100) return 80;
            if (weight >= 50) return 60;
            if (weight >= 25) return 40;
            return 20;
        },
        description: 'ç›®æ ‡è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Low Kick': {
        basePowerCallback: (attacker, defender) => {
            const weight = defender.maxHp;
            if (weight >= 200) return 120;
            if (weight >= 150) return 100;
            if (weight >= 100) return 80;
            if (weight >= 50) return 60;
            if (weight >= 25) return 40;
            return 20;
        },
        description: 'ç›®æ ‡è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Heavy Slam': {
        basePowerCallback: (attacker, defender) => {
            // æ ¹æ®ä½“é‡æ¯”
            const userWeight = attacker.maxHp;
            const targetWeight = Math.max(1, defender.maxHp);
            const ratio = userWeight / targetWeight;
            if (ratio >= 5) return 120;
            if (ratio >= 4) return 100;
            if (ratio >= 3) return 80;
            if (ratio >= 2) return 60;
            return 40;
        },
        description: 'è‡ªå·±è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Heat Crash': {
        basePowerCallback: (attacker, defender) => {
            const userWeight = attacker.maxHp;
            const targetWeight = Math.max(1, defender.maxHp);
            const ratio = userWeight / targetWeight;
            if (ratio >= 5) return 120;
            if (ratio >= 4) return 100;
            if (ratio >= 3) return 80;
            if (ratio >= 2) return 60;
            return 40;
        },
        description: 'è‡ªå·±è¶Šé‡å¨åŠ›è¶Šé«˜'
    },
    'Stored Power': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 20 + 20 Ã— èƒ½åŠ›æå‡æ€»ç­‰çº§
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (attacker.boosts[stat] > 0) {
                    totalBoosts += attacker.boosts[stat];
                }
            }
            return 20 + 20 * totalBoosts;
        },
        description: 'èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Power Trip': {
        basePowerCallback: (attacker, defender) => {
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (attacker.boosts[stat] > 0) {
                    totalBoosts += attacker.boosts[stat];
                }
            }
            return 20 + 20 * totalBoosts;
        },
        description: 'èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Punishment': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 60 + 20 Ã— ç›®æ ‡èƒ½åŠ›æå‡æ€»ç­‰çº§ï¼Œæœ€é«˜ 200
            let totalBoosts = 0;
            for (const stat of ['atk', 'def', 'spa', 'spd', 'spe']) {
                if (defender.boosts[stat] > 0) {
                    totalBoosts += defender.boosts[stat];
                }
            }
            return Math.min(200, 60 + 20 * totalBoosts);
        },
        description: 'ç›®æ ‡èƒ½åŠ›æå‡è¶Šå¤šå¨åŠ›è¶Šé«˜'
    },
    'Reversal': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ›æ ¹æ®å‰©ä½™ HP ç™¾åˆ†æ¯”
            const hpPercent = attacker.currHp / attacker.maxHp;
            if (hpPercent <= 0.0417) return 200;
            if (hpPercent <= 0.1042) return 150;
            if (hpPercent <= 0.2083) return 100;
            if (hpPercent <= 0.3542) return 80;
            if (hpPercent <= 0.6875) return 40;
            return 20;
        },
        description: 'HP è¶Šä½å¨åŠ›è¶Šé«˜'
    },
    'Flail': {
        basePowerCallback: (attacker, defender) => {
            const hpPercent = attacker.currHp / attacker.maxHp;
            if (hpPercent <= 0.0417) return 200;
            if (hpPercent <= 0.1042) return 150;
            if (hpPercent <= 0.2083) return 100;
            if (hpPercent <= 0.3542) return 80;
            if (hpPercent <= 0.6875) return 40;
            return 20;
        },
        description: 'HP è¶Šä½å¨åŠ›è¶Šé«˜'
    },
    'Eruption': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 150 Ã— (å½“å‰HP / æœ€å¤§HP)
            return Math.max(1, Math.floor(150 * attacker.currHp / attacker.maxHp));
        },
        description: 'HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Water Spout': {
        basePowerCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(150 * attacker.currHp / attacker.maxHp));
        },
        description: 'HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Crush Grip': {
        basePowerCallback: (attacker, defender) => {
            // å¨åŠ› = 120 Ã— (ç›®æ ‡å½“å‰HP / ç›®æ ‡æœ€å¤§HP)
            return Math.max(1, Math.floor(120 * defender.currHp / defender.maxHp));
        },
        description: 'ç›®æ ‡ HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    'Wring Out': {
        basePowerCallback: (attacker, defender) => {
            return Math.max(1, Math.floor(120 * defender.currHp / defender.maxHp));
        },
        description: 'ç›®æ ‡ HP è¶Šé«˜å¨åŠ›è¶Šé«˜'
    },
    // ã€é³ƒå’¬ã€‘å…ˆæ‰‹å¨åŠ›ç¿»å€ (Gen 8 åŒ–çŸ³é¾™æ ¸å¿ƒæ‹›å¼)
    'Fishious Rend': {
        basePowerCallback: (attacker, defender, move, battle) => {
            // å¦‚æœä½¿ç”¨è€…æ¯”ç›®æ ‡å…ˆè¡ŒåŠ¨ï¼Œå¨åŠ›ç¿»å€ (85 -> 170)
            const mySpeed = attacker.getStat ? attacker.getStat('spe') : attacker.spe;
            const enemySpeed = defender.getStat ? defender.getStat('spe') : defender.spe;
            // ç®€åŒ–åˆ¤å®šï¼šé€Ÿåº¦å¿«çš„è§†ä¸ºå…ˆè¡ŒåŠ¨
            if (mySpeed >= enemySpeed) {
                console.log(`[Fishious Rend] å…ˆæ‰‹å¨åŠ›ç¿»å€ï¼170`);
                return 170;
            }
            return 85;
        },
        description: 'å¦‚æœæ¯”å¯¹æ‰‹å…ˆå‡ºæ‰‹ï¼Œå¨åŠ›ç¿»å€ (170)'
    },
    // ã€ç”µå–™ã€‘å…ˆæ‰‹å¨åŠ›ç¿»å€ (Gen 8 åŒ–çŸ³é¾™æ ¸å¿ƒæ‹›å¼)
    'Bolt Beak': {
        basePowerCallback: (attacker, defender, move, battle) => {
            const mySpeed = attacker.getStat ? attacker.getStat('spe') : attacker.spe;
            const enemySpeed = defender.getStat ? defender.getStat('spe') : defender.spe;
            if (mySpeed >= enemySpeed) {
                console.log(`[Bolt Beak] å…ˆæ‰‹å¨åŠ›ç¿»å€ï¼170`);
                return 170;
            }
            return 85;
        },
        description: 'å¦‚æœæ¯”å¯¹æ‰‹å…ˆå‡ºæ‰‹ï¼Œå¨åŠ›ç¿»å€ (170)'
    },
    // ã€å…‰å­å–·æ¶Œã€‘ä½¿ç”¨ç‰©æ”»å’Œç‰¹æ”»ä¸­è¾ƒé«˜çš„ä¸€æ–¹è®¡ç®—ä¼¤å®³
    'Photon Geyser': {
        modifyAtk: (attacker, defender, isSpecial) => {
            const atkStat = attacker.getStat ? attacker.getStat('atk') : attacker.atk;
            const spaStat = attacker.getStat ? attacker.getStat('spa') : attacker.spa;
            // ä½¿ç”¨è¾ƒé«˜çš„æ”»å‡»èƒ½åŠ›
            const usedStat = Math.max(atkStat, spaStat);
            console.log(`[Photon Geyser] ç‰©æ”»=${atkStat}, ç‰¹æ”»=${spaStat}, ä½¿ç”¨=${usedStat}`);
            return usedStat;
        },
        description: 'ä½¿ç”¨ç‰©æ”»å’Œç‰¹æ”»ä¸­è¾ƒé«˜çš„ä¸€æ–¹è®¡ç®—ä¼¤å®³ï¼Œæ— è§†ç›®æ ‡ç‰¹æ€§'
    },
    // ã€ç„šå¤©ç­ä¸–ç‚½å…‰çˆ†ã€‘åŒæ ·ä½¿ç”¨ç‰©æ”»å’Œç‰¹æ”»ä¸­è¾ƒé«˜çš„ä¸€æ–¹
    'Light That Burns the Sky': {
        modifyAtk: (attacker, defender, isSpecial) => {
            const atkStat = attacker.getStat ? attacker.getStat('atk') : attacker.atk;
            const spaStat = attacker.getStat ? attacker.getStat('spa') : attacker.spa;
            const usedStat = Math.max(atkStat, spaStat);
            console.log(`[Light That Burns the Sky] ç‰©æ”»=${atkStat}, ç‰¹æ”»=${spaStat}, ä½¿ç”¨=${usedStat}`);
            return usedStat;
        },
        description: 'ä½¿ç”¨ç‰©æ”»å’Œç‰¹æ”»ä¸­è¾ƒé«˜çš„ä¸€æ–¹è®¡ç®—ä¼¤å®³ï¼Œæ— è§†ç›®æ ‡ç‰¹æ€§'
    },
    // ============================================
    // 3. ç‰¹æ®Šæ”»é˜²è®¡ç®— (Modified Stat Moves)
    // ============================================
    'Foul Play': {
        modifyAtk: (attacker, defender, isSpecial) => {
            // ä½¿ç”¨ç›®æ ‡çš„æ”»å‡»åŠ›
            return defender.getStat('atk');
        },
        description: 'ä½¿ç”¨ç›®æ ‡çš„æ”»å‡»åŠ›è®¡ç®—ä¼¤å®³'
    },
    'Body Press': {
        modifyAtk: (attacker, defender, isSpecial) => {
            // ä½¿ç”¨è‡ªå·±çš„é˜²å¾¡åŠ›ä»£æ›¿æ”»å‡»åŠ›
            return attacker.getStat('def');
        },
        description: 'ä½¿ç”¨è‡ªå·±çš„é˜²å¾¡åŠ›è®¡ç®—ä¼¤å®³'
    },
    'Psyshock': {
        modifyDef: (attacker, defender, isSpecial) => {
            // ç‰¹æ®Šæ”»å‡»ä½†æ‰“ç‰©é˜²
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    'Psystrike': {
        modifyDef: (attacker, defender, isSpecial) => {
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    'Secret Sword': {
        modifyDef: (attacker, defender, isSpecial) => {
            return defender.getStat('def');
        },
        description: 'ç‰¹æ®Šæ”»å‡»ä½†è®¡ç®—ç‰©ç†é˜²å¾¡'
    },
    // ============================================
    // 4. æ¢äººæŠ€èƒ½ (Pivot Moves) - ä»…æ—¥å¿—è¾“å‡º
    // ============================================
    'U-turn': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äººï¼ˆå…ç–«/æœªå‘½ä¸­ä¸è§¦å‘ï¼‰
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Volt Switch': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äººï¼ˆåœ°é¢ç³»å…ç–«ç”µç³»ï¼‰
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Flip Turn': {
        onHit: (attacker, defender, damage, logs) => {
            // å…³é”®ä¿®å¤ï¼šåªæœ‰é€ æˆä¼¤å®³æ—¶æ‰è§¦å‘æ¢äºº
            if (damage <= 0) {
                return { pivot: false };
            }
            // æ—¥å¿—ç§»åˆ° index.js çš„æ¢äººé€»è¾‘ä¸­ï¼Œé¿å…è¯¯å¯¼
            return { pivot: true };
        },
        description: 'æ”»å‡»åå¯ä»¥æ¢äººï¼ˆå…ç–«æ—¶ä¸è§¦å‘ï¼‰'
    },
    'Parting Shot': {
        onHit: (attacker, defender, damage, logs) => {
            // Parting Shot æ˜¯å˜åŒ–æŠ€ï¼Œåªè¦æˆåŠŸä½¿ç”¨å°±è§¦å‘ï¼ˆé™¤éè¢«æŒ‘è¡…ç­‰é˜»æ­¢ï¼‰
            logs.push(`${attacker.cnName} ç•™ä¸‹ç‹ è¯åæ’¤é€€äº†!`);
            return { pivot: true };
        },
        description: 'é™ä½å¯¹æ‰‹èƒ½åŠ›åæ¢äºº'
    },
    'Fake Out': {
        onUse: (attacker, defender, logs) => {
            // å…³é”®ä¿®å¤ï¼šFake Out åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[Fake Out] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            return {};
        },
        // ã€ä¿®å¤ã€‘ç§»é™¤ onHit é’©å­ï¼Œç•ç¼©æ•ˆæœç”± battle-effects.js çš„ secondary å¤„ç†ç»Ÿä¸€å¤„ç†
        // é¿å…é‡å¤è¾“å‡º"ç•ç¼©äº†!"æ—¥å¿—
        description: 'å…ˆåˆ¶æŠ€ï¼Œä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆï¼Œ100%ç•ç¼©'
    },
    'First Impression': {
        onUse: (attacker, defender, logs) => {
            // First Impression åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[First Impression] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            return {};
        },
        description: 'è™«ç³»å…ˆåˆ¶å¤§æ‹›ï¼Œä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆ'
    },
    'Mat Block': {
        onUse: (attacker, defender, logs) => {
            // Mat Block åªèƒ½åœ¨ä¸Šåœºç¬¬ä¸€å›åˆä½¿ç”¨
            console.log(`[Mat Block] ${attacker.cnName} turnsOnField: ${attacker.turnsOnField}`);
            if (attacker.turnsOnField > 0) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { failed: true };
            }
            logs.push(`${attacker.cnName} æ€èµ·äº†æ¦»æ¦»ç±³è¿›è¡Œé˜²å¾¡!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'ä»…åœ¨ä¸Šåœºç¬¬ä¸€å›åˆæœ‰æ•ˆï¼Œé˜²å¾¡ç‰©ç†å’Œç‰¹æ®Šæ”»å‡»'
    },
    // ============================================
    // å®ˆä½ç±»æŠ€èƒ½ (Protect Family) - è¿ç»­ä½¿ç”¨æƒ©ç½š
    // ============================================
    'Protect': {
        onUse: (attacker, defender, logs) => {
            // è¿ç»­ä½¿ç”¨æˆåŠŸç‡è¡°å‡ï¼š1 -> 1/3 -> 1/9 -> ...
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è¿ç»­ä½¿ç”¨å®ˆä½æˆåŠŸç‡é™ä½)`);
                    return { failed: true };
                }
            }
            // æˆåŠŸä½¿ç”¨
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} å®ˆä½äº†è‡ªå·±!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'å®ˆä½æ‰€æœ‰æ”»å‡»ï¼Œè¿ç»­ä½¿ç”¨æˆåŠŸç‡é™ä½'
    },
    'Detect': {
        onUse: (attacker, defender, logs) => {
            // ä¸ Protect å…±äº«è®¡æ•°å™¨
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è¿ç»­ä½¿ç”¨è§åˆ‡æˆåŠŸç‡é™ä½)`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†è§åˆ‡!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'ä¸å®ˆä½æ•ˆæœç›¸åŒï¼Œå…±äº«è¿ç»­ä½¿ç”¨è®¡æ•°å™¨'
    },
    'King\'s Shield': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†ç‹è€…ç›¾ç‰Œ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.kingsShield = true; // æ¥è§¦æ”»å‡»é™æ”»
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„æ”»å‡»'
    },
    'Spiky Shield': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†å°–åˆºé˜²å®ˆ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.spikyShield = true; // æ¥è§¦æ”»å‡»åä¼¤
            }
            return {};
        },
        description: 'å®ˆä½å¹¶å¯¹æ¥è§¦æ”»å‡»è€…é€ æˆä¼¤å®³'
    },
    'Baneful Bunker': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} èº²è¿›äº†ç¢‰å ¡!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.banefulBunker = true; // æ¥è§¦æ”»å‡»ä¸­æ¯’
            }
            return {};
        },
        description: 'å®ˆä½å¹¶ä½¿æ¥è§¦æ”»å‡»è€…ä¸­æ¯’'
    },
    'Obstruct': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†æ‹¦å µ!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.obstruct = true; // æ¥è§¦æ”»å‡»é™é˜²
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„é˜²å¾¡'
    },
    'Silk Trap': {
        onUse: (attacker, defender, logs) => {
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†çº¿é˜±!`);
            if (attacker.volatile) {
                attacker.volatile.protect = true;
                attacker.volatile.silkTrap = true; // æ¥è§¦æ”»å‡»é™é€Ÿ
            }
            return {};
        },
        description: 'å®ˆä½å¹¶é™ä½æ¥è§¦æ”»å‡»è€…çš„é€Ÿåº¦'
    },
    'Endure': {
        onUse: (attacker, defender, logs) => {
            // æŒºä½ï¼šä¸å®ˆä½å…±äº«è®¡æ•°å™¨
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} æ‘†å‡ºäº†æŒºä½çš„æ¶åŠ¿!`);
            if (attacker.volatile) attacker.volatile.endure = true;
            return {};
        },
        description: 'æœ¬å›åˆè‡³å°‘ä¿ç•™1HPï¼Œä¸å®ˆä½å…±äº«è®¡æ•°å™¨'
    },
    'Max Guard': {
        onUse: (attacker, defender, logs) => {
            // ä¸å®ˆä½å…±äº«è®¡æ•°å™¨
            const counter = attacker.protectCounter || 0;
            if (counter > 0) {
                const successChance = Math.pow(1/3, counter);
                if (Math.random() > successChance) {
                    logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è¿ç»­ä½¿ç”¨æˆåŠŸç‡é™ä½)`);
                    return { failed: true };
                }
            }
            attacker.protectCounter = counter + 1;
            logs.push(`${attacker.cnName} å®ˆä½äº†è‡ªå·±!`);
            if (attacker.volatile) attacker.volatile.protect = true;
            return {};
        },
        description: 'æå·¨åŒ–æ—¶çš„å®ˆä½ï¼Œä¸æ™®é€šå®ˆä½å…±äº«è®¡æ•°å™¨'
    },
    'Destiny Bond': {
        onUse: (attacker, defender, logs) => {
            // Gen 7+ï¼šè¿ç»­ä½¿ç”¨å¿…å¤±è´¥
            if (attacker.lastMoveUsed === 'Destiny Bond') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (åŒå‘½ä¸èƒ½è¿ç»­ä½¿ç”¨)`);
                return { failed: true };
            }
            logs.push(`${attacker.cnName} æƒ³è¦å’Œå¯¹æ‰‹åŒå½’äºå°½!`);
            if (attacker.volatile) attacker.volatile.destinyBond = true;
            return {};
        },
        description: 'æœ¬å›åˆè¢«å‡»å€’æ—¶å¯¹æ‰‹ä¹Ÿä¼šå€’ä¸‹ï¼Œä¸èƒ½è¿ç»­ä½¿ç”¨'
    },
    // ============================================
    // åƒµç›´ç±»æŠ€èƒ½ (Recharge Moves)
    // ============================================
    'Hyper Beam': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'å¼ºåŠ›æ”»å‡»ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Giga Impact': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'å¼ºåŠ›ç‰©ç†æ”»å‡»ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Frenzy Plant': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'è‰ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Blast Burn': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'ç«ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Hydro Cannon': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'æ°´ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Prismatic Laser': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'è¶…èƒ½åŠ›ç³»å¤§æ‹›ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Meteor Assault': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'æ ¼æ–—ç³»å¤§æ‹›ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Eternabeam': {
        onUse: (attacker, defender, logs) => {
            if (attacker.mustRecharge) {
                logs.push(`${attacker.cnName} å› ä¸ºä¸Šå›åˆçš„åä½œç”¨åŠ›æ— æ³•åŠ¨å¼¹!`);
                attacker.mustRecharge = false;
                return { failed: true };
            }
            return {};
        },
        onHit: (attacker, defender, damage, logs) => {
            if (damage > 0) {
                attacker.mustRecharge = true;
                logs.push(`${attacker.cnName} ä¸‹å›åˆéœ€è¦ä¼‘æ¯!`);
            }
            return {};
        },
        description: 'é¾™ç³»ç©¶ææŠ€ï¼Œå‘½ä¸­åä¸‹å›åˆæ— æ³•è¡ŒåŠ¨'
    },
    'Baton Pass': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} ä½¿ç”¨äº†æ¥åŠ›æ£’!`);
            return { pivot: true, passBoosts: true };
        },
        description: 'æ¢äººå¹¶ä¼ é€’èƒ½åŠ›å˜åŒ–'
    },
    'Teleport': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} ä½¿ç”¨ç¬é—´ç§»åŠ¨æ’¤é€€äº†!`);
            return { pivot: true };
        },
        description: 'æ’¤é€€æ¢äºº'
    },
    // ============================================
    // 5. å¼ºåˆ¶æ¢äººæŠ€èƒ½ (Phazing Moves)
    // ============================================
    'Roar': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«å“è·‘äº†!`);
            return { phaze: true };
        },
        description: 'å¼ºåˆ¶å¯¹æ‰‹æ¢äºº'
    },
    'Whirlwind': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«å¹èµ°äº†!`);
            return { phaze: true };
        },
        description: 'å¼ºåˆ¶å¯¹æ‰‹æ¢äºº'
    },
    'Dragon Tail': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«ç”©é£äº†!`);
            return { phaze: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¼ºåˆ¶æ¢äºº'
    },
    'Circle Throw': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`${defender.cnName} è¢«æ‘”å‡ºå»äº†!`);
            return { phaze: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¼ºåˆ¶æ¢äºº'
    },
    // ============================================
    // 6. å¤©æ°”æŠ€èƒ½ (Weather Moves)
    // ============================================
    'Rain Dance': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'rain';
            logs.push('å¤©ç©ºä¸‹èµ·äº†å¤§é›¨!');
            logs.push('<span style="color:#3498db">æ°´ç³»æŠ€èƒ½å¨åŠ›æå‡ï¼Œç«ç³»æŠ€èƒ½å¨åŠ›ä¸‹é™!</span>');
            return { weather: 'rain' };
        },
        description: 'å¬å”¤é›¨å¤©'
    },
    'Sunny Day': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'sun';
            logs.push('é˜³å…‰å˜å¾—å¼ºçƒˆäº†!');
            logs.push('<span style="color:#e67e22">ç«ç³»æŠ€èƒ½å¨åŠ›æå‡ï¼Œæ°´ç³»æŠ€èƒ½å¨åŠ›ä¸‹é™!</span>');
            return { weather: 'sun' };
        },
        description: 'å¬å”¤æ™´å¤©'
    },
    'Sandstorm': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'sand';
            logs.push('æ²™æš´åˆ®èµ·æ¥äº†!');
            logs.push('<span style="color:#d4ac0d">å²©çŸ³ç³»ç‰¹é˜²æå‡ï¼Œéå²©/åœ°/é’¢ç³»æ¯å›åˆå—ä¼¤!</span>');
            return { weather: 'sand' };
        },
        description: 'å¬å”¤æ²™æš´'
    },
    'Hail': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'hail';
            logs.push('å¼€å§‹ä¸‹å†°é›¹äº†!');
            logs.push('<span style="color:#5dade2">éå†°ç³»æ¯å›åˆå—ä¼¤!</span>');
            return { weather: 'hail' };
        },
        description: 'å¬å”¤å†°é›¹'
    },
    'Snowscape': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle) battle.weather = 'snow';
            logs.push('ä¸‹èµ·äº†é›ª!');
            logs.push('<span style="color:#85c1e9">å†°ç³»é˜²å¾¡æå‡!</span>');
            return { weather: 'snow' };
        },
        description: 'å¬å”¤é›ªå¤©'
    },
    // ============================================
    // 7. åœºåœ°æŠ€èƒ½ (Terrain/Hazard Moves) - ç®€åŒ–ç‰ˆ
    // ============================================
    'Stealth Rock': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('å°–é”çš„å²©çŸ³æ¼‚æµ®åœ¨å¯¹æ–¹åœºåœ°å‘¨å›´!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.stealthRock = true;
            }
            return { hazard: 'stealthRock' };
        },
        description: 'è®¾ç½®éšå½¢å²©'
    },
    'Spikes': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('æ’’è±æ•£å¸ƒåœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.spikes = (battle.hazards.spikes || 0) + 1;
            }
            return { hazard: 'spikes' };
        },
        description: 'è®¾ç½®æ’’è±'
    },
    'Toxic Spikes': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('æ¯’è±æ•£å¸ƒåœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.toxicSpikes = (battle.hazards.toxicSpikes || 0) + 1;
            }
            return { hazard: 'toxicSpikes' };
        },
        description: 'è®¾ç½®æ¯’è±'
    },
    'Sticky Web': {
        onUse: (attacker, defender, logs, battle) => {
            logs.push('é»é»ç½‘é“ºè®¾åœ¨å¯¹æ–¹åœºåœ°ä¸Š!');
            if (battle) {
                battle.hazards = battle.hazards || {};
                battle.hazards.stickyWeb = true;
            }
            return { hazard: 'stickyWeb' };
        },
        description: 'è®¾ç½®é»é»ç½‘'
    },
    'Rapid Spin': {
        onHit: (attacker, defender, damage, logs, battle) => {
            logs.push(`${attacker.cnName} æ€¥é€Ÿæ—‹è½¬ï¼Œæ‰«é™¤äº†åœºä¸Šçš„éšœç¢!`);
            if (battle && battle.hazards) {
                battle.hazards = {};
            }
            // æ¸…é™¤è‡ªèº«çš„æŸç¼šçŠ¶æ€
            if (attacker.volatile) {
                delete attacker.volatile.partiallytrapped;
                delete attacker.volatile.leechseed;
            }
            return { clearHazards: true };
        },
        description: 'æ¸…é™¤å·±æ–¹åœºåœ°éšœç¢'
    },
    'Defog': {
        onHit: (attacker, defender, damage, logs, battle) => {
            logs.push('åœºåœ°ä¸Šçš„éšœç¢ç‰©è¢«å¹æ•£äº†!');
            if (battle) {
                battle.hazards = {};
            }
            return { clearHazards: true };
        },
        description: 'æ¸…é™¤åŒæ–¹åœºåœ°éšœç¢'
    },
    // ============================================
    // 8. è“„åŠ›æŠ€èƒ½ (Two-Turn Moves) - ç®€åŒ–ä¸ºå•å›åˆ
    // ============================================
    'Solar Beam': {
        onUse: (attacker, defender, logs, battle) => {
            // ç®€åŒ–ï¼šç›´æ¥å‘å°„ï¼Œä¸éœ€è¦è“„åŠ›
            if (battle && battle.weather === 'sun') {
                logs.push(`${attacker.cnName} å€ŸåŠ©å¼ºçƒˆçš„é˜³å…‰ï¼Œç¬é—´å‘å°„äº†æ—¥å…‰æŸ!`);
            } else {
                logs.push(`${attacker.cnName} è¿…é€Ÿèšé›†èƒ½é‡å‘å°„äº†æ—¥å…‰æŸ!`);
            }
            return { skipCharge: true };
        },
        description: 'æ™´å¤©ä¸‹æ— éœ€è“„åŠ›'
    },
    'Solar Blade': {
        onUse: (attacker, defender, logs, battle) => {
            if (battle && battle.weather === 'sun') {
                logs.push(`${attacker.cnName} å€ŸåŠ©é˜³å…‰çš„åŠ›é‡æŒ¥å‡ºäº†æ—¥å…‰åˆƒ!`);
            } else {
                logs.push(`${attacker.cnName} èšé›†å…‰èŠ’æŒ¥å‡ºäº†æ—¥å…‰åˆƒ!`);
            }
            return { skipCharge: true };
        },
        description: 'æ™´å¤©ä¸‹æ— éœ€è“„åŠ›'
    },
    'Hyper Beam': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`<span style="color:#e74c3c">${attacker.cnName} éœ€è¦ä¼‘æ¯æ¢å¤!</span>`);
            // ç®€åŒ–ï¼šä¸å®é™…è·³è¿‡å›åˆï¼Œåªæ˜¯æç¤º
            return { recharge: true };
        },
        description: 'ä½¿ç”¨åéœ€è¦ä¼‘æ¯'
    },
    'Giga Impact': {
        onHit: (attacker, defender, damage, logs) => {
            logs.push(`<span style="color:#e74c3c">${attacker.cnName} éœ€è¦ä¼‘æ¯æ¢å¤!</span>`);
            return { recharge: true };
        },
        description: 'ä½¿ç”¨åéœ€è¦ä¼‘æ¯'
    },
    // ============================================
    // 9. å…¶ä»–ç‰¹æ®ŠæŠ€èƒ½
    // ============================================
    'Explosion': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} å¼•çˆ†äº†è‡ªå·±!`);
            // è‡ªçˆ†ï¼šä½¿ç”¨è€…å€’ä¸‹
            attacker.currHp = 0;
            return { selfDestruct: true };
        },
        description: 'ä½¿ç”¨è€…å€’ä¸‹'
    },
    'Self-Destruct': {
        onUse: (attacker, defender, logs) => {
            logs.push(`${attacker.cnName} è‡ªçˆ†äº†!`);
            attacker.currHp = 0;
            return { selfDestruct: true };
        },
        description: 'ä½¿ç”¨è€…å€’ä¸‹'
    },
    'Final Gambit': {
        damageCallback: (attacker, defender) => {
            const damage = attacker.currHp;
            attacker.currHp = 0; // ä½¿ç”¨è€…å€’ä¸‹
            return damage;
        },
        description: 'é€ æˆç­‰äºè‡ªèº«å‰©ä½™ HP çš„ä¼¤å®³ï¼Œä½¿ç”¨è€…å€’ä¸‹'
    },
    'Endeavor': {
        damageCallback: (attacker, defender) => {
            // å°†ç›®æ ‡ HP é™åˆ°ä¸è‡ªå·±ç›¸åŒ
            if (defender.currHp > attacker.currHp) {
                return defender.currHp - attacker.currHp;
            }
            return 0;
        },
        description: 'å°†ç›®æ ‡ HP é™åˆ°ä¸è‡ªå·±ç›¸åŒ'
    },
    'Pain Split': {
        onUse: (attacker, defender, logs) => {
            const avgHp = Math.floor((attacker.currHp + defender.currHp) / 2);
            attacker.currHp = Math.min(avgHp, attacker.maxHp);
            defender.currHp = Math.min(avgHp, defender.maxHp);
            logs.push(`${attacker.cnName} å’Œ ${defender.cnName} å¹³åˆ†äº†ç—›è‹¦!`);
            return { hpShared: true };
        },
        description: 'å¹³åˆ†åŒæ–¹ HP'
    },
    'Destiny Bond': {
        onUse: (attacker, defender, logs) => {
            attacker.volatile = attacker.volatile || {};
            attacker.volatile.destinyBond = true;
            logs.push(`${attacker.cnName} æƒ³è¦åŒå½’äºå°½!`);
            return { destinyBond: true };
        },
        description: 'å¦‚æœå€’ä¸‹åˆ™å¸¦èµ°å¯¹æ‰‹'
    },
    'Perish Song': {
        onUse: (attacker, defender, logs) => {
            logs.push('ç­äº¡ä¹‹æ­Œå“èµ·äº†! 3 å›åˆååœºä¸Šçš„å®å¯æ¢¦éƒ½ä¼šå€’ä¸‹!');
            // ç®€åŒ–ï¼šåªæ˜¯æç¤ºï¼Œä¸å®é™…å®ç°è®¡æ•°å™¨
            return { perishSong: true };
        },
        description: '3 å›åˆååŒæ–¹å€’ä¸‹'
    },
    'Metronome': {
        onUse: (attacker, defender, logs) => {
            // ç®€åŒ–ï¼šéšæœºé€‰æ‹©ä¸€ä¸ªå¸¸è§æ”»å‡»æŠ€èƒ½
            const randomMoves = ['Flamethrower', 'Thunderbolt', 'Ice Beam', 'Psychic', 
                                'Shadow Ball', 'Energy Ball', 'Earthquake', 'Surf'];
            const chosen = randomMoves[Math.floor(Math.random() * randomMoves.length)];
            logs.push(`${attacker.cnName} æŒ¥åŠ¨æ‰‹æŒ‡... ä½¿å‡ºäº† ${chosen}!`);
            return { metronome: chosen };
        },
        description: 'éšæœºä½¿ç”¨ä¸€ä¸ªæŠ€èƒ½'
    },
    // ============================================
    // 10. å±æ€§å˜åŒ–ç±»æŠ€èƒ½ (Type Changing Moves)
    // ============================================
    // ã€çº¹ç†ã€‘ï¼šå˜æˆè‡ªå·±ç¬¬ä¸€æ‹›çš„å±æ€§
    'Conversion': {
        onUse: (attacker, defender, logs) => {
            // è·å–ç¬¬ä¸€æ‹›
            const firstMove = attacker.moves[0];
            if (!firstMove) return;
            const targetType = firstMove.type;
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯è¯¥å±æ€§ï¼ˆå¦‚æœæ˜¯ï¼Œåˆ™æ‹›å¼å¤±è´¥ï¼‰
            // æ³¨æ„ï¼šattacker.types æ˜¯æ•°ç»„ï¼Œæ¯”å¦‚ ['Normal', 'Flying']
            if (attacker.types.length === 1 && attacker.types[0] === targetType) {
                logs.push(`ä½†æ˜¯åœ¨ ${targetType} å±æ€§ä¸‹æ— æ³•å†å˜åŒ–äº†!`);
                return;
            }
            // ä¿®æ”¹å±æ€§
            attacker.types = [targetType];
            logs.push(`${attacker.cnName} çš„çº¹ç†å˜å¾—å’Œ ${firstMove.name} ä¸€æ ·äº†!`);
            logs.push(`<span style="color:#a855f7">âœ¦ å˜æˆäº† ${targetType} å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†è‡ªèº«å±æ€§å˜ä¸ºç¬¬ä¸€æ‹›å¼çš„å±æ€§'
    },
    // ã€é•œé¢å±æ€§ã€‘ï¼šå¤åˆ¶å¯¹æ‰‹çš„å±æ€§
    'Reflect Type': {
        onUse: (attacker, defender, logs) => {
            if (!defender.types || defender.types.length === 0) return;
            // å¤åˆ¶å±æ€§æ•°ç»„ï¼ˆä½¿ç”¨æ‰©å±•è¿ç®—ç¬¦ ... é˜²æ­¢å¼•ç”¨ä¼ é€’ï¼‰
            attacker.types = [...defender.types];
            const typeStr = attacker.types.join('/');
            logs.push(`${attacker.cnName} å¤åˆ¶äº†å¯¹æ‰‹çš„å±æ€§!`);
            logs.push(`<span style="color:#a855f7">âœ¦ å˜æˆäº† ${typeStr} å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†è‡ªèº«å±æ€§å˜ä¸ºå’Œç›®æ ‡ç›¸åŒ'
    },
    // ã€æµ¸æ°´ã€‘ï¼šæŠŠå¯¹æ‰‹å˜æˆçº¯æ°´ç³»
    'Soak': {
        onHit: (attacker, defender, damage, logs) => {
            // æ— æ³•å¯¹æ›¿èº«ç”Ÿæ•ˆï¼ˆç®€åŒ–å¤„ç†å¿½ç•¥æ›¿èº«ï¼‰ï¼Œæ— æ³•å¯¹é˜¿å°”å®™æ–¯/é“¶ä¼´æˆ˜å…½ç”Ÿæ•ˆ
            if (defender.ability === 'Multitype' || defender.ability === 'RKS System') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            // å·²ç»æ˜¯çº¯æ°´ç³»åˆ™å¤±è´¥
            if (defender.types && defender.types.length === 1 && defender.types[0] === 'Water') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            defender.types = ['Water'];
            logs.push(`${attacker.cnName} å‘å¯¹æ‰‹å–·å°„äº†ç‰¹æ®Šçš„æ°´!`);
            logs.push(`<span style="color:#3498db">âœ¦ ${defender.cnName} å˜æˆäº† æ°´ å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†ç›®æ ‡å˜ä¸ºæ°´å±æ€§'
    },
    // ã€é­”æ³•ç²‰ã€‘ï¼šæŠŠå¯¹æ‰‹å˜æˆçº¯è¶…èƒ½åŠ›ç³»
    'Magic Powder': {
        onHit: (attacker, defender, damage, logs) => {
            if (defender.ability === 'Multitype' || defender.ability === 'RKS System') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            // å·²ç»æ˜¯çº¯è¶…èƒ½åŠ›ç³»åˆ™å¤±è´¥
            if (defender.types && defender.types.length === 1 && defender.types[0] === 'Psychic') {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            // è‰ç³»å…ç–«ç²‰æœ«ç±»æ‹›å¼
            if (defender.types && defender.types.includes('Grass')) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†! (è‰ç³»å…ç–«ç²‰æœ«)`);
                return;
            }
            if (defender.ability === 'Overcoat') {
                logs.push(`${defender.cnName} çš„é˜²å°˜ç‰¹æ€§ä½¿å…¶å…ç–«äº†ç²‰æœ«!`);
                return;
            }
            defender.types = ['Psychic'];
            logs.push(`${attacker.cnName} æ’’ä¸‹äº†é­”æ³•ç²‰!`);
            logs.push(`<span style="color:#a855f7">âœ¦ ${defender.cnName} å˜æˆäº† è¶…èƒ½åŠ› å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'å°†ç›®æ ‡å˜ä¸ºè¶…èƒ½åŠ›å±æ€§'
    },
    // ã€ä¸‡åœ£å¤œã€‘ï¼šç»™å¯¹æ‰‹è¿½åŠ å¹½çµå±æ€§
    'Trick-or-Treat': {
        onHit: (attacker, defender, damage, logs) => {
            // å·²ç»æœ‰å¹½çµå±æ€§åˆ™å¤±è´¥
            if (defender.types && defender.types.includes('Ghost')) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            defender.types = [...(defender.types || ['Normal']), 'Ghost'];
            logs.push(`${attacker.cnName} é‚€è¯·å¯¹æ‰‹å‚åŠ ä¸‡åœ£å¤œæ´¾å¯¹!`);
            logs.push(`<span style="color:#9b59b6">âœ¦ ${defender.cnName} è¿½åŠ äº† å¹½çµ å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'ç»™ç›®æ ‡è¿½åŠ å¹½çµå±æ€§'
    },
    // ã€æ£®æ—è¯…å’’ã€‘ï¼šç»™å¯¹æ‰‹è¿½åŠ è‰å±æ€§
    "Forest's Curse": {
        onHit: (attacker, defender, damage, logs) => {
            // å·²ç»æœ‰è‰å±æ€§åˆ™å¤±è´¥
            if (defender.types && defender.types.includes('Grass')) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return;
            }
            defender.types = [...(defender.types || ['Normal']), 'Grass'];
            logs.push(`${attacker.cnName} æ–½åŠ äº†æ£®æ—çš„è¯…å’’!`);
            logs.push(`<span style="color:#27ae60">âœ¦ ${defender.cnName} è¿½åŠ äº† è‰ å±æ€§!</span>`);
            return { typeChange: true };
        },
        description: 'ç»™ç›®æ ‡è¿½åŠ è‰å±æ€§'
    },
    // ã€ç‡ƒå°½ã€‘ï¼šå¼ºåŠ›ç«ç³»æ”»å‡»ï¼Œä½¿ç”¨åå¤±å»ç«å±æ€§
    'Burn Up': {
        onHit: (attacker, defender, damage, logs) => {
            // ä¸æ˜¯ç«ç³»åˆ™å¤±è´¥ï¼ˆä¼¤å®³ä»ç„¶é€ æˆï¼Œä½†ä¸ä¼šå¤±å»å±æ€§ï¼‰
            if (!attacker.types || !attacker.types.includes('Fire')) {
                logs.push(`ä½†æ˜¯ ${attacker.cnName} ä¸æ˜¯ç«å±æ€§ï¼Œæ— æ³•ç‡ƒå°½!`);
                return { failed: true };
            }
            // ç§»é™¤ç«å±æ€§
            attacker.types = attacker.types.filter(t => t !== 'Fire');
            if (attacker.types.length === 0) {
                attacker.types = ['Normal']; // å˜æˆæ— å±æ€§ï¼ˆæ¸¸æˆä¸­æ˜¾ç¤ºä¸º???ï¼Œè¿™é‡Œç®€åŒ–ä¸ºNormalï¼‰
            }
            logs.push(`<span style="color:#e74c3c">ğŸ”¥ ${attacker.cnName} ç‡ƒçƒ§æ®†å°½ï¼Œå¤±å»äº†ç«å±æ€§!</span>`);
            return { typeChange: true, lostType: 'Fire' };
        },
        description: 'å¼ºåŠ›ç«ç³»æ”»å‡»ï¼Œä½¿ç”¨åå¤±å»ç«å±æ€§'
    },
    // ã€ç”µå…‰åŒå‡»ã€‘ï¼šå¼ºåŠ›ç”µç³»æ”»å‡»ï¼Œä½¿ç”¨åå¤±å»ç”µå±æ€§
    'Double Shock': {
        onHit: (attacker, defender, damage, logs) => {
            // ä¸æ˜¯ç”µç³»åˆ™å¤±è´¥
            if (!attacker.types || !attacker.types.includes('Electric')) {
                logs.push(`ä½†æ˜¯ ${attacker.cnName} ä¸æ˜¯ç”µå±æ€§ï¼Œæ— æ³•é‡Šæ”¾ç”µå…‰åŒå‡»!`);
                return { failed: true };
            }
            // ç§»é™¤ç”µå±æ€§
            attacker.types = attacker.types.filter(t => t !== 'Electric');
            if (attacker.types.length === 0) {
                attacker.types = ['Normal'];
            }
            logs.push(`<span style="color:#f1c40f">âš¡ ${attacker.cnName} é‡Šæ”¾äº†å…¨éƒ¨ç”µåŠ›ï¼Œå¤±å»äº†ç”µå±æ€§!</span>`);
            return { typeChange: true, lostType: 'Electric' };
        },
        description: 'å¼ºåŠ›ç”µç³»æ”»å‡»ï¼Œä½¿ç”¨åå¤±å»ç”µå±æ€§'
    },
    // ============================================
    // 11. ç©¶ææŠ€èƒ½ï¼šå˜èº« (Transform)
    // ============================================
    'Transform': {
        onUse: (attacker, defender, logs) => {
            if (attacker.isTransformed) {
                logs.push(`ä½†æ˜¯ ${attacker.cnName} å·²ç»å˜èº«è¿‡äº†!`);
                return;
            }
            // 1. å¤åˆ¶å±æ€§
            attacker.types = [...defender.types];
            // 2. å¤åˆ¶èƒ½åŠ›å€¼ (é™¤HPå¤–)
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ç›´æ¥è¦†ç›– current statsã€‚
            // æ­£è§„é€»è¾‘åº”è¯¥å¤åˆ¶ baseStats ç„¶åé‡æ–°è®¡ç®—ï¼Œä½†ä¸ºäº†ç®€åŒ– RP æ•ˆæœï¼Œç›´æ¥å¤åˆ¶æ•°å€¼å³å¯ã€‚
            attacker.atk = defender.atk;
            attacker.def = defender.def;
            attacker.spa = defender.spa;
            attacker.spd = defender.spd;
            attacker.spe = defender.spe;
            // å¤åˆ¶èƒ½åŠ›ç­‰çº§ (Boosts)
            attacker.boosts = { ...defender.boosts };
            // 3. å¤åˆ¶æŠ€èƒ½ (ç®€åŒ–ï¼šç›´æ¥å¼•ç”¨å¯¹è±¡çš„æŠ€èƒ½æ•°ç»„ï¼ŒåŸæœ¬åº”è¯¥åªæœ‰5PPï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ— é™)
            // å¿…é¡»æ·±æ‹·è´æŠ€èƒ½æ•°ç»„ï¼Œå¦åˆ™ä¸€æ–¹æ¶ˆè€—PPä¼šå½±å“å¦ä¸€æ–¹ï¼ˆè™½ç„¶ç›®å‰æ²¡åšPPç³»ç»Ÿï¼‰
            attacker.moves = defender.moves.map(m => ({...m}));
            // 4. å¤åˆ¶ç‰¹æ€§
            attacker.ability = defender.ability;
            // 5. æ ‡è®°å˜èº«çŠ¶æ€ (é˜²æ­¢å¥—å¨ƒ)
            attacker.isTransformed = true;
            attacker.dittoOriginalName = attacker.cnName; // è®°ä½åŸå
            attacker.cnName = defender.cnName; // æ”¹å
            logs.push(`${attacker.dittoOriginalName} å˜èº«æˆäº† ${defender.cnName}!`);
            // å°è¯•æ›´æ–°å›¾ç‰‡ä¸ºå¯¹æ‰‹çš„å›¾ç‰‡ (è¿™æ˜¯ä¸€ä¸ªé«˜çº§è§†è§‰æ•ˆæœ)
            // æ³¨æ„ï¼šè¿™éœ€è¦å‰ç«¯ index.js æ”¯æŒï¼Œé€šè¿‡ id æŸ¥æ‰¾ DOM æ›´æ–° src
            if (typeof document !== 'undefined') {
                const playerSprite = document.getElementById('player-sprite');
                const enemySprite = document.getElementById('enemy-sprite');
                // ç®€å•çš„å›¾ç‰‡äº¤æ¢é€»è¾‘ï¼ˆä»…è§†è§‰ï¼‰
                if (playerSprite && enemySprite) {
                    // å¦‚æœæˆ‘æ˜¯ç©å®¶ï¼Œæˆ‘å˜èº«æˆæ•Œäºº
                    // è¿™ç§ç®€å•çš„ src å¤åˆ¶åœ¨ Showdown å›¾åº“ä¸‹æ˜¯æœ‰æ•ˆçš„ï¼ˆæ­£åé¢å¯èƒ½ä¸ä¸€è‡´ï¼Œä½†èƒ½çœ‹ï¼‰
                    // æ›´å¥½çš„åšæ³•æ˜¯å»è·å–å¯¹æ‰‹çš„æ­£åé¢ ID
                    /* è¿™é‡Œä¸åšå¤æ‚ DOM æ“ä½œï¼Œä»¥å…æŠ¥é”™ï¼Œä»…æ–‡å­—æç¤º */
                }
            }
            return { transform: true };
        },
        description: 'å˜èº«æˆå¯¹æ‰‹çš„æ ·å­'
    },
    // ============================================
    // å›å¤æŠ€èƒ½ (Recovery Moves)
    // ============================================
    'Recover': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Soft-Boiled': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Slack Off': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å·æ‡’æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%'
    },
    'Roost': {
        onHit: (attacker, defender, damage, logs) => {
            const healAmount = Math.floor(attacker.maxHp / 2);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é™è½ä¼‘æ¯æ¢å¤äº†ä½“åŠ›!`);
                // ç¾½æ –æ•ˆæœï¼šæœ¬å›åˆå¤±å»é£è¡Œå±æ€§ï¼ˆç®€åŒ–å¤„ç†ï¼Œä¸å®ç°ï¼‰
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤æœ€å¤§HPçš„50%ï¼Œæœ¬å›åˆå¤±å»é£è¡Œå±æ€§'
    },
    'Synthesis': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            // å¤©æ°”å½±å“
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é€šè¿‡å…‰åˆä½œç”¨æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    'Morning Sun': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ²æµ´æ™¨å…‰æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    'Moonlight': {
        onHit: (attacker, defender, damage, logs, battle) => {
            let healRatio = 0.5;
            if (battle) {
                if (battle.weather === 'sunnyday' || battle.weather === 'desolateland') {
                    healRatio = 2/3;
                } else if (battle.weather && battle.weather !== 'none') {
                    healRatio = 0.25;
                }
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} æ²æµ´æœˆå…‰æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ™´å¤©æ¢å¤æ›´å¤š'
    },
    // ============================================
    // èƒ½åŠ›å˜åŒ–æ¸…é™¤æŠ€èƒ½ (Stat Reset Moves)
    // ============================================
    'Haze': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // é‡ç½®åŒæ–¹æ‰€æœ‰èƒ½åŠ›å˜åŒ–
            const resetBoosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
            if (attacker.boosts) {
                attacker.boosts = { ...resetBoosts };
            }
            if (defender.boosts) {
                defender.boosts = { ...resetBoosts };
            }
            logs.push(`åœºä¸Šæ‰€æœ‰çš„èƒ½åŠ›å˜åŒ–ç”±äºé»‘é›¾éƒ½æ¶ˆå¤±äº†!`);
            return { haze: true };
        },
        description: 'æ¸…é™¤åœºä¸Šæ‰€æœ‰å®å¯æ¢¦çš„èƒ½åŠ›å˜åŒ–'
    },
    'Clear Smog': {
        onHit: (attacker, defender, damage, logs) => {
            // åªé‡ç½®å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–
            const resetBoosts = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 };
            if (defender.boosts) {
                defender.boosts = { ...resetBoosts };
            }
            logs.push(`${defender.cnName} çš„å¼ºåŒ–è¢«æ¸…é™¤ä¹‹çƒŸæŠµæ¶ˆäº†!`);
            return { clearSmog: true };
        },
        description: 'é€ æˆä¼¤å®³å¹¶æ¸…é™¤å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–'
    },
    // ã€æ¢åœº (Court Change)ã€‘äº¤æ¢åŒæ–¹åœºåœ°æ•ˆæœ - é—ªç„°ç‹ç‰Œä¸“å±
    'Court Change': {
        onHit: (attacker, defender, damage, logs, battle, isPlayer) => {
            if (!battle) return {};
            // ç¡®ä¿åœºåœ°å¯¹è±¡å­˜åœ¨
            if (!battle.playerSide) battle.playerSide = {};
            if (!battle.enemySide) battle.enemySide = {};
            const pSide = battle.playerSide;
            const eSide = battle.enemySide;
            // éœ€è¦äº¤æ¢çš„åœºåœ°æ•ˆæœ
            const fieldsToSwap = [
                // å…¥åœºå±å®³
                'spikes', 'toxicSpikes', 'stealthRock', 'stickyWeb',
                // å¢™/å±éšœ
                'auroraVeil', 'reflect', 'lightScreen',
                // é¡ºé£/é€†é£
                'tailwind',
                // G-Max DOT æ•ˆæœ
                'gmaxWildfire', 'gmaxCannonade', 'gmaxVineLash', 'gmaxVolcalith'
            ];
            let swapped = false;
            fieldsToSwap.forEach(key => {
                const temp = pSide[key];
                if (pSide[key] || eSide[key]) swapped = true;
                pSide[key] = eSide[key];
                eSide[key] = temp;
            });
            if (swapped) {
                logs.push(`ğŸ” <b>${attacker.cnName}</b> äº’æ¢äº†åŒæ–¹çš„åœºåœ°çŠ¶æ€ï¼(æ¢åœº)`);
            } else {
                logs.push(`${attacker.cnName} ä½¿ç”¨äº†æ¢åœºï¼Œä½†åœºä¸Šæ²¡æœ‰å¯äº¤æ¢çš„æ•ˆæœ...`);
            }
            // è§†è§‰æ›´æ–°
            if (typeof window !== 'undefined' && typeof window.updateAllVisuals === 'function') {
                window.updateAllVisuals();
            }
            return { courtChange: true };
        },
        description: 'äº’æ¢åŒæ–¹åœºåœ°çš„æ•ˆæœï¼ˆé’‰å­ã€å¢™ã€é¡ºé£ã€G-Max DOTï¼‰'
    },
    // ============================================
    // èƒ½åŠ›å˜åŒ–æ“æ§æŠ€èƒ½ (Stat Manipulation Moves)
    // ============================================
    'Topsy-Turvy': {
        onHit: (attacker, defender, damage, logs) => {
            // é¢ å€’å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–ï¼ˆ+3 å˜ -3ï¼Œ-1 å˜ +1ï¼‰
            const stats = ['atk', 'def', 'spa', 'spd', 'spe', 'accuracy', 'evasion'];
            let reversed = false;
            if (defender.boosts) {
                stats.forEach(key => {
                    if (defender.boosts[key] && defender.boosts[key] !== 0) {
                        defender.boosts[key] *= -1;
                        reversed = true;
                    }
                });
            }
            if (reversed) {
                logs.push(`${defender.cnName} çš„èƒ½åŠ›å˜åŒ–è¢«å®Œå…¨é¢ å€’äº†!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { topsyTurvy: true };
        },
        description: 'å°†å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–æ•°å€¼åè½¬'
    },
    'Spectral Thief': {
        onHit: (attacker, defender, damage, logs) => {
            // å·å–å¯¹æ‰‹çš„æ­£é¢èƒ½åŠ›å˜åŒ–
            const stats = ['atk', 'def', 'spa', 'spd', 'spe', 'accuracy', 'evasion'];
            let stolen = false;
            if (defender.boosts && attacker.boosts) {
                stats.forEach(key => {
                    if (defender.boosts[key] && defender.boosts[key] > 0) {
                        // è‡ªå·±åŠ ä¸Šå¯¹æ‰‹çš„å¢ç›Š
                        attacker.boosts[key] = Math.min(6, (attacker.boosts[key] || 0) + defender.boosts[key]);
                        // å¯¹æ‰‹æ¸…é›¶
                        defender.boosts[key] = 0;
                        stolen = true;
                    }
                });
            }
            if (stolen) {
                logs.push(`${attacker.cnName} å¤ºå–äº†å¯¹æ‰‹çš„å¼ºåŒ–èƒ½åŠ›!`);
            }
            return { spectralThief: true };
        },
        description: 'å·å–å¯¹æ‰‹çš„æ­£é¢èƒ½åŠ›å˜åŒ–åé€ æˆä¼¤å®³'
    },
    'Psych Up': {
        onHit: (attacker, defender, damage, logs) => {
            // å¤åˆ¶å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–
            if (defender.boosts) {
                attacker.boosts = { ...defender.boosts };
                logs.push(`${attacker.cnName} å¤åˆ¶äº† ${defender.cnName} çš„èƒ½åŠ›å˜åŒ–!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { psychUp: true };
        },
        description: 'å¤åˆ¶å¯¹æ‰‹çš„èƒ½åŠ›å˜åŒ–è¦†ç›–è‡ªå·±'
    },
    'Heart Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const temp = { ...attacker.boosts };
                attacker.boosts = { ...defender.boosts };
                defender.boosts = temp;
                logs.push(`${attacker.cnName} å’Œ ${defender.cnName} çš„èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { heartSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„èƒ½åŠ›å˜åŒ–'
    },
    'Power Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const tempAtk = attacker.boosts.atk || 0;
                const tempSpa = attacker.boosts.spa || 0;
                attacker.boosts.atk = defender.boosts.atk || 0;
                attacker.boosts.spa = defender.boosts.spa || 0;
                defender.boosts.atk = tempAtk;
                defender.boosts.spa = tempSpa;
                logs.push(`åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { powerSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„æ”»å‡»å’Œç‰¹æ”»èƒ½åŠ›å˜åŒ–'
    },
    'Guard Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–
            if (attacker.boosts && defender.boosts) {
                const tempDef = attacker.boosts.def || 0;
                const tempSpd = attacker.boosts.spd || 0;
                attacker.boosts.def = defender.boosts.def || 0;
                attacker.boosts.spd = defender.boosts.spd || 0;
                defender.boosts.def = tempDef;
                defender.boosts.spd = tempSpd;
                logs.push(`åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–äº’æ¢äº†!`);
            }
            return { guardSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„é˜²å¾¡å’Œç‰¹é˜²èƒ½åŠ›å˜åŒ–'
    },
    'Speed Swap': {
        onHit: (attacker, defender, damage, logs) => {
            // äº¤æ¢åŒæ–¹çš„å®é™…é€Ÿåº¦å€¼
            const tempSpe = attacker.spe;
            attacker.spe = defender.spe;
            defender.spe = tempSpe;
            logs.push(`${attacker.cnName} å’Œ ${defender.cnName} çš„é€Ÿåº¦äº’æ¢äº†!`);
            return { speedSwap: true };
        },
        description: 'äº¤æ¢åŒæ–¹çš„å®é™…é€Ÿåº¦å€¼'
    },
    // ============================================
    // çŠ¶æ€æ²»ç–—æŠ€èƒ½ (Status Healing Moves)
    // ============================================
    'Aromatherapy': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€ï¼ˆç®€åŒ–ï¼šåªæ²»æ„ˆè‡ªå·±ï¼‰
            let cured = false;
            if (attacker.status) {
                attacker.status = null;
                attacker.statusTurns = 0;
                cured = true;
            }
            // å°è¯•æ²»æ„ˆé˜Ÿå‹ï¼ˆå¦‚æœæœ‰ battle å¯¹è±¡ï¼‰
            if (battle && battle.playerParty) {
                battle.playerParty.forEach(pm => {
                    if (pm && pm.status && pm.isAlive && pm.isAlive()) {
                        pm.status = null;
                        pm.statusTurns = 0;
                        cured = true;
                    }
                });
            }
            if (cured) {
                logs.push(`èŠ³é¦™æ²»ç–—çš„é¦™æ°”æ²»æ„ˆäº†å¼‚å¸¸çŠ¶æ€!`);
            } else {
                logs.push(`èŠ³é¦™å››æº¢... ä½†å¥½åƒæ²¡ä»€ä¹ˆæ•ˆæœã€‚`);
            }
            return { aromatherapy: true };
        },
        description: 'æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€'
    },
    'Heal Bell': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€ï¼ˆç®€åŒ–ï¼šåªæ²»æ„ˆè‡ªå·±ï¼‰
            let cured = false;
            if (attacker.status) {
                attacker.status = null;
                attacker.statusTurns = 0;
                cured = true;
            }
            // å°è¯•æ²»æ„ˆé˜Ÿå‹
            if (battle && battle.playerParty) {
                battle.playerParty.forEach(pm => {
                    if (pm && pm.status && pm.isAlive && pm.isAlive()) {
                        pm.status = null;
                        pm.statusTurns = 0;
                        cured = true;
                    }
                });
            }
            if (cured) {
                logs.push(`æ²»æ„ˆé“ƒå£°å›è¡ï¼Œå¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
            } else {
                logs.push(`é“ƒå£°å›è¡... ä½†å¥½åƒæ²¡ä»€ä¹ˆæ•ˆæœã€‚`);
            }
            return { healBell: true };
        },
        description: 'æ²»æ„ˆå·±æ–¹å…¨é˜Ÿçš„å¼‚å¸¸çŠ¶æ€'
    },
    'Refresh': {
        onHit: (attacker, defender, damage, logs) => {
            // æ²»æ„ˆè‡ªå·±çš„ä¸­æ¯’ã€éº»ç—¹ã€ç¼ä¼¤
            const curableStatus = ['psn', 'tox', 'par', 'brn'];
            if (attacker.status && curableStatus.includes(attacker.status)) {
                attacker.status = null;
                attacker.statusTurns = 0;
                logs.push(`${attacker.cnName} çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
            } else {
                logs.push(`ä½†æ˜¯æ²¡æœ‰æ•ˆæœ...`);
            }
            return { refresh: true };
        },
        description: 'æ²»æ„ˆè‡ªå·±çš„ä¸­æ¯’ã€éº»ç—¹ã€ç¼ä¼¤'
    },
    'Purify': {
        onHit: (attacker, defender, damage, logs) => {
            // æ²»æ„ˆå¯¹æ‰‹çš„å¼‚å¸¸çŠ¶æ€ï¼Œè‡ªå·±å›å¤50%HP
            if (defender.status) {
                defender.status = null;
                defender.statusTurns = 0;
                logs.push(`${defender.cnName} çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†!`);
                // è‡ªå·±å›å¤HP
                const healAmount = Math.floor(attacker.maxHp / 2);
                const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
                if (actualHeal > 0) {
                    attacker.currHp += actualHeal;
                    logs.push(`${attacker.cnName} æ¢å¤äº†ä½“åŠ›!`);
                }
            } else {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
            }
            return { purify: true };
        },
        description: 'æ²»æ„ˆå¯¹æ‰‹çš„å¼‚å¸¸çŠ¶æ€ï¼Œè‡ªå·±å›å¤50%HP'
    },
    // ============================================
    // ç‰¹æ®Šå›å¤æŠ€èƒ½ (Special Recovery Moves)
    // ============================================
    'Rest': {
        onHit: (attacker, defender, damage, logs) => {
            // å®Œå…¨å›å¤HPï¼Œä½†é™·å…¥ç¡çœ 2å›åˆ
            if (attacker.currHp >= attacker.maxHp) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†!`);
                return { rest: false };
            }
            attacker.currHp = attacker.maxHp;
            attacker.status = 'slp';
            attacker.statusTurns = 0;
            // ç¡çœ å›åˆæ•°ï¼ˆRest å›ºå®šç¡2å›åˆï¼Œç¬¬3å›åˆé†’æ¥ï¼‰
            attacker.sleepTurns = 3;
            logs.push(`${attacker.cnName} ç¡ç€äº†å¹¶æ¢å¤äº†å…¨éƒ¨ä½“åŠ›!`);
            return { rest: true };
        },
        description: 'å®Œå…¨å›å¤HPï¼Œä½†é™·å…¥ç¡çœ 2å›åˆ'
    },
    'Wish': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // ä¸‹å›åˆç»“æŸæ—¶å›å¤50%HPï¼ˆç®€åŒ–ï¼šç«‹å³å›å¤ï¼‰
            // å®Œæ•´å®ç°éœ€è¦å»¶è¿Ÿæ•ˆæœç³»ç»Ÿ
            if (battle) {
                battle.wishPending = {
                    target: 'player',
                    amount: Math.floor(attacker.maxHp / 2),
                    turnsLeft: 1
                };
            }
            logs.push(`${attacker.cnName} è®¸ä¸‹äº†æ„¿æœ›!`);
            return { wish: true };
        },
        description: 'ä¸‹å›åˆç»“æŸæ—¶å›å¤50%HP'
    },
    'Healing Wish': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦
            attacker.currHp = 0;
            if (battle) {
                battle.healingWishPending = true;
            }
            logs.push(`${attacker.cnName} ç‰ºç‰²è‡ªå·±è®¸ä¸‹äº†æ²»æ„ˆä¹‹æ„¿!`);
            return { healingWish: true, selfKO: true };
        },
        description: 'è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦'
    },
    'Lunar Dance': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦ï¼ˆåŒ…æ‹¬PPï¼‰
            attacker.currHp = 0;
            if (battle) {
                battle.lunarDancePending = true;
            }
            logs.push(`${attacker.cnName} è·³èµ·äº†æ–°æœˆä¹‹èˆ!`);
            return { lunarDance: true, selfKO: true };
        },
        description: 'è‡ªå·±å€’ä¸‹ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦'
    },
    'Shore Up': {
        onHit: (attacker, defender, damage, logs, battle) => {
            // æ²™æš´å¤©æ°”ä¸‹å›å¤2/3ï¼Œå¦åˆ™å›å¤1/2
            let healRatio = 0.5;
            if (battle && battle.weather === 'sandstorm') {
                healRatio = 2/3;
            }
            const healAmount = Math.floor(attacker.maxHp * healRatio);
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} é›†æ²™æ¢å¤äº†ä½“åŠ›!`);
            } else {
                logs.push(`${attacker.cnName} çš„ä½“åŠ›å·²æ»¡!`);
            }
            return { heal: actualHeal };
        },
        description: 'æ¢å¤HPï¼Œæ²™æš´å¤©æ°”ä¸‹æ¢å¤æ›´å¤š'
    },
    'Strength Sap': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ç­‰äºå¯¹æ‰‹æ”»å‡»åŠ›çš„HPï¼Œå¹¶é™ä½å¯¹æ‰‹æ”»å‡»
            const healAmount = defender.atk;
            const actualHeal = Math.min(healAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº† ${defender.cnName} çš„åŠ›é‡!`);
            }
            // é™ä½å¯¹æ‰‹æ”»å‡»
            if (defender.boosts) {
                const oldAtk = defender.boosts.atk || 0;
                defender.boosts.atk = Math.max(-6, oldAtk - 1);
                if (oldAtk > -6) {
                    logs.push(`${defender.cnName} çš„æ”»å‡»ä¸‹é™äº†!`);
                }
            }
            return { strengthSap: true };
        },
        description: 'å›å¤ç­‰äºå¯¹æ‰‹æ”»å‡»åŠ›çš„HPï¼Œå¹¶é™ä½å¯¹æ‰‹æ”»å‡»'
    },
    'Leech Seed': {
        onHit: (attacker, defender, damage, logs) => {
            // ç§ä¸‹å¯„ç”Ÿç§å­
            if (defender.types && defender.types.includes('Grass')) {
                logs.push(`å¯¹è‰å±æ€§å®å¯æ¢¦æ²¡æœ‰æ•ˆæœ!`);
                return { leechSeed: false };
            }
            if (!defender.volatile) defender.volatile = {};
            defender.volatile.leechSeed = true;
            logs.push(`${defender.cnName} è¢«ç§ä¸‹äº†å¯„ç”Ÿç§å­!`);
            return { leechSeed: true };
        },
        description: 'æ¯å›åˆå¸å–å¯¹æ‰‹1/8HP'
    },
    'Pain Split': {
        onHit: (attacker, defender, damage, logs) => {
            // å¹³åˆ†åŒæ–¹HP
            const totalHp = attacker.currHp + defender.currHp;
            const splitHp = Math.floor(totalHp / 2);
            attacker.currHp = Math.min(splitHp, attacker.maxHp);
            defender.currHp = Math.min(splitHp, defender.maxHp);
            logs.push(`åŒæ–¹å¹³åˆ†äº†ç—›è‹¦!`);
            return { painSplit: true };
        },
        description: 'å¹³åˆ†åŒæ–¹å½“å‰HP'
    },
    // ============================================
    // å¸è¡€/åä¼¤æŠ€èƒ½è¡¥å…… (Drain/Recoil Moves)
    // ============================================
    'Giga Drain': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Drain Punch': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Horn Leech': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Leech Life': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Oblivion Wing': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ä¼¤å®³çš„75%
            const drainAmount = Math.floor(damage * 0.75);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„75%'
    },
    'Draining Kiss': {
        onHit: (attacker, defender, damage, logs) => {
            // å›å¤ä¼¤å®³çš„75%
            const drainAmount = Math.floor(damage * 0.75);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„75%'
    },
    'Absorb': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Mega Drain': {
        onHit: (attacker, defender, damage, logs) => {
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} å¸å–äº†å¯¹æ‰‹çš„ä½“åŠ›!`);
            }
            return { drain: actualHeal };
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤ä¼¤å®³çš„50%'
    },
    'Dream Eater': {
        onHit: (attacker, defender, damage, logs) => {
            // åªå¯¹ç¡çœ çŠ¶æ€çš„å¯¹æ‰‹æœ‰æ•ˆï¼ˆä¼¤å®³è®¡ç®—å·²åœ¨åˆ«å¤„å¤„ç†ï¼‰
            const drainAmount = Math.floor(damage / 2);
            const actualHeal = Math.min(drainAmount, attacker.maxHp - attacker.currHp);
            if (actualHeal > 0) {
                attacker.currHp += actualHeal;
                logs.push(`${attacker.cnName} åƒæ‰äº†å¯¹æ‰‹çš„æ¢¦!`);
            }
            return { drain: actualHeal };
        },
        description: 'åƒæ‰ç¡çœ ä¸­å¯¹æ‰‹çš„æ¢¦ï¼Œå›å¤ä¼¤å®³çš„50%'
    },
    // ============================================
    // é“å…·äº¤æ¢æŠ€èƒ½ (Item Swap Moves)
    // ============================================
    'Trick': {
        onUse: (user, target, logs, battle) => {
            // æ£€æŸ¥åŒæ–¹é“å…·
            const userItem = user.item || null;
            const targetItem = target.item || null;
            // å¦‚æœåŒæ–¹éƒ½æ²¡æœ‰é“å…·ï¼ŒæŠ€èƒ½å¤±è´¥
            if (!userItem && !targetItem) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            const userItemId = userItem ? userItem.toLowerCase().replace(/[^a-z0-9]/g, '') : '';
            const targetItemId = targetItem ? targetItem.toLowerCase().replace(/[^a-z0-9]/g, '') : '';
            // ä½¿ç”¨ items-data.js çš„ isSwappable å‡½æ•°æ£€æŸ¥
            const checkSwappable = typeof isSwappable === 'function' ? isSwappable : (id) => {
                // Fallback: ç¡¬ç¼–ç æ£€æŸ¥
                const unswappableItems = [
                    'rustedsword', 'rustedshield', 'griseousorb', 'adamantorb', 'lustrousorb',
                    'souldew', 'lightball', 'thickclub', 'luckypunch', 'leek', 'stick', 'mail'
                ];
                if (unswappableItems.includes(id)) return false;
                if (id.endsWith('ite') && id !== 'eviolite') return false; // Mega çŸ³
                if (id.endsWith('iumz') || id.endsWith('iniumz')) return false; // Z æ°´æ™¶
                return true;
            };
            if (!checkSwappable(userItemId) || !checkSwappable(targetItemId)) {
                logs.push(`ä½†æ˜¯å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            // æ£€æŸ¥é»ç€ç‰¹æ€§
            if (target.ability === 'Sticky Hold') {
                logs.push(`${target.cnName} çš„é»ç€ç‰¹æ€§é˜»æ­¢äº†é“å…·äº¤æ¢ï¼`);
                return { failed: true };
            }
            // æ‰§è¡Œäº¤æ¢
            user.item = targetItem;
            target.item = userItem;
            // è®°å½•äº¤æ¢ï¼ˆç”¨äº AI åˆ¤æ–­é”æ‹›ï¼‰- ä½¿ç”¨ items-data.js çš„ isChoiceItem
            const checkChoice = typeof isChoiceItem === 'function' ? isChoiceItem : 
                (item) => item && (item.includes('Choice') || item.includes('è®²ç©¶'));
            if (checkChoice(targetItem)) {
                target.choiceLocked = true;
                target.choiceLockedMove = null;
            }
            if (checkChoice(userItem)) {
                user.choiceLocked = true;
                user.choiceLockedMove = null;
            }
            // ç”Ÿæˆæ—¥å¿— - å°è¯•è·å–ä¸­æ–‡å
            const getItemCnName = (item) => {
                if (!item) return 'æ— ';
                if (typeof getItem === 'function') {
                    const data = getItem(item);
                    if (data && data.cnName) return data.cnName;
                }
                return item;
            };
            const userItemName = getItemCnName(userItem);
            const targetItemName = getItemCnName(targetItem);
            logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} å’Œ ${target.cnName} äº¤æ¢äº†é“å…·ï¼</b>`);
            logs.push(`${user.cnName} è·å¾—äº† ${targetItemName}ï¼`);
            logs.push(`${target.cnName} è·å¾—äº† ${userItemName}ï¼`);
            console.log(`[TRICK] ${user.name}: ${userItem} -> ${targetItem}, ${target.name}: ${targetItem} -> ${userItem}`);
        },
        description: 'å’Œå¯¹æ‰‹äº¤æ¢æŒæœ‰çš„é“å…·'
    },
    'Switcheroo': {
        onUse: (user, target, logs, battle) => {
            // Switcheroo å’Œ Trick æ•ˆæœå®Œå…¨ç›¸åŒ
            const trickHandler = MoveHandlers['Trick'];
            if (trickHandler && trickHandler.onUse) {
                return trickHandler.onUse(user, target, logs, battle);
            }
        },
        description: 'å’Œå¯¹æ‰‹äº¤æ¢æŒæœ‰çš„é“å…·'
    },
    // ============================================
    // åœºåœ°çŠ¶æ€æŠ€èƒ½ (Field Condition Moves)
    // ============================================
    'Trick Room': {
        onUse: (user, target, logs, battle) => {
            console.log('[TRICK ROOM] onUse called, battle:', battle, 'field:', battle?.field);
            // å¦‚æœ battle æˆ– field ä¸å­˜åœ¨ï¼Œå°è¯•ä»å…¨å±€è·å–
            if (!battle) {
                battle = (typeof window !== 'undefined' && window.battle) ? window.battle : null;
                console.log('[TRICK ROOM] Using global battle:', battle);
            }
            if (!battle) {
                console.warn('[TRICK ROOM] No battle object available!');
                logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} æ‰­æ›²äº†æ—¶ç©ºï¼</b>`);
                logs.push(`<span style="color:#c084fc">æˆæ³•ç©ºé—´å±•å¼€ï¼é€Ÿåº¦æ…¢çš„å®å¯æ¢¦å°†å…ˆè¡ŒåŠ¨ï¼</span>`);
                return;
            }
            // ç¡®ä¿ field å¯¹è±¡å­˜åœ¨
            if (!battle.field) {
                battle.field = { trickRoom: 0 };
            }
            if (battle.field.trickRoom > 0) {
                // å·²ç»æœ‰ç©ºé—´ï¼Œå†ç”¨ä¼šå…³é—­
                battle.field.trickRoom = 0;
                logs.push(`${user.cnName} è®©æ‰­æ›²çš„æ—¶ç©ºæ¢å¤äº†æ­£å¸¸ï¼`);
                console.log('[TRICK ROOM] Closed! trickRoom =', battle.field.trickRoom);
            } else {
                // å¼€å¯ç©ºé—´ï¼ŒæŒç»­5å›åˆ
                battle.field.trickRoom = 5;
                logs.push(`<b style="color:#a855f7">âœ¦ ${user.cnName} æ‰­æ›²äº†æ—¶ç©ºï¼</b>`);
                logs.push(`<span style="color:#c084fc">æˆæ³•ç©ºé—´å±•å¼€ï¼é€Ÿåº¦æ…¢çš„å®å¯æ¢¦å°†å…ˆè¡ŒåŠ¨ï¼</span>`);
                console.log('[TRICK ROOM] Opened! trickRoom =', battle.field.trickRoom);
            }
        },
        priority: -7,
        description: '5å›åˆå†…é€Ÿåº¦æ…¢çš„å…ˆåŠ¨'
    },
    // ã€å·²ç§»é™¤ã€‘Tailwind ç”± MoveEffects.applySideCondition ç»Ÿä¸€å¤„ç†
    // é¿å…é‡å¤å¤„ç†å¯¼è‡´"æˆåŠŸååˆæ˜¾ç¤ºå¤±è´¥"çš„ Bug
    'Reflect': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            if (side.reflect > 0) {
                logs.push(`åå°„å£å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.reflect = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#f97316">ğŸ›¡ï¸ ${sideText}å»ºèµ·äº†åå°„å£ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰©ç†ä¼¤å®³å‡åŠ'
    },
    'Light Screen': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            if (side.lightScreen > 0) {
                logs.push(`å…‰å¢™å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.lightScreen = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#facc15">âœ¨ ${sideText}å»ºèµ·äº†å…‰å¢™ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰¹æ®Šä¼¤å®³å‡åŠ'
    },
    'Aurora Veil': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return;
            const side = isPlayer ? battle.playerSide : battle.enemySide;
            if (!side) return;
            // æå…‰å¹•éœ€è¦å†°é›¹/é›ªå¤©æ°”
            // ç®€åŒ–ï¼šæš‚æ—¶ä¸æ£€æŸ¥å¤©æ°”ï¼Œç›´æ¥å…è®¸ä½¿ç”¨
            if (side.auroraVeil > 0) {
                logs.push(`æå…‰å¹•å·²ç»å­˜åœ¨ï¼`);
                return { failed: true };
            }
            // å…‰ä¹‹é»åœŸå»¶é•¿åˆ°8å›åˆ - ä½¿ç”¨ items-data.js çš„ ItemEffects
            const screenDuration = (typeof ItemEffects !== 'undefined' && ItemEffects.getScreenDuration) 
                ? ItemEffects.getScreenDuration(user) 
                : ((user.item || '').toLowerCase().includes('lightclay') ? 8 : 5);
            side.auroraVeil = screenDuration;
            const sideText = isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹';
            logs.push(`<b style="color:#22d3ee">â„ï¸ ${sideText}å±•å¼€äº†æå…‰å¹•ï¼</b>`);
        },
        description: '5å›åˆå†…ç‰©ç†å’Œç‰¹æ®Šä¼¤å®³éƒ½å‡åŠ'
    },
    // ============================================
    // åå¼¹æŠ€èƒ½ (Counter / Mirror Coat)
    // ============================================
    // è¿™ä¸¤ä¸ªæŠ€èƒ½éœ€è¦æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ç±»å‹
    // Counter: åå¼¹ç‰©ç†ä¼¤å®³çš„ä¸¤å€
    // Mirror Coat: åå¼¹ç‰¹æ®Šä¼¤å®³çš„ä¸¤å€
    'Counter': {
        // æ ‡è®°ä¸ºåå¼¹æŠ€èƒ½ï¼Œä¸æ˜¯æ™®é€šå˜åŒ–æŠ€
        isReflectMove: true,
        reflectCategory: 'physical',
        damageCallback: (attacker, defender) => {
            // æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0; // æ²¡å—ä¼¤ï¼Œåå¼¹å¤±è´¥
            }
            // å¿…é¡»æ˜¯ç‰©ç†ä¼¤å®³
            const cat = takenDamage.category || '';
            if (cat !== 'physical' && cat !== 'phys') {
                return 0; // ç±»å‹ä¸å¯¹
            }
            // åŒå€è¿”è¿˜
            return takenDamage.amount * 2;
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            const cat = takenDamage.category || '';
            if (cat !== 'physical' && cat !== 'phys') {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æ²¡æœ‰å—åˆ°ç‰©ç†æ”»å‡»)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#c0392b">ğŸ’¥ ${user.cnName} å°†ç‰©ç†ä¼¤å®³åŒå€å¥‰è¿˜ï¼</b>`);
            return { damage: takenDamage.amount * 2 };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ç‰©ç†ä¼¤å®³åŒå€è¿”è¿˜'
    },
    'Mirror Coat': {
        // æ ‡è®°ä¸ºåå¼¹æŠ€èƒ½ï¼Œä¸æ˜¯æ™®é€šå˜åŒ–æŠ€
        isReflectMove: true,
        reflectCategory: 'special',
        damageCallback: (attacker, defender) => {
            // æ£€æŸ¥æœ¬å›åˆå—åˆ°çš„ä¼¤å®³
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0; // æ²¡å—ä¼¤ï¼Œåå¼¹å¤±è´¥
            }
            // å¿…é¡»æ˜¯ç‰¹æ®Šä¼¤å®³
            const cat = takenDamage.category || '';
            if (cat !== 'special' && cat !== 'spec') {
                return 0; // ç±»å‹ä¸å¯¹
            }
            // åŒå€è¿”è¿˜
            return takenDamage.amount * 2;
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            const cat = takenDamage.category || '';
            if (cat !== 'special' && cat !== 'spec') {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æ²¡æœ‰å—åˆ°ç‰¹æ®Šæ”»å‡»)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#9b59b6">âœ¨ ${user.cnName} å°†ç‰¹æ®Šä¼¤å®³åŒå€å¥‰è¿˜ï¼</b>`);
            return { damage: takenDamage.amount * 2 };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ç‰¹æ®Šä¼¤å®³åŒå€è¿”è¿˜'
    },
    // Metal Burst: åå¼¹æœ€åå—åˆ°ä¼¤å®³çš„ 1.5 å€ï¼ˆä¸åˆ†ç‰©ç†ç‰¹æ®Šï¼‰
    'Metal Burst': {
        isReflectMove: true,
        reflectCategory: 'any',
        damageCallback: (attacker, defender) => {
            const takenDamage = attacker.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                return 0;
            }
            // 1.5 å€è¿”è¿˜
            return Math.floor(takenDamage.amount * 1.5);
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            const takenDamage = user.turnData?.lastDamageTaken;
            if (!takenDamage || takenDamage.amount <= 0) {
                logs.push(`<b style="color:#888">ä½†æ˜¯å¤±è´¥äº†ï¼(æœ¬å›åˆæ²¡æœ‰å—åˆ°ä¼¤å®³)</b>`);
                return { failed: true };
            }
            logs.push(`<b style="color:#7f8c8d">âš”ï¸ ${user.cnName} ä»¥é‡‘å±çˆ†å‘åå‡»ï¼</b>`);
            return { damage: Math.floor(takenDamage.amount * 1.5) };
        },
        description: 'å°†æœ¬å›åˆå—åˆ°çš„ä¼¤å®³ 1.5 å€è¿”è¿˜'
    },
    // ============================================
    // å¤ªæ™¶çˆ†å‘ (Tera Blast) - æ˜Ÿæ™¶ç‰¹æ®Šæ•ˆæœ
    // ============================================
    'Tera Blast': {
        onHit: (attacker, defender, damage, logs) => {
            // åªæœ‰åœ¨æ˜Ÿæ™¶å¤ªæ™¶åŒ–çŠ¶æ€ä¸‹æ‰æœ‰å‰¯ä½œç”¨
            if (attacker.isTerastallized && attacker.teraType === 'Stellar') {
                if (typeof attacker.applyBoost === 'function') {
                    attacker.applyBoost('atk', -1);
                    attacker.applyBoost('spa', -1);
                    logs.push(`<span style="color:#d400ff">âœ¦ å› ä¸ºè¿™è‚¡èƒ½é‡è¿‡äºåºå¤§ï¼Œ${attacker.cnName} çš„æ”»å‡»å’Œç‰¹æ”»ä¸‹é™äº†! (æ˜Ÿæ™¶åå™¬)</span>`);
                    if (typeof window.playSFX === 'function') window.playSFX('STAT_DOWN');
                }
            }
            return {};
        },
        description: 'å¤ªæ™¶åŒ–æ—¶æ”¹å˜å±æ€§ã€‚è‹¥æ˜¯æ˜Ÿæ™¶å±æ€§ï¼Œå¨åŠ›å¼ºå¤§ä½†ä¼šé™ä½åŒæ”»ã€‚'
    },
    // ============================================
    // ç”Ÿå‘½ç½®æ¢ç³»ç»Ÿ (HP Cost Mechanics)
    // ============================================
    // ã€è…¹é¼“ã€‘æ¶ˆè€—50%HPï¼Œæ”»å‡»ç›´æ¥+6
    'Belly Drum': {
        onUse: (user, target, logs) => {
            const cost = Math.floor(user.maxHp / 2);
            // å¤±è´¥åˆ¤å®šï¼šè¡€é‡ä¸è¶³ 50%
            if (user.currHp <= cost) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(ä½“åŠ›ä¸è¶³)</b>`);
                return { failed: true };
            }
            // å¤±è´¥åˆ¤å®šï¼šæ”»å‡»ç­‰çº§å·²æ»¡ (+6)
            if (!user.boosts) user.boosts = {};
            if (user.boosts.atk >= 6) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(æ”»å‡»å·²ç»åˆ°äº†æé™)</b>`);
                return { failed: true };
            }
            // æ‰§è¡Œæ•ˆæœï¼šæ‰£è¡€
            user.takeDamage(cost);
            // å¼ºåˆ¶å°†æ”»å‡»ç­‰çº§è®¾ä¸º +6
            user.boosts.atk = 6;
            logs.push(`<b style="color:#e74c3c">ğŸ¥ ${user.cnName} å‰Šå‡äº†ä½“åŠ›ï¼Œæ•²å“è…¹é¼“ï¼Œå°†æ”»å‡»æå‡åˆ°äº†æç‚¹ï¼(Atk MAX)</b>`);
            if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            // ã€ä¿®å¤ã€‘å¼ºåˆ¶è§¦å‘ä¸€æ¬¡ HP é˜ˆå€¼ç±»é“å…·æ£€æŸ¥ (æ–‡æŸšæœ/æ··ä¹±æœç­‰)
            if (user.item) {
                const itemId = user.item.toLowerCase().replace(/[^a-z0-9]/g, '');
                const hpPercent = user.currHp / user.maxHp;
                // æ–‡æŸšæœ: HP <= 50% æ—¶å›å¤ 25%
                if (itemId === 'sitrusberry' && hpPercent <= 0.5) {
                    const heal = Math.floor(user.maxHp * 0.25);
                    user.currHp = Math.min(user.maxHp, user.currHp + heal);
                    user.item = null;
                    logs.push(`<span style="color:#27ae60">ğŸŠ ${user.cnName} åƒæ‰äº†æ–‡æŸšæœï¼Œå›å¤äº† ${heal} ç‚¹ä½“åŠ›ï¼</span>`);
                    if (typeof window.playSFX === 'function') window.playSFX('HEAL');
                }
                // æ··ä¹±æœç³»åˆ— (å‹¿èŠ±æœ/å¼‚å¥‡æœ/èŠ’èŠ’æœ/èŠ­äºšæœ/ä¹èŠ­æœ): HP <= 25% æ—¶å›å¤ 33%
                // è´ªåƒé¬¼ç‰¹æ€§: è§¦å‘çº¿æå‡åˆ° 50%
                const confuseBerries = ['figyberry', 'wikiberry', 'magoberry', 'aguavberry', 'iapapaberry'];
                const isGluttony = user.ability && user.ability.toLowerCase().replace(/[^a-z]/g, '') === 'gluttony';
                const confuseTrigger = isGluttony ? 0.5 : 0.25;
                if (confuseBerries.includes(itemId) && hpPercent <= confuseTrigger) {
                    const heal = Math.floor(user.maxHp / 3);
                    user.currHp = Math.min(user.maxHp, user.currHp + heal);
                    const berryName = user.item;
                    user.item = null;
                    logs.push(`<span style="color:#27ae60">ğŸ‡ ${user.cnName} åƒæ‰äº†${berryName}ï¼Œå›å¤äº† ${heal} ç‚¹ä½“åŠ›ï¼</span>`);
                    if (typeof window.playSFX === 'function') window.playSFX('HEAL');
                    // TODO: æ€§æ ¼ä¸åˆæ—¶æ··ä¹±åˆ¤å®š
                }
            }
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return { bellyDrum: true, success: true };
        },
        description: 'æ¶ˆè€—æœ€å¤§HPçš„ä¸€åŠï¼Œå°†æ”»å‡»åŠ›æå‡è‡³æœ€å¤§(+6)'
    },
    // ã€ç”©è‚‰/è½»èº«ã€‘æ¶ˆè€—50%HPï¼Œæ”»/ç‰¹æ”»/é€Ÿåº¦+2
    'Fillet Away': {
        onUse: (user, target, logs) => {
            const cost = Math.floor(user.maxHp / 2);
            if (user.currHp <= cost) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(ä½“åŠ›ä¸è¶³ä»¥ç”©æ‰è‚‰èº«)</b>`);
                return { failed: true };
            }
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èƒ½åŠ›éƒ½å·²æ»¡çº§
            if (!user.boosts) user.boosts = {};
            if (user.boosts.atk >= 6 && user.boosts.spa >= 6 && user.boosts.spe >= 6) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(èƒ½åŠ›å·²ç»åˆ°äº†æé™)</b>`);
                return { failed: true };
            }
            user.takeDamage(cost);
            logs.push(`<b style="color:#e91e63">ğŸ”ª ${user.cnName} å‰Šå‡äº†è‡ªå·±çš„ä½“åŠ›ï¼Œèº«ä½“å˜å¾—è½»ç›ˆäº†ï¼</b>`);
            if (typeof user.applyBoost === 'function') {
                user.applyBoost('atk', 2);
                user.applyBoost('spa', 2);
                user.applyBoost('spe', 2);
            }
            if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return { success: true };
        },
        description: 'æ¶ˆè€—50%ä½“åŠ›ï¼Œå¤§å¹…æå‡æ”»å‡»/ç‰¹æ”»/é€Ÿåº¦(+2)'
    },
    // ã€é­‚èˆçƒˆéŸ³çˆ†ã€‘æ¶ˆè€—33%HPï¼Œå…¨å±æ€§+1
    'Clangorous Soul': {
        onUse: (user, target, logs) => {
            const cost = Math.floor(user.maxHp / 3);
            if (user.currHp <= cost) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(ä½“åŠ›ä¸è¶³ä»¥å‘å‡ºå¼å«)</b>`);
                return { failed: true };
            }
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èƒ½åŠ›éƒ½å·²æ»¡çº§
            if (!user.boosts) user.boosts = {};
            const allMaxed = ['atk', 'def', 'spa', 'spd', 'spe'].every(s => (user.boosts[s] || 0) >= 6);
            if (allMaxed) {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(èƒ½åŠ›å·²ç»åˆ°äº†æé™)</b>`);
                return { failed: true };
            }
            user.takeDamage(cost);
            logs.push(`<b style="color:#f1c40f">ğŸ‰ ${user.cnName} è·³èµ·äº†æˆ˜èˆï¼Œæµ‘èº«å……æ»¡åŠ›é‡ï¼</b>`);
            ['atk', 'def', 'spa', 'spd', 'spe'].forEach(stat => {
                if (typeof user.applyBoost === 'function') user.applyBoost(stat, 1);
            });
            if (typeof window.playSFX === 'function') window.playSFX('STAT_UP');
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return { success: true };
        },
        description: 'æ¶ˆè€—1/3ä½“åŠ›ï¼Œå…¨å±æ€§æå‡(+1)'
    },
    // ã€æƒŠçˆ†å¤§å¤´ã€‘å¨åŠ›150ç«ç³»ç‰¹æ®Šï¼Œä½¿ç”¨åè‡ªæŸ50%æœ€å¤§HP
    'Mind Blown': {
        onHit: (attacker, defender, damage, logs) => {
            const recoil = Math.ceil(attacker.maxHp / 2);
            attacker.takeDamage(recoil);
            logs.push(`<span style="color:#e11d48">ğŸ’¥ ${attacker.cnName} çš„å¤´ç‚¸è£‚äº†ï¼å—åˆ°äº† ${recoil} ç‚¹åä½œç”¨ä¼¤å®³ï¼</span>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return {};
        },
        description: 'å¨åŠ›150ç«ç³»ç‰¹æ®Šï¼Œä½¿ç”¨åè‡ªæŸ50%æœ€å¤§HP'
    },
    // ã€é“è¹„å…‰çº¿ã€‘å¨åŠ›140é’¢ç³»ç‰¹æ®Šï¼Œä½¿ç”¨åè‡ªæŸ50%æœ€å¤§HP
    'Steel Beam': {
        onHit: (attacker, defender, damage, logs) => {
            const recoil = Math.ceil(attacker.maxHp / 2);
            attacker.takeDamage(recoil);
            logs.push(`<span style="color:#95a5a6">âš¡ ${attacker.cnName} æµ‘èº«å°„å‡ºäº†å…‰èŠ’ï¼å—åˆ°äº† ${recoil} ç‚¹åä½œç”¨ä¼¤å®³ï¼</span>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return {};
        },
        description: 'å¨åŠ›140é’¢ç³»ç‰¹æ®Šï¼Œä½¿ç”¨åè‡ªæŸ50%æœ€å¤§HP'
    },
    // ============================================
    // è¯…å’’ (Curse) - å¹½çµ/éå¹½çµåŒæ¨¡å¼
    // ============================================
    'Curse': {
        onUse: (user, target, logs) => {
            const isGhost = user.types && user.types.includes('Ghost');
            if (isGhost) {
                // å¹½çµç³»ï¼šæ‰£50%è¡€ï¼Œè®©å¯¹æ‰‹æ¯å›åˆæ‰1/4
                const cost = Math.floor(user.maxHp / 2);
                if (user.currHp <= cost) {
                    logs.push(`<b style="color:#7c3aed">ä½†æ˜¯æ²¡æ³•å†å‰Šå‡ä½“åŠ›äº†...</b>`);
                    return { failed: true };
                }
                user.takeDamage(cost);
                logs.push(`<b style="color:#7c3aed">ğŸ‘» ${user.cnName} å‰Šå‡ä½“åŠ›è¯…å’’äº† ${target.cnName}ï¼</b>`);
                // ç»™å¯¹æ‰‹æ–½åŠ è¯…å’’çŠ¶æ€
                if (!target.volatile) target.volatile = {};
                target.volatile.curse = true;
                if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
                return { success: true, ghostCurse: true };
            } else {
                // éå¹½çµç³»ï¼šé€Ÿåº¦-1ï¼Œæ”»é˜²+1 (ç™½è¯…å’’)
                if (!user.boosts) user.boosts = {};
                // æ£€æŸ¥æ”»é˜²æ˜¯å¦éƒ½å·²æ»¡çº§
                if ((user.boosts.atk || 0) >= 6 && (user.boosts.def || 0) >= 6) {
                    logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼(èƒ½åŠ›å·²ç»åˆ°äº†æé™)</b>`);
                    return { failed: true };
                }
                if (typeof user.applyBoost === 'function') {
                    user.applyBoost('spe', -1);
                    user.applyBoost('atk', 1);
                    user.applyBoost('def', 1);
                }
                logs.push(`${user.cnName} çš„é€Ÿåº¦é™ä½ï¼Œä½†è‚Œè‚‰è†¨èƒ€äº†ï¼(æ”»é˜²æå‡)`);
                return { success: true, whiteCurse: true };
            }
        },
        description: 'å¹½çµç³»å‰Šè¡€è¯…å’’å¯¹æ‰‹ï¼›éå¹½çµç³»é™ä½é€Ÿåº¦æ¢æ”»é˜²'
    },
    // ============================================
    // æŒ¥æŒ‡ (Metronome) - éšæœºæ‹›å¼
    // ============================================
    'Metronome': {
        onUse: (user, target, logs, battle, isPlayer) => {
            // å®‰å…¨æ‹›å¼æ± ï¼ˆé¿å…æ‘‡å‡ºå¤æ‚é€’å½’æˆ–è‡ªçˆ†ï¼‰
            const safePool = [
                'Flamethrower', 'Ice Beam', 'Thunderbolt', 'Psychic', 'Earthquake',
                'Surf', 'Shadow Ball', 'Dazzling Gleam', 'Hyper Beam', 'Air Slash',
                'Dark Pulse', 'Flash Cannon', 'Energy Ball', 'Sludge Bomb', 'Stone Edge',
                'Close Combat', 'Brave Bird', 'Draco Meteor', 'Moonblast', 'Play Rough'
            ];
            const rndMoveName = safePool[Math.floor(Math.random() * safePool.length)];
            logs.push(`${user.cnName} æ‘†åŠ¨äº†æ‰‹æŒ‡...`);
            logs.push(`<b style="color:#d4ac0d">âœ¨ ä½¿å‡ºäº† ${rndMoveName}ï¼</b>`);
            // è¿”å›éšæœºæ‹›å¼åï¼Œè®©å¼•æ“æ‰§è¡Œ
            return { metronome: true, randomMove: rndMoveName };
        },
        description: 'éšæœºä½¿å‡º1ç§æ‹›å¼'
    },
    // ============================================
    // ç»ˆæå†²å‡»ç±» (Final Gambit / Explosion)
    // ============================================
    // ã€æå‘½ã€‘é€ æˆç­‰äºè‡ªèº«å½“å‰HPçš„ä¼¤å®³ï¼Œè‡ªå·±æ¿’æ­»
    'Final Gambit': {
        damageCallback: (attacker, defender) => {
            return attacker.currHp; // é€ æˆç­‰äºè‡ªèº«å½“å‰HPçš„ä¼¤å®³
        },
        onHit: (attacker, defender, damage, logs) => {
            // è‡ªå·±æ¿’æ­»
            attacker.currHp = 0;
            logs.push(`<span style="color:#e74c3c">ğŸ’€ ${attacker.cnName} æ‹¼å°½å…¨åŠ›åå€’ä¸‹äº†ï¼</span>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return {};
        },
        description: 'é€ æˆç­‰äºè‡ªèº«å½“å‰HPçš„ä¼¤å®³ï¼Œè‡ªå·±æ¿’æ­»'
    },
    // ã€æ²»æ„ˆä¹‹æ„¿ã€‘è‡ªå·±æ¿’æ­»ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦
    'Healing Wish': {
        onUse: (user, target, logs) => {
            user.currHp = 0;
            // æ ‡è®°æ²»æ„ˆä¹‹æ„¿æ•ˆæœ
            if (!user.side) user.side = {};
            user.side.healingWish = true;
            logs.push(`<b style="color:#ff69b4">ğŸ’– ${user.cnName} åŒ–ä½œäº†æ²»æ„ˆä¹‹å…‰ï¼</b>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return { success: true, selfKO: true };
        },
        description: 'è‡ªå·±æ¿’æ­»ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦'
    },
    // ã€æ–°æœˆç¥ˆç¥·ã€‘è‡ªå·±æ¿’æ­»ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦ï¼ˆå«PPï¼‰
    'Lunar Dance': {
        onUse: (user, target, logs) => {
            user.currHp = 0;
            if (!user.side) user.side = {};
            user.side.lunarDance = true;
            logs.push(`<b style="color:#9b59b6">ğŸŒ™ ${user.cnName} åŒ–ä½œäº†æœˆå…‰ï¼</b>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return { success: true, selfKO: true };
        },
        description: 'è‡ªå·±æ¿’æ­»ï¼Œå®Œå…¨æ²»æ„ˆä¸‹ä¸€åªå‡ºåœºçš„å®å¯æ¢¦ï¼ˆå«PPï¼‰'
    },
    // ã€åŒå‘½ã€‘å¦‚æœè¿™å›åˆè¢«å‡»å€’ï¼Œå‡»å€’è‡ªå·±çš„å¯¹æ‰‹ä¹Ÿä¼šå€’ä¸‹
    'Destiny Bond': {
        onUse: (user, target, logs) => {
            // è¿ç»­ä½¿ç”¨æ£€æµ‹
            if (user.lastMoveUsed === 'Destiny Bond') {
                logs.push(`<b style="color:#e74c3c">ä½†æ˜¯å¤±è´¥äº†ï¼</b>`);
                return { failed: true };
            }
            if (!user.volatile) user.volatile = {};
            user.volatile.destinyBond = true;
            logs.push(`<b style="color:#7c3aed">ğŸ’€ ${user.cnName} æƒ³è¦å’Œå¯¹æ‰‹åŒå½’äºå°½ï¼</b>`);
            return { success: true };
        },
        description: 'å¦‚æœè¿™å›åˆè¢«å‡»å€’ï¼Œå‡»å€’è‡ªå·±çš„å¯¹æ‰‹ä¹Ÿä¼šå€’ä¸‹'
    },
    // ã€æŒ£æ‰ã€‘PPè€—å°½æ—¶çš„æœ€åæ‰‹æ®µ
    'Struggle': {
        onHit: (attacker, defender, damage, logs) => {
            // åä¼¤ 1/4 æœ€å¤§HP
            const recoil = Math.max(1, Math.floor(attacker.maxHp / 4));
            attacker.takeDamage(recoil);
            logs.push(`<span style="color:#e74c3c">${attacker.cnName} å—åˆ°äº†åä½œç”¨ä¼¤å®³ï¼(-${recoil})</span>`);
            if (typeof window.updateAllVisuals === 'function') window.updateAllVisuals(false);
            return {};
        },
        description: 'PPè€—å°½æ—¶çš„æœ€åæ‰‹æ®µï¼Œä¼šå—åˆ°åä¼¤'
    },
    // ============================================
    // æ²»æ„ˆç±»æ‹›å¼ (Healing Moves)
    // ============================================
    // ã€æ²»æ„ˆé“ƒå£°ã€‘æ²»æ„ˆé˜Ÿä¼æ‰€æœ‰å¼‚å¸¸çŠ¶æ€
    'Heal Bell': {
        onUse: (user, target, logs, battle, isPlayer) => {
            logs.push(`<b style="color:#27ae60">ğŸ”” æ²»æ„ˆé“ƒå£°å“èµ·ï¼é˜Ÿä¼çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†ï¼</b>`);
            user.status = null;
            return { success: true };
        },
        description: 'æ²»æ„ˆé˜Ÿä¼æ‰€æœ‰å®å¯æ¢¦çš„å¼‚å¸¸çŠ¶æ€'
    },
    // ã€èŠ³é¦™æ²»ç–—ã€‘åŒæ²»æ„ˆé“ƒå£°
    'Aromatherapy': {
        onUse: (user, target, logs, battle, isPlayer) => {
            logs.push(`<b style="color:#27ae60">ğŸŒ¸ èŠ³é¦™å¼¥æ¼«ï¼é˜Ÿä¼çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†ï¼</b>`);
            user.status = null;
            return { success: true };
        },
        description: 'æ²»æ„ˆé˜Ÿä¼æ‰€æœ‰å®å¯æ¢¦çš„å¼‚å¸¸çŠ¶æ€'
    },
    // ============================================
    // åœºåœ°æ¸…é™¤æ‹›å¼ (Hazard Removal)
    // æ³¨æ„ï¼šåœºåœ°é’‰å­è®¾ç½®ç”± move-effects.js çš„ applySideCondition å¤„ç†
    // è¿™é‡Œåªå¤„ç†æ¸…é™¤é€»è¾‘
    // ============================================
    // ã€é«˜é€Ÿæ—‹è½¬ã€‘æ¸…é™¤å·±æ–¹åœºåœ°é’‰å­ + é€Ÿåº¦+1
    'Rapid Spin': {
        onHit: (attacker, defender, damage, logs, battle, isPlayer) => {
            if (!battle) return {};
            const userSide = isPlayer ? battle.playerSide : battle.enemySide;
            if (!userSide) return {};
            // ä½¿ç”¨ move-effects.js çš„ clearEntryHazards å‡½æ•°
            if (typeof MoveEffects !== 'undefined' && MoveEffects.clearEntryHazards) {
                const clearLogs = MoveEffects.clearEntryHazards(userSide);
                clearLogs.forEach(l => logs.push(l));
            }
            // é€Ÿåº¦+1 (ç¬¬8ä¸–ä»£æ–°å¢æ•ˆæœ)
            if (!attacker.boosts) attacker.boosts = {};
            attacker.boosts.spe = Math.min(6, (attacker.boosts.spe || 0) + 1);
            logs.push(`${attacker.cnName} çš„é€Ÿåº¦æå‡äº†ï¼`);
            return {};
        },
        description: 'æ¸…é™¤å·±æ–¹åœºåœ°é’‰å­ï¼Œé€Ÿåº¦+1'
    },
    // ã€æ¸…é™¤æµ“é›¾ã€‘æ¸…é™¤åŒæ–¹åœºåœ°æ•ˆæœ
    'Defog': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!battle) return { failed: true };
            const userSide = isPlayer ? battle.playerSide : battle.enemySide;
            const targetSide = isPlayer ? battle.enemySide : battle.playerSide;
            let cleared = false;
            // ä½¿ç”¨ move-effects.js çš„ clearEntryHazards å‡½æ•°
            if (typeof MoveEffects !== 'undefined' && MoveEffects.clearEntryHazards) {
                const userClearLogs = MoveEffects.clearEntryHazards(userSide);
                const targetClearLogs = MoveEffects.clearEntryHazards(targetSide);
                if (userClearLogs.length > 0 || targetClearLogs.length > 0) cleared = true;
            }
            // æ¸…é™¤å¯¹æ–¹å£
            if (targetSide) {
                if (targetSide.reflect > 0) { targetSide.reflect = 0; cleared = true; }
                if (targetSide.lightScreen > 0) { targetSide.lightScreen = 0; cleared = true; }
                if (targetSide.auroraVeil > 0) { targetSide.auroraVeil = 0; cleared = true; }
            }
            if (cleared) {
                logs.push(`<b style="color:#87ceeb">ğŸ’¨ æµ“é›¾æ•£å»ï¼Œåœºåœ°æ•ˆæœè¢«æ¸…é™¤äº†ï¼</b>`);
            } else {
                logs.push(`æµ“é›¾æ•£å»...ä½†æ˜¯æ²¡æœ‰ä»€ä¹ˆæ•ˆæœã€‚`);
            }
            // é™ä½å¯¹æ‰‹é—ªé¿
            if (!target.boosts) target.boosts = {};
            target.boosts.evasion = Math.max(-6, (target.boosts.evasion || 0) - 1);
            return { success: true };
        },
        description: 'æ¸…é™¤åŒæ–¹åœºåœ°æ•ˆæœï¼Œé™ä½å¯¹æ‰‹é—ªé¿'
    },
    // ============================================
    // é€šç”¨ Max æå·¨æ‹›å¼ (å¤©æ°”/åœºåœ°æ•ˆæœ)
    // ============================================
    'Max Flare': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle && battle.weather !== 'sunnyday') {
                battle.weather = 'sunnyday';
                battle.weatherTurns = 5;
                logs.push(`<span style="color:#f59e0b">â˜€ï¸ é˜³å…‰å˜å¾—å¼ºçƒˆäº†ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¬å”¤æ™´å¤©'
    },
    'Max Geyser': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle && battle.weather !== 'raindance') {
                battle.weather = 'raindance';
                battle.weatherTurns = 5;
                logs.push(`<span style="color:#3b82f6">ğŸŒ§ï¸ å¤©ç©ºä¸‹èµ·äº†å¤§é›¨ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¬å”¤é›¨å¤©'
    },
    'Max Hailstorm': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle && battle.weather !== 'hail') {
                battle.weather = 'hail';
                battle.weatherTurns = 5;
                logs.push(`<span style="color:#a5f3fc">â„ï¸ å†°é›¹å¼€å§‹ä¸‹äº†ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¬å”¤å†°é›¹'
    },
    'Max Rockfall': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle && battle.weather !== 'sandstorm') {
                battle.weather = 'sandstorm';
                battle.weatherTurns = 5;
                logs.push(`<span style="color:#d97706">ğŸœï¸ æ²™æš´åˆ®èµ·æ¥äº†ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¬å”¤æ²™æš´'
    },
    'Max Overgrowth': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle) {
                battle.terrain = 'grassyterrain';
                battle.terrainTurns = 5;
                logs.push(`<span style="color:#22c55e">ğŸŒ¿ è„šä¸‹é•¿å‡ºäº†é’è‰ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å±•å¼€é’è‰åœºåœ°'
    },
    'Max Lightning': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle) {
                battle.terrain = 'electricterrain';
                battle.terrainTurns = 5;
                logs.push(`<span style="color:#facc15">âš¡ ç”µæµåœ¨è„šä¸‹å¥”æ¶Œï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å±•å¼€ç”µæ°”åœºåœ°'
    },
    'Max Starfall': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle) {
                battle.terrain = 'mistyterrain';
                battle.terrainTurns = 5;
                logs.push(`<span style="color:#f472b6">âœ¨ è–„é›¾ç¬¼ç½©äº†æˆ˜åœºï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å±•å¼€è–„é›¾åœºåœ°'
    },
    'Max Mindstorm': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (battle) {
                battle.terrain = 'psychicterrain';
                battle.terrainTurns = 5;
                logs.push(`<span style="color:#a78bfa">ğŸ”® å¥‡å¦™çš„æ„Ÿè§‰ç¬¼ç½©äº†æˆ˜åœºï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å±•å¼€ç²¾ç¥åœºåœ°'
    },
    'Max Airstream': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.boosts) user.boosts = {};
            user.boosts.spe = Math.min(6, (user.boosts.spe || 0) + 1);
            logs.push(`<span style="color:#60a5fa">ğŸ’¨ ${user.cnName} çš„é€Ÿåº¦æå‡äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æå‡å·±æ–¹é€Ÿåº¦'
    },
    'Max Knuckle': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.boosts) user.boosts = {};
            user.boosts.atk = Math.min(6, (user.boosts.atk || 0) + 1);
            logs.push(`<span style="color:#ef4444">ğŸ’ª ${user.cnName} çš„æ”»å‡»æå‡äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æå‡å·±æ–¹æ”»å‡»'
    },
    'Max Ooze': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.boosts) user.boosts = {};
            user.boosts.spa = Math.min(6, (user.boosts.spa || 0) + 1);
            logs.push(`<span style="color:#a855f7">ğŸ§ª ${user.cnName} çš„ç‰¹æ”»æå‡äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æå‡å·±æ–¹ç‰¹æ”»'
    },
    'Max Steelspike': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.boosts) user.boosts = {};
            user.boosts.def = Math.min(6, (user.boosts.def || 0) + 1);
            logs.push(`<span style="color:#94a3b8">ğŸ›¡ï¸ ${user.cnName} çš„é˜²å¾¡æå‡äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æå‡å·±æ–¹é˜²å¾¡'
    },
    'Max Quake': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.boosts) user.boosts = {};
            user.boosts.spd = Math.min(6, (user.boosts.spd || 0) + 1);
            logs.push(`<span style="color:#d97706">ğŸŒ ${user.cnName} çš„ç‰¹é˜²æå‡äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æå‡å·±æ–¹ç‰¹é˜²'
    },
    'Max Wyrmwind': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.atk = Math.max(-6, (target.boosts.atk || 0) - 1);
            logs.push(`<span style="color:#7c3aed">ğŸ‰ ${target.cnName} çš„æ”»å‡»ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡æ”»å‡»'
    },
    'Max Phantasm': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.def = Math.max(-6, (target.boosts.def || 0) - 1);
            logs.push(`<span style="color:#6366f1">ğŸ‘» ${target.cnName} çš„é˜²å¾¡ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡é˜²å¾¡'
    },
    'Max Darkness': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.spd = Math.max(-6, (target.boosts.spd || 0) - 1);
            logs.push(`<span style="color:#1f2937">ğŸŒ‘ ${target.cnName} çš„ç‰¹é˜²ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡ç‰¹é˜²'
    },
    'Max Flutterby': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.spa = Math.max(-6, (target.boosts.spa || 0) - 1);
            logs.push(`<span style="color:#84cc16">ğŸ¦‹ ${target.cnName} çš„ç‰¹æ”»ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡ç‰¹æ”»'
    },
    'Max Strike': {
        isMax: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.spe = Math.max(-6, (target.boosts.spe || 0) - 1);
            logs.push(`<span style="color:#6b7280">âš¡ ${target.cnName} çš„é€Ÿåº¦ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡é€Ÿåº¦'
    },
    // ============================================
    // G-Max è¶…æå·¨æ‹›å¼å¤„ç†å™¨ (ä¸è§¦å‘å¤©æ°”/åœºåœ°)
    // ============================================
    // === 1. æŒç»­ä¼¤å®³ç±» (DOT Field) - 4å›åˆéå¯¹åº”å±æ€§æ‰£ 1/6 HP ===
    'G-Max Wildfire': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.gmaxWildfire) {
                targetSide.gmaxWildfire = { turns: 4 };
                logs.push(`<span style="color:#ef4444">ğŸ”¥ çƒˆç„°åŒ…å›´äº†æˆ˜åœºï¼éç«å±æ€§å®å¯æ¢¦å°†æŒç»­å—åˆ°ä¼¤å®³ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³ï¼Œ4å›åˆå†…éç«å±æ€§å®å¯æ¢¦æ¯å›åˆå—åˆ°1/6æœ€å¤§HPä¼¤å®³'
    },
    'G-Max Vine Lash': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.gmaxVineLash) {
                targetSide.gmaxVineLash = { turns: 4 };
                logs.push(`<span style="color:#22c55e">ğŸŒ¿ è‡´å‘½è—¤è”“ç¼ ç»•äº†æˆ˜åœºï¼éè‰å±æ€§å®å¯æ¢¦å°†æŒç»­å—åˆ°ä¼¤å®³ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³ï¼Œ4å›åˆå†…éè‰å±æ€§å®å¯æ¢¦æ¯å›åˆå—åˆ°1/6æœ€å¤§HPä¼¤å®³'
    },
    'G-Max Cannonade': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.gmaxCannonade) {
                targetSide.gmaxCannonade = { turns: 4 };
                logs.push(`<span style="color:#3b82f6">ğŸ’§ æ¿€æµåœ¨æˆ˜åœºä¸Šç¿»æ¶Œï¼éæ°´å±æ€§å®å¯æ¢¦å°†æŒç»­å—åˆ°ä¼¤å®³ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³ï¼Œ4å›åˆå†…éæ°´å±æ€§å®å¯æ¢¦æ¯å›åˆå—åˆ°1/6æœ€å¤§HPä¼¤å®³'
    },
    'G-Max Volcalith': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.gmaxVolcalith) {
                targetSide.gmaxVolcalith = { turns: 4 };
                logs.push(`<span style="color:#f97316">ï¿½ite ç‚½çƒ­å²©çŸ³æ•£è½æˆ˜åœºï¼éå²©å±æ€§å®å¯æ¢¦å°†æŒç»­å—åˆ°ä¼¤å®³ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³ï¼Œ4å›åˆå†…éå²©å±æ€§å®å¯æ¢¦æ¯å›åˆå—åˆ°1/6æœ€å¤§HPä¼¤å®³'
    },
    // === 2. åœºåœ°/å¢™ç±» ===
    'G-Max Resonance': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const userSide = (user === battle.getPlayer()) ? battle.playerSide : battle.enemySide;
            const itemExt = (user.item === 'Light Clay') ? 3 : 0;
            if (!userSide.auroraVeil || userSide.auroraVeil <= 0) {
                userSide.auroraVeil = 5 + itemExt;
                logs.push(`<b style="color:#a5f3fc">â„ï¸ æå…‰æ—‹å¾‹å¼€å¯äº†æå…‰å¹•ï¼ç‰©ç†å’Œç‰¹æ®Šä¼¤å®³éƒ½å°†å‡åŠï¼</b>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¼€å¯æå…‰å¹•(æ— è§†å¤©æ°”)'
    },
    'G-Max Steelsurge': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.gmaxSteelsurge) {
                targetSide.gmaxSteelsurge = true;
                logs.push(`<span style="color:#94a3b8">âš™ï¸ å°–é”çš„é’¢åˆºæ•£å¸ƒåœ¨å¯¹æ‰‹åœºåœ°ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶åœ¨å¯¹æ–¹åœºåœ°è®¾ç½®é’¢ä¹‹æ’’è±'
    },
    'G-Max Stonesurge': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            if (!targetSide.stealthRock) {
                targetSide.stealthRock = true;
                logs.push(`<span style="color:#a8a29e">ğŸª¨ å°–é”çš„å²©çŸ³æ¼‚æµ®åœ¨å¯¹æ‰‹åœºåœ°å‘¨å›´ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶è®¾ç½®éšå½¢å²©'
    },
    // === 3. çŠ¶æ€å¼‚å¸¸ç±» ===
    'G-Max Befuddle': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (target.status) return {};
            const rand = Math.random();
            let status = 'psn';
            if (rand < 0.33) status = 'slp';
            else if (rand < 0.66) status = 'par';
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, status);
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶éšæœºä½¿ç›®æ ‡é™·å…¥ç¡çœ /éº»ç—¹/ä¸­æ¯’'
    },
    'G-Max Volt Crash': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, 'par');
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡éº»ç—¹'
    },
    'G-Max Stun Shock': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (target.status) return {};
            const status = Math.random() < 0.5 ? 'par' : 'psn';
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, status);
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶éšæœºä½¿ç›®æ ‡éº»ç—¹æˆ–ä¸­æ¯’'
    },
    'G-Max Malodor': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, 'psn');
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡ä¸­æ¯’'
    },
    'G-Max Snooze': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            if (!target.volatile.yawn) {
                target.volatile.yawn = 2;
                logs.push(`<span style="color:#a78bfa">ğŸ˜´ ${target.cnName} å¼€å§‹æ‰“å“ˆæ¬ äº†...</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡è¿›å…¥å“ˆæ¬ çŠ¶æ€(ä¸‹å›åˆç¡ç€)'
    },
    // === 4. èµ„æºå›å¤ç±» ===
    'G-Max Replenish': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.item && user._consumedBerry && Math.random() < 0.5) {
                user.item = user._consumedBerry;
                logs.push(`<span style="color:#22c55e">ğŸ ${user.cnName} æ¡å›äº†${user._consumedBerry}ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³ï¼Œ50%æ¦‚ç‡æ¢å¤å·²æ¶ˆè€—çš„æ ‘æœ'
    },
    'G-Max Finale': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            const heal = Math.floor(user.maxHp / 6);
            user.currHp = Math.min(user.maxHp, user.currHp + heal);
            logs.push(`<span style="color:#f472b6">ğŸ‚ ${user.cnName} å›å¤äº† ${heal} HPï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å›å¤å·±æ–¹1/6æœ€å¤§HP'
    },
    // === 5. èƒ½åŠ›å˜åŒ–ç±» ===
    'G-Max Chi Strike': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.focusenergy = true;
            logs.push(`<span style="color:#ef4444">ğŸ’ª ${user.cnName} æ°”åŠ¿é«˜æ¶¨ï¼æš´å‡»ç‡å¤§å¹…æå‡ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¤§å¹…æå‡æš´å‡»ç‡'
    },
    'G-Max Terror': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            target.volatile.trapped = true;
            logs.push(`<span style="color:#7c3aed">ğŸ‘» ${target.cnName} è¢«ææƒ§ç¬¼ç½©ï¼Œæ— æ³•é€ƒèµ°ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡æ— æ³•é€ƒèµ°'
    },
    'G-Max Cuddle': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            target.volatile.infatuated = true;
            logs.push(`<span style="color:#ec4899">ğŸ’• ${target.cnName} è¢«è¿·ä½äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡ç€è¿·'
    },
    // === 6. å¾¡ä¸‰å®¶/æ­¦é“ç†Šå¸ˆ ç ´æ ¼ç±» ===
    'G-Max Fireball': {
        isGMax: true,
        noWeather: true,
        ignoreAbility: true,
        description: 'é€ æˆä¼¤å®³ï¼Œæ— è§†ç›®æ ‡ç‰¹æ€§'
    },
    'G-Max Hydrosnipe': {
        isGMax: true,
        noWeather: true,
        ignoreAbility: true,
        description: 'é€ æˆä¼¤å®³ï¼Œæ— è§†ç›®æ ‡ç‰¹æ€§'
    },
    'G-Max Drum Solo': {
        isGMax: true,
        noWeather: true,
        ignoreAbility: true,
        description: 'é€ æˆä¼¤å®³ï¼Œæ— è§†ç›®æ ‡ç‰¹æ€§'
    },
    'G-Max One Blow': {
        isGMax: true,
        noWeather: true,
        bypassProtect: true,
        description: 'é€ æˆä¼¤å®³ï¼Œæ— è§†å®ˆä½'
    },
    'G-Max Rapid Flow': {
        isGMax: true,
        noWeather: true,
        bypassProtect: true,
        description: 'é€ æˆä¼¤å®³ï¼Œæ— è§†å®ˆä½'
    },
    // === 7. å…¶ä»– G-Max æ‹›å¼ (åŸºç¡€æ•ˆæœ) ===
    'G-Max Gold Rush': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, 'confusion');
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡æ··ä¹±'
    },
    'G-Max Smite': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (typeof MoveEffects !== 'undefined' && MoveEffects.tryInflictStatus) {
                const res = MoveEffects.tryInflictStatus(target, 'confusion');
                if (res && res.success) logs.push(res.message);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡æ··ä¹±'
    },
    'G-Max Foam Burst': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.spe = Math.max(-6, (target.boosts.spe || 0) - 2);
            logs.push(`<span style="color:#3b82f6">ğŸ«§ ${target.cnName} çš„é€Ÿåº¦å¤§å¹…ä¸‹é™ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å¤§å¹…é™ä½ç›®æ ‡é€Ÿåº¦'
    },
    'G-Max Centiferno': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            target.volatile.partiallytrapped = { turns: 4, source: user };
            logs.push(`<span style="color:#ef4444">ğŸ”¥ ${target.cnName} è¢«çƒˆç„°ç¼ ç»•äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æŸç¼šç›®æ ‡4-5å›åˆ'
    },
    'G-Max Sandblast': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            target.volatile.partiallytrapped = { turns: 4, source: user };
            logs.push(`<span style="color:#d97706">ğŸœï¸ ${target.cnName} è¢«æ²™æš´ç¼ ç»•äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æŸç¼šç›®æ ‡4-5å›åˆ'
    },
    'G-Max Wind Rage': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            const targetSide = (user === battle.getPlayer()) ? battle.enemySide : battle.playerSide;
            let cleared = false;
            if (targetSide) {
                if (targetSide.reflect > 0) { targetSide.reflect = 0; cleared = true; }
                if (targetSide.lightScreen > 0) { targetSide.lightScreen = 0; cleared = true; }
                if (targetSide.auroraVeil > 0) { targetSide.auroraVeil = 0; cleared = true; }
            }
            if (cleared) {
                logs.push(`<span style="color:#60a5fa">ğŸ’¨ å¯¹æ‰‹çš„å£è¢«å¹æ•£äº†ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æ¸…é™¤å¯¹æ‰‹çš„å£'
    },
    'G-Max Gravitas': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!battle) return {};
            battle.pseudoWeather = battle.pseudoWeather || {};
            battle.pseudoWeather.gravity = 5;
            logs.push(`<b style="color:#a78bfa">ğŸŒŒ é‡åŠ›åœºå±•å¼€äº†ï¼</b>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å±•å¼€é‡åŠ›åœº'
    },
    'G-Max Depletion': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (target.moves && target.moves.length > 0) {
                const lastMove = target.lastMove;
                if (lastMove) {
                    const move = target.moves.find(m => m.name === lastMove || m.cn === lastMove);
                    if (move && move.pp > 0) {
                        move.pp = Math.max(0, move.pp - 2);
                        logs.push(`<span style="color:#7c3aed">âš¡ ${target.cnName} çš„ ${move.cn || move.name} PPå‡å°‘äº†ï¼</span>`);
                    }
                }
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶å‡å°‘ç›®æ ‡æœ€åä½¿ç”¨æ‹›å¼çš„PP'
    },
    'G-Max Tartness': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.boosts) target.boosts = {};
            target.boosts.evasion = Math.max(-6, (target.boosts.evasion || 0) - 1);
            logs.push(`<span style="color:#84cc16">ğŸ ${target.cnName} çš„é—ªé¿ç‡ä¸‹é™äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶é™ä½ç›®æ ‡é—ªé¿ç‡'
    },
    'G-Max Sweetness': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (user.status) {
                user.status = null;
                logs.push(`<span style="color:#22c55e">ğŸ¯ ${user.cnName} çš„å¼‚å¸¸çŠ¶æ€è¢«æ²»æ„ˆäº†ï¼</span>`);
            }
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶æ²»æ„ˆå·±æ–¹å¼‚å¸¸çŠ¶æ€'
    },
    'G-Max Meltdown': {
        isGMax: true,
        noWeather: true,
        onHit: (user, target, damage, logs, battle) => {
            if (!target.volatile) target.volatile = {};
            target.volatile.torment = true;
            logs.push(`<span style="color:#94a3b8">ğŸ”© ${target.cnName} æ— æ³•è¿ç»­ä½¿ç”¨ç›¸åŒæ‹›å¼äº†ï¼</span>`);
            return {};
        },
        description: 'é€ æˆä¼¤å®³å¹¶ä½¿ç›®æ ‡æ— æ³•è¿ç»­ä½¿ç”¨ç›¸åŒæ‹›å¼'
    },
    // ============================================
    // è“„åŠ›ç³»åˆ—æŠ€èƒ½ (Stockpile / Spit Up / Swallow)
    // ============================================
    'Stockpile': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            const currentStacks = user.volatile.stockpile || 0;
            // æœ€å¤šè“„åŠ› 3 æ¬¡
            if (currentStacks >= 3) {
                logs.push(`${user.cnName} å·²ç»è“„æ»¡äº†ï¼æ— æ³•ç»§ç»­è“„åŠ›ï¼`);
                return { failed: true };
            }
            user.volatile.stockpile = currentStacks + 1;
            const newStacks = user.volatile.stockpile;
            // æ¯æ¬¡è“„åŠ›æå‡ 1 çº§é˜²å¾¡å’Œç‰¹é˜²
            const defDiff = user.applyBoost('def', 1);
            const spdDiff = user.applyBoost('spd', 1);
            logs.push(`${user.cnName} è“„åŠ›äº†ï¼(${newStacks}/3)`);
            if (defDiff > 0) logs.push(`${user.cnName} çš„é˜²å¾¡æå‡äº†ï¼`);
            if (spdDiff > 0) logs.push(`${user.cnName} çš„ç‰¹é˜²æå‡äº†ï¼`);
            return {};
        },
        description: 'è“„åŠ›ï¼ˆæœ€å¤š3æ¬¡ï¼‰ï¼Œæ¯æ¬¡æå‡1çº§é˜²å¾¡å’Œç‰¹é˜²'
    },
    'Spit Up': {
        basePowerCallback: (attacker, defender) => {
            const stacks = (attacker.volatile && attacker.volatile.stockpile) || 0;
            // å¨åŠ› = 100 Ã— è“„åŠ›å±‚æ•°
            return stacks * 100;
        },
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            const stacks = user.volatile.stockpile || 0;
            if (stacks === 0) {
                logs.push(`${user.cnName} æ²¡æœ‰è“„åŠ›ï¼Œå–·å‡ºå¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            return {};
        },
        onHit: (user, target, damage, logs, battle) => {
            // ä½¿ç”¨åæ¸…ç©ºè“„åŠ›å±‚æ•°å¹¶é™ä½å¯¹åº”çš„é˜²å¾¡/ç‰¹é˜²
            const stacks = (user.volatile && user.volatile.stockpile) || 0;
            if (stacks > 0) {
                user.applyBoost('def', -stacks);
                user.applyBoost('spd', -stacks);
                user.volatile.stockpile = 0;
                logs.push(`${user.cnName} çš„è“„åŠ›æ¶ˆè€—æ®†å°½ï¼é˜²å¾¡å’Œç‰¹é˜²ä¸‹é™äº†ï¼`);
            }
            return {};
        },
        description: 'æ¶ˆè€—è“„åŠ›å±‚æ•°é€ æˆä¼¤å®³ï¼ˆ100/200/300å¨åŠ›ï¼‰'
    },
    'Swallow': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            const stacks = user.volatile.stockpile || 0;
            if (stacks === 0) {
                logs.push(`${user.cnName} æ²¡æœ‰è“„åŠ›ï¼Œåä¸‹å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            // å›å¤é‡æ ¹æ®è“„åŠ›å±‚æ•°ï¼š1å±‚=25%, 2å±‚=50%, 3å±‚=100%
            const healPercent = stacks === 1 ? 0.25 : (stacks === 2 ? 0.50 : 1.00);
            const healAmount = Math.floor(user.maxHp * healPercent);
            const actualHeal = Math.min(healAmount, user.maxHp - user.currHp);
            user.currHp = Math.min(user.maxHp, user.currHp + healAmount);
            logs.push(`${user.cnName} åä¸‹äº†è“„åŠ›ï¼å›å¤äº† ${actualHeal} HPï¼`);
            // æ¶ˆè€—è“„åŠ›å±‚æ•°å¹¶é™ä½å¯¹åº”çš„é˜²å¾¡/ç‰¹é˜²
            user.applyBoost('def', -stacks);
            user.applyBoost('spd', -stacks);
            user.volatile.stockpile = 0;
            logs.push(`${user.cnName} çš„è“„åŠ›æ¶ˆè€—æ®†å°½ï¼é˜²å¾¡å’Œç‰¹é˜²ä¸‹é™äº†ï¼`);
            return {};
        },
        description: 'æ¶ˆè€—è“„åŠ›å±‚æ•°å›å¤HPï¼ˆ25%/50%/100%ï¼‰'
    },
    'Stuff Cheeks': {
        onUse: (user, target, logs, battle, isPlayer) => {
            // æ£€æŸ¥æ˜¯å¦æŒæœ‰æ ‘æœ
            const item = user.item || '';
            const isBerry = item.toLowerCase().includes('berry') || 
                           item.includes('æœ') ||
                           (typeof window !== 'undefined' && typeof window.isBerry === 'function' && window.isBerry(item));
            if (!item || !isBerry) {
                logs.push(`${user.cnName} æ²¡æœ‰æŒæœ‰æ ‘æœï¼Œå¤§å¿«æœµé¢å¤±è´¥äº†ï¼`);
                return { failed: true };
            }
            // å¼ºåˆ¶åƒæ‰æ ‘æœ
            const berryName = user.item;
            logs.push(`${user.cnName} åƒæ‰äº† ${berryName}ï¼`);
            // è§¦å‘æ ‘æœæ•ˆæœï¼ˆå¦‚æœæœ‰ consumeItem å‡½æ•°ï¼‰
            if (typeof window !== 'undefined' && typeof window.consumeItem === 'function') {
                const itemLogs = window.consumeItem(user, battle);
                if (itemLogs && itemLogs.length) {
                    logs.push(...itemLogs);
                }
            } else {
                // ç®€åŒ–å¤„ç†ï¼šç›´æ¥æ¸…é™¤é“å…·
                user.item = null;
            }
            // é˜²å¾¡å¤§å¹…æå‡ (+2)
            const defDiff = user.applyBoost('def', 2);
            if (defDiff > 0) {
                logs.push(`${user.cnName} çš„é˜²å¾¡å¤§å¹…æå‡äº†ï¼`);
            } else {
                logs.push(`${user.cnName} çš„é˜²å¾¡å·²ç»æ— æ³•å†æå‡äº†ï¼`);
            }
            return {};
        },
        description: 'åƒæ‰æŒæœ‰çš„æ ‘æœå¹¶å¤§å¹…æå‡é˜²å¾¡'
    },
    // ============================================
    // åˆ·æ–°å‹ Volatile æŠ€èƒ½ (Refreshable Volatile Moves)
    // è¿™äº›æŠ€èƒ½é‡å¤ä½¿ç”¨ä¼šåˆ·æ–°æ•ˆæœï¼Œä¸ä¼šå¤±è´¥
    // ============================================
    'Charge': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.charge = true;
            // å……ç”µè¿˜ä¼šæå‡ç‰¹é˜²
            const spdDiff = user.applyBoost('spd', 1);
            logs.push(`${user.cnName} å¼€å§‹å……ç”µï¼`);
            if (spdDiff > 0) logs.push(`${user.cnName} çš„ç‰¹é˜²æå‡äº†ï¼`);
            logs.push(`<span style="color:#f59e0b">ä¸‹å›åˆç”µç³»æ‹›å¼å¨åŠ›ç¿»å€ï¼</span>`);
            return {};
        },
        description: 'å……ç”µï¼Œä¸‹å›åˆç”µç³»æ‹›å¼å¨åŠ›ç¿»å€ï¼Œç‰¹é˜²+1'
    },
    'Defense Curl': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.defensecurl = true;
            // å˜åœ†æå‡é˜²å¾¡
            const defDiff = user.applyBoost('def', 1);
            logs.push(`${user.cnName} èœ·ç¼©èµ·èº«ä½“ï¼`);
            if (defDiff > 0) {
                logs.push(`${user.cnName} çš„é˜²å¾¡æå‡äº†ï¼`);
            } else {
                logs.push(`${user.cnName} çš„é˜²å¾¡å·²ç»æ— æ³•å†æå‡äº†ï¼`);
            }
            return {};
        },
        description: 'å˜åœ†ï¼Œé˜²å¾¡+1ï¼Œæ»šåŠ¨/å†°çƒå¨åŠ›ç¿»å€'
    },
    'Laser Focus': {
        onUse: (user, target, logs, battle, isPlayer) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.laserfocus = true;
            logs.push(`${user.cnName} é›†ä¸­ç²¾ç¥ï¼`);
            logs.push(`<span style="color:#ef4444">ä¸‹å›åˆæ”»å‡»å¿…å®šæš´å‡»ï¼</span>`);
            return {};
        },
        description: 'ç£¨ç ºï¼Œä¸‹å›åˆæ”»å‡»å¿…å®šæš´å‡»'
    },
    // ============================================
    // æ»šåŠ¨/å†°çƒ (Rollout / Ice Ball)
    // å¨åŠ›é€’å¢ï¼Œå˜åœ†åå¨åŠ›ç¿»å€
    // ============================================
    'Rollout': {
        basePowerCallback: (attacker, defender) => {
            // åŸºç¡€å¨åŠ› 30ï¼Œæ¯æ¬¡ç¿»å€ï¼Œæœ€å¤š5æ¬¡ (30->60->120->240->480)
            const rolloutCount = attacker.volatile?.rolloutCount || 1;
            let power = 30 * Math.pow(2, rolloutCount - 1);
            // å˜åœ†åå¨åŠ›ç¿»å€
            if (attacker.volatile?.defensecurl) {
                power *= 2;
            }
            return Math.min(480, power);
        },
        onHit: (user, target, damage, logs, battle) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.rolloutCount = (user.volatile.rolloutCount || 0) + 1;
            // æœ€å¤š5æ¬¡
            if (user.volatile.rolloutCount >= 5) {
                user.volatile.rolloutCount = 0;
                user.volatile.lockedMove = null;
            } else {
                user.volatile.lockedMove = 'Rollout';
            }
            return {};
        },
        onMiss: (user, target, logs) => {
            // æœªå‘½ä¸­åˆ™é‡ç½®
            if (user.volatile) {
                user.volatile.rolloutCount = 0;
                user.volatile.lockedMove = null;
            }
            return {};
        },
        description: 'æ»šåŠ¨ï¼Œå¨åŠ›é€’å¢ï¼Œå˜åœ†åç¿»å€'
    },
    'Ice Ball': {
        basePowerCallback: (attacker, defender) => {
            const rolloutCount = attacker.volatile?.iceballCount || 1;
            let power = 30 * Math.pow(2, rolloutCount - 1);
            if (attacker.volatile?.defensecurl) {
                power *= 2;
            }
            return Math.min(480, power);
        },
        onHit: (user, target, damage, logs, battle) => {
            if (!user.volatile) user.volatile = {};
            user.volatile.iceballCount = (user.volatile.iceballCount || 0) + 1;
            if (user.volatile.iceballCount >= 5) {
                user.volatile.iceballCount = 0;
                user.volatile.lockedMove = null;
            } else {
                user.volatile.lockedMove = 'Ice Ball';
            }
            return {};
        },
        onMiss: (user, target, logs) => {
            if (user.volatile) {
                user.volatile.iceballCount = 0;
                user.volatile.lockedMove = null;
            }
            return {};
        },
        description: 'å†°çƒï¼Œå¨åŠ›é€’å¢ï¼Œå˜åœ†åç¿»å€'
    }
    // æ³¨æ„ï¼šä»¥ä¸‹æ‹›å¼ç”± move-effects.js ç»Ÿä¸€å¤„ç†ï¼Œä¸éœ€è¦åœ¨è¿™é‡Œé‡å¤å®šä¹‰ï¼š
    // - Taunt, Encore, Disable -> MoveEffects.applyVolatileStatus
    // - Stealth Rock, Spikes, Toxic Spikes, Sticky Web -> MoveEffects.applySideCondition
    // - Haze -> MoveEffects (å·²æœ‰ onHit å¤„ç†å™¨åœ¨ä¸Šæ–¹)
};
// ============================================
// è¾…åŠ©å‡½æ•°ï¼šè·å–æŠ€èƒ½å¤„ç†å™¨
// ============================================
function getMoveHandler(moveName) {
    return MoveHandlers[moveName] || null;
}
function hasMoveHandler(moveName) {
    return moveName in MoveHandlers;
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
if (typeof window !== 'undefined') {
    window.MoveHandlers = MoveHandlers;
    window.getMoveHandler = getMoveHandler;
    window.hasMoveHandler = hasMoveHandler;
}
]]></file>
    </directory>
    <directory name="mechanics">
        <file name="dynamax.js"><![CDATA[/**
 * ===========================================
 * DYNAMAX.JS - æå·¨åŒ–ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - æå·¨åŒ–çŠ¶æ€ç®¡ç†
 * - æ‹›å¼è½¬æ¢ï¼ˆæ™®é€šæ‹›å¼ <-> æå·¨æ‹›å¼ï¼‰
 * - æå·¨æ‹›å¼æ¨å¯¼ï¼ˆMax Move / G-Max Moveï¼‰
 * - HP å€å¢/æ¢å¤
 */
// ============================================
// G-Max ä¸“å±æ‹›å¼è¡¨ (åŠ¨æ€æ„å»º)
// ============================================
const GMAX_MOVE_MAP = {};
// ============================================
// åˆå§‹åŒ–ï¼šä»æ•°æ®åº“æ„å»º G-Max æ˜ å°„è¡¨
// ============================================
(function buildGMaxMoveMap() {
    if (typeof MOVES === 'undefined') {
        console.warn('[DYNAMAX] MOVES database not loaded');
        return;
    }
    // éå†æ‰€æœ‰æ‹›å¼ï¼Œæ„å»º G-Max ä¸“å±æ‹›å¼è¡¨
    for (const moveId in MOVES) {
        const moveData = MOVES[moveId];
        // æ„å»º G-Max ä¸“å±æ‹›å¼è¡¨
        if (moveData.isMax && typeof moveData.isMax === 'string') {
            const species = moveData.isMax.toLowerCase().replace(/[^a-z0-9]/g, '');
            GMAX_MOVE_MAP[species] = {
                name: moveData.name,
                id: moveId,
                type: moveData.type,
                basePower: moveData.basePower || 130
            };
        }
    }
    console.log('[DYNAMAX] Built GMAX_MOVE_MAP:', Object.keys(GMAX_MOVE_MAP).length, 'entries');
})();
// ============================================
// æå·¨æ‹›å¼æ¨å¯¼å‡½æ•°
// ============================================
/**
 * è®¡ç®—æå·¨æ‹›å¼å¨åŠ›
 * @param {number} basePower - åŸæ‹›å¼å¨åŠ›
 * @param {string} moveType - æ‹›å¼å±æ€§
 * @returns {number} æå·¨æ‹›å¼å¨åŠ›
 */
function calculateMaxMovePower(basePower, moveType) {
    // æ ¼æ–—ç³»å’Œæ¯’ç³»æå·¨æ‹›å¼å¨åŠ›ç¨ä½ï¼ˆå› ä¸ºæœ‰åŠ æ”»/åŠ ç‰¹æ”»ç‰¹æ•ˆï¼‰
    if (moveType === 'Fighting' || moveType === 'Poison') {
        if (basePower >= 150) return 100;
        if (basePower >= 110) return 95;
        if (basePower >= 75) return 90;
        if (basePower >= 65) return 85;
        if (basePower >= 55) return 80;
        if (basePower >= 45) return 75;
        return 70;
    }
    // é€šç”¨å¨åŠ›è®¡ç®—
    if (basePower >= 150) return 150;
    if (basePower >= 110) return 140;
    if (basePower >= 75) return 130;
    if (basePower >= 65) return 120;
    if (basePower >= 55) return 110;
    if (basePower >= 45) return 100;
    return 90;
}
/**
 * è·å–å®å¯æ¢¦çš„åŸºç¡€ç‰©ç§ IDï¼ˆç”¨äº G-Max æŸ¥è¡¨ï¼‰
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {string} åŸºç¡€ç‰©ç§ ID
 */
function getBaseSpeciesId(pokemon) {
    const pokeName = pokemon.name || '';
    // ç§»é™¤ gmax/mega/gigantamax åç¼€ï¼Œä½†ä¿ç•™å½¢æ€åç¼€å¦‚ lowkey/rapidstrike
    let speciesId = pokeName.toLowerCase().replace(/[^a-z0-9]/g, '');
    speciesId = speciesId.replace(/(gmax|mega|gigantamax)$/g, '');
    return speciesId;
}
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦æœ‰è¶…æå·¨åŒ–å› å­
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {Object|null} G-Max æ•°æ® { move, type, cn } æˆ– null
 */
function getGMaxFactor(pokemon) {
    // å¦‚æœæ˜¾å¼æ ‡è®°ä¸ºé€šç”¨æå·¨åŒ–ï¼Œåˆ™è·³è¿‡
    if (pokemon.isGenericDynamax) return null;
    // ä¼˜å…ˆä½¿ç”¨ GMAX_SPECIES_DATAï¼ˆæ¥è‡ª move-constants.jsï¼‰
    const gmaxTable = typeof GMAX_SPECIES_DATA !== 'undefined' ? GMAX_SPECIES_DATA : 
                      (typeof window !== 'undefined' && window.GMAX_SPECIES_DATA) ? window.GMAX_SPECIES_DATA : null;
    if (!gmaxTable) return null;
    const speciesId = getBaseSpeciesId(pokemon);
    return gmaxTable[speciesId] || null;
}
/**
 * è·å–æ‹›å¼å¯¹åº”çš„æå·¨åŒ–æ‹›å¼åç§°
 * @param {Object} baseMoveObj - åŸå§‹æ‹›å¼å¯¹è±¡
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {Object|null} Max æ‹›å¼ä¿¡æ¯ { name, type, power, isGMax, cn } æˆ– null
 */
function getMaxMoveTarget(baseMoveObj, pokemon) {
    // å˜åŒ–æŠ€å˜æˆ Max Guard
    if (baseMoveObj.category === 'Status' || baseMoveObj.cat === 'status') {
        const cnTable = typeof GENERIC_MAX_CN !== 'undefined' ? GENERIC_MAX_CN :
                        (typeof window !== 'undefined' && window.GENERIC_MAX_CN) ? window.GENERIC_MAX_CN : {};
        return {
            name: 'Max Guard',
            type: 'Normal',
            power: 0,
            isGMax: false,
            cn: cnTable['Max Guard'] || 'æå·¨é˜²å£'
        };
    }
    const moveType = baseMoveObj.type || 'Normal';
    const basePower = baseMoveObj.basePower || baseMoveObj.power || 60;
    // === æ ¸å¿ƒä¿®æ”¹ï¼šä¼˜å…ˆæŸ¥é˜… GMAX_SPECIES_DATA è¡¨ ===
    const gmaxFactor = getGMaxFactor(pokemon);
    if (gmaxFactor && gmaxFactor.type === moveType) {
        // è¯¥ç‰©ç§åœ¨è¡¨é‡Œï¼Œä¸”å½“å‰æ‹›å¼å±æ€§åŒ¹é…ä¸“å±å±æ€§
        // G-Max æ‹›å¼å¨åŠ›é€šå¸¸è¾ƒé«˜ï¼Œå– max(è®¡ç®—å¨åŠ›, 130)
        const maxPower = Math.max(calculateMaxMovePower(basePower, moveType), 130);
        return {
            name: gmaxFactor.move,
            type: moveType,
            power: maxPower,
            isGMax: true,
            cn: gmaxFactor.cn
        };
    }
    // å¤‡ç”¨ï¼šæ£€æŸ¥ GMAX_MOVE_MAPï¼ˆä» moves-data.js åŠ¨æ€æ„å»ºçš„ï¼‰
    const speciesId = getBaseSpeciesId(pokemon);
    if (GMAX_MOVE_MAP[speciesId] && !pokemon.isGenericDynamax) {
        const gmaxData = GMAX_MOVE_MAP[speciesId];
        if (gmaxData.type === moveType) {
            return {
                name: gmaxData.name,
                type: gmaxData.type,
                power: gmaxData.basePower || 130,
                isGMax: true,
                cn: gmaxData.cn || gmaxData.name
            };
        }
    }
    // é€šç”¨ Max æ‹›å¼ (ä» move-constants.js è·å–)
    const maxByType = typeof window !== 'undefined' && window.GENERIC_MAX_BY_TYPE ? window.GENERIC_MAX_BY_TYPE : {};
    const genericMaxName = maxByType[moveType];
    if (genericMaxName) {
        const maxPower = calculateMaxMovePower(basePower, moveType);
        const cnTable = typeof GENERIC_MAX_CN !== 'undefined' ? GENERIC_MAX_CN :
                        (typeof window !== 'undefined' && window.GENERIC_MAX_CN) ? window.GENERIC_MAX_CN : {};
        return {
            name: genericMaxName,
            type: moveType,
            power: maxPower,
            isGMax: false,
            cn: cnTable[genericMaxName] || genericMaxName
        };
    }
    return null;
}
// ============================================
// æå·¨åŒ–çŠ¶æ€ç®¡ç†å‡½æ•°
// ============================================
/**
 * åº”ç”¨æå·¨åŒ–çŠ¶æ€å˜æ¢ï¼ˆæ‹›å¼æ›¿æ¢/å›é€€ï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 */
function applyDynamaxState(pokemon, isActive) {
    if (!pokemon) return;
    // === æ— ææ±°é‚£ (Eternatus) ç‰¹åˆ¤ ===
    // æ— ææ±°é‚£çš„"æå·¨åŒ–"æ˜¯å‰§æƒ…å˜èº«ï¼Œæ‹›å¼ä¿æŒåŸæ ·ï¼ˆä¸éµå¾ª Max Move è§„åˆ™ï¼‰
    const pokeName = (pokemon.name || '').toLowerCase();
    if (pokeName.includes('eternatus')) {
        console.log(`[DYNAMAX] Eternatus detected - Skipping Move Transformation (Boss Logic)`);
        // æ— ææ±°é‚£åªåšè§†è§‰å˜åŒ–ï¼Œä¸æ”¹æ‹›å¼
        if (isActive) {
            pokemon.isEternamax = true;
        } else {
            pokemon.isEternamax = false;
        }
        return;
    }
    if (isActive) {
        // [ON] å¼€å¯æå·¨åŒ–
        console.log(`[DYNAMAX] ${pokemon.name} æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼`);
        // === æ£€æµ‹æ˜¯å¦æœ‰è¶…æå·¨åŒ–å› å­ ===
        const gmaxFactor = getGMaxFactor(pokemon);
        if (gmaxFactor) {
            pokemon.hasGMaxFactor = true;
            console.log(`[DYNAMAX] ${pokemon.name} æ£€æµ‹åˆ°è¶…æå·¨åŒ–å› å­: ${gmaxFactor.move} (${gmaxFactor.type})`);
            // è‡ªåŠ¨è®¾ç½® G-Max ç²¾çµå›¾ URL
            const speciesId = (pokemon.name || '').toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(gmax|mega|gigantamax)$/g, '');
            pokemon.gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani/${speciesId}-gmax.gif`;
            console.log(`[DYNAMAX] G-Max ç²¾çµå›¾ URL: ${pokemon.gmaxSpriteUrl}`);
        } else {
            pokemon.hasGMaxFactor = false;
            pokemon.gmaxSpriteUrl = null;
        }
        // === æ’­æ”¾æå·¨åŒ–å«å£° ===
        if (typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(pokemon.name);
        }
        // 1. å¤‡ä»½åŸå§‹æŠ€èƒ½ (éå¸¸é‡è¦ï¼ä¸ºäº†å›é€€)
        pokemon._originalMoves = JSON.parse(JSON.stringify(pokemon.moves));
        // 2. ä½¿ç”¨è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿç”Ÿæˆæå·¨æ‹›å¼
        pokemon.moves = pokemon._originalMoves.map(m => {
            const maxTarget = getMaxMoveTarget(m, pokemon);
            if (!maxTarget) {
                // æ— æ³•æ¨å¯¼ï¼Œä¿æŒåŸæ ·
                return { ...m, isMax: true };
            }
            const maxMoveId = maxTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
            const MOVES = typeof window !== 'undefined' ? window.MOVES : null;
            const maxMoveData = (MOVES && MOVES[maxMoveId]) ? MOVES[maxMoveId] : {};
            const inheritedCat = m.cat || (maxMoveData.category === 'Physical' ? 'phys' : 'spec');
            return {
                name: maxTarget.name,
                cn: maxTarget.cn || maxMoveData.cn || maxTarget.name,
                type: maxTarget.type,
                power: maxTarget.power,
                basePower: maxTarget.power,
                accuracy: 100,
                pp: 5,
                cat: inheritedCat,
                category: maxMoveData.category || (inheritedCat === 'phys' ? 'Physical' : 'Special'),
                isMax: true,
                isGMax: maxTarget.isGMax
            };
        });
        console.log(`[DYNAMAX] è‡ªåŠ¨æ¨å¯¼æå·¨æ‹›å¼:`, pokemon.moves.map(m => `${m.name}(${m.type}, pow:${m.power}, gmax:${m.isGMax})`));
    } else {
        // [OFF] å…³é—­æå·¨åŒ–
        console.log(`[DYNAMAX] ${pokemon.name} æ‹›å¼æ¢å¤ä¸ºæ™®é€šæ‹›å¼`);
        // æ¸…ç† G-Max ç›¸å…³çŠ¶æ€
        pokemon.hasGMaxFactor = false;
        pokemon.gmaxSpriteUrl = null;
        // è¿˜åŸæŠ€èƒ½
        if (pokemon._originalMoves) {
            pokemon.moves = pokemon._originalMoves;
            delete pokemon._originalMoves;
            console.log(`[DYNAMAX] æ‹›å¼å·²æ¢å¤:`, pokemon.moves.map(m => m.name));
        }
    }
}
/**
 * åº”ç”¨æå·¨åŒ– HP å˜åŒ–
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 * @param {number} multiplier HP å€ç‡ï¼ˆé»˜è®¤ 2ï¼‰
 */
function applyDynamaxHP(pokemon, isActive, multiplier = 2) {
    if (!pokemon) return;
    // === æ— ææ±°é‚£ (Eternatus) æ— æå·¨åŒ–ç‰¹æ®Šå¤„ç† ===
    // æ— æå·¨åŒ–ä¸ä»…æ”¹ HPï¼Œè¿˜æ”¹å…¨å±æ€§ï¼ˆBOSS æ¨¡å¼ï¼‰
    if (pokemon.isEternamax) {
        if (isActive) {
            // å¤‡ä»½åŸå§‹å±æ€§
            pokemon._originalStats = {
                maxHp: pokemon.maxHp,
                currHp: pokemon.currHp,
                atk: pokemon.atk,
                def: pokemon.def,
                spa: pokemon.spa,
                spd: pokemon.spd,
                spe: pokemon.spe
            };
            // æ— æå·¨åŒ–ç§æ—å€¼å˜åŒ–ï¼ˆå®˜æ–¹æ•°æ®ï¼‰
            // HP: 140 -> 255 (çº¦ 1.82x)
            // Atk: 85 -> 115 (çº¦ 1.35x)
            // Def: 95 -> 250 (çº¦ 2.63x)
            // SpA: 145 -> 125 (ä¸‹é™)
            // SpD: 95 -> 250 (çº¦ 2.63x)
            // Spe: 130 -> 130 (ä¸å˜)
            const hpRatio = pokemon.currHp / pokemon.maxHp;
            pokemon.maxHp = Math.floor(pokemon.maxHp * 1.82);
            pokemon.currHp = Math.floor(pokemon.maxHp * hpRatio);
            pokemon.atk = Math.floor(pokemon.atk * 1.35);
            pokemon.def = Math.floor(pokemon.def * 2.63);
            pokemon.spa = Math.floor(pokemon.spa * 0.86); // ç‰¹æ”»ä¸‹é™
            pokemon.spd = Math.floor(pokemon.spd * 2.63);
            // é€Ÿåº¦ä¸å˜
            console.log(`[ETERNAMAX] Boss Mode Activated! Def/SpD Skyrocketed!`);
            console.log(`[ETERNAMAX] HP: ${pokemon._originalStats.currHp}/${pokemon._originalStats.maxHp} -> ${pokemon.currHp}/${pokemon.maxHp}`);
            console.log(`[ETERNAMAX] Def: ${pokemon._originalStats.def} -> ${pokemon.def}, SpD: ${pokemon._originalStats.spd} -> ${pokemon.spd}`);
        } else {
            // è¿˜åŸåŸå§‹å±æ€§
            if (pokemon._originalStats) {
                const hpRatio = pokemon.currHp / pokemon.maxHp;
                pokemon.maxHp = pokemon._originalStats.maxHp;
                pokemon.currHp = Math.max(1, Math.floor(pokemon.maxHp * hpRatio));
                pokemon.atk = pokemon._originalStats.atk;
                pokemon.def = pokemon._originalStats.def;
                pokemon.spa = pokemon._originalStats.spa;
                pokemon.spd = pokemon._originalStats.spd;
                pokemon.spe = pokemon._originalStats.spe;
                delete pokemon._originalStats;
                console.log(`[ETERNAMAX] Boss Mode Deactivated, stats restored`);
            }
        }
        return; // è·³è¿‡å¸¸è§„å¤„ç†
    }
    // === å¸¸è§„æå·¨åŒ– HP å¤„ç† ===
    if (isActive) {
        // å¤‡ä»½åŸå§‹ HP
        pokemon._originalMaxHp = pokemon.maxHp;
        pokemon._originalCurrHp = pokemon.currHp;
        // HP ç¿»å€
        const hpRatio = pokemon.currHp / pokemon.maxHp;
        pokemon.maxHp = Math.floor(pokemon.maxHp * multiplier);
        pokemon.currHp = Math.floor(pokemon.maxHp * hpRatio);
        console.log(`[DYNAMAX] ${pokemon.name} HP: ${pokemon._originalCurrHp}/${pokemon._originalMaxHp} -> ${pokemon.currHp}/${pokemon.maxHp}`);
    } else {
        // æ¢å¤åŸå§‹ HP
        if (pokemon._originalMaxHp) {
            const hpRatio = pokemon.currHp / pokemon.maxHp;
            pokemon.maxHp = pokemon._originalMaxHp;
            pokemon.currHp = Math.max(1, Math.floor(pokemon.maxHp * hpRatio));
            delete pokemon._originalMaxHp;
            delete pokemon._originalCurrHp;
            console.log(`[DYNAMAX] ${pokemon.name} HP æ¢å¤: ${pokemon.currHp}/${pokemon.maxHp}`);
        }
    }
}
/**
 * å®Œæ•´çš„æå·¨åŒ–åˆ‡æ¢ï¼ˆæ‹›å¼ + HPï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isActive true=å¼€å¯æå·¨åŒ–, false=å…³é—­æå·¨åŒ–
 */
function toggleDynamax(pokemon, isActive) {
    if (!pokemon) return;
    applyDynamaxState(pokemon, isActive);
    applyDynamaxHP(pokemon, isActive);
    pokemon.isDynamaxed = isActive;
    if (isActive) {
        pokemon.dynamaxTurns = 3; // æå·¨åŒ–æŒç»­ 3 å›åˆ
    } else {
        pokemon.dynamaxTurns = 0;
    }
}
/**
 * æ¿€æ´»æå·¨åŒ–ï¼ˆç»Ÿä¸€å…¥å£ï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {Object} options é€‰é¡¹ { isEnemy: boolean, justSwitchedIn: boolean }
 * @returns {Object} { success: boolean, hpMultiplier: number }
 */
function activateDynamax(pokemon, options = {}) {
    if (!pokemon) return { success: false };
    const hpMultiplier = 1.5;
    const oldMaxHp = pokemon.maxHp;
    const oldCurrHp = pokemon.currHp;
    // HP å€ç‡
    pokemon.maxHp = Math.floor(oldMaxHp * hpMultiplier);
    pokemon.currHp = Math.floor(oldCurrHp * hpMultiplier);
    // è®¾ç½®æå·¨åŒ–çŠ¶æ€
    pokemon.isDynamaxed = true;
    pokemon.dynamaxTurns = 3;
    pokemon.preDynamaxMaxHp = oldMaxHp;
    pokemon.preDynamaxCurrHp = oldCurrHp;
    // å¦‚æœæ˜¯æ¢å…¥æ—¶æå·¨åŒ–ï¼Œæ ‡è®°è·³è¿‡ç¬¬ä¸€æ¬¡ tick
    if (options.justSwitchedIn) {
        pokemon.dynamaxJustActivated = true;
    }
    // æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼
    applyDynamaxState(pokemon, true);
    console.log(`[DYNAMAX] ${pokemon.name} æ¿€æ´»æå·¨åŒ–: HP ${oldCurrHp}/${oldMaxHp} -> ${pokemon.currHp}/${pokemon.maxHp}`);
    return { success: true, hpMultiplier, oldMaxHp, oldCurrHp };
}
/**
 * å‡å°‘æå·¨åŒ–å›åˆæ•°
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {boolean} æ˜¯å¦åº”è¯¥ç»“æŸæå·¨åŒ–
 */
function tickDynamaxTurn(pokemon) {
    if (!pokemon || !pokemon.isDynamaxed) return false;
    pokemon.dynamaxTurns = (pokemon.dynamaxTurns || 0) - 1;
    if (pokemon.dynamaxTurns <= 0) {
        console.log(`[DYNAMAX] ${pokemon.name} æå·¨åŒ–ç»“æŸ`);
        return true;
    }
    console.log(`[DYNAMAX] ${pokemon.name} æå·¨åŒ–å‰©ä½™ ${pokemon.dynamaxTurns} å›åˆ`);
    return false;
}
/**
 * å¤„ç†æå·¨åŒ–å›åˆç»“æŸï¼ˆç»Ÿä¸€å…¥å£ï¼‰
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {boolean} isPlayer æ˜¯å¦ä¸ºç©å®¶æ–¹
 * @param {Function} logFn æ—¥å¿—å‡½æ•°
 * @returns {Object} { ended: boolean, logs: string[] }
 */
async function processDynamaxEndTurn(pokemon, isPlayer, logFn) {
    const logs = [];
    const log = logFn || console.log;
    if (!pokemon || !pokemon.isAlive() || !pokemon.isDynamaxed || pokemon.dynamaxTurns <= 0) {
        return { ended: false, logs };
    }
    // ã€ä¿®å¤ã€‘å¦‚æœæ˜¯æœ¬å›åˆåˆšæå·¨åŒ–çš„ï¼Œè·³è¿‡è¿™æ¬¡ tick
    if (pokemon.dynamaxJustActivated) {
        delete pokemon.dynamaxJustActivated;
        console.log(`[DYNAMAX] ${isPlayer ? 'ç©å®¶' : 'æ•Œæ–¹'}æœ¬å›åˆåˆšæå·¨åŒ–ï¼Œè·³è¿‡ tick`);
        return { ended: false, logs, skipped: true };
    }
    // å‡å°‘å›åˆæ•°
    pokemon.dynamaxTurns--;
    if (pokemon.dynamaxTurns === 0) {
        // æå·¨åŒ–ç»“æŸ
        const prefix = isPlayer ? '' : 'æ•Œæ–¹çš„ ';
        logs.push(`<b style="color:#94a3b8">âš¡ ${prefix}æå·¨åŒ–èƒ½é‡è€—å°½äº†...</b>`);
        // æ‹›å¼æ¢å¤ä¸ºæ™®é€šæ‹›å¼
        applyDynamaxState(pokemon, false);
        // æ¢å¤åŸå§‹åç§°å’Œä¸­æ–‡å
        if (pokemon.originalName) {
            pokemon.name = pokemon.originalName;
            if (typeof window !== 'undefined' && window.Locale) {
                pokemon.cnName = window.Locale.get(pokemon.originalName);
            } else {
                pokemon.cnName = pokemon.originalName;
            }
            delete pokemon.originalName;
        }
        logs.push(`${prefix}${pokemon.cnName} å˜å›äº†åŸæ¥çš„æ ·å­ã€‚`);
        // æ¢å¤ HP
        const hpRatio = pokemon.currHp / pokemon.maxHp;
        pokemon.maxHp = pokemon.preDynamaxMaxHp || Math.floor(pokemon.maxHp / 1.5);
        pokemon.currHp = Math.max(1, Math.floor(pokemon.maxHp * hpRatio));
        pokemon.isDynamaxed = false;
        delete pokemon.preDynamaxMaxHp;
        delete pokemon.preDynamaxCurrHp;
        return { ended: true, logs };
    } else {
        // è¿˜æœ‰å‰©ä½™å›åˆ
        const prefix = isPlayer ? '' : 'æ•Œæ–¹';
        logs.push(`<span style="color:#ff6b8a">[${prefix}æå·¨åŒ–å‰©ä½™å›åˆ: ${pokemon.dynamaxTurns}]</span>`);
        return { ended: false, logs };
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    // æå·¨æ‹›å¼æ¨å¯¼å‡½æ•°
    window.GMAX_MOVE_MAP = GMAX_MOVE_MAP;
    window.calculateMaxMovePower = calculateMaxMovePower;
    window.getBaseSpeciesId = getBaseSpeciesId;
    window.getGMaxFactor = getGMaxFactor;
    window.getMaxMoveTarget = getMaxMoveTarget;
    // æå·¨åŒ–çŠ¶æ€ç®¡ç†å‡½æ•°
    window.applyDynamaxState = applyDynamaxState;
    window.applyDynamaxHP = applyDynamaxHP;
    window.toggleDynamax = toggleDynamax;
    window.activateDynamax = activateDynamax;
    window.tickDynamaxTurn = tickDynamaxTurn;
    window.processDynamaxEndTurn = processDynamaxEndTurn;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        // æå·¨æ‹›å¼æ¨å¯¼
        GMAX_MOVE_MAP,
        calculateMaxMovePower,
        getBaseSpeciesId,
        getGMaxFactor,
        getMaxMoveTarget,
        // æå·¨åŒ–çŠ¶æ€ç®¡ç†
        applyDynamaxState,
        applyDynamaxHP,
        toggleDynamax,
        tickDynamaxTurn
    };
}
]]></file>
        <file name="mechanic-checker.js"><![CDATA[/**
 * ===========================================
 * MECHANIC-CHECKER.JS - æœºåˆ¶äº’æ–¥æ£€æŸ¥ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥æ¿€æ´»æŒ‡å®šæœºåˆ¶
 * - æœºåˆ¶äº’æ–¥é€»è¾‘ (Mega/Dynamax/Z-Move/Tera)
 * - é“å…·å†²çªæ£€æŸ¥
 */
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥æ¿€æ´»æŒ‡å®šæœºåˆ¶
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @param {string} mechanicType æœºåˆ¶ç±»å‹: 'mega' | 'dynamax' | 'zmove' | 'tera'
 * @returns {boolean} æ˜¯å¦å¯ä»¥æ¿€æ´»
 */
function canActivateMechanic(pokemon, mechanicType) {
    if (!pokemon) return false;
    // 1. å¦‚æœå¤„äºä»»ä½•ä¸€ç§ "Super State"ï¼Œåˆ™ç¦æ­¢å¼€å¯å¦ä¸€ç§
    const inBeastMode = pokemon.isMega || 
                        pokemon.isDynamaxed || 
                        pokemon.hasBondResonance ||
                        pokemon.isTera;
    if (inBeastMode) {
        console.log(`[MECHANIC] ${pokemon.name} å·²å¤„äºç‰¹æ®ŠçŠ¶æ€ï¼Œæ— æ³•æ¿€æ´» ${mechanicType}`);
        return false;
    }
    // 2. æ£€æŸ¥ JSON é…ç½®çš„ç³»ç»Ÿé”
    // å¦‚æœ JSON é‡Œ explicitly è®¾ç½®äº† mechanic: "dynamax"ï¼Œé‚£ä¹ˆå®ƒå°±ä¸èƒ½ Mega
    if (pokemon.mechanic && pokemon.mechanic !== mechanicType) {
        console.log(`[MECHANIC] ${pokemon.name} è¢«é”å®šä¸º ${pokemon.mechanic}ï¼Œæ— æ³•æ¿€æ´» ${mechanicType}`);
        return false;
    }
    // 3. é“å…·å†²çªæ£€æŸ¥
    // Mega çŸ³å’Œ Z çº¯æ™¶äº’æ–¥
    const item = (pokemon.item || '').toLowerCase();
    if (mechanicType === 'zmove' && item.includes('ite') && !item.includes('ium')) {
        // æºå¸¦ Mega çŸ³ï¼ˆå¦‚ Lucarioniteï¼‰æ— æ³•ä½¿ç”¨ Z æ‹›å¼
        console.log(`[MECHANIC] ${pokemon.name} æºå¸¦ Mega çŸ³ï¼Œæ— æ³•ä½¿ç”¨ Z æ‹›å¼`);
        return false;
    }
    if (mechanicType === 'mega' && item.includes('ium z')) {
        // æºå¸¦ Z çº¯æ™¶æ— æ³• Mega
        console.log(`[MECHANIC] ${pokemon.name} æºå¸¦ Z çº¯æ™¶ï¼Œæ— æ³• Mega è¿›åŒ–`);
        return false;
    }
    return true;
}
/**
 * æ£€æŸ¥æ˜¯å¦å¤„äºä»»ä½•ç‰¹æ®ŠçŠ¶æ€
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {boolean} æ˜¯å¦å¤„äºç‰¹æ®ŠçŠ¶æ€
 */
function isInSuperState(pokemon) {
    if (!pokemon) return false;
    return pokemon.isMega || 
           pokemon.isDynamaxed || 
           pokemon.hasBondResonance ||
           pokemon.isTera;
}
/**
 * è·å–å½“å‰æ¿€æ´»çš„æœºåˆ¶ç±»å‹
 * @param {Pokemon} pokemon å®å¯æ¢¦å¯¹è±¡
 * @returns {string|null} 'mega' | 'dynamax' | 'bond' | 'tera' | null
 */
function getActiveMechanic(pokemon) {
    if (!pokemon) return null;
    if (pokemon.isMega) return 'mega';
    if (pokemon.isDynamaxed) return 'dynamax';
    if (pokemon.hasBondResonance) return 'bond';
    if (pokemon.isTera) return 'tera';
    return null;
}
/**
 * æ£€æŸ¥é“å…·æ˜¯å¦ä¸º Mega çŸ³
 * @param {string} itemName é“å…·åç§°
 * @returns {boolean}
 */
function isMegaStoneItem(itemName) {
    if (!itemName) return false;
    const item = itemName.toLowerCase();
    // Mega çŸ³ä»¥ 'ite' ç»“å°¾ï¼Œä½†ä¸æ˜¯ 'eviolite'
    return item.endsWith('ite') && item !== 'eviolite';
}
/**
 * æ£€æŸ¥é“å…·æ˜¯å¦ä¸º Z çº¯æ™¶
 * @param {string} itemName é“å…·åç§°
 * @returns {boolean}
 */
function isZCrystalItem(itemName) {
    if (!itemName) return false;
    const item = itemName.toLowerCase();
    return item.endsWith('iumz') || item.endsWith('iniumz') || item.includes('ium z');
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.canActivateMechanic = canActivateMechanic;
    window.isInSuperState = isInSuperState;
    window.getActiveMechanic = getActiveMechanic;
    window.isMegaStoneItem = isMegaStoneItem;
    window.isZCrystalItem = isZCrystalItem;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        canActivateMechanic,
        isInSuperState,
        getActiveMechanic,
        isMegaStoneItem,
        isZCrystalItem
    };
}
]]></file>
        <file name="mega-evolution.js"><![CDATA[/**
 * =============================================
 * MEGA EVOLUTION SYSTEM
 * =============================================
 * 
 * ä» battle-engine.js è¿ç§»çš„ Mega è¿›åŒ–æ ¸å¿ƒé€»è¾‘
 * 
 * èŒè´£:
 * - å½¢æ€å˜åŒ–èµ„æ ¼æ£€æµ‹ (Mega/Ultra/Primal/Dynamax/Crowned)
 * - Mega è¿›åŒ–æ‰§è¡Œ
 * - éå®˜æ–¹ Mega æ£€æµ‹
 * 
 * ä¾èµ–: pokedex-data.js, battle-engine.js (Pokemon, calcStats, getPokemonData)
 */
/* ==========================================================
 *  æ™ºèƒ½å½¢æ€æ¢æµ‹å™¨ v3 : Zero-Config, Database-Driven
 *  åŸºäº mechanic å­—æ®µå’Œæ•°æ®åº“è‡ªåŠ¨æ£€æµ‹å¯ç”¨å½¢æ€
 * ========================================================== */ 
/**
 * è‡ªåŠ¨æ£€æµ‹å®å¯æ¢¦çš„å½¢æ€å˜åŒ–èµ„æ ¼ï¼ˆMega/Ultra/Primal/Dynamax ç­‰ï¼‰
 * 
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {string|null} explicitFormFlag - JSON ä¸­æ˜¾å¼æŒ‡å®šçš„å½¢æ€ ('x', 'y', 'primal', 'ultra', 'crowned', 'machampgmax' ç­‰)
 */
function autoDetectFormChangeEligibility(pokemon, explicitFormFlag = null) {
    // ä½¿ç”¨è§„èŒƒåŒ–åç§°æŸ¥æ‰¾ POKEDEX
    const normalizedName = typeof normalizePokemonName === 'function' 
        ? normalizePokemonName(pokemon.name) 
        : pokemon.name;
    const baseId = normalizedName.toLowerCase().replace(/[^a-z0-9]/g, '');
    const data = typeof POKEDEX !== 'undefined' ? POKEDEX[baseId] : null;
    // è·å–ç©å®¶åœ¨ JSON é…ç½®é‡ŒæŒ‡å®šçš„"æ„æ„¿" (Mechanic Lock)
    const desiredMechanic = pokemon.mechanic || 'any'; // 'mega', 'dynamax', 'zmove', 'any'(Auto)
    console.log(`[FORM] Auto-Scan for ${pokemon.name} (baseId: ${baseId}), mechanic: ${desiredMechanic}, hasData: ${!!data}`);
    // ========================================
    // æ­¥éª¤ 1ï¼šæ‰«ææ•°æ®åº“çš„æ‰€æœ‰å½¢æ€æ ‘
    // ========================================
    let avail = {
        mega: [],
        gmax: [],
        primal: null,
        ultra: null,
        crowned: null
    };
    // ä» otherFormes æ”¶é›†
    if (data && data.otherFormes) {
        for (const formeName of data.otherFormes) {
            const formeId = formeName.toLowerCase().replace(/[^a-z0-9]/g, '');
            if (formeId.includes('gmax') || formeId.includes('gigantamax')) {
                avail.gmax.push(formeId);
            } else if (formeName.includes('Mega') && formeId.match(/mega[xy]?$/)) {
                avail.mega.push(formeId);
            } else if (formeName.includes('Primal')) {
                avail.primal = formeId;
            } else if (formeName.includes('Ultra')) {
                avail.ultra = formeId;
            } else if (formeName.includes('Crowned')) {
                avail.crowned = formeId;
            }
        }
    }
    // æ¿€è¿›æ¢æµ‹ï¼šå°è¯•æ‹¼æ¥ IDï¼ˆæ•°æ®åº“å¯èƒ½æ²¡æœ‰ otherFormes ä½†æœ‰å®é™…æ•°æ®ï¼‰
    const guessedGmaxId = baseId + 'gmax';
    const guessedMegaId = baseId + 'mega';
    if (avail.gmax.length === 0 && typeof POKEDEX !== 'undefined' && POKEDEX[guessedGmaxId]) {
        avail.gmax.push(guessedGmaxId);
    }
    if (avail.mega.length === 0 && typeof POKEDEX !== 'undefined' && POKEDEX[guessedMegaId]) {
        avail.mega.push(guessedMegaId);
    }
    // åŒ Mega ç™½åå•
    const KNOWN_DUAL_MEGAS = ['charizard', 'mewtwo'];
    const hasDualMega = (avail.mega.length >= 2) && KNOWN_DUAL_MEGAS.includes(baseId);
    console.log(`[FORM] Available forms:`, avail);
    // ========================================
    // æ­¥éª¤ 2ï¼šåŸå§‹å›å½’ / Crowned - ç«‹å³å›ºåŒ–
    // ========================================
    if (avail.primal && typeof POKEDEX !== 'undefined' && POKEDEX[avail.primal]) {
        pokemon.isPrimal = true;
        pokemon.primalTargetId = avail.primal;
        pokemon.needsInitTransform = true;
        pokemon.initTransformTarget = avail.primal;
        pokemon.initTransformType = 'primal';
    }
    if (avail.crowned && typeof POKEDEX !== 'undefined' && POKEDEX[avail.crowned]) {
        pokemon.isCrowned = true;
        pokemon.crownedTargetId = avail.crowned;
        pokemon.needsInitTransform = true;
        pokemon.initTransformTarget = avail.crowned;
        pokemon.initTransformType = 'crowned';
    }
    // ===================================
    //  å†³ç­–åŒº: æ ¹æ® mechanic å†³å®š Target
    // ===================================
    // ğŸ‘‰ åœºæ™¯ A: æ˜ç¡®æƒ³è¦æå·¨åŒ– (mechanic='dynamax')
    if (desiredMechanic === 'dynamax') {
        // ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·åœ¨ JSON ä¸­æ˜¾å¼æŒ‡å®šçš„ mega/mega_target å­—æ®µ
        if (pokemon.megaTargetId && pokemon.megaTargetId.includes('gmax')) {
            // ç”¨æˆ·å·²ç»æŒ‡å®šäº† G-Max å½¢æ€ï¼Œç›´æ¥ä½¿ç”¨
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            console.log(`[FORM] Using explicit G-Max target: ${pokemon.megaTargetId}`);
        } else if (avail.gmax.length > 0) {
            // æ‰¾åˆ°æ­£ç‰ˆ Gmax æ•°æ®
            pokemon.megaTargetId = avail.gmax[0];
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            console.log(`[FORM] Locked Dynamax target: ${pokemon.megaTargetId}`);
        } else {
            // æ²¡æœ‰ GMax æ•°æ®ï¼Œèµ°é€šç”¨æå·¨åŒ– (Non-GMax Dynamax)
            pokemon.megaTargetId = guessedGmaxId; // è™šæ‹Ÿ IDï¼Œä¾›å›¾ç‰‡åŠ è½½å°è¯•
            pokemon.canMegaEvolve = true;
            pokemon.canDynamax = true;
            pokemon.evolutionType = 'dynamax';
            pokemon.isGenericDynamax = true; // æ ‡è®°ä¸ºé€šç”¨æå·¨åŒ–
            console.log(`[FORM] Generic Dynamax (No G-Form in DB) target: ${pokemon.megaTargetId}`);
        }
        return;
    }
    // ğŸ‘‰ åœºæ™¯ B: æ˜ç¡®æƒ³è¦ Mega (mechanic='mega')
    if (desiredMechanic === 'mega') {
        if (avail.mega.length > 0) {
            const validMegaForms = avail.mega.filter(f => typeof POKEDEX !== 'undefined' && POKEDEX[f]);
            if (validMegaForms.length > 0) {
                if (hasDualMega && validMegaForms.length >= 2) {
                    pokemon.hasDualMega = true;
                    pokemon.megaFormsAvailable = validMegaForms;
                    pokemon.megaTargetId = validMegaForms.find(f => f.endsWith('x')) || validMegaForms[0];
                } else {
                    pokemon.megaTargetId = validMegaForms[0];
                }
                pokemon.canMegaEvolve = true;
                pokemon.evolutionType = 'mega';
                console.log(`[FORM] Locked Mega target: ${pokemon.megaTargetId}`);
                return;
            }
        }
        // æ²¡æœ‰ Mega æ•°æ®ï¼Œç¦ç”¨
        pokemon.canMegaEvolve = false;
        console.log(`[FORM] ${pokemon.name} has no Mega form - Mega DISABLED`);
        return;
    }
    // ğŸ‘‰ åœºæ™¯ C: Z æ‹›å¼æ¨¡å¼ (mechanic='zmove')
    if (desiredMechanic === 'zmove') {
        // Z æ‹›å¼ä¸éœ€è¦å½¢æ€å˜åŒ–ï¼Œä½†ç¦æ­¢ Mega/Dynamax
        pokemon.canMegaEvolve = false;
        pokemon.canDynamax = false;
        console.log(`[FORM] ${pokemon.name} locked to Z-Move - form changes DISABLED`);
        return;
    }
    if (desiredMechanic === 'tera') {
        // å¤ªæ™¶åŒ–ä¸éœ€è¦å½¢æ€å˜åŒ–ï¼Œç¦æ­¢è‡ªåŠ¨æ£€æµ‹ Mega/Dynamax
        pokemon.canMegaEvolve = false;
        pokemon.canDynamax = false;
        console.log(`[FORM] ${pokemon.name} locked to Tera - form changes DISABLED`);
        return;
    }
    // ğŸ‘‰ åœºæ™¯ D: è‡ªåŠ¨æŒ¡ (mechanic ä¸å¡«æˆ– 'any')
    // ä¼˜å…ˆ Megaï¼ˆå› ä¸º Mega æ”¹å˜ç§æ—ç‰¹æ€§æ›´æ˜æ˜¾ï¼‰ï¼Œæ²¡ Mega çœ‹èƒ½ä¸èƒ½ GMax
    if (avail.ultra && typeof POKEDEX !== 'undefined' && POKEDEX[avail.ultra]) {
        pokemon.megaTargetId = avail.ultra;
        pokemon.canMegaEvolve = true;
        pokemon.evolutionType = 'ultra';
        console.log(`[FORM] Auto-detected Ultra: ${pokemon.megaTargetId}`);
    } else if (avail.mega.length > 0) {
        // ã€ä¿®å¤ã€‘åªæœ‰æºå¸¦å¯¹åº” Mega çŸ³çš„å®å¯æ¢¦æ‰èƒ½è‡ªåŠ¨æ£€æµ‹ Mega
        const pokemonItem = (pokemon.item || '').toLowerCase().replace(/[^a-z]/g, '');
        const validMegaForms = avail.mega.filter(f => {
            if (typeof POKEDEX === 'undefined' || !POKEDEX[f]) return false;
            const megaData = POKEDEX[f];
            // æ£€æŸ¥æ˜¯å¦æºå¸¦å¯¹åº”çš„ Mega çŸ³
            const requiredItem = (megaData.requiredItem || '').toLowerCase().replace(/[^a-z]/g, '');
            return requiredItem && pokemonItem === requiredItem;
        });
        if (validMegaForms.length > 0) {
            if (hasDualMega && validMegaForms.length >= 2) {
                pokemon.hasDualMega = true;
                pokemon.megaFormsAvailable = validMegaForms;
            }
            pokemon.megaTargetId = validMegaForms.find(f => f.endsWith('x')) || validMegaForms[0];
            pokemon.canMegaEvolve = true;
            pokemon.evolutionType = 'mega';
            console.log(`[FORM] Auto-detected Mega (with item): ${pokemon.megaTargetId}`);
        } else {
            // æ²¡æœ‰æºå¸¦ Mega çŸ³ï¼Œç¦ç”¨è‡ªåŠ¨ Mega
            pokemon.canMegaEvolve = false;
            console.log(`[FORM] ${pokemon.name} has Mega form but no Mega Stone - Mega DISABLED`);
        }
    } else if (avail.gmax.length > 0) {
        // åªæœ‰ä¸“å± GMax çš„æ‰è‡ªåŠ¨æ¿€æ´»ï¼Œé€šç”¨æå·¨åŒ–éœ€è¦æ‰‹åŠ¨æŒ‡å®š mechanic
        pokemon.megaTargetId = avail.gmax[0];
        pokemon.canMegaEvolve = true;
        pokemon.canDynamax = true;
        pokemon.evolutionType = 'dynamax';
        console.log(`[FORM] Auto-detected GMax: ${pokemon.megaTargetId}`);
    } else {
        pokemon.canMegaEvolve = false;
        pokemon.canFormChange = false;
        console.log(`[FORM] ${pokemon.name} has NO form changes available`);
    }
}
// å‘åå…¼å®¹åˆ«å
const autoDetectMegaEligibility = autoDetectFormChangeEligibility;
/**
 * æ£€æŸ¥æ˜¯å¦ä¸ºéå®˜æ–¹ Megaï¼ˆåŠ¨æ€æ£€æµ‹ï¼‰
 * ä¸å†ä½¿ç”¨ç¡¬ç¼–ç åˆ—è¡¨ï¼
 * å®é™…æ£€æµ‹åœ¨ smartLoadSprite ä¸­è¿›è¡Œï¼šå½“æ‰€æœ‰ç²¾çµå›¾å›é€€éƒ½å¤±è´¥æ—¶ï¼Œè‡ªåŠ¨åˆ¤æ–­ä¸ºéå®˜æ–¹ Mega
 */
function isUnofficialMega(megaTargetId) {
    // ä¸å†é¢„åˆ¤ï¼Œè®© smartLoadSprite çš„å›é€€æœºåˆ¶æ¥åŠ¨æ€æ£€æµ‹
    return false;
}
/**
 * æ‰§è¡Œ Mega è¿›åŒ– (å¼•æ“å±‚é¢)
 * @param {Pokemon} pokemon - è¦è¿›åŒ–çš„å®å¯æ¢¦
 * @returns {object|null} - è¿›åŒ–ç»“æœä¿¡æ¯ï¼Œæˆ– null å¦‚æœå¤±è´¥
 */
function performMegaEvolution(pokemon) {
    if (!pokemon.canMegaEvolve || pokemon.isMega || !pokemon.megaTargetId) {
        return null;
    }
    const megaData = typeof getPokemonData === 'function' 
        ? getPokemonData(pokemon.megaTargetId)
        : null;
    if (!megaData) {
        console.warn(`[MEGA] Mega form data not found: ${pokemon.megaTargetId}`);
        return null;
    }
    // æ£€æµ‹æ˜¯å¦ä¸ºéå®˜æ–¹ Mega
    const isUnofficial = isUnofficialMega(pokemon.megaTargetId);
    if (isUnofficial) {
        console.log(`[MEGA] Detected unofficial Mega: ${pokemon.megaTargetId} (Radical Red / ROM Hack)`);
        pokemon.isUnofficialMega = true;
    }
    // ä¿å­˜æ—§æ•°æ®ç”¨äºæ—¥å¿—
    const oldName = pokemon.cnName;
    const oldTypes = [...pokemon.types];
    const oldAbility = pokemon.ability;
    // æ›´æ–°åŸºç¡€æ•°æ®
    pokemon.name = megaData.name;
    // [BUG FIX] å¼ºåˆ¶åˆ·æ–°ä¸­æ–‡åï¼Œé˜²æ­¢å˜å›è‹±æ–‡
    if (typeof window !== 'undefined' && window.Locale) {
        // å…ˆå°è¯•æŸ¥å…¨å "Lucario-Mega" => "è¶…çº§è·¯å¡åˆ©æ¬§"
        let cn = window.Locale.get(megaData.name);
        // å¦‚æœæŸ¥ä¸åˆ°ç¿»è¯‘(è¿˜æ˜¯è‹±æ–‡)ï¼Œå°è¯•æ™ºèƒ½æ‹¼è£…: "è¶…çº§" + åŸºç¡€å
        if (cn === megaData.name) {
            const baseCn = window.Locale.get(pokemon.name.split('-')[0]);
            cn = `è¶…çº§${baseCn}`;
        }
        pokemon.cnName = cn;
    } else {
        pokemon.cnName = megaData.name;
    }
    pokemon.types = megaData.types || pokemon.types;
    pokemon.baseStats = megaData.baseStats;
    // è·å– Mega å½¢æ€çš„ç‰¹æ€§
    // ã€ä¿®å¤ã€‘å¦‚æœç”¨æˆ·åœ¨ JSON ä¸­è‡ªå®šä¹‰äº†ç‰¹æ€§ï¼ˆéé»˜è®¤ç‰¹æ€§ï¼‰ï¼Œåˆ™ä¿ç•™ç”¨æˆ·ç‰¹æ€§
    const megaPokedexData = typeof POKEDEX !== 'undefined' ? POKEDEX[pokemon.megaTargetId] : null;
    const basePokedexData = typeof POKEDEX !== 'undefined' ? POKEDEX[pokemon.megaTargetId.replace(/mega[xy]?$/, '')] : null;
    const isCustomAbility = basePokedexData && basePokedexData.abilities && 
        !Object.values(basePokedexData.abilities).includes(oldAbility);
    if (isCustomAbility) {
        // ç”¨æˆ·è‡ªå®šä¹‰äº†ç‰¹æ€§ï¼ˆå¦‚ Magic Guardï¼‰ï¼Œä¿ç•™ä¸è¦†ç›–
        console.log(`[MEGA] Preserving custom ability: ${oldAbility}`);
    } else if (megaPokedexData && megaPokedexData.abilities) {
        pokemon.ability = megaPokedexData.abilities['0'] || megaPokedexData.abilities['H'] || pokemon.ability;
    }
    // é‡æ–°è®¡ç®—èƒ½åŠ›å€¼ (HP ä¸å˜!)
    const oldHp = pokemon.currHp;
    const oldMaxHp = pokemon.maxHp;
    let autoEv = Math.floor(pokemon.level * 1.5);
    if (autoEv > 85) autoEv = 85;
    const newStats = typeof calcStats === 'function'
        ? calcStats(megaData.baseStats, pokemon.level, 31, autoEv)
        : megaData.baseStats;
    // HP ä¿æŒä¸å˜ (Mega è¿›åŒ–çš„æ ¸å¿ƒè§„åˆ™)
    // pokemon.maxHp = oldMaxHp; // ä¸å˜
    // pokemon.currHp = oldHp;   // ä¸å˜
    // æ›´æ–°å…¶ä»–èƒ½åŠ›å€¼
    pokemon.atk = newStats.atk;
    pokemon.def = newStats.def;
    pokemon.spa = newStats.spa;
    pokemon.spd = newStats.spd;
    pokemon.spe = newStats.spe;
    // æ ‡è®°å·² Mega è¿›åŒ–
    pokemon.isMega = true;
    pokemon.canMegaEvolve = false;
    // === æ’­æ”¾ Mega è¿›åŒ–å«å£° ===
    if (typeof window !== 'undefined' && typeof window.playPokemonCry === 'function') {
        window.playPokemonCry(pokemon.name);
    }
    return {
        oldName,
        newName: pokemon.cnName,
        oldTypes,
        newTypes: pokemon.types,
        oldAbility,
        newAbility: pokemon.ability,
        typeChanged: JSON.stringify(oldTypes) !== JSON.stringify(pokemon.types),
        abilityChanged: oldAbility !== pokemon.ability
    };
}
/**
 * æ£€æŸ¥å®å¯æ¢¦æ˜¯å¦å¯ä»¥ Mega è¿›åŒ–
 * @param {Pokemon} pokemon
 * @returns {boolean}
 */
function canMegaEvolve(pokemon) {
    return pokemon && pokemon.canMegaEvolve && !pokemon.isMega && pokemon.megaTargetId;
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
if (typeof window !== 'undefined') {
    window.autoDetectFormChangeEligibility = autoDetectFormChangeEligibility;
    window.autoDetectMegaEligibility = autoDetectMegaEligibility;
    window.performMegaEvolution = performMegaEvolution;
    window.canMegaEvolve = canMegaEvolve;
    window.isUnofficialMega = isUnofficialMega;
}
// å¯¼å‡ºä¸ºæ¨¡å—ï¼ˆå¦‚æœæ”¯æŒï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        autoDetectFormChangeEligibility,
        autoDetectMegaEligibility,
        performMegaEvolution,
        canMegaEvolve,
        isUnofficialMega
    };
}
]]></file>
        <file name="move-styles.js"><![CDATA[/**
 * ===========================================
 * MOVE-STYLES.JS - å¤æ­¦ç³»ç»Ÿï¼ˆæ‹›å¼é£æ ¼ï¼‰
 * ===========================================
 * 
 * èŒè´£:
 * - æ‹›å¼é£æ ¼çŠ¶æ€ç®¡ç† (é“/è¿…/åˆš)
 * - é£æ ¼åˆ‡æ¢ UI æ›´æ–°
 * - å†·å´çŠ¶æ€æ˜¾ç¤º
 */
// ============================================
// çŠ¶æ€ä¸å¸¸é‡
// ============================================
// å½“å‰é€‰æ‹©çš„æ‹›å¼é£æ ¼
let currentMoveStyle = 'normal';
// é£æ ¼åºåˆ—
const STYLE_SEQUENCE = ['normal', 'agile', 'strong'];
// é£æ ¼æ ‡ç­¾ï¼ˆä¸­æ–‡æ˜¾ç¤ºï¼‰
const STYLE_LABELS = {
    normal: 'é“',
    agile: 'è¿…',
    strong: 'åˆš'
};
// ============================================
// æ ¸å¿ƒå‡½æ•°
// ============================================
/**
 * è®¾ç½®å½“å‰æ‹›å¼é£æ ¼
 * @param {string} style - 'normal' | 'agile' | 'strong'
 * @param {{silent?: boolean, animate?: boolean}} options
 */
function setMoveStyle(style, options = {}) {
    if (!STYLE_SEQUENCE.includes(style)) style = 'normal';
    const prev = currentMoveStyle;
    currentMoveStyle = style;
    const orb = document.getElementById('btn-style-taiji');
    const label = document.getElementById('taiji-text');
    if (orb) {
        STYLE_SEQUENCE.forEach(cls => orb.classList.remove(cls));
        orb.classList.add(style);
        // ã€å†·å´çŠ¶æ€ã€‘æ£€æŸ¥æ˜¯å¦åœ¨å†·å´ä¸­ï¼Œå¦‚æœæ˜¯åˆ™æ·»åŠ  disabled æ ·å¼
        // éœ€è¦è®¿é—®å…¨å±€ battle å¯¹è±¡
        const battle = typeof window !== 'undefined' ? window.battle : null;
        if (battle && battle.playerStyleCooldown > 0) {
            orb.classList.add('cooldown');
            orb.style.opacity = '0.4';
            orb.style.filter = 'grayscale(80%)';
            orb.style.pointerEvents = 'none';
        } else {
            orb.classList.remove('cooldown');
            orb.style.opacity = '';
            orb.style.filter = '';
            orb.style.pointerEvents = '';
        }
    }
    if (label) {
        const nextChar = STYLE_LABELS[style] || 'é“';
        // ã€å†·å´çŠ¶æ€ã€‘å†·å´ä¸­æ˜¾ç¤ºç‰¹æ®Šå­—ç¬¦
        const battle = typeof window !== 'undefined' ? window.battle : null;
        const displayChar = (battle && battle.playerStyleCooldown > 0) ? 'ä¼‘' : nextChar;
        if (options.animate !== false && prev !== style) {
            animateTaijiText(label, displayChar);
        } else {
            label.textContent = displayChar;
        }
    }
    if (!options.silent) {
        console.log(`[STYLES] æ‹›å¼é£æ ¼åˆ‡æ¢ä¸º: ${style}`);
    }
}
/**
 * æ›´æ–°é£æ ¼æŒ‰é’®çš„å†·å´çŠ¶æ€æ˜¾ç¤º
 */
function updateStyleButtonCooldown() {
    const orb = document.getElementById('btn-style-taiji');
    const label = document.getElementById('taiji-text');
    if (!orb) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const isCooldown = battle && battle.playerStyleCooldown > 0;
    if (isCooldown) {
        orb.classList.add('cooldown');
        orb.style.opacity = '0.4';
        orb.style.filter = 'grayscale(80%)';
        orb.style.pointerEvents = 'none';
        if (label) label.textContent = 'ä¼‘';
    } else {
        orb.classList.remove('cooldown');
        orb.style.opacity = '';
        orb.style.filter = '';
        orb.style.pointerEvents = '';
        if (label) label.textContent = STYLE_LABELS[currentMoveStyle] || 'é“';
    }
}
/**
 * æ–‡å­—åˆ‡æ¢åŠ¨ç”»
 */
function animateTaijiText(el, newChar) {
    if (!el) return;
    el.style.transition = 'transform 0.15s ease, opacity 0.15s ease';
    el.style.transform = 'skewX(15deg) scale(0)';
    el.style.opacity = '0';
    setTimeout(() => {
        el.textContent = newChar;
        el.style.transform = 'skewX(15deg) scale(1.2)';
        el.style.opacity = '1';
        setTimeout(() => {
            el.style.transform = 'skewX(15deg) scale(1)';
        }, 150);
    }, 150);
}
/**
 * å¾ªç¯åˆ‡æ¢é£æ ¼ï¼šnormal -> agile -> strong -> normal
 */
function cycleMoveStyle() {
    const idx = STYLE_SEQUENCE.indexOf(currentMoveStyle);
    const nextStyle = STYLE_SEQUENCE[(idx + 1) % STYLE_SEQUENCE.length];
    setMoveStyle(nextStyle);
}
/**
 * è·å–å½“å‰æ‹›å¼é£æ ¼
 * @returns {string} 'normal' | 'agile' | 'strong'
 */
function getCurrentMoveStyle() {
    return currentMoveStyle;
}
/**
 * é‡ç½®æ‹›å¼é£æ ¼ä¸ºé»˜è®¤
 */
function resetMoveStyle() {
    currentMoveStyle = 'normal';
    setMoveStyle('normal', { silent: true, animate: false });
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.currentMoveStyle = currentMoveStyle;
    window.STYLE_SEQUENCE = STYLE_SEQUENCE;
    window.STYLE_LABELS = STYLE_LABELS;
    window.setMoveStyle = setMoveStyle;
    window.updateStyleButtonCooldown = updateStyleButtonCooldown;
    window.animateTaijiText = animateTaijiText;
    window.cycleMoveStyle = cycleMoveStyle;
    window.getCurrentMoveStyle = getCurrentMoveStyle;
    window.resetMoveStyle = resetMoveStyle;
    // ä½¿ç”¨ getter ä¿æŒ currentMoveStyle åŒæ­¥
    Object.defineProperty(window, 'currentMoveStyle', {
        get: () => currentMoveStyle,
        set: (val) => { currentMoveStyle = val; }
    });
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        STYLE_SEQUENCE,
        STYLE_LABELS,
        setMoveStyle,
        updateStyleButtonCooldown,
        animateTaijiText,
        cycleMoveStyle,
        getCurrentMoveStyle,
        resetMoveStyle,
        get currentMoveStyle() { return currentMoveStyle; },
        set currentMoveStyle(val) { currentMoveStyle = val; }
    };
}
]]></file>
        <file name="z-moves.js"><![CDATA[/**
 * ===========================================
 * Z-MOVES.JS - Z æ‹›å¼æ¨å¯¼ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - Z æ‹›å¼æ¨å¯¼ (é€šç”¨ Z / ä¸“å± Z)
 * - Z æ‹›å¼æ˜ å°„è¡¨ç®¡ç†
 * 
 * æ³¨æ„ï¼šæå·¨åŒ–ç›¸å…³åŠŸèƒ½å·²è¿ç§»è‡³ mechanics/dynamax.js
 */
// ============================================
// Z æ‹›å¼æ•°æ®è¡¨
// ============================================
// é€šç”¨å±æ€§ Z æ‹›å¼è¡¨ (Type -> Z-Move Name)
const GENERIC_Z_BY_TYPE = {
    'Normal': 'Breakneck Blitz', 'Fire': 'Inferno Overdrive', 'Water': 'Hydro Vortex',
    'Grass': 'Bloom Doom', 'Electric': 'Gigavolt Havoc', 'Ice': 'Subzero Slammer',
    'Fighting': 'All-Out Pummeling', 'Poison': 'Acid Downpour', 'Ground': 'Tectonic Rage',
    'Flying': 'Supersonic Skystrike', 'Psychic': 'Shattered Psyche', 'Bug': 'Savage Spin-Out',
    'Rock': 'Continental Crush', 'Ghost': 'Never-Ending Nightmare', 'Dragon': 'Devastating Drake',
    'Dark': 'Black Hole Eclipse', 'Steel': 'Corkscrew Crash', 'Fairy': 'Twinkle Tackle'
};
// ============================================
// ä¸“å± Z çŸ©é˜µ (Signature Z Matrix)
// æ ¼å¼: "basemove+species" => "Z-Move Name"
// ============================================
const SIGNATURE_Z_MATRIX = {
    // çš®å¡ä¸˜ç³»
    'thunderbolt+pikachu': '10,000,000 Volt Thunderbolt',
    'volttackle+pikachu': 'Catastropika',
    'thunderbolt+raichu': 'Stoked Sparksurfer',
    'thunderbolt+raichualola': 'Stoked Sparksurfer',
    // ä¼Šå¸ƒ
    'lastresort+eevee': 'Extreme Evoboost',
    // å¡æ¯”å…½
    'gigaimpact+snorlax': 'Pulverizing Pancake',
    // å¾¡ä¸‰å®¶
    'darkestlariat+incineroar': 'Malicious Moonsault',
    'sparklingaria+primarina': 'Oceanic Operetta',
    'spiritshackle+decidueye': 'Sinister Arrow Raid',
    // ä¼ è¯´/ç¥å…½
    'photongeyser+necrozma': 'Light That Burns the Sky',
    'sunsteelstrike+solgaleo': 'Searing Sunraze Smash',
    'moongeistbeam+lunala': 'Menacing Moonraze Maelstrom',
    'spectralthief+marshadow': 'Soul-Stealing 7-Star Strike',
    'clangingscales+kommoo': 'Clangorous Soulblaze',
    'psychic+mew': 'Genesis Supernova',
    // å…¶ä»–
    'playrough+mimikyu': "Let's Snuggle Forever",
    'stoneedge+lycanroc': 'Splintered Stormshards',
    'naturesmadness+tapukoko': 'Guardian of Alola',
    'naturesmadness+tapulele': 'Guardian of Alola',
    'naturesmadness+tapubulu': 'Guardian of Alola',
    'naturesmadness+tapufini': 'Guardian of Alola'
};
// ============================================
// ä¸“å± Z ä¼˜å…ˆçº§è¡¨ (è¶Šé å‰ä¼˜å…ˆçº§è¶Šé«˜)
// ç”¨äºè§£å†³åŒä¸€åªå®å¯æ¢¦æœ‰å¤šä¸ªä¸“å± Z æ—¶çš„å†²çª
// ============================================
const SIGNATURE_Z_PRIORITY = [
    '10,000,000 Volt Thunderbolt', // æ™ºçš® Z (æœ€é«˜ä¼˜å…ˆçº§)
    'Catastropika',                 // çš®å¡ Z
    'Stoked Sparksurfer',           // é›·ä¸˜ Z
    'Extreme Evoboost',             // ä¼Šå¸ƒ Z
    'Clangorous Soulblaze',         // æ–å°¾é³ç”²é¾™ Z
    'Light That Burns the Sky',     // å¥ˆå…‹æ´›å…¹ç› Z
    'Searing Sunraze Smash',        // ç´¢å°”è¿¦é›·æ¬§ Z
    'Menacing Moonraze Maelstrom',  // éœ²å¥ˆé›…æ‹‰ Z
    'Soul-Stealing 7-Star Strike',  // ç›å¤å¤š Z
    'Malicious Moonsault',          // ç‚½ç„°å’†å“®è™ Z
    'Oceanic Operetta',             // è¥¿ç‹®æµ·å£¬ Z
    'Sinister Arrow Raid',          // ç‹™å°„æ ‘æ­ Z
    'Genesis Supernova',            // æ¢¦å¹» Z
    "Let's Snuggle Forever",        // è°œæ‹ŸQ Z
    'Splintered Stormshards',       // é¬ƒå²©ç‹¼äºº Z
    'Guardian of Alola',            // å¡ç’ Z
    'Pulverizing Pancake'           // å¡æ¯”å…½ Z
];
// ============================================
// åŠ¨æ€ç”Ÿæˆçš„æ˜ å°„è¡¨
// ============================================
// ä¸“å± Z æ‹›å¼åæŸ¥è¡¨ (BaseMove ID -> Z-Move Data)
const EXCLUSIVE_Z_MAP = {};
// ============================================
// åˆå§‹åŒ–ï¼šä»æ•°æ®åº“æ„å»º Z æ‹›å¼åæŸ¥è¡¨
// ============================================
(function buildZMoveMaps() {
    if (typeof MOVES === 'undefined') {
        console.warn('[Z-MOVES] MOVES database not loaded');
        return;
    }
    // ä¸“å± Z æ‹›å¼çš„ baseMove æ˜ å°„ (æ‰‹åŠ¨ç»´æŠ¤ï¼Œå› ä¸ºæ•°æ®åº“æ²¡æœ‰è¿™ä¸ªå­—æ®µ)
    const EXCLUSIVE_Z_BASE_MOVES = {
        '10000000voltthunderbolt': 'thunderbolt',
        'catastropika': 'volttackle',
        'stokedsparksurfer': 'thunderbolt',
        'extremeevoboost': 'lastresort',
        'oceanicoperetta': 'sparklingaria',
        'maliciousmoonsault': 'darkestlariat',
        'soulstealing7starstrike': 'spectralthief',
        'sinisterarrowraid': 'spiritshackle',
        'clangoroussoulblaze': 'clangingscales',
        'lightthatburnsthesky': 'photongeyser',
        'searingsunrazesmash': 'sunsteelstrike',
        'menacingmoonrazemaelstrom': 'moongeistbeam',
        'letssnuggleforever': 'playrough',
        'splinteredstormshards': 'stoneedge',
        'pulverizingpancake': 'gigaimpact',
        'genesis supernova': 'psychic'
    };
    // éå†æ‰€æœ‰æ‹›å¼ï¼Œæ„å»ºä¸“å± Z æ‹›å¼åæŸ¥è¡¨
    for (const moveId in MOVES) {
        const moveData = MOVES[moveId];
        if (moveData.isZ && typeof moveData.isZ === 'string') {
            const baseMove = EXCLUSIVE_Z_BASE_MOVES[moveId];
            if (baseMove) {
                EXCLUSIVE_Z_MAP[baseMove] = {
                    name: moveData.name,
                    id: moveId,
                    type: moveData.type,
                    basePower: moveData.basePower || 180,
                    zCrystal: moveData.isZ
                };
            }
        }
    }
    console.log('[Z-MOVES] Built EXCLUSIVE_Z_MAP:', Object.keys(EXCLUSIVE_Z_MAP).length, 'entries');
})();
// ============================================
// Z æ‹›å¼æ¨å¯¼å‡½æ•°
// ============================================
/**
 * è®¡ç®—å®å¯æ¢¦çš„"å‘½ä¸­æ³¨å®šä¸“å± Z"ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªï¼‰
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {string|null} æœ€é«˜ä¼˜å…ˆçº§çš„ä¸“å± Z åç§°ï¼Œæˆ– null
 */
function calculateBestZForPokemon(pokemon) {
    // ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤è®¡ç®—
    if (pokemon._cachedBestZ !== undefined) return pokemon._cachedBestZ;
    const speciesId = (pokemon.name || '').toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(partner|alola|galar|gmax|mega|cap)/g, '');
    let bestFound = null;
    let highestPrio = Infinity;
    // éå†ç²¾çµæ‰€æœ‰æ‹›å¼ï¼Œæ‰¾å‡ºä¼˜å…ˆçº§æœ€é«˜çš„ä¸“å± Z
    (pokemon.moves || []).forEach(m => {
        const moveId = (m.name || m || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        const matrixKey = `${moveId}+${speciesId}`;
        const targetZName = SIGNATURE_Z_MATRIX[matrixKey];
        if (targetZName) {
            let prio = SIGNATURE_Z_PRIORITY.indexOf(targetZName);
            if (prio === -1) prio = 999; // æœªæ’åºçš„é»˜è®¤å¾ˆä½
            if (prio < highestPrio) {
                highestPrio = prio;
                bestFound = targetZName;
            }
        }
    });
    // ç¼“å­˜ç»“æœ
    pokemon._cachedBestZ = bestFound;
    return bestFound;
}
/**
 * è·å–æ‹›å¼å¯¹åº”çš„ Z æ‹›å¼åç§° (å•ä¸€ Z é”å®šç­–ç•¥)
 * @param {Object} baseMoveObj - åŸå§‹æ‹›å¼å¯¹è±¡
 * @param {Object} pokemon - å®å¯æ¢¦å¯¹è±¡
 * @returns {Object|null} Z æ‹›å¼ä¿¡æ¯ { name, type, power } æˆ– null
 */
function getZMoveTarget(baseMoveObj, pokemon) {
    // 0. åŸºç¡€é—¨æ§›
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (battle && battle.playerUnlocks && !battle.playerUnlocks.enable_z_move) return null;
    if (pokemon.mechanic !== 'zmove') return null;
    if (pokemon.isMega || pokemon.isDynamaxed || pokemon.hasBondResonance) return null;
    if (baseMoveObj.category === 'Status' || baseMoveObj.cat === 'status') return null;
    // å‡†å¤‡ Key
    const moveId = (baseMoveObj.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const moveType = baseMoveObj.type || 'Normal';
    const speciesRoot = (pokemon.name || '').toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(partner|alola|galar|gmax|mega|cap)/g, '');
    // 1. è·å–è¿™åªå®å¯æ¢¦"å‘½ä¸­æ³¨å®š"çš„ä¸“å± Zï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªï¼‰
    const theOneZ = calculateBestZForPokemon(pokemon);
    // 2. æ£€æŸ¥å½“å‰æ‹›å¼æ˜¯å¦èƒ½äº§ç”Ÿä¸“å± Z
    const sigKey = `${moveId}+${speciesRoot}`;
    const potentialZ = SIGNATURE_Z_MATRIX[sigKey];
    if (potentialZ) {
        // å…³é”®åˆ¤æ–­ï¼šåªæœ‰å½“è¿™ä¸ªæ‹›å¼äº§ç”Ÿçš„ Z ç­‰äº"å‘½ä¸­æ³¨å®š"çš„ Z æ—¶ï¼Œæ‰ç‚¹äº®
        if (potentialZ === theOneZ) {
            return {
                name: potentialZ,
                type: moveType,
                power: 200,
                isExclusive: true
            };
        }
        // è™½ç„¶æ˜¯ä¸“å±æ‹›å¼ï¼Œä½†å› ä¼˜å…ˆçº§è¾“äº†ï¼Œè¿”å› null
        return null;
    }
    // 3. å¦‚æœè¿™åªå®å¯æ¢¦æ²¡æœ‰ä»»ä½•ä¸“å± Z èƒ½åŠ›ï¼Œå…è®¸é€šç”¨ Z
    if (!theOneZ) {
        if (GENERIC_Z_BY_TYPE[moveType]) {
            const basePower = baseMoveObj.basePower || baseMoveObj.power || 60;
            let zPower = 100;
            if (basePower >= 140) zPower = 200;
            else if (basePower >= 130) zPower = 195;
            else if (basePower >= 120) zPower = 190;
            else if (basePower >= 110) zPower = 185;
            else if (basePower >= 100) zPower = 180;
            else if (basePower >= 90) zPower = 175;
            else if (basePower >= 80) zPower = 160;
            else if (basePower >= 70) zPower = 140;
            else if (basePower >= 60) zPower = 120;
            else zPower = 100;
            return {
                name: GENERIC_Z_BY_TYPE[moveType],
                type: moveType,
                power: zPower,
                isExclusive: false
            };
        }
    }
    // 4. å¦‚æœè¿™åªå®å¯æ¢¦æœ‰ä¸“å± Zï¼ˆtheOneZ å­˜åœ¨ï¼‰ï¼Œå…¶ä»–æ‹›å¼ä¸èƒ½å˜æˆé€šç”¨ Z
    return null;
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.GENERIC_Z_BY_TYPE = GENERIC_Z_BY_TYPE;
    window.SIGNATURE_Z_MATRIX = SIGNATURE_Z_MATRIX;
    window.SIGNATURE_Z_PRIORITY = SIGNATURE_Z_PRIORITY;
    window.EXCLUSIVE_Z_MAP = EXCLUSIVE_Z_MAP;
    window.calculateBestZForPokemon = calculateBestZForPokemon;
    window.getZMoveTarget = getZMoveTarget;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        GENERIC_Z_BY_TYPE,
        SIGNATURE_Z_MATRIX,
        SIGNATURE_Z_PRIORITY,
        EXCLUSIVE_Z_MAP,
        calculateBestZForPokemon,
        getZMoveTarget
    };
}
]]></file>
    </directory>
    <directory name="scripts">
        <file name="bundle-trainer-data.js"><![CDATA[const fs = require('fs');
const path = require('path');
const baseDir = __dirname;
const trainerPath = path.resolve(baseDir, '..', 'TRAINER_data.js');
const pluginPath = path.join(baseDir, 'pkm-tavern-plugin.js');
const asyncMarker = '(async function() {';
const inlineMarker = '// ---------------------------------------------------------------\n//  ä»¥ä¸‹ä¸ºå†…ç½®çš„ trainer_data.js';
function bundleTrainerData() {
  if (!fs.existsSync(trainerPath)) {
    throw new Error(`æ— æ³•æ‰¾åˆ°è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶: ${trainerPath}`);
  }
  if (!fs.existsSync(pluginPath)) {
    throw new Error(`æ— æ³•æ‰¾åˆ°æ’ä»¶æ–‡ä»¶: ${pluginPath}`);
  }
  const trainerRaw = fs.readFileSync(trainerPath, 'utf8').trimEnd();
  const trainerContent = `${trainerRaw}\n`;
  const pluginContent = fs.readFileSync(pluginPath, 'utf8');
  const asyncIndex = pluginContent.indexOf(asyncMarker);
  if (asyncIndex === -1) {
    throw new Error('æœªåœ¨æ’ä»¶ä¸­æ‰¾åˆ° (async function() { æ ‡è®°ï¼Œæ— æ³•æ’å…¥æ•°æ®');
  }
  const inlineIndex = pluginContent.indexOf(inlineMarker);
  const header = inlineIndex !== -1
    ? pluginContent.slice(0, inlineIndex)
    : pluginContent.slice(0, asyncIndex);
  const after = pluginContent.slice(asyncIndex);
  const prefix = `${header}// ---------------------------------------------------------------\n//  ä»¥ä¸‹ä¸ºå†…ç½®çš„ trainer_data.jsï¼ˆè‡ªåŠ¨æ‰“åŒ…ç”Ÿæˆï¼‰\n// ---------------------------------------------------------------\n${trainerContent}\n`;
  const bundled = prefix + after;
  fs.writeFileSync(pluginPath, bundled, 'utf8');
  console.log('å·²å°† trainer_data.js å†…è”åˆ° pkm-tavern-plugin.js');
}
bundleTrainerData();
]]></file>
        <file name="convert-showdown-data.js"><![CDATA[#!/usr/bin/env node
/**
 * Pokemon Showdown æ•°æ®è½¬æ¢è„šæœ¬
 * å°† TypeScript æ ¼å¼çš„ pokedex.ts å’Œ moves.ts è½¬æ¢ä¸ºæµè§ˆå™¨å¯ç”¨çš„çº¯ JS
 * 
 * ä½¿ç”¨æ–¹æ³•ï¼š
 *   node convert-showdown-data.js
 * 
 * è¾“å‡ºï¼š
 *   - pokedex-data.js  (å®å¯æ¢¦æ•°æ®åº“)
 *   - moves-data.js    (æŠ€èƒ½æ•°æ®åº“)
 */
const fs = require('fs');
const path = require('path');
const SHOWDOWN_DIR = path.join(__dirname, 'Pokemon Showdown');
const OUTPUT_DIR = __dirname;
// ============================================================
// 1. è½¬æ¢ Pokedex (å®å¯æ¢¦æ•°æ®)
// ============================================================
function convertPokedex() {
    console.log('Converting pokedex.ts...');
    const inputPath = path.join(SHOWDOWN_DIR, 'pokedex.ts');
    const outputPath = path.join(OUTPUT_DIR, 'pokedex-data.js');
    let content = fs.readFileSync(inputPath, 'utf-8');
    // ç§»é™¤ TypeScript ç±»å‹æ³¨è§£
    content = content.replace(
        /^export const Pokedex:\s*import\([^)]+\)\.[^\s=]+ = /m,
        'const POKEDEX = '
    );
    // æ·»åŠ æ–‡ä»¶å¤´æ³¨é‡Š
    const header = `/**
 * Pokemon Showdown Pokedex Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/pokedex.ts
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="pokedex-data.js"></script>
 *   console.log(POKEDEX.pikachu.baseStats);
 */
`;
    content = header + content;
    fs.writeFileSync(outputPath, content, 'utf-8');
    console.log(`  -> ${outputPath}`);
    // ç»Ÿè®¡æ•°é‡
    const count = (content.match(/^\t[a-z]/gm) || []).length;
    console.log(`  -> ${count} Pokemon entries`);
}
// ============================================================
// 2. è½¬æ¢ Moves - ä½¿ç”¨ eval ç›´æ¥è§£æï¼Œæå–çº¯æ•°æ®
// ============================================================
function convertMoves() {
    console.log('Converting moves.ts (extracting static data only)...');
    const inputPath = path.join(SHOWDOWN_DIR, 'moves.ts');
    const outputPath = path.join(OUTPUT_DIR, 'moves-data.js');
    let content = fs.readFileSync(inputPath, 'utf-8');
    // ç§»é™¤ TypeScript ç±»å‹æ³¨è§£
    content = content.replace(
        /^export const Moves:\s*import\([^)]+\)\.[^\s=]+ = /m,
        'const Moves = '
    );
    // ç§»é™¤æ³¨é‡Š
    content = content.replace(/^\/\/.*$/gm, '');
    // ç§»é™¤æ‰€æœ‰å‡½æ•° - ä½¿ç”¨é€’å½’åŒ¹é…å¤§æ‹¬å·
    // åŒ¹é…å½¢å¦‚: funcName(args) { ... } æˆ– funcName: function(args) { ... }
    function removeFunctions(str) {
        let result = str;
        let changed = true;
        while (changed) {
            changed = false;
            // ç§»é™¤æ–¹æ³•å®šä¹‰: name(args) { body }
            // éœ€è¦æ­£ç¡®åŒ¹é…åµŒå¥—å¤§æ‹¬å·
            const funcRegex = /(\w+)\s*\([^)]*\)\s*\{/g;
            let match;
            while ((match = funcRegex.exec(result)) !== null) {
                const startIdx = match.index;
                const braceStart = result.indexOf('{', startIdx);
                // æ‰¾åˆ°åŒ¹é…çš„ç»“æŸå¤§æ‹¬å·
                let depth = 1;
                let endIdx = braceStart + 1;
                while (depth > 0 && endIdx < result.length) {
                    if (result[endIdx] === '{') depth++;
                    if (result[endIdx] === '}') depth--;
                    endIdx++;
                }
                if (depth === 0) {
                    // æ£€æŸ¥è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªæ–¹æ³•å®šä¹‰ï¼ˆä¸æ˜¯å¯¹è±¡å­—é¢é‡ï¼‰
                    const beforeMatch = result.substring(Math.max(0, startIdx - 10), startIdx);
                    if (!beforeMatch.match(/:\s*$/)) {
                        // è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•å®šä¹‰ï¼Œæ›¿æ¢ä¸º null
                        const funcName = match[1];
                        const replacement = `${funcName}: null`;
                        result = result.substring(0, startIdx) + replacement + result.substring(endIdx);
                        changed = true;
                        break;
                    }
                }
            }
        }
        return result;
    }
    content = removeFunctions(content);
    // ç§»é™¤ TypeScript ç‰¹æœ‰è¯­æ³•
    content = content.replace(/!\./g, '.'); // éç©ºæ–­è¨€
    content = content.replace(/!,/g, ',');
    content = content.replace(/!\)/g, ')');
    content = content.replace(/!\]/g, ']');
    content = content.replace(/!\}/g, '}');
    content = content.replace(/ as \w+/g, '');
    content = content.replace(/<[A-Za-z\[\]|, ]+>/g, '');
    // ç§»é™¤ condition å—ï¼ˆåŒ…å«å¤æ‚é€»è¾‘ï¼‰
    function removeConditionBlocks(str) {
        let result = str;
        const conditionRegex = /condition:\s*\{/g;
        let match;
        while ((match = conditionRegex.exec(result)) !== null) {
            const startIdx = match.index;
            const braceStart = result.indexOf('{', startIdx);
            let depth = 1;
            let endIdx = braceStart + 1;
            while (depth > 0 && endIdx < result.length) {
                if (result[endIdx] === '{') depth++;
                if (result[endIdx] === '}') depth--;
                endIdx++;
            }
            if (depth === 0) {
                // ç§»é™¤æ•´ä¸ª condition å—
                result = result.substring(0, startIdx) + 'condition: null' + result.substring(endIdx);
            }
        }
        return result;
    }
    content = removeConditionBlocks(content);
    // æ·»åŠ æ–‡ä»¶å¤´
    const header = `/**
 * Pokemon Showdown Moves Data
 * è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘
 * æ¥æº: https://github.com/smogon/pokemon-showdown/blob/master/data/moves.ts
 * 
 * æ³¨æ„: å‡½æ•°å›è°ƒã€condition å—å·²è¢«ç§»é™¤ï¼Œä»…ä¿ç•™é™æ€æ•°æ®
 * 
 * ä½¿ç”¨æ–¹æ³•:
 *   <script src="moves-data.js"></script>
 *   console.log(MOVES.thunderbolt.basePower); // 90
 */
`;
    // é‡å‘½åå˜é‡
    content = content.replace(/const Moves = /, 'const MOVES = ');
    content = header + content;
    fs.writeFileSync(outputPath, content, 'utf-8');
    console.log(`  -> ${outputPath}`);
    // ç»Ÿè®¡æ•°é‡
    const count = (content.match(/^\t[a-z"]/gm) || []).length;
    console.log(`  -> ${count} Move entries`);
}
// ============================================================
// 3. éªŒè¯ç”Ÿæˆçš„æ–‡ä»¶
// ============================================================
function validateFiles() {
    console.log('Validating generated files...');
    const pokedexPath = path.join(OUTPUT_DIR, 'pokedex-data.js');
    const movesPath = path.join(OUTPUT_DIR, 'moves-data.js');
    // éªŒè¯ pokedex
    try {
        const vm = require('vm');
        const pokedexContent = fs.readFileSync(pokedexPath, 'utf-8');
        vm.runInNewContext(pokedexContent);
        console.log('  -> pokedex-data.js: OK');
    } catch (e) {
        console.log('  -> pokedex-data.js: ERROR -', e.message);
    }
    // éªŒè¯ moves
    try {
        const vm = require('vm');
        const movesContent = fs.readFileSync(movesPath, 'utf-8');
        vm.runInNewContext(movesContent);
        console.log('  -> moves-data.js: OK');
    } catch (e) {
        console.log('  -> moves-data.js: ERROR -', e.message.substring(0, 100));
    }
}
// ============================================================
// Main
// ============================================================
function main() {
    console.log('='.repeat(60));
    console.log('Pokemon Showdown Data Converter');
    console.log('='.repeat(60));
    const pokedexPath = path.join(SHOWDOWN_DIR, 'pokedex.ts');
    const movesPath = path.join(SHOWDOWN_DIR, 'moves.ts');
    const hasPokedex = fs.existsSync(pokedexPath);
    const hasMoves = fs.existsSync(movesPath);
    if (!hasPokedex) {
        console.warn('Warning: pokedex.ts not found. Skipping pokedex-data.js generation.');
    }
    if (!hasMoves) {
        console.error('Error: moves.ts not found in', SHOWDOWN_DIR);
        process.exit(1);
    }
    if (hasPokedex) {
        convertPokedex();
    }
    convertMoves();
    validateFiles();
    console.log('='.repeat(60));
    console.log('Done! Files generated:');
    console.log('  - pokedex-data.js');
    console.log('  - moves-data.js');
    console.log('');
    console.log('Usage in HTML:');
    console.log('  <script src="pokedex-data.js"></script>');
    console.log('  <script src="moves-data.js"></script>');
    console.log('='.repeat(60));
}
main();
]]></file>
        <file name="inline-trainer-data.js"><![CDATA[const fs = require('fs');
const path = require('path');
const baseDir = __dirname;
const trainerDataPath = path.resolve(baseDir, '..', 'TRAINER_data.js');
const pluginPath = path.join(baseDir, 'pkm-tavern-plugin.js');
console.log('å¼€å§‹å†…è”è®­ç»ƒå®¶æ•°æ®...');
console.log(`è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶: ${trainerDataPath}`);
console.log(`æ’ä»¶æ–‡ä»¶: ${pluginPath}`);
// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if (!fs.existsSync(trainerDataPath)) {
  console.error(`âŒ é”™è¯¯: æ‰¾ä¸åˆ°è®­ç»ƒå®¶æ•°æ®æ–‡ä»¶ ${trainerDataPath}`);
  process.exit(1);
}
if (!fs.existsSync(pluginPath)) {
  console.error(`âŒ é”™è¯¯: æ‰¾ä¸åˆ°æ’ä»¶æ–‡ä»¶ ${pluginPath}`);
  process.exit(1);
}
// è¯»å–è®­ç»ƒå®¶æ•°æ®
const trainerData = fs.readFileSync(trainerDataPath, 'utf8');
console.log(`âœ“ å·²è¯»å–è®­ç»ƒå®¶æ•°æ® (${trainerData.length} å­—ç¬¦)`);
// è¯»å–æ’ä»¶æ–‡ä»¶
let pluginContent = fs.readFileSync(pluginPath, 'utf8');
console.log(`âœ“ å·²è¯»å–æ’ä»¶æ–‡ä»¶ (${pluginContent.length} å­—ç¬¦)`);
// ç§»é™¤æ—§çš„å†…è”å†…å®¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
const inlineStartMarker = '// ================================================================\n//  ä»¥ä¸‹ä¸ºå†…è”çš„è®­ç»ƒå®¶æ•°æ® (è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘)\n// ================================================================';
const inlineEndMarker = '// ================================================================\n//  è®­ç»ƒå®¶æ•°æ®å†…è”ç»“æŸ\n// ================================================================';
const startIdx = pluginContent.indexOf(inlineStartMarker);
const endIdx = pluginContent.indexOf(inlineEndMarker);
if (startIdx !== -1 && endIdx !== -1) {
  const endOfBlock = endIdx + inlineEndMarker.length;
  // ç§»é™¤æ—§çš„å†…è”å—ï¼ˆåŒ…æ‹¬åé¢çš„ç©ºè¡Œï¼‰
  let afterBlock = pluginContent.substring(endOfBlock);
  // å»æ‰å¼€å¤´çš„ç©ºè¡Œ
  afterBlock = afterBlock.replace(/^\n+/, '\n');
  pluginContent = afterBlock;
  console.log('âœ“ å·²ç§»é™¤æ—§çš„å†…è”å†…å®¹');
}
// æŸ¥æ‰¾æ’å…¥ä½ç½® - åœ¨ (async function() { ä¹‹å‰
const asyncMarker = '(async function() {';
const insertIndex = pluginContent.indexOf(asyncMarker);
if (insertIndex === -1) {
  console.error('âŒ é”™è¯¯: åœ¨æ’ä»¶æ–‡ä»¶ä¸­æ‰¾ä¸åˆ° (async function() { æ ‡è®°');
  process.exit(1);
}
console.log(`âœ“ æ‰¾åˆ°æ’å…¥ä½ç½®: ç¬¬ ${insertIndex} ä¸ªå­—ç¬¦`);
// æ„å»ºæ–°çš„æ’ä»¶å†…å®¹ - ç›´æ¥åœ¨æ–‡ä»¶å¼€å¤´æ’å…¥è®­ç»ƒå®¶æ•°æ®
const inlineBlock = `// ================================================================
//  ä»¥ä¸‹ä¸ºå†…è”çš„è®­ç»ƒå®¶æ•°æ® (è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘)
// ================================================================
${trainerData}
// ================================================================
//  è®­ç»ƒå®¶æ•°æ®å†…è”ç»“æŸ
// ================================================================
`;
const newPluginContent = inlineBlock + pluginContent;
// å†™å…¥æ–°çš„æ’ä»¶æ–‡ä»¶
fs.writeFileSync(pluginPath, newPluginContent, 'utf8');
console.log('âœ“ è®­ç»ƒå®¶æ•°æ®å·²æˆåŠŸå†…è”åˆ°æ’ä»¶æ–‡ä»¶');
console.log(`æ–°æ’ä»¶æ–‡ä»¶å¤§å°: ${newPluginContent.length} å­—ç¬¦`);
console.log('å®Œæˆï¼');
]]></file>
    </directory>
    <directory name="systems">
        <file name="audio-manager.js"><![CDATA[/**
 * ===========================================
 * AUDIO-MANAGER.JS - éŸ³æ•ˆç®¡ç†ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - é¢„åŠ è½½çŸ­éŸ³æ•ˆ (æé«˜å“åº”é€Ÿåº¦)
 * - å®ç°å¹¶å‘æ’­æ”¾ (cloneNode)
 * - ä¸ BGM ç³»ç»ŸååŒå·¥ä½œ
 */
// ============================================
// è·¯å¾„å…¼å®¹ (GitHub Pages)
// ============================================
function getSfxBasePath() {
    const path = window.location.pathname;
    if (path.includes('/pkm12/')) {
        return path.substring(0, path.indexOf('/pkm12/') + 7);
    }
    return './';
}
const SFX_BASE_PATH = getSfxBasePath();
// ============================================
// SFX é…ç½®è¡¨
// ============================================
const SFX_CONFIG = {
    // UI ç±»
    'CONFIRM':    `${SFX_BASE_PATH}data/sfx/ui_01_confirm.mp3`,
    'CANCEL':     `${SFX_BASE_PATH}data/sfx/ui_01_confirm.mp3`,
    // æˆ˜æ–—åé¦ˆç±»
    'HIT_NORMAL': `${SFX_BASE_PATH}data/sfx/hit_00_normal.mp3`,
    'HIT_SUPER':  `${SFX_BASE_PATH}data/sfx/Hit_Super_Effective_XY.mp3`,
    'HIT_WEAK':   `${SFX_BASE_PATH}data/sfx/hit_02_weak.mp3`,
    // èƒ½åŠ›å˜åŒ–ç±»
    'STAT_UP':    `${SFX_BASE_PATH}data/sfx/stat_up.mp3`,
    'STAT_DOWN':  `${SFX_BASE_PATH}data/sfx/stat_down.mp3`,
    // äº‹ä»¶ç±»
    'FAINT':      `${SFX_BASE_PATH}data/sfx/battle_faint.mp3`,
    'HEAL':       `${SFX_BASE_PATH}data/sfx/battle_heal.mp3`,
    'THROW':      `${SFX_BASE_PATH}data/sfx/ball_throw.mp3`,
    'BALL_OPEN':  `${SFX_BASE_PATH}data/sfx/ball_open.mp3`
};
// ============================================
// SFX éŸ³é‡é…ç½®è¡¨ (0.0 - 1.0)
// ============================================
const SFX_VOLUME_CONFIG = {
    'CONFIRM':    0.5,
    'CANCEL':     0.5,
    'HIT_NORMAL': 0.6,
    'HIT_SUPER':  0.7,
    'HIT_WEAK':   0.5,
    'STAT_UP':    0.3,
    'STAT_DOWN':  0.3,
    'FAINT':      0.6,
    'HEAL':       0.5,
    'THROW':      0.6,
    'BALL_OPEN':  0.6
};
// éŸ³é¢‘ç¼“å­˜æ± 
const sfxCache = {};
// ============================================
// é¢„åŠ è½½ SFX
// ============================================
(function preloadSFX() {
    console.log('[SFX] Starting preload...');
    let loadedCount = 0;
    const totalCount = Object.keys(SFX_CONFIG).length;
    for (const [key, path] of Object.entries(SFX_CONFIG)) {
        const audio = new Audio();
        audio.src = path;
        audio.preload = 'auto';
        audio.volume = SFX_VOLUME_CONFIG[key] || 0.6;
        audio.addEventListener('canplaythrough', () => {
            loadedCount++;
            if (loadedCount === totalCount) {
                console.log(`[SFX] All ${loadedCount} files preloaded.`);
            }
        }, { once: true });
        audio.addEventListener('error', () => {
            console.warn(`[SFX] Failed to load: ${key} (${path})`);
            loadedCount++; // è®¡å…¥å¤±è´¥çš„ä¹Ÿç®—å®Œæˆ
        }, { once: true });
        sfxCache[key] = audio;
        // ã€å¼ºåˆ¶é¢„åŠ è½½ã€‘è°ƒç”¨ load() ç¡®ä¿æµè§ˆå™¨å¼€å§‹åŠ è½½
        audio.load();
    }
    console.log(`[SFX] Queued ${Object.keys(sfxCache).length} files for preload.`);
})();
// ============================================
// æ’­æ”¾ SFX (æ”¯æŒå¹¶å‘)
// ============================================
/**
 * æ’­æ”¾çŸ­éŸ³æ•ˆ (æ”¯æŒå¹¶å‘)
 * @param {string} key - SFX_CONFIG ä¸­çš„é”®å
 * @param {number} volumeOverride - å¯é€‰çš„éŸ³é‡è¦†ç›– (0.0 - 1.0)
 */
function playSFX(key, volumeOverride = null) {
    const original = sfxCache[key];
    if (!original) {
        return;
    }
    try {
        const clone = original.cloneNode();
        clone.volume = volumeOverride !== null 
            ? volumeOverride 
            : (SFX_VOLUME_CONFIG[key] || 0.6);
        clone.play().catch(() => {
            // å¿½ç•¥æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶é”™è¯¯
        });
    } catch (e) {
        console.error('[SFX] Play error:', e);
    }
}
/**
 * æ ¹æ®ä¼¤å®³æ•ˆæœæ’­æ”¾å¯¹åº”æ‰“å‡»éŸ³æ•ˆ
 * @param {number} effectiveness - å…‹åˆ¶å€ç‡
 * @param {boolean} isCrit - æ˜¯å¦æš´å‡»
 */
function playHitSFX(effectiveness, isCrit = false) {
    if (isCrit || effectiveness >= 2) {
        playSFX('HIT_SUPER');
    } else if (effectiveness > 0 && effectiveness <= 0.5) {
        playSFX('HIT_WEAK');
    } else {
        playSFX('HIT_NORMAL');
    }
}
// ============================================
// å¯¼å‡ºåˆ°å…¨å±€
// ============================================
window.playSFX = playSFX;
window.playHitSFX = playHitSFX;
window.SFX_CONFIG = SFX_CONFIG;
// ============================================
// å®å¯æ¢¦å«å£°ç³»ç»Ÿ
// ============================================
const CRY_VOLUME = 0.45;
/**
 * æ’­æ”¾å®å¯æ¢¦å«å£° (åœ¨çº¿æ‹‰å– Showdown éŸ³é¢‘åº“)
 * @param {string} speciesName - å®å¯æ¢¦åå­— (å¦‚ "Pikachu", "Charizard-Mega-Y")
 */
window.playPokemonCry = function(speciesName) {
    if (!speciesName) return;
    // ä¼˜å…ˆä½¿ç”¨é¢„åŠ è½½ç¼“å­˜
    if (typeof playCachedCry === 'function') {
        playCachedCry(speciesName, CRY_VOLUME);
        return;
    }
    // Fallback: åœ¨çº¿åŠ è½½
    let id = speciesName.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (typeof POKEDEX !== 'undefined' && POKEDEX[id]) {
        if (POKEDEX[id].baseSpecies) {
            id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
    }
    const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
    for (const s of suffixes) {
        if (id.endsWith(s) && id.length > s.length) {
            id = id.replace(s, '');
            break;
        }
    }
    const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
    const cryAudio = new Audio(url);
    cryAudio.volume = CRY_VOLUME;
    cryAudio.play().catch(() => {});
    console.log(`[CRY] Playing online: ${speciesName} -> ${id}`);
};
]]></file>
        <file name="bgm-system.js"><![CDATA[/**
 * ===========================================
 * BGM-SYSTEM.JS - èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
 * ===========================================
 * 
 * æ´›è¿ªäºšç‰¹åŒº BGM ç®¡ç†ç³»ç»Ÿ
 * 
 * èŒè´£:
 * - æˆ˜æ–— BGM é€‰æ‹© (æ ¹æ®ç­‰çº§/è®­ç»ƒå®¶ç±»å‹)
 * - èƒœåˆ©éŸ³ä¹æ’­æ”¾ (é‡ç”Ÿ/è®­ç»ƒå®¶)
 * - åŠ¨æ€åˆ‡æ­Œ (é¦†ä¸»æˆ˜å±æœºæ—¶åˆ»)
 * - éŸ³é¢‘æ·¡å…¥æ·¡å‡º
 */
// ============================================
// BGM èµ„æºç´¢å¼•è¡¨
// ============================================
// è·å–åŸºç¡€è·¯å¾„ (å…¼å®¹ GitHub Pages)
function getBasePath() {
    const path = window.location.pathname;
    // GitHub Pages: /repo-name/
    if (path.includes('/pkm12/')) {
        return path.substring(0, path.indexOf('/pkm12/') + 7);
    }
    return './';
}
const BASE_PATH = getBasePath();
const BGM_INDEX = {
    // === é‡ç”Ÿé­é‡æˆ˜ (Wild Encounters) ===
    WILD_LOW:     `${BASE_PATH}data/bgm/wild_01_low_unova.mp3`,
    WILD_MID:     `${BASE_PATH}data/bgm/wild_02_mid_sinnoh.mp3`,
    WILD_HIGH:    `${BASE_PATH}data/bgm/wild_03_ex_areazero.mp3`,
    // === è®­ç»ƒå®¶æˆ˜æ–— (Trainer Battles) ===
    TIER_1:       `${BASE_PATH}data/bgm/battle_01_raw.mp3`,
    TIER_2:       `${BASE_PATH}data/bgm/battle_02_standard.mp3`,
    // === åŠ¨æ€åˆ‡æ­Œå±‚ (Gym Leader / Tier 3) ===
    TIER_3_MAIN:  `${BASE_PATH}data/bgm/battle_03_gym_main.mp3`,
    TIER_3_LAST:  `${BASE_PATH}data/bgm/battle_03_gym_crisis.mp3`,
    // === é«˜éš¾/BOSSæˆ˜ (High Stakes) ===
    TIER_4:       `${BASE_PATH}data/bgm/battle_04_elite.mp3`,
    TIER_5_BOSS:  `${BASE_PATH}data/bgm/battle_05_legend.mp3`,
    // === èƒœåˆ©éŸ³ä¹ (Victory Events) ===
    WIN_WILD:     `${BASE_PATH}data/bgm/win_01_wild.mp3`,
    WIN_TRAINER:  `${BASE_PATH}data/bgm/win_02_trainer.mp3`
};
// ============================================
// BGM éŸ³é‡é…ç½®è¡¨ (0.0 - 1.0)
// ============================================
// BGM éŸ³é‡é…ç½® (ä½¿ç”¨æ–‡ä»¶åä½œä¸º keyï¼Œå…¼å®¹ä¸åŒè·¯å¾„)
const BGM_VOLUME_CONFIG = {};
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_LOW] = 0.25;
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_MID] = 0.28;
BGM_VOLUME_CONFIG[BGM_INDEX.WILD_HIGH] = 0.20;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_1] = 0.22;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_2] = 0.25;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_3_MAIN] = 0.28;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_3_LAST] = 0.32;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_4] = 0.30;
BGM_VOLUME_CONFIG[BGM_INDEX.TIER_5_BOSS] = 0.35;
BGM_VOLUME_CONFIG[BGM_INDEX.WIN_WILD] = 0.20;
BGM_VOLUME_CONFIG[BGM_INDEX.WIN_TRAINER] = 0.27;
// ============================================
// BGM æ’­æ”¾å™¨çŠ¶æ€
// ============================================
const BgmPlayer = {
    currentAudio: null,
    currentKey: null,
    defaultVolume: 0.25,
    play(url, loop = true, fadeInDuration = 500) {
        // å¦‚æœæ­£åœ¨æ’­æ”¾ç›¸åŒçš„ BGM ä¸”æœªæš‚åœï¼Œè·³è¿‡
        if (this.currentAudio && this.currentKey === url && !this.currentAudio.paused) {
            console.log('[BGM] Already playing:', url);
            return;
        }
        // åœæ­¢å½“å‰æ’­æ”¾çš„ BGM
        this.stop(0);
        console.log('[BGM] Starting playback:', url);
        try {
            this.currentAudio = new Audio(url);
            this.currentKey = url;
            this.currentAudio.loop = loop;
            this.currentAudio.volume = 0;
            const playPromise = this.currentAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('[BGM] Playback started successfully');
                }).catch(err => {
                    console.warn('[BGM] Autoplay blocked:', err);
                });
            }
            // ä½¿ç”¨é…ç½®è¡¨ä¸­çš„éŸ³é‡ï¼Œå¦‚æœæ²¡æœ‰é…ç½®åˆ™ä½¿ç”¨é»˜è®¤å€¼
            const targetVolume = BGM_VOLUME_CONFIG[url] || this.defaultVolume;
            this._fadeIn(fadeInDuration, targetVolume);
        } catch (err) {
            console.error('[BGM] Play error:', err);
        }
    },
    stop(fadeOutDuration = 300) {
        if (!this.currentAudio) return;
        if (fadeOutDuration > 0) {
            this._fadeOut(fadeOutDuration, () => {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                    this.currentKey = null;
                }
            });
        } else {
            this.currentAudio.pause();
            this.currentAudio = null;
            this.currentKey = null;
        }
    },
    crossFade(url, loop = true) {
        if (this.currentKey === url) return;
        const oldAudio = this.currentAudio;
        try {
            const newAudio = new Audio(url);
            newAudio.loop = loop;
            newAudio.volume = 0;
            newAudio.play().then(() => {
                if (oldAudio) {
                    this._fadeOutAudio(oldAudio, 800, () => {
                        oldAudio.pause();
                    });
                }
                this.currentAudio = newAudio;
                this.currentKey = url;
                const targetVolume = BGM_VOLUME_CONFIG[url] || this.defaultVolume;
                this._fadeIn(800, targetVolume);
            }).catch(err => {
                console.warn('[BGM] åˆ‡æ¢å¤±è´¥:', err.message);
            });
        } catch (e) {
            console.warn('[BGM] åˆ‡æ¢éŸ³é¢‘å¤±è´¥:', e.message);
        }
    },
    setVolume(vol) {
        this.defaultVolume = Math.max(0, Math.min(1, vol));
        if (this.currentAudio) {
            this.currentAudio.volume = this.defaultVolume;
        }
    },
    _fadeIn(duration, targetVolume = null) {
        if (!this.currentAudio) return;
        const startTime = Date.now();
        const volume = targetVolume !== null ? targetVolume : this.defaultVolume;
        const fade = () => {
            if (!this.currentAudio) return;
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            this.currentAudio.volume = volume * progress;
            if (progress < 1) requestAnimationFrame(fade);
        };
        requestAnimationFrame(fade);
    },
    _fadeOut(duration, callback) {
        if (!this.currentAudio) {
            if (callback) callback();
            return;
        }
        this._fadeOutAudio(this.currentAudio, duration, callback);
    },
    _fadeOutAudio(audio, duration, callback) {
        const startTime = Date.now();
        const startVolume = audio.volume;
        const fade = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            audio.volume = startVolume * (1 - progress);
            if (progress < 1) {
                requestAnimationFrame(fade);
            } else {
                if (callback) callback();
            }
        };
        requestAnimationFrame(fade);
    }
};
// ============================================
// BGM é€‰æ‹©é€»è¾‘
// ============================================
function getBattleBgm(avgLevel, isTrainer, isCrisis = false) {
    if (!isTrainer) {
        if (avgLevel >= 70) return BGM_INDEX.WILD_HIGH;
        if (avgLevel >= 40) return BGM_INDEX.WILD_MID;
        return BGM_INDEX.WILD_LOW;
    } else {
        if (avgLevel >= 85) return BGM_INDEX.TIER_5_BOSS;
        // Tier 4 (70-84çº§) ä¹Ÿæ”¯æŒå±æœº BGM
        if (avgLevel >= 70) return isCrisis ? BGM_INDEX.TIER_3_LAST : BGM_INDEX.TIER_4;
        // Tier 3 (50-69çº§) æ”¯æŒå±æœº BGM
        if (avgLevel >= 50) return isCrisis ? BGM_INDEX.TIER_3_LAST : BGM_INDEX.TIER_3_MAIN;
        if (avgLevel >= 25) return BGM_INDEX.TIER_2;
        return BGM_INDEX.TIER_1;
    }
}
function getPartyAvgLevel(party) {
    if (!party || party.length === 0) return 1;
    const total = party.reduce((sum, p) => sum + (p.level || p.lv || 1), 0);
    return Math.round(total / party.length);
}
function playBattleBgm() {
    if (typeof battle === 'undefined' || !battle) {
        console.warn('[BGM] battle å¯¹è±¡æœªå®šä¹‰');
        return;
    }
    const enemyParty = battle.enemyParty || [];
    if (enemyParty.length === 0) {
        console.warn('[BGM] æ•Œæ–¹é˜Ÿä¼ä¸ºç©ºï¼Œå»¶è¿Ÿ 100ms é‡è¯•');
        setTimeout(playBattleBgm, 100);
        return;
    }
    const avgLevel = getPartyAvgLevel(enemyParty);
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    const bgmUrl = getBattleBgm(avgLevel, isTrainer, false);
    console.log(`[BGM] æˆ˜æ–—å¼€å§‹ - å¹³å‡ç­‰çº§: ${avgLevel}, è®­ç»ƒå®¶: ${isTrainer}, é˜Ÿä¼æ•°: ${enemyParty.length}`);
    console.log(`[BGM] æ’­æ”¾: ${bgmUrl}`);
    BgmPlayer.play(bgmUrl, true);
}
function checkCrisisBgm() {
    if (typeof battle === 'undefined' || !battle) return;
    const enemyParty = battle.enemyParty || [];
    const avgLevel = getPartyAvgLevel(enemyParty);
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    // åªåœ¨ Tier 3 (50-69çº§) å’Œ Tier 4 (70-84çº§) è§¦å‘å±æœº BGM
    if (!isTrainer || avgLevel < 50 || avgLevel >= 85) return;
    const totalEnemies = enemyParty.length;
    const aliveEnemies = enemyParty.filter(p => p.currHp > 0);
    const aliveCount = aliveEnemies.length;
    // æ ¹æ®é˜Ÿä¼æ€»æ•°å†³å®šè§¦å‘æ—¶æœº
    let shouldTriggerCrisis = false;
    if (totalEnemies <= 2) {
        // 1-2åª: ä¸æ’­æ”¾å±æœº BGM
        shouldTriggerCrisis = false;
    } else if (totalEnemies >= 3 && totalEnemies <= 5) {
        // 3-5åª: æœ€åä¸€åªæ—¶æ’­æ”¾
        shouldTriggerCrisis = (aliveCount === 1);
    } else if (totalEnemies === 6) {
        // 6åª: æœ€åä¸¤åªæ—¶æ’­æ”¾
        shouldTriggerCrisis = (aliveCount <= 2);
    }
    if (shouldTriggerCrisis) {
        const crisisBgm = BGM_INDEX.TIER_3_LAST;
        if (BgmPlayer.currentKey !== crisisBgm) {
            console.log(`[BGM] å±æœºæ—¶åˆ»ï¼é˜Ÿä¼: ${totalEnemies}åª, å‰©ä½™: ${aliveCount}åª, åˆ‡æ¢BGM`);
            BgmPlayer.crossFade(crisisBgm, true);
        }
    }
}
function playVictoryBgm(isTrainerBattle) {
    const bgmUrl = isTrainerBattle ? BGM_INDEX.WIN_TRAINER : BGM_INDEX.WIN_WILD;
    console.log(`[BGM] èƒœåˆ©éŸ³ä¹ - è®­ç»ƒå®¶: ${isTrainerBattle}`);
    BgmPlayer.play(bgmUrl, false, 300);
}
function stopBgm(fadeOut = 500) {
    BgmPlayer.stop(fadeOut);
}
// ============================================
// å¯¼å‡º
// ============================================
if (typeof window !== 'undefined') {
    window.BGM_INDEX = BGM_INDEX;
    window.BgmPlayer = BgmPlayer;
    window.getBattleBgm = getBattleBgm;
    window.getPartyAvgLevel = getPartyAvgLevel;
    window.playBattleBgm = playBattleBgm;
    window.checkCrisisBgm = checkCrisisBgm;
    window.playVictoryBgm = playVictoryBgm;
    window.stopBgm = stopBgm;
}
]]></file>
        <file name="catch-system.js"><![CDATA[/**
 * ===========================================
 * CATCH-SYSTEM.JS - æ•è·ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ç²¾çµçƒèœå•æ§åˆ¶
 * - æ•è·æ¦‚ç‡è®¡ç®—
 * - æ•è·åŠ¨ç”»ä¸æµç¨‹
 */
// ============================================
// ç²¾çµçƒèœå•æ§åˆ¶
// ============================================
/**
 * æ‰“å¼€ç²¾çµçƒèœå•
 */
function openBallMenu() {
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const trainer = battle.trainer;
    const isWild = trainer && (trainer.id === 'wild' || !trainer.id);
    if (battle.locked || !isWild) return;
    const layer = document.getElementById('ball-layer');
    if (layer) layer.classList.remove('hidden');
}
/**
 * å…³é—­ç²¾çµçƒèœå•
 */
function closeBallMenu() {
    const layer = document.getElementById('ball-layer');
    if (layer) layer.classList.add('hidden');
}
// ============================================
// æ•è·é€»è¾‘
// ============================================
/**
 * å°è¯•æ•è·é‡ç”Ÿå®å¯æ¢¦
 * @param {number} ballMultiplier ç²¾çµçƒæ•è·ç‡å€æ•°
 */
async function tryCatch(ballMultiplier = 1) {
    closeBallMenu();
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const trainer = battle.trainer;
    const isWild = trainer && (trainer.id === 'wild' || !trainer.id);
    if (battle.locked || !isWild) return;
    const enemy = typeof battle.getEnemy === 'function' ? battle.getEnemy() : null;
    if (!enemy || !enemy.isAlive()) {
        log('å½“å‰æ²¡æœ‰å¯æ•æ‰çš„ç›®æ ‡ã€‚');
        return;
    }
    battle.locked = true;
    // æ’­æ”¾æ•è·åŠ¨ç”»
    const sprite = document.getElementById('enemy-sprite');
    if (sprite) {
        sprite.style.transition = 'transform 0.4s ease-in, opacity 0.3s';
        sprite.style.transform = 'scale(0.1) rotate(360deg)';
        sprite.style.opacity = '0';
    }
    log(`ä½ å‘ ${enemy.cnName} æŠ•æ·äº†ç²¾çµçƒï¼`);
    await wait(600);
    // è®¡ç®—æ•è·ç‡
    const catchResult = calculateCatchRate(enemy, ballMultiplier);
    const { finalChance, caught } = catchResult;
    // æ‘‡æ™ƒåŠ¨ç”»
    const shakeLog = async (count) => {
        log(`(ç²¾çµçƒæ‘‡æ™ƒäº† ${count} ä¸‹...)`);
        await wait(600);
    };
    if (!caught) {
        // æ•è·å¤±è´¥
        const breakShakes = finalChance > 0.7 ? 3 : finalChance > 0.4 ? 2 : 1;
        for (let i = 1; i <= breakShakes; i++) {
            await shakeLog(i);
        }
        if (breakShakes >= 3) {
            log("å•Šï¼æ˜æ˜å°±å·®ä¸€ç‚¹ç‚¹äº†ï¼");
        } else {
            log("å¤ªå¯æƒœäº†ï¼çƒç ´å¼€äº†ï¼");
        }
        // æ¢å¤ç²¾çµå›¾
        if (sprite) {
            sprite.style.transition = 'transform 0.35s ease-out, opacity 0.35s';
            sprite.style.transform = 'scale(1) rotate(0deg)';
            sprite.style.opacity = '1';
            sprite.classList.remove('entering');
            setTimeout(() => {
                sprite.style.transition = '';
                sprite.style.transform = '';
                sprite.style.opacity = '';
                sprite.classList.add('entering');
                setTimeout(() => sprite.classList.remove('entering'), 650);
            }, 400);
        }
        await wait(500);
        if (typeof updateAllVisuals === 'function') {
            updateAllVisuals(true);
        }
        if (typeof enemyTurn === 'function') {
            await enemyTurn();
        }
        return;
    }
    // æ•è·æˆåŠŸ
    await shakeLog(1);
    await shakeLog(2);
    await shakeLog(3);
    log("âœ¨ å’šï¼");
    await wait(500);
    const catchColor = (getComputedStyle(document.documentElement).getPropertyValue('--color-catch') || '#4ade80').trim() || '#4ade80';
    log(`<b style="color:${catchColor}">æˆåŠŸæ”¶æœäº† ${enemy.cnName}!</b>`);
    enemy.currHp = 0;
    battle.phase = 'caught';
    await wait(800);
    if (typeof battleEndSequence === 'function') {
        battleEndSequence('caught');
    }
}
/**
 * è®¡ç®—æ•è·ç‡
 * @param {Object} enemy æ•Œæ–¹å®å¯æ¢¦
 * @param {number} ballMultiplier ç²¾çµçƒå€ç‡
 * @returns {Object} { finalChance, caught }
 */
function calculateCatchRate(enemy, ballMultiplier = 1) {
    // è®¡ç®—ç§æ—å€¼æ€»å’Œ
    const statKeys = ['hp', 'atk', 'def', 'spa', 'spd', 'spe'];
    const stats = enemy.baseStats || {};
    let bst = 0;
    statKeys.forEach(key => {
        const val = typeof stats[key] === 'number' ? stats[key] : 50;
        bst += val;
    });
    // åŸºç¡€æ•è·ç‡ï¼ˆç§æ—å€¼è¶Šé«˜è¶Šéš¾æ•è·ï¼‰
    let baseCatchRate = 350 - (bst / 1.8);
    baseCatchRate = Math.max(3, Math.min(255, baseCatchRate));
    // HP å› å­ï¼ˆHP è¶Šä½è¶Šå®¹æ˜“æ•è·ï¼‰
    const hpFactorRaw = ((3 * enemy.maxHp) - (2 * enemy.currHp)) / (3 * Math.max(1, enemy.maxHp));
    const hpFactor = Math.min(1, Math.max(0.1, hpFactorRaw));
    // çŠ¶æ€å› å­ï¼ˆæš‚æœªå®ç°å¼‚å¸¸çŠ¶æ€åŠ æˆï¼‰
    const statusFactor = 1;
    // æœ€ç»ˆæ•è·ç‡
    let finalChance = (baseCatchRate * hpFactor * ballMultiplier * statusFactor) / 255;
    // å¤§å¸ˆçƒä¿è¯æ•è·
    if (ballMultiplier >= 255) {
        finalChance = 2;
    } else {
        finalChance = Math.max(0.02, Math.min(0.95, finalChance));
    }
    // åˆ¤å®šæ˜¯å¦æ•è·æˆåŠŸ
    const caught = finalChance >= 1 || Math.random() <= finalChance;
    return { finalChance, caught, baseCatchRate, hpFactor };
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.openBallMenu = openBallMenu;
    window.closeBallMenu = closeBallMenu;
    window.tryCatch = tryCatch;
    window.calculateCatchRate = calculateCatchRate;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        openBallMenu,
        closeBallMenu,
        tryCatch,
        calculateCatchRate
    };
}
]]></file>
        <file name="data-loader.js"><![CDATA[/**
 * ===========================================
 * DATA-LOADER.JS - æ•°æ®åŠ è½½ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - é»˜è®¤æˆ˜æ–—æ•°æ®
 * - JSON æ•°æ®è§£æä¸åŠ è½½
 * - æˆ˜æ–—åˆå§‹åŒ–æ•°æ®å¤„ç†
 */
// ============================================
// é»˜è®¤æˆ˜æ–—æ•°æ®
// ============================================
/**
 * è·å–é»˜è®¤æˆ˜æ–—æ•°æ® (å½“æ²¡æœ‰å¤–éƒ¨JSONæ³¨å…¥æ—¶ä½¿ç”¨)
 * 
 * æ–°ç‰ˆæ ¼å¼æ”¯æŒï¼š
 * - stats_meta: { ivs: {...}, ev_level: 0~252 }
 * - nature: æ€§æ ¼åç§°
 * - ability: ç‰¹æ€§åç§°
 * - gender: 'M' | 'F' | null
 * - shiny: boolean
 * - mechanic: 'mega' | 'dynamax' | 'zmove' | 'tera' (äº’æ–¥æœºåˆ¶é”)
 * - dynamax_moves: string[] (æå·¨åŒ–æ—¶çš„æ‹›å¼åˆ—è¡¨)
 * - z_move_config: { base_move, target_move, is_unique }
 */
function getDefaultBattleData() {
    return {
  "difficulty": "expert",
  "player": {
    "name": "player",
    "trainerProficiency": 255,
    "party": [
      {
        "slot": 1,
        "name": "Delphox",
        "gender": "F",
        "lv": 36,
        "quality": "high",
        "nature": "Sassy",
        "ability": "Magic Guard",
        "shiny": false,
        "item": null,
        "mechanic": null,
        "teraType": null,
        "isAce": true,
        "isLead": true,
        "moves": ["Flamethrower", "Flame Charge", "Mystical Fire", "Howl"],
        "stats_meta": {
          "ivs": { "hp": 31, "atk": 31, "def": 12, "spa": 31, "spd": 31, "spe": 31 },
          "ev_level": 177,
          "ev_up": 0
        },
        "avs": { "trust": 255, "passion": 255, "insight": 255, "devotion": 255 }
      },
      {
        "slot": 2,
        "name": "Wimpod",
        "gender": "M",
        "lv": 28,
        "quality": "medium",
        "nature": "Timid",
        "ability": "Wimp Out",
        "shiny": false,
        "item": null,
        "mechanic": null,
        "teraType": null,
        "isAce": true,
        "isLead": false,
        "moves": ["Struggle Bug", "Sand Attack", "Defense Curl", "Aqua Jet"],
        "stats_meta": {
          "ivs": { "hp": 7, "atk": 15, "def": 28, "spa": 18, "spd": 21, "spe": 31 },
          "ev_level": 78,
          "ev_up": 0
        },
        "avs": { "trust": 255, "passion": 255, "insight": 255, "devotion": 255 }
      },
      {
        "slot": 3,
        "name": "Kirlia",
        "gender": "F",
        "lv": 24,
        "quality": "high",
        "nature": "Timid",
        "ability": "Telepathy",
        "shiny": false,
        "item": "Soothe Bell",
        "mechanic": null,
        "teraType": null,
        "isAce": true,
        "isLead": false,
        "moves": ["Disarming Voice", "Double Team", "Confusion", "Life Dew"],
        "stats_meta": {
          "ivs": { "hp": 12, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
          "ev_level": 83,
          "ev_up": 0
        },
        "avs": { "trust": 251, "passion": 12, "insight": 52, "devotion": 255 }
      },
      {
        "slot": 4,
        "name": "Floragato",
        "gender": "F",
        "lv": 33,
        "quality": "high",
        "nature": "Adamant",
        "ability": "Protean",
        "shiny": false,
        "item": null,
        "mechanic": "tera",
        "teraType": "Steel",
        "isAce": true,
        "isLead": false,
        "moves": ["Metal Claw", "Leafage", "Sucker Punch", "Hone Claws"],
        "stats_meta": {
          "ivs": { "hp": 1, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
          "ev_level": 107,
          "ev_up": 0
        },
        "avs": { "trust": 25, "passion": 69, "insight": 38, "devotion": 0 }
      }
    ],
    "unlocks": {
      "enable_bond": false,
      "enable_styles": false,
      "enable_insight": false,
      "enable_mega": false,
      "enable_z_move": false,
      "enable_dynamax": false,
      "enable_tera": true
    }
  },
  "enemy": {
    "id": "Gloria",
    "type": "trainer",
    "name": "Gloria",
    "lines": {
      "start": "Don't blink! Or you'll miss the taste of defeat!",
      "win": "Haha! Looks like you're on dish duty!",
      "lose": "Eh?! Greedent got stuffed?! ...Fine, a deal's a deal!",
      "escape": "Hey! Where are you going?! The dishes are this way!"
    },
    "unlocks": {
      "enable_bond": false,
      "enable_styles": false,
      "enable_insight": false,
      "enable_mega": false,
      "enable_z_move": false,
      "enable_dynamax": true,
      "enable_tera": false
    },
    "party": [
      {
        "name": "Greedent",
        "gender": "M",
        "lv": 40,
        "nature": "Impish",
        "ability": "Cheek Pouch",
        "shiny": false,
        "item": "Sitrus Berry",
        "mechanic": null,
        "teraType": null,
        "stats_meta": {
          "ivs": { "hp": 31,"atk": 31,"def": 31,"spa": 31,"spd": 31,"spe": 31 },
          "ev_level": 252
        },
        "moves": ["Belch", "Body Slam", "Bullet Seed", "Stockpile"],
        "mega": null,
        "avs": { "trust": 0, "passion": 0, "insight": 0, "devotion": 0 }
      }
    ]
  },
  "party": [
    {
      "name": "Greedent",
      "gender": "M",
      "lv": 40,
      "nature": "Impish",
      "ability": "Cheek Pouch",
      "shiny": false,
      "item": "Sitrus Berry",
      "mechanic": null,
      "teraType": null,
      "stats_meta": {
        "ivs": { "hp": 31, "atk": 31, "def": 31, "spa": 31, "spd": 31, "spe": 31 },
        "ev_level": 252
      },
      "moves": ["Belch", "Body Slam", "Bullet Seed", "Stockpile"],
      "mega": null,
      "avs": { "trust": 0, "passion": 0, "insight": 0, "devotion": 0 }
    }
  ],
  "script": null
}
}
// ============================================
// JSON æ•°æ®åŠ è½½
// ============================================
/**
 * ä»å¤–éƒ¨ JSON å­—ç¬¦ä¸²åŠ è½½å¯¹æˆ˜ (ä¾› AI RP è°ƒç”¨)
 * JSON æ ¼å¼:
 * {
 *   "player": { "name": "ä¸»è§’å", "party": [...] },  // å¯é€‰
 *   "trainer": { "name": "è®­ç»ƒå®¶", "id": "xxx", "line": "å°è¯" },
 *   "party": [...],  // æ•Œæ–¹é˜Ÿä¼
 *   "script": "loss" | "win" | null
 * }
 */
function loadBattleFromJSON(jsonString) {
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) {
        console.error('[DATA-LOADER] battle object not found');
        return false;
    }
    try {
        const json = typeof jsonString === 'string' ? JSON.parse(jsonString) : jsonString;
        // åŠ è½½ç©å®¶é˜Ÿä¼ (å¦‚æœæœ‰)
        if (json.player && json.player.party) {
            const unlocks = json.player.unlocks || {};
            battle.playerUnlocks = {
                enable_bond: unlocks.enable_bond !== false,
                enable_styles: unlocks.enable_styles !== false,
                enable_insight: unlocks.enable_insight !== false,
                enable_mega: unlocks.enable_mega !== false,
                enable_z_move: unlocks.enable_z_move !== false,
                enable_dynamax: unlocks.enable_dynamax !== false,
                enable_tera: unlocks.enable_tera !== false
            };
            const playerCanMega = battle.playerUnlocks.enable_mega;
            battle.setPlayerParty(json.player.party, playerCanMega);
            battle.playerName = json.player.name || 'ä¸»è§’';
        }
        // åŠ è½½æ•Œæ–¹æ•°æ®
        battle.loadFromJSON(json);
        // æ›´æ–°è§†è§‰
        if (typeof updateAllVisuals === 'function') {
            updateAllVisuals();
        }
        return true;
    } catch (e) {
        console.error('Invalid battle JSON:', e);
        return false;
    }
}
/**
 * è§£æç©å®¶è§£é”é…ç½®
 * @param {Object} unlocks è§£é”é…ç½®å¯¹è±¡
 * @returns {Object} æ ‡å‡†åŒ–çš„è§£é”é…ç½®
 */
function parseUnlocks(unlocks = {}) {
    return {
        enable_bond: unlocks.enable_bond !== false,
        enable_styles: unlocks.enable_styles !== false,
        enable_insight: unlocks.enable_insight !== false,
        enable_mega: unlocks.enable_mega !== false,
        enable_z_move: unlocks.enable_z_move !== false,
        enable_dynamax: unlocks.enable_dynamax !== false,
        enable_tera: unlocks.enable_tera !== false
    };
}
/**
 * éªŒè¯æˆ˜æ–— JSON æ ¼å¼
 * @param {Object} json æˆ˜æ–—æ•°æ®
 * @returns {Object} { valid: boolean, errors: string[] }
 */
function validateBattleJSON(json) {
    const errors = [];
    if (!json) {
        errors.push('JSON data is null or undefined');
        return { valid: false, errors };
    }
    // æ£€æŸ¥æ•Œæ–¹é˜Ÿä¼
    if (!json.party || !Array.isArray(json.party) || json.party.length === 0) {
        errors.push('Missing or empty enemy party');
    }
    // æ£€æŸ¥æ¯ä¸ªå®å¯æ¢¦çš„å¿…è¦å­—æ®µ
    const checkPokemon = (pokemon, index, side) => {
        if (!pokemon.name) {
            errors.push(`${side} Pokemon #${index + 1}: missing name`);
        }
        if (typeof pokemon.lv !== 'number' || pokemon.lv < 1 || pokemon.lv > 100) {
            errors.push(`${side} Pokemon #${index + 1}: invalid level`);
        }
        if (!pokemon.moves || !Array.isArray(pokemon.moves) || pokemon.moves.length === 0) {
            errors.push(`${side} Pokemon #${index + 1}: missing moves`);
        }
    };
    if (json.party) {
        json.party.forEach((p, i) => checkPokemon(p, i, 'Enemy'));
    }
    if (json.player && json.player.party) {
        json.player.party.forEach((p, i) => checkPokemon(p, i, 'Player'));
    }
    return { valid: errors.length === 0, errors };
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.getDefaultBattleData = getDefaultBattleData;
    window.loadBattleFromJSON = loadBattleFromJSON;
    window.parseUnlocks = parseUnlocks;
    window.validateBattleJSON = validateBattleJSON;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        getDefaultBattleData,
        loadBattleFromJSON,
        parseUnlocks,
        validateBattleJSON
    };
}
]]></file>
        <file name="preloader.js"><![CDATA[/**
 * ===========================================
 * PRELOADER.JS - èµ„æºé¢„åŠ è½½ç³»ç»Ÿ
 * ===========================================
 */
const PreloadCache = {
    sprites: {},
    cries: {},
    bgm: null,
    trainerAvatars: {},
    pokemonIcons: {}
};
/**
 * é¢„åŠ è½½ç²¾çµå›¾
 */
function preloadSprite(name, isBack = false) {
    return new Promise((resolve) => {
        const id = name.toLowerCase().replace(/[^a-z0-9-]/g, '');
        const cacheKey = `${id}_${isBack ? 'back' : 'front'}`;
        if (PreloadCache.sprites[cacheKey]) {
            resolve(PreloadCache.sprites[cacheKey]);
            return;
        }
        const suffix = isBack ? '-back' : '';
        const url = `https://play.pokemonshowdown.com/sprites/ani${suffix}/${id}.gif`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.sprites[cacheKey] = img;
            resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½å«å£°
 */
function preloadCry(name) {
    return new Promise((resolve) => {
        let id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
        if (typeof POKEDEX !== 'undefined' && POKEDEX[id] && POKEDEX[id].baseSpecies) {
            id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
        const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
        for (const s of suffixes) {
            if (id.endsWith(s) && id.length > s.length) {
                id = id.replace(s, '');
                break;
            }
        }
        if (PreloadCache.cries[id]) {
            resolve(PreloadCache.cries[id]);
            return;
        }
        const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
        const audio = new Audio();
        audio.preload = 'auto';
        audio.oncanplaythrough = () => {
            PreloadCache.cries[id] = audio;
            resolve(audio);
        };
        audio.onerror = () => resolve(null);
        audio.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½è®­ç»ƒå®¶å¤´åƒ
 */
function preloadTrainerAvatar(trainerId) {
    return new Promise((resolve) => {
        if (!trainerId || trainerId === 'wild') {
            resolve(null);
            return;
        }
        if (PreloadCache.trainerAvatars[trainerId]) {
            resolve(PreloadCache.trainerAvatars[trainerId]);
            return;
        }
        const url = `./data/trainers/${trainerId}.png`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.trainerAvatars[trainerId] = img;
            resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = url;
        setTimeout(() => resolve(null), 3000);
    });
}
/**
 * é¢„åŠ è½½å®å¯æ¢¦å¤´åƒ sprite sheet (æ‰€æœ‰å®å¯æ¢¦å…±äº«)
 */
function preloadPokemonIconSheet() {
    return new Promise((resolve) => {
        if (PreloadCache.pokemonIcons['sheet']) {
            resolve(PreloadCache.pokemonIcons['sheet']);
            return;
        }
        const url = `https://play.pokemonshowdown.com/sprites/pokemonicons-sheet.png`;
        const img = new Image();
        img.onload = () => {
            PreloadCache.pokemonIcons['sheet'] = img;
            console.log('[PRELOAD] Pokemon icon sheet loaded');
            resolve(img);
        };
        img.onerror = () => {
            console.warn('[PRELOAD] Failed to load pokemon icon sheet');
            resolve(null);
        };
        img.src = url;
        setTimeout(() => resolve(null), 5000);
    });
}
/**
 * é¢„åŠ è½½æœ¬å±€æ‰€æœ‰èµ„æº
 */
async function preloadBattleResources(playerParty, enemyParty, trainerId, onProgress) {
    const tasks = [];
    // è®¡ç®—æ€»æ•°: ç©å®¶é˜Ÿä¼(ç²¾çµå›¾+å«å£°) + æ•Œæ–¹é˜Ÿä¼(ç²¾çµå›¾+å«å£°) + è®­ç»ƒå®¶å¤´åƒ + å®å¯æ¢¦å¤´åƒsheet
    const total = (playerParty.length + enemyParty.length) * 2 + 2;
    let loaded = 0;
    const updateProgress = () => {
        loaded++;
        if (onProgress) onProgress(loaded, total);
    };
    // ç©å®¶é˜Ÿä¼
    for (const p of playerParty) {
        const name = p.name || p;
        tasks.push(preloadSprite(name, true).then(updateProgress));
        tasks.push(preloadCry(name).then(updateProgress));
    }
    // æ•Œæ–¹é˜Ÿä¼
    for (const e of enemyParty) {
        const name = e.name || e;
        tasks.push(preloadSprite(name, false).then(updateProgress));
        tasks.push(preloadCry(name).then(updateProgress));
    }
    // è®­ç»ƒå®¶å¤´åƒ
    tasks.push(preloadTrainerAvatar(trainerId).then(updateProgress));
    // å®å¯æ¢¦å¤´åƒ sprite sheet (åªåŠ è½½ä¸€æ¬¡)
    tasks.push(preloadPokemonIconSheet().then(updateProgress));
    await Promise.all(tasks);
    console.log('[PRELOAD] All resources loaded');
}
/**
 * è·å–ç¼“å­˜çš„å«å£°å¹¶æ’­æ”¾
 */
function playCachedCry(name, volume = 0.45) {
    let id = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (typeof POKEDEX !== 'undefined' && POKEDEX[id] && POKEDEX[id].baseSpecies) {
        id = POKEDEX[id].baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '');
    }
    const suffixes = ['mega', 'megax', 'megay', 'gmax', 'alola', 'hisui', 'paldea', 'galar'];
    for (const s of suffixes) {
        if (id.endsWith(s) && id.length > s.length) {
            id = id.replace(s, '');
            break;
        }
    }
    const cached = PreloadCache.cries[id];
    if (cached) {
        const clone = cached.cloneNode();
        clone.volume = volume;
        clone.play().catch(() => {});
        console.log(`[CRY] Playing cached: ${name} -> ${id}`);
    } else {
        // Fallback: ç›´æ¥åœ¨çº¿åŠ è½½ (é¿å…é€’å½’è°ƒç”¨ playPokemonCry)
        const url = `https://play.pokemonshowdown.com/audio/cries/${id}.mp3`;
        const cryAudio = new Audio(url);
        cryAudio.volume = volume;
        cryAudio.play().catch(() => {});
        console.log(`[CRY] Playing online (cache miss): ${name} -> ${id}`);
    }
}
// å¯¼å‡º
window.preloadBattleResources = preloadBattleResources;
window.preloadTrainerAvatar = preloadTrainerAvatar;
window.preloadPokemonIconSheet = preloadPokemonIconSheet;
window.playCachedCry = playCachedCry;
window.PreloadCache = PreloadCache;
]]></file>
        <file name="translations.js"><![CDATA[/**
 * ===========================================
 * TRANSLATIONS.JS - æ±‰åŒ–æ•°æ®åº“
 * æ•°æ®æ¥æº: PSChina Tampermonkey Script (Ceca3)
 * ===========================================
 */
var translations={
    "Sort:":"æ’åºæ–¹å¼",
    "you have no pokemon lol":"ä½ çš„é˜Ÿä¼é‡Œè¿˜æ²¡æœ‰å®å¯æ¢¦",
    "Import from text":"ä»æ–‡æœ¬å¯¼å…¥",
    "Select a format":"é€‰æ‹©ä¸€ä¸ªåˆ†çº§",
    "Backup/Restore all teams":"å¤‡ä»½æ‰€æœ‰é˜Ÿä¼",
    "Backup all teams from this folder":"å¤‡ä»½è¯¥æ–‡ä»¶å¤¹é‡Œçš„æ‰€æœ‰é˜Ÿä¼",
    "Base":"ç§æ—å€¼",
    "Import":"å¯¼å…¥",
    "Types":"å±æ€§",
    "(automatic type)":"è‡ªåŠ¨å¯¹åº”çš„å±æ€§",
    "Hidden Power:":"è§‰é†’åŠ›é‡å±æ€§ï¼š",
    "You can also set natures by typing \"+\" and \"-\" next to a stat.":"ä½ å¯ä»¥åœ¨åŸºç¡€ç‚¹æ•°æ¡†å†…è¾“å…¥+å’Œ-æ¥è®¾å®šæ€§æ ¼",
    "Protip:":"æç¤ºï¼š",
    "Nature:":"æ€§æ ¼ï¼š",
    "Sort":"æ’åºæ–¹æ³•",
    "Hide":"éšè—",
    "Dark mode":"å¤œé—´æ¨¡å¼",
    "Minimum Elo:":"æœ€ä½Eloç§¯åˆ†ï¼š",
    "None":"æ— é™åˆ¶",
    "Search":"æœç´¢",
    "(muted)":"ï¼ˆå·²é™éŸ³ï¼‰",
    "Mute sounds":"å…¨éƒ¨é™éŸ³",
    "Effect volume:":"å®å¯æ¢¦å«å£°éŸ³é‡ï¼š",
    "Music volume:":"èƒŒæ™¯éŸ³ä¹éŸ³é‡ï¼š",
    "Notification volume:":"é€šçŸ¥æé†’éŸ³é‡",
    "(Offline)":"ï¼ˆç¦»çº¿ï¼‰",
    "Rated battle":"è®¡åˆ†æˆ˜æ–—",
    "Battle Options":"æˆ˜æ–—é€‰é¡¹",
    "In this battle":"åœ¨è¿™åœºæˆ˜æ–—ä¸­",
    "Ignore Spectators":"å¿½ç•¥æ¥è‡ªè§‚æˆ˜è€…çš„æ¶ˆæ¯",
    "Ignore Opponent":"å¿½ç•¥æ¥è‡ªå¯¹æ‰‹çš„æ¶ˆæ¯",
    "All battles":"æ‰€æœ‰æˆ˜æ–—ä¸­",
    "Ignore nicknames":"å¿½ç•¥å®å¯æ¢¦æ˜µç§°",
    "Open new battles on the right side":"åœ¨å³ä¾§å¼€å¯æ–°æˆ˜æ–—çª—å£",
    "Close":"å…³é—­",
    "Hardcore mode (hide info not shown in-game) (beta)":"ç¡¬æ ¸æ¨¡å¼(éšè—å®æœºæ— æ³•çœ‹åˆ°çš„ä¿¡æ¯)(æµ‹è¯•)",
    "Item:":"é“å…·ï¼š",
    "Ability:":"ç‰¹æ€§ï¼š",
    "(before items/abilities/modifiers)":"ï¼ˆä¸è®¡ç®—é“å…·/ç‰¹æ€§/åŠ æˆï¼‰",
    "(fainted)":"",
    "Waiting for players...":"ç­‰å¾…é€‰æ‰‹è¡ŒåŠ¨...",
    "Spectators ignored.":"è§‚æˆ˜è€…æ¶ˆæ¯å·²ç»è¢«å¿½ç•¥",
    "Spectators no longer ignored.":"è§‚æˆ˜è€…çš„æ¶ˆæ¯å·²ç»ä¸å†å¿½ç•¥",
    "Opponent ignored.":"å¯¹æ‰‹çš„æ¶ˆæ¯å·²ç»è¢«å¿½ç•¥",
    "Opponent no longer ignored.":"å¯¹æ‰‹çš„æ¶ˆæ¯å·²ç»ä¸å†å¿½ç•¥",
    "Hardcore mode ON: Information not available in-game is now hidden.":"ç¡¬æ ¸æ¨¡å¼å¼€å¯ï¼Œå®æœºæ— æ³•çœ‹åˆ°çš„ä¿¡æ¯å·²ç»è¢«éšè—",
    "Hardcore mode OFF: Information not available in-game is now shown.":"ç¡¬æ ¸æ¨¡å¼å…³é—­ï¼Œå®æœºæ— æ³•çœ‹åˆ°çš„ä¿¡æ¯å°†ä¼šæ˜¾ç¤º",
    "Nicknames ignored.":"æ˜µç§°å·²ç»è¢«å¿½ç•¥",
    "Nicknames no longer ignored.":"æ˜µç§°ä¸å†è¢«å¿½ç•¥",
    "(fainted)":"ï¼ˆæ¿’æ­»ï¼‰",
    "Turn":"å›åˆ",
    "PSN":"ä¸­æ¯’",
    "SLP":"ç¡çœ ",
    "PAR":"éº»ç—¹",
    "BRN":"ç¼ä¼¤",
    "TOX":"ä¸­å‰§æ¯’",
    "Attack":"æ”»å‡»",
    "Defense":"é˜²å¾¡",
    "Speed":"é€Ÿåº¦",
    "Speed:":"é€Ÿåº¦ï¼š",
    "Hyperfast":"æå¿«",
    "Fast":"å¿«",
    "Slow":"æ…¢",
    "Really Slow":"ææ…¢",
    "Music:":"éŸ³ä¹ï¼š",
    "Play (music off)":"æ’­æ”¾ï¼ˆå…³é—­éŸ³ä¹ï¼‰",
    "Reset":"é‡ç½®",
    "Next turn":"ä¸‹ä¸€å›åˆ",
    "Go to turn...":"è·³è‡³...å›åˆ",
    "Resume":"æ¢å¤",
    "Battle timer is ON: inactive players will automatically lose when time's up.":"æˆ˜æ–—æœºè®¡æ—¶å™¨å·²ç»å¼€å¯ï¼šç©å®¶è‹¥ä¸è¡ŒåŠ¨åˆ™åœ¨æ—¶é—´è€—å°½åä¼šè¾“æ‰æ¯”èµ›",
    "EVs":"åŸºç¡€ç‚¹æ•°",
    "IVs":"ä¸ªä½“å€¼",
    "IV spreads":"ä¸ªä½“å€¼åˆ†é…",
    "Remaining:":"å‰©ä½™ç‚¹æ•°ï¼š",
    "Prompt on refresh":"åˆ·æ–°é¡µé¢æ—¶å¼¹å‡ºæé†’çª—å£",
    "(Others will be able to see your name change. To change name privately, use \"Log out\")":"å…¶ä»–äººå¯ä»¥çœ‹åˆ°ä½ æ›´æ”¹äº†ç”¨æˆ·åï¼Œæƒ³è¦ç§ä¸‹åœ°æ›´æ”¹ç”¨æˆ·åï¼Œç‚¹å‡»â€˜ç™»å‡ºâ€™æŒ‰é’®",
    "Power":"å¨åŠ›",
    "Accuracy":"å‘½ä¸­",
    "Tournaments:":"æˆ¿é—´æ¯”èµ›ä¿¡æ¯",
    "Notifications":"æ¥æ”¶æ¶ˆæ¯",
    "No Notifications":"ä¸æ¥æ”¶æ¶ˆæ¯",
    "Block PMs":"å±è”½ç§èŠä¿¡æ¯",
    "Block Challenges":"å±è”½æŒ‘æˆ˜",
    "Choose an avatar or":"é€‰æ‹©ä¸€ä¸ªå¤´åƒæˆ–è€…",
    "Text formatting":"æ–‡æœ¬æ ¼å¼",
    "You have been logged out and disconnected.":"ä½ å·²ç»ç™»å‡ºå¹¶ä¸”æ–­å¼€äº†è¿æ¥",
    "If you wanted to change your name while staying connected, use the 'Change Name' button or the '/nick' command.":"å¦‚æœä½ æƒ³è¦åœ¨ä¿æŒè¿æ¥çš„æƒ…å†µä¸‹æ›´æ”¹ç”¨æˆ·åï¼Œç‚¹å‡»â€˜æ›´æ”¹ç”¨æˆ·åâ€™æŒ‰é’®æˆ–è€…ä½¿ç”¨/nick å‘½ä»¤",
    "Suppressed":"è¢«æ¶ˆé™¤",
    "Possible abilities:":"å¯èƒ½çš„ç‰¹æ€§ï¼š",
    "The name you chose is registered.":"ä½ é€‰æ‹©çš„ç”¨æˆ·åå·²ç»è¢«æ³¨å†Œäº†",
    "If this is your account:":"å¦‚æœè¿™æ˜¯ä½ çš„è´¦å·ï¼š",
[... truncated: only first 100 lines included ...]
]]></file>
    </directory>
    <directory name="ui">
        <file name="sprite-duplicate-fix.js"><![CDATA[/**
 * ===========================================
 * SPRITE-DUPLICATE-FIX.JS - é‡å¤ç²¾çµå›¾ä¿®å¤
 * ===========================================
 * 
 * é—®é¢˜ï¼šå½“å¤šåªç›¸åŒå®å¯æ¢¦å‡ºç°æ—¶ï¼Œæµè§ˆå™¨ç¼“å­˜ GIF å¯¼è‡´
 *       åç»­ç›¸åŒ URL çš„ç²¾çµå›¾ä¸ä¼šé‡æ–°æ’­æ”¾åŠ¨ç”»
 * 
 * è§£å†³æ–¹æ¡ˆï¼šé”€æ¯å¹¶é‡å»º img å…ƒç´ ï¼Œå¼ºåˆ¶æµè§ˆå™¨é‡æ–°æ¸²æŸ“ GIF
 */
(function() {
    'use strict';
    // è®°å½•å½“å‰æ˜¾ç¤ºçš„ç²¾çµå›¾ URLï¼ˆå»é™¤æŸ¥è¯¢å‚æ•°åçš„åŸºç¡€ URLï¼‰
    let currentEnemySpriteUrl = null;
    // æ ‡è®°æ˜¯å¦æ˜¯çœŸæ­£çš„æ¢äººï¼ˆç”±å¤–éƒ¨è°ƒç”¨è®¾ç½®ï¼‰
    let isActualSwitch = false;
    /**
     * é”€æ¯å¹¶é‡å»ºç²¾çµå›¾å…ƒç´ ï¼ˆç»ˆææ–¹æ¡ˆï¼‰
     * ã€ä¼˜åŒ–ã€‘ä½¿ç”¨æ·¡å…¥æ·¡å‡ºæ•ˆæœï¼Œé¿å…çªç„¶æ¶ˆå¤±
     * @param {string} spriteId - DOM å…ƒç´  ID
     * @param {string} url - å›¾ç‰‡ URL
     */
    function recreateSpriteElement(spriteId, url) {
        const oldImg = document.getElementById(spriteId);
        if (!oldImg) return;
        const parent = oldImg.parentNode;
        if (!parent) return;
        console.log(`[SPRITE-FIX] Recreating element for: ${url}`);
        // æ·»åŠ å”¯ä¸€å‚æ•°ç¡®ä¿ä¸ä½¿ç”¨ç¼“å­˜
        const separator = url.includes('?') ? '&' : '?';
        const uniqueUrl = `${url}${separator}_t=${Date.now()}`;
        // ã€åŒæ­¥æ›¿æ¢ã€‘ç«‹å³åˆ›å»ºæ–°å…ƒç´ å¹¶æ›¿æ¢
        const newImg = document.createElement('img');
        newImg.id = spriteId;
        // ã€ä¿®å¤ã€‘ä¿ç•™åŸå§‹ç±»ï¼ˆåŒ…æ‹¬ player-scaleï¼‰
        newImg.className = oldImg.className.replace(/loaded|entering|fainted-hidden|fainting/g, '').trim() || 'p-sprite';
        newImg.alt = oldImg.alt || '';
        // è®¾ç½®åŠ è½½å›è°ƒ
        newImg.onload = function() {
            newImg.classList.add('loaded');
            newImg.classList.remove('entering');
            void newImg.offsetWidth;
            newImg.classList.add('entering');
            setTimeout(() => newImg.classList.remove('entering'), 650);
            console.log(`[SPRITE-FIX] Recreate complete: ${spriteId}`);
        };
        newImg.onerror = function() {
            console.error(`[SPRITE-FIX] Failed to load: ${uniqueUrl}`);
        };
        // å…ˆè®¾ç½® src
        newImg.src = uniqueUrl;
        // ç«‹å³æ›¿æ¢æ—§å…ƒç´ 
        parent.replaceChild(newImg, oldImg);
    }
    /**
     * åŒ…è£…åŸå§‹çš„ smartLoadSprite å‡½æ•°
     * æ£€æµ‹é‡å¤ URL å¹¶é‡å»ºå…ƒç´ 
     */
    function wrapSmartLoadSprite() {
        const originalSmartLoadSprite = window.smartLoadSprite;
        if (!originalSmartLoadSprite) {
            console.warn('[SPRITE-FIX] smartLoadSprite not found, retrying...');
            setTimeout(wrapSmartLoadSprite, 100);
            return;
        }
        window.smartLoadSprite = function(id, url, forceAnim = false) {
            // åªå¤„ç†æ•Œæ–¹ç²¾çµå›¾çš„é‡å¤é—®é¢˜
            if (id === 'enemy-sprite') {
                const baseUrl = url.split('?')[0];
                // ã€ç®€åŒ–é€»è¾‘ã€‘åªæœ‰å½“ isActualSwitch=true ä¸” URL ç›¸åŒæ—¶æ‰è§¦å‘é‡å»º
                // isActualSwitch ç”±å¤–éƒ¨åœ¨æ¢äººå‰è®¾ç½®ä¸º true
                if (isActualSwitch && currentEnemySpriteUrl === baseUrl) {
                    console.log(`[SPRITE-FIX] Duplicate enemy sprite on switch: ${baseUrl}`);
                    isActualSwitch = false; // é‡ç½®æ ‡è®°
                    recreateSpriteElement(id, url);
                    return;
                }
                // é‡ç½®æ ‡è®°ï¼ˆæ— è®ºæ˜¯å¦è§¦å‘é‡å»ºï¼‰
                isActualSwitch = false;
                // è®°å½•å½“å‰ URL
                currentEnemySpriteUrl = baseUrl;
            }
            // è°ƒç”¨åŸå§‹å‡½æ•°
            originalSmartLoadSprite.call(this, id, url, forceAnim);
        };
        console.log('[SPRITE-FIX] smartLoadSprite wrapped successfully');
    }
    /**
     * é‡ç½®çŠ¶æ€ï¼ˆæˆ˜æ–—ç»“æŸæ—¶è°ƒç”¨ï¼‰
     */
    function resetDuplicateFix() {
        currentEnemySpriteUrl = null;
        isActualSwitch = false;
        console.log('[SPRITE-FIX] State reset');
    }
    /**
     * æ ‡è®°å³å°†è¿›è¡Œæ¢äººï¼ˆåœ¨æ¢äººå‰è°ƒç”¨ï¼‰
     * è¿™æ · smartLoadSprite å°±çŸ¥é“è¿™æ˜¯çœŸæ­£çš„æ¢äººï¼Œè€Œä¸æ˜¯å½¢æ€åˆ‡æ¢æˆ–å›åˆæ›´æ–°
     */
    function markEnemySwitch() {
        isActualSwitch = true;
        console.log('[SPRITE-FIX] Enemy switch marked');
    }
    // å¯¼å‡ºå‡½æ•°
    window.resetSpriteDuplicateFix = resetDuplicateFix;
    window.markEnemySwitch = markEnemySwitch;
    // åˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', wrapSmartLoadSprite);
    } else {
        setTimeout(wrapSmartLoadSprite, 50);
    }
    console.log('[SPRITE-FIX] Module loaded');
})();
]]></file>
        <file name="ui-menus.js"><![CDATA[/**
 * ===========================================
 * UI-MENUS.JS - èœå•ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - ä¸»èœå•/æŠ€èƒ½èœå•åˆ‡æ¢
 * - Mega/Dynamax/Tera æŒ‰é’®æ§åˆ¶
 * - è¿›åŒ–åŠ¨ç”»æ’­æ”¾
 */
// ============================================
// èœå•åˆ‡æ¢
// ============================================
/**
 * æ˜¾ç¤ºæŠ€èƒ½èœå•
 */
function showMovesMenu() {
    console.log('[UI-MENUS] showMovesMenu called');
    const battle = typeof window !== 'undefined' ? window.battle : null;
    // =========================================================
    // ã€æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿã€‘æ£€æŸ¥æ˜¯å¦è§¦å‘æŒ‡æŒ¥èœå•
    // =========================================================
    if (battle && typeof window.shouldShowCommanderMenu === 'function') {
        if (window.shouldShowCommanderMenu()) {
            // è§¦å‘æŒ‡æŒ¥èœå•ï¼Œæš‚æ—¶ä¸æ˜¾ç¤ºæŠ€èƒ½èœå•
            if (typeof window.showCommanderMenu === 'function') {
                window.showCommanderMenu();
                return; // ç­‰å¾…ç©å®¶é€‰æ‹©æŒ‡ä»¤åå†æ˜¾ç¤ºæŠ€èƒ½èœå•
            }
        }
    }
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('moves-menu').classList.remove('hidden');
    // ã€å¤æ­¦ç³»ç»Ÿã€‘æ ¹æ® enable_styles æ˜¾ç¤º/éšè—å¤ªæçƒ
    const taijiOrb = document.getElementById('btn-style-taiji');
    console.log('[UI-MENUS] battle:', battle, 'taijiOrb:', taijiOrb);
    if (taijiOrb && battle) {
        const unlocks = battle.playerUnlocks || {};
        console.log('[UI-MENUS] unlocks:', unlocks);
        if (unlocks.enable_styles) {
            taijiOrb.classList.remove('hidden');
            console.log('[UI-MENUS] Showing taiji orb (styles enabled)');
            // åˆå§‹åŒ–é£æ ¼ä¸º normal
            if (typeof setMoveStyle === 'function') {
                setMoveStyle('normal', { silent: true });
            }
        } else {
            taijiOrb.classList.add('hidden');
            console.log('[UI-MENUS] Hiding taiji orb (styles disabled)');
        }
    }
    // æ›´æ–° Mega æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
    console.log('[UI-MENUS] Calling updateMegaButtonVisibility');
    updateMegaButtonVisibility();
}
/**
 * æ˜¾ç¤ºä¸»èœå•
 */
function showMainMenu() {
    if (typeof window.playSFX === 'function') window.playSFX('CANCEL');
    document.getElementById('moves-menu').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
    const battle = typeof window !== 'undefined' ? window.battle : null;
    // è¿”å›ä¸»èœå•æ—¶é‡ç½® Mega é¢„å¤‡çŠ¶æ€
    if (battle && battle.playerMegaArmed) {
        battle.playerMegaArmed = false;
        const megaBtn = document.getElementById('btn-mega');
        if (megaBtn) megaBtn.classList.remove('armed');
    }
}
// ============================================
// Mega/Dynamax/Tera æŒ‰é’®æ§åˆ¶
// ============================================
/**
 * æ›´æ–° Mega/Dynamax/Tera æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
 */
function updateMegaButtonVisibility() {
    const megaBtn = document.getElementById('btn-mega');
    if (!megaBtn) {
        console.log('[MEGA UI] btn-mega element not found!');
        return;
    }
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const p = battle.getPlayer();
    if (!p) {
        console.log('[MEGA UI] No player pokemon');
        megaBtn.classList.add('hidden');
        return;
    }
    // æ¸…é™¤ä¹‹å‰çš„æ ·å¼çŠ¶æ€
    megaBtn.classList.remove('dynamax-style', 'evo-style', 'tera-style');
    const iconText = megaBtn.querySelector('.mega-icon text');
    if (iconText) iconText.textContent = 'M'; // é»˜è®¤ M
    // äº’æ–¥æœºåˆ¶æ£€æŸ¥
    const lockedMechanic = p.mechanic;
    console.log(`[MEGA UI] Player: ${p.name}, canMegaEvolve: ${p.canMegaEvolve}, canDynamax: ${p.canDynamax}, canTera: ${p.canTera}, mechanic: ${lockedMechanic}`);
    const canMegaEvolveFunc = window.canMegaEvolve;
    const canActivateMechanicFunc = window.canActivateMechanic || (() => true);
    // è§£é”ç³»ç»Ÿæ£€æŸ¥
    const unlocks = battle.playerUnlocks || {};
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥ Mega è¿›åŒ–
    const canMega = unlocks.enable_mega !== false
        && typeof canMegaEvolveFunc === 'function' 
        && canMegaEvolveFunc(p) 
        && !battle.playerMegaUsed
        && canActivateMechanicFunc(p, 'mega')
        && (!lockedMechanic || lockedMechanic === 'mega');
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æå·¨åŒ–
    const canDynamax = unlocks.enable_dynamax !== false
        && p.canDynamax 
        && !p.isDynamaxed 
        && !battle.playerMaxUsed
        && canActivateMechanicFunc(p, 'dynamax')
        && (!lockedMechanic || lockedMechanic === 'dynamax');
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤ªæ™¶åŒ–
    const canTerastallize = unlocks.enable_tera !== false
        && p.canTera 
        && !p.isTerastallized 
        && !battle.playerTeraUsed
        && canActivateMechanicFunc(p, 'tera')
        && lockedMechanic === 'tera';
    const isDynamaxTarget = p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax');
    console.log(`[MEGA UI] canMega: ${canMega}, canDynamax: ${canDynamax}, canTera: ${canTerastallize}, lockedMechanic: ${lockedMechanic}, isDynamaxTarget: ${isDynamaxTarget}`);
    // å¤ªæ™¶åŒ–æ¨¡å¼
    if (lockedMechanic === 'tera') {
        if (canTerastallize) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.add('tera-style');
            if (iconText) iconText.textContent = 'T';
            p.evolutionType = 'tera';
        } else {
            megaBtn.classList.add('hidden');
            battle.playerMegaArmed = false;
        }
        return;
    }
    // Z-Move æ¨¡å¼ä¸æ˜¾ç¤ºæŒ‰é’®
    if (lockedMechanic === 'zmove') {
        megaBtn.classList.add('hidden');
        battle.playerMegaArmed = false;
        return;
    }
    // Dynamax æ¨¡å¼ï¼ˆä¼˜å…ˆæ£€æŸ¥ï¼‰
    if (lockedMechanic === 'dynamax') {
        if (canDynamax) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.add('dynamax-style');
            if (iconText) iconText.textContent = 'X';
            p.evolutionType = 'dynamax';
            console.log('[MEGA UI] Showing Dynamax button (mechanic locked)');
        } else {
            megaBtn.classList.add('hidden');
            console.log('[MEGA UI] Hidden: mechanic locked to dynamax but canDynamax is false');
        }
        return;
    }
    // Mega æ¨¡å¼
    if (lockedMechanic === 'mega') {
        if (canMega) {
            megaBtn.classList.remove('hidden');
            megaBtn.classList.remove('dynamax-style');
            p.evolutionType = 'mega';
            console.log('[MEGA UI] Showing Mega button (mechanic locked)');
        } else {
            megaBtn.classList.add('hidden');
            console.log('[MEGA UI] Hidden: mechanic locked to mega but canMega is false');
        }
        return;
    }
    // æ— é”å®šæœºåˆ¶æ—¶çš„è‡ªåŠ¨æ£€æµ‹
    if (canDynamax || (canMega && isDynamaxTarget)) {
        // æå·¨åŒ–æ¨¡å¼
        megaBtn.classList.remove('hidden');
        megaBtn.classList.add('dynamax-style');
        if (iconText) iconText.textContent = 'X';
        p.evolutionType = 'dynamax';
        console.log('[MEGA UI] Showing Dynamax button (auto-detected)');
    } else if (canMega) {
        // æ™®é€š Mega æ¨¡å¼
        megaBtn.classList.remove('hidden');
        megaBtn.classList.remove('dynamax-style');
        p.evolutionType = 'mega';
        console.log('[MEGA UI] Showing Mega button (auto-detected)');
    } else {
        megaBtn.classList.add('hidden');
        console.log('[MEGA UI] Hidden: no mechanic available');
        battle.playerMegaArmed = false;
        megaBtn.classList.remove('armed');
    }
}
// ============================================
// è¿›åŒ–åŠ¨ç”»
// ============================================
/**
 * æ‰§è¡Œ Mega è¿›åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function playMegaEvolutionAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    const isBack = isPlayer;
    const newSpriteUrl = pokemon.getSprite(isBack);
    sprite.classList.remove('evo-silhouette', 'evo-burst', 'evo-finish');
    // é˜¶æ®µ 1: DNA å‰ªå½±
    sprite.classList.add('evo-silhouette');
    await wait(1000);
    // é˜¶æ®µ 2: ç™½å…‰çˆ†å‘ + åˆ‡æ¢å›¾ç‰‡
    sprite.classList.remove('evo-silhouette');
    sprite.classList.add('evo-burst');
    const spriteRequestedUrls = window.spriteRequestedUrls || {};
    delete spriteRequestedUrls[spriteId];
    if (typeof smartLoadSprite === 'function') {
        smartLoadSprite(spriteId, newSpriteUrl, false);
    }
    spriteRequestedUrls[spriteId] = newSpriteUrl;
    await wait(300);
    // é˜¶æ®µ 3: å†·å´åŠ¨ç”»
    sprite.classList.remove('evo-burst');
    sprite.classList.add('evo-finish');
    await wait(800);
    // ã€ä¿®å¤ã€‘ä¿ç•™ player-scale ç±»ï¼Œé¿å…ç²¾çµå›¾å¤§å°å˜åŒ–
    sprite.classList.remove('evo-silhouette', 'evo-burst', 'evo-finish');
    if (!sprite.classList.contains('loaded')) {
        sprite.classList.add('loaded');
    }
    sprite.classList.add(isPlayer ? 'mega-player' : 'mega-enemy');
}
/**
 * æ‰§è¡Œæå·¨åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function playDynamaxAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    sprite.classList.remove('evo-silhouette', 'evo-burst', 'evo-finish', 'state-dynamax', 'dynamax-burst', 'dynamax-shrink');
    // é˜¶æ®µ 1: çº¢è‰²çˆ†å‘åŠ¨ç”»
    sprite.classList.add('dynamax-burst');
    await wait(800);
    // é˜¶æ®µ 2: è¿›å…¥æå·¨åŒ–çŠ¶æ€
    sprite.classList.remove('dynamax-burst');
    sprite.classList.add('state-dynamax');
    await wait(200);
}
/**
 * ç»“æŸæå·¨åŒ–çš„è§†è§‰æ•ˆæœ
 */
async function endDynamaxAnimation(pokemon, isPlayer = true) {
    const spriteId = isPlayer ? 'player-sprite' : 'enemy-sprite';
    const sprite = document.getElementById(spriteId);
    if (!sprite) return;
    sprite.classList.remove('state-dynamax');
    sprite.classList.add('dynamax-shrink');
    await wait(600);
    sprite.classList.remove('dynamax-shrink', 'dynamax-burst');
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šç­‰å¾…
 */
function wait(ms) { 
    return new Promise(r => setTimeout(r, ms)); 
}
/**
 * è¾…åŠ©å‡½æ•°ï¼šæ—¥å¿—è¾“å‡º
 */
function log(msg) {
    if (typeof window !== 'undefined' && typeof window.log === 'function') {
        window.log(msg);
    } else {
        console.log(msg);
    }
}
// ============================================
// Mega/Dynamax/Tera åˆ‡æ¢
// ============================================
/**
 * åˆ‡æ¢ Mega/Dynamax/Tera è¿›åŒ–é¢„å¤‡çŠ¶æ€
 */
function toggleMega() {
    const megaBtn = document.getElementById('btn-mega');
    if (!megaBtn) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    if (!battle) return;
    const p = battle.getPlayer();
    const canMegaEvolveFunc = window.canMegaEvolve;
    // =========================================================
    // å¤ªæ™¶åŒ–æ¨¡å¼ (ä¼˜å…ˆæ£€æŸ¥)
    // =========================================================
    if (p && p.mechanic === 'tera' && p.canTera) {
        if (battle.playerTeraUsed || p.isTerastallized) {
            return;
        }
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#22d3ee">ğŸ’ å¤ªæ™¶åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œå¤ªæ™¶åŒ–ï¼(${p.teraType})</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆå¤ªæ™¶åŒ–é¢„å¤‡ã€‚</span>`);
        }
        return;
    }
    // æ£€æŸ¥æ˜¯å¦æ˜¯æå·¨åŒ–æ¨¡å¼
    const isDynamaxMode = p && (p.canDynamax || (p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax')));
    if (isDynamaxMode) {
        // === æå·¨åŒ–æ¨¡å¼ ===
        if (battle.playerMaxUsed || p.isDynamaxed) {
            return;
        }
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#e11d48">âœ¦ æå·¨åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œæå·¨åŒ–ï¼</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆæå·¨åŒ–é¢„å¤‡ã€‚</span>`);
        }
        return;
    }
    // === æ™®é€š Mega æ¨¡å¼ ===
    if (!p || !canMegaEvolveFunc || !canMegaEvolveFunc(p) || battle.playerMegaUsed) {
        return;
    }
    // æ£€æŸ¥æ˜¯å¦æ˜¯åŒ Mega å®å¯æ¢¦ï¼ˆå–·ç«é¾™/è¶…æ¢¦ï¼‰
    if (p.hasDualMega && p.megaFormsAvailable && p.megaFormsAvailable.length >= 2) {
        // å¦‚æœå·²ç»é¢„å¤‡ï¼Œåˆ™å–æ¶ˆ
        if (battle.playerMegaArmed) {
            battle.playerMegaArmed = false;
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆ Mega è¿›åŒ–é¢„å¤‡ã€‚</span>`);
            return;
        }
        // æ˜¾ç¤ºé€‰æ‹©å¯¹è¯æ¡†
        if (typeof showMegaFormSelectionDialog === 'function') {
            showMegaFormSelectionDialog(p, (selectedFormId) => {
                if (selectedFormId) {
                    p.megaTargetId = selectedFormId;
                    p.formTargetId = selectedFormId;
                    battle.playerMegaArmed = true;
                    megaBtn.classList.add('armed');
                    const formName = selectedFormId.includes('megax') ? 'Mega X' : 'Mega Y';
                    log(`<span style="color:#a855f7">âœ¦ ${formName} è¿›åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œ Mega è¿›åŒ–ï¼</span>`);
                }
            });
        }
    } else {
        // æ™®é€š Megaï¼ˆå•ä¸€å½¢æ€ï¼‰
        battle.playerMegaArmed = !battle.playerMegaArmed;
        if (battle.playerMegaArmed) {
            megaBtn.classList.add('armed');
            log(`<span style="color:#a855f7">âœ¦ Mega è¿›åŒ–å°±ç»ªï¼é€‰æ‹©æ‹›å¼åå°†è¿›è¡Œ Mega è¿›åŒ–ï¼</span>`);
        } else {
            megaBtn.classList.remove('armed');
            log(`<span style="color:#94a3b8">å–æ¶ˆ Mega è¿›åŒ–é¢„å¤‡ã€‚</span>`);
        }
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.showMovesMenu = showMovesMenu;
    window.showMainMenu = showMainMenu;
    window.updateMegaButtonVisibility = updateMegaButtonVisibility;
    window.toggleMega = toggleMega;
    window.playMegaEvolutionAnimation = playMegaEvolutionAnimation;
    window.playDynamaxAnimation = playDynamaxAnimation;
    window.endDynamaxAnimation = endDynamaxAnimation;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        showMovesMenu,
        showMainMenu,
        toggleMega,
        updateMegaButtonVisibility,
        playMegaEvolutionAnimation,
        playDynamaxAnimation,
        endDynamaxAnimation
    };
}
]]></file>
        <file name="ui-renderer.js"><![CDATA[/**
 * ===========================================
 * UI-RENDERER.JS - æ ¸å¿ƒ UI æ¸²æŸ“
 * ===========================================
 * 
 * èŒè´£:
 * - è¡€æ¡æ¸²æŸ“
 * - ç²¾çµçƒæ§½æ¸²æŸ“
 * - UI ç¼©æ”¾
 */
// ============================================
// UI ç¼©æ”¾
// ============================================
/**
 * å›ºå®šç”»å¸ƒç­‰æ¯”ç¼©æ”¾ (åŸºå‡† 1280x720)
 */
function updateUIScale() {
    const baseW = 1280;
    const baseH = 720;
    const pad = 0;
    const vw = Math.max(0, window.innerWidth - pad * 2);
    const vh = Math.max(0, window.innerHeight - pad * 2);
    const scale = Math.min(vw / baseW, vh / baseH);
    const el = document.getElementById('ui-scale');
    if (!el) return;
    el.style.setProperty('--ui-scale', String(scale));
}
// ============================================
// è¡€æ¡æ¸²æŸ“
// ============================================
/**
 * æ¸²æŸ“è¡€æ¡
 * @param {string} who 'player' æˆ– 'enemy'
 * @param {number} curr å½“å‰ HP
 * @param {number} max æœ€å¤§ HP
 */
function renderHp(who, curr, max) {
    const pct = Math.max(0, (curr / max) * 100);
    const bar = document.getElementById(`${who}-hp-fill`);
    const txt = document.getElementById(`${who}-hp-txt`);
    if (bar) {
        bar.style.width = pct + "%";
        bar.style.background = pct < 20 ? 'var(--hp-low)' : (pct < 50 ? 'var(--hp-mid)' : 'var(--hp-high)');
    }
    if (txt) txt.innerText = `${curr}/${max}`;
}
// ============================================
// ç²¾çµçƒæ§½æ¸²æŸ“
// ============================================
/**
 * æ¸²æŸ“ 6 ä¸ªç²¾çµçƒæ§½ä½œä¸ºçŠ¶æ€æ˜¾ç¤º
 * @param {string} idBox DOM å…ƒç´  ID
 * @param {Array} party é˜Ÿä¼æ•°ç»„
 * @param {number} idxActive å½“å‰å‡ºæˆ˜ç´¢å¼•
 */
function renderDots(idBox, party, idxActive) {
    const box = document.getElementById(idBox);
    if (!box) return;
    box.innerHTML = '';
    for (let i = 0; i < 6; i++) {
        const slot = document.createElement('div');
        slot.className = 'poke-slot';
        if (i >= party.length) {
            slot.classList.add('empty');
        } else {
            const pm = party[i];
            if (pm.isAlive()) {
                slot.classList.add('alive');
            } else {
                slot.classList.add('dead');
            }
            if (i === idxActive) {
                slot.classList.add('active');
            }
        }
        box.appendChild(slot);
    }
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.updateUIScale = updateUIScale;
    window.renderHp = renderHp;
    window.renderDots = renderDots;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        updateUIScale,
        renderHp,
        renderDots
    };
}
]]></file>
        <file name="ui-sprites.js"><![CDATA[/**
 * ===========================================
 * UI-SPRITES.JS - ç²¾çµå›¾åŠ è½½ä¸ç®¡ç†
 * ===========================================
 * 
 * èŒè´£:
 * - ç²¾çµå›¾æ™ºèƒ½åŠ è½½ï¼ˆæ”¯æŒå¤šå›¾åº“å›é€€ï¼‰
 * - ID å˜ä½“ç”Ÿæˆï¼ˆæ”¯æŒåœ°åŒºå½¢æ€ã€Mega ç­‰ï¼‰
 * - ç²¾çµå›¾çŠ¶æ€é‡ç½®
 */
// ============================================
// çŠ¶æ€ç®¡ç†
// ============================================
// è®°å½•æ¯ä¸ªç²¾çµå½“å‰è¯·æ±‚çš„åŸå§‹URLï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ–°åŠ è½½ï¼‰
const spriteRequestedUrls = {};
// ============================================
// ID å˜ä½“ç”Ÿæˆ
// ============================================
/**
 * ç”Ÿæˆ ID å˜ä½“ï¼ˆæ”¯æŒå¸¦æ¨ªæ çš„å®å¯æ¢¦åå­—ï¼‰
 * @param {string} name åŸå§‹åç§°
 * @returns {object} åŒ…å«å¤šç§ ID å˜ä½“çš„å¯¹è±¡
 */
function generateIdVariants(name = '') {
    const raw = name.toLowerCase().trim();
    // 1. ä¸¥æ ¼æ¨¡å¼ (ä¿ç•™æ¨ªæ ): "vulpix-alola", "ho-oh"
    const strict = raw.replace(/[^a-z0-9-]/g, '');
    // 2. ç´§å‡‘æ¨¡å¼ (æ— æ¨ªæ ): "vulpixalola", "hooh"
    const compact = raw.replace(/[^a-z0-9]/g, '');
    // 3. åŸºç¡€æ¨¡å¼ (å°è¯•ç§»é™¤åç¼€): "vulpix-alola" -> "vulpix"
    const suffixes = [
        '-alola', '-galar', '-hisui', '-paldea',
        '-mega', '-megax', '-megay', '-gmax',
        '-origin', '-therian', '-incarnate',
        '-black', '-white', '-dusk', '-dawn',
        '-school', '-complete', '-attack', '-defense', '-speed',
        '-primal', '-combat', '-blaze', '-aqua'
    ];
    let base = strict;
    for (const suffix of suffixes) {
        if (base.endsWith(suffix)) {
            base = base.replace(suffix, '');
            break;
        }
    }
    // ä¿ç•™ç‰¹æ®Šåå­—çš„æ¨ªæ 
    if (base !== 'ho-oh' && base !== 'porygon-z' && base !== 'jangmo-o' && base !== 'hakamo-o' && base !== 'kommo-o') {
        base = base.replace(/-/g, '');
    }
    return { strict, compact, base };
}
// ============================================
// æ™ºèƒ½ç²¾çµå›¾åŠ è½½
// ============================================
/**
 * æ™ºèƒ½åŠ è½½ç²¾çµå›¾ï¼ˆæ”¯æŒå¤šå›¾åº“å›é€€ï¼‰
 * @param {string} id DOM å…ƒç´  ID
 * @param {string} url ç›®æ ‡ URL
 * @param {boolean} forceAnim æ˜¯å¦å¼ºåˆ¶æ’­æ”¾å…¥åœºåŠ¨ç”»
 */
function smartLoadSprite(id, url, forceAnim = false) {
    const img = document.getElementById(id);
    if (!img) return;
    // å¦‚æœè¯·æ±‚çš„URLæ²¡å˜ä¸”å·²åŠ è½½å®Œæˆï¼Œè·³è¿‡ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
    if (!forceAnim && spriteRequestedUrls[id] === url && img.classList.contains('loaded')) {
        return;
    }
    // å¼ºåˆ¶é‡æ’­åŠ¨ç”»ï¼ˆæ¢äººæ—¶ï¼‰
    if (forceAnim && spriteRequestedUrls[id] === url && img.classList.contains('loaded')) {
        console.log(`[SPRITE] Replay entry animation for: ${url}`);
        img.classList.remove('entering');
        void img.offsetWidth;
        img.classList.add('entering');
        setTimeout(() => img.classList.remove('entering'), 650);
        return;
    }
    // è®°å½•æœ¬æ¬¡è¯·æ±‚çš„åŸå§‹URL
    spriteRequestedUrls[id] = url;
    // æ ‡è®°æ˜¯å¦å·²ç»æ’­æ”¾è¿‡å…¥åœºåŠ¨ç”»
    let hasPlayedAnimation = false;
    // æ’­æ”¾å…¥åœºåŠ¨ç”»çš„helper
    const playEntryAnimation = () => {
        if (!hasPlayedAnimation) {
            hasPlayedAnimation = true;
            img.classList.remove('entering');
            void img.offsetWidth;
            img.classList.add('entering');
            setTimeout(() => img.classList.remove('entering'), 650);
        }
    };
    // === å…³é”®ä¿®å¤ï¼šä½¿ç”¨é¢„åŠ è½½ï¼Œå®Œå…¨åŠ è½½åå†ä¸€æ¬¡æ€§åˆ‡æ¢ ===
    const tryLoadUrl = (targetUrl, fallbackUrls = []) => {
        console.log(`[SPRITE] Trying to load: ${targetUrl}, fallbacks: ${fallbackUrls.length}`);
        const preloader = new Image();
        preloader.onload = () => {
            console.log(`[SPRITE] SUCCESS: ${preloader.src}`);
            // ã€å…³é”®ã€‘å¦‚æœ URL å˜åŒ–äº†ï¼ˆçœŸæ­£çš„ç²¾çµå›¾åˆ‡æ¢ï¼‰ï¼Œè§¦å‘æ·¡å…¥æ•ˆæœ
            const isUrlChanged = img.src !== preloader.src;
            if (isUrlChanged) {
                // URL å˜åŒ–ï¼šç§»é™¤ loaded ç±»è§¦å‘æ·¡å…¥
                img.style.transition = 'none';
                img.classList.remove('loaded', 'fainted-hidden', 'fainting', 'entering');
                img.src = preloader.src;
                void img.offsetWidth; // å¼ºåˆ¶é‡æ’
                img.style.transition = '';
                img.classList.add('loaded');
            } else {
                // URL æœªå˜ï¼šåªç§»é™¤åŠ¨ç”»ç±»ï¼Œä¿æŒæ˜¾ç¤ºçŠ¶æ€
                img.classList.remove('fainted-hidden', 'fainting', 'entering');
                img.src = preloader.src;
                if (!img.classList.contains('loaded')) {
                    img.classList.add('loaded');
                }
            }
            playEntryAnimation();
        };
        preloader.onerror = () => {
            console.log(`[SPRITE] FAILED: ${targetUrl}, trying next fallback...`);
            if (fallbackUrls.length > 0) {
                tryLoadUrl(fallbackUrls[0], fallbackUrls.slice(1));
            } else {
                console.log(`[SPRITE] All fallbacks exhausted for: ${targetUrl}`);
                // === åŠ¨æ€æ£€æµ‹éå®˜æ–¹ Megaï¼šæ‰€æœ‰å›é€€éƒ½å¤±è´¥ ===
                const originalUrl = spriteRequestedUrls[id] || url;
                const megaMatch = originalUrl.match(/sprites\/(ani|ani-back)\/(.+?)\.gif$/);
                if (megaMatch && megaMatch[2].includes('mega')) {
                    const isBack = megaMatch[1] === 'ani-back';
                    const baseId = megaMatch[2].replace(/mega[xy]?$/, '').replace(/-$/, '');
                    const baseSpriteUrl = `https://play.pokemonshowdown.com/sprites/${isBack ? 'ani-back' : 'ani'}/${baseId}.gif`;
                    console.log(`[SPRITE] Unofficial Mega detected! Falling back to base form: ${baseSpriteUrl}`);
                    img.classList.add('unofficial-mega');
                    const baseLoader = new Image();
                    baseLoader.onload = () => {
                        img.style.transition = 'none';
                        img.classList.remove('loaded', 'entering');
                        img.src = baseLoader.src;
                        void img.offsetWidth;
                        img.style.transition = '';
                        img.classList.add('loaded');
                        playEntryAnimation();
                    };
                    baseLoader.onerror = () => {
                        img.style.transition = 'none';
                        img.classList.remove('loaded', 'entering');
                        img.src = targetUrl;
                        void img.offsetWidth;
                        img.style.transition = '';
                        img.classList.add('loaded');
                    };
                    baseLoader.src = baseSpriteUrl;
                    return;
                }
                img.style.transition = 'none';
                img.classList.remove('loaded', 'entering');
                img.src = targetUrl;
                void img.offsetWidth;
                img.style.transition = '';
                img.classList.add('loaded');
            }
        };
        preloader.src = targetUrl;
    };
    // æ„å»ºå›é€€URLåˆ—è¡¨
    const m = url.match(/https?:\/\/play\.pokemonshowdown\.com\/sprites\/(ani|ani-back|ani-back-shiny|ani-shiny)\/(.+?)\.gif$/);
    if (m) {
        const spriteFolder = m[1];
        const isBack = spriteFolder.includes('back');
        const isShiny = spriteFolder.includes('shiny');
        const spriteId = m[2];
        const { strict, compact, base } = generateIdVariants(spriteId);
        const baseId = typeof getFallbackSpriteId === 'function' ? getFallbackSpriteId(spriteId) : base;
        const idVariants = [spriteId];
        if (strict !== spriteId) idVariants.push(strict);
        if (compact !== spriteId && compact !== strict) idVariants.push(compact);
        const semiCompact = spriteId.replace(/-([a-z]+)-/g, '-$1');
        if (semiCompact !== spriteId && !idVariants.includes(semiCompact)) {
            idVariants.push(semiCompact);
        }
        if (baseId !== spriteId && !idVariants.includes(baseId)) {
            idVariants.push(baseId);
        }
        const fallbacks = [];
        const isMega = spriteId.includes('mega');
        const isGmax = spriteId.includes('gmax');
        const isPrimal = spriteId.includes('primal');
        const isSpecialForm = isMega || isGmax || isPrimal;
        const aniFolder = isShiny 
            ? (isBack ? 'ani-back-shiny' : 'ani-shiny')
            : (isBack ? 'ani-back' : 'ani');
        const frontFolder = isShiny ? 'ani-shiny' : 'ani';
        const gen5aniFolder = isBack ? 'gen5ani-back' : 'gen5ani';
        const gen5Folder = isBack ? 'gen5-back' : 'gen5';
        const formVariants = idVariants.filter(id => id !== baseId);
        if (isSpecialForm) {
            // ç‰¹æ®Šå½¢æ€ä¼˜å…ˆ
            for (const id of formVariants) {
                if (id !== spriteId) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${id}.gif`);
                }
            }
            if (isBack) {
                for (const id of formVariants) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${id}.gif`);
                }
            }
            // pkparaiso å›¾åº“
            let pkparaisoId = spriteId;
            if (/mega[xy]?$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/mega([xy])?$/i, '-mega$1');
            } else if (/gmax$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/gmax$/i, '-gmax');
            } else if (/primal$/i.test(pkparaisoId)) {
                pkparaisoId = pkparaisoId.replace(/primal$/i, '-primal');
            }
            const pkparaisoFolder = isBack ? 'animados-espalda' : 'animados';
            const isORASForm = spriteId.includes('rayquaza') || spriteId.includes('primal');
            const pkparaisoGen = isORASForm ? 'rubi-omega-zafiro-alfa' : (isGmax ? 'espada_escudo' : 'xy');
            fallbacks.push(`https://www.pkparaiso.com/imagenes/${pkparaisoGen}/sprites/${pkparaisoFolder}/${pkparaisoId}.gif`);
            for (const id of formVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${id}.gif`);
            }
            for (const id of formVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${id}.png`);
            }
            // æœ€åå›é€€åˆ°åŸºç¡€å½¢æ€
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${baseId}.gif`);
            if (isBack) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${baseId}.gif`);
            }
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${baseId}.gif`);
            fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${baseId}.png`);
        } else {
            // æ™®é€šå½¢æ€æŒ‰å±‚çº§å›é€€
            for (const id of idVariants) {
                if (id !== spriteId) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${aniFolder}/${id}.gif`);
                }
            }
            if (isBack) {
                for (const id of idVariants) {
                    fallbacks.push(`https://play.pokemonshowdown.com/sprites/${frontFolder}/${id}.gif`);
                }
            }
            for (const id of idVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5aniFolder}/${id}.gif`);
            }
            for (const id of idVariants) {
                fallbacks.push(`https://play.pokemonshowdown.com/sprites/${gen5Folder}/${id}.png`);
            }
        }
        // Pokesprite å›¾åº“ï¼ˆåªæœ‰æ­£é¢å›¾ï¼‰
        if (!isBack) {
            for (const id of idVariants) {
                fallbacks.push(`https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${id}.png`);
            }
        }
        tryLoadUrl(url, fallbacks);
    } else {
        tryLoadUrl(url, []);
    }
}
// ============================================
// ç²¾çµå›¾çŠ¶æ€é‡ç½®
// ============================================
/**
 * é‡ç½®ç²¾çµå›¾çŠ¶æ€
 */
function resetSpriteState() {
    ['player-sprite', 'enemy-sprite'].forEach(id => {
        const sprite = document.getElementById(id);
        if (!sprite) return;
        sprite.classList.remove('fainted-hidden', 'fainting', 'entering', 'loaded', 'shake-hit-anim');
        sprite.style.removeProperty('opacity');
        sprite.style.removeProperty('transform');
    });
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.spriteRequestedUrls = spriteRequestedUrls;
    window.generateIdVariants = generateIdVariants;
    window.smartLoadSprite = smartLoadSprite;
    window.resetSpriteState = resetSpriteState;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        spriteRequestedUrls,
        generateIdVariants,
        smartLoadSprite,
        resetSpriteState
    };
}
]]></file>
        <file name="ui-trainer-hud.js"><![CDATA[/**
 * ===========================================
 * UI-TRAINER-HUD.JS - è®­ç»ƒå®¶å¤´åƒä¸ Cut-in ç³»ç»Ÿ
 * ===========================================
 * 
 * èŒè´£:
 * - è®­ç»ƒå®¶å¤´åƒæ˜¾ç¤ºä¸åŠ è½½
 * - å¤´åƒ ID è§£æä¸å›é€€
 * - Cut-in å‰§åœºåŒ–æ¼”å‡ºç³»ç»Ÿ
 */
// ============================================
// å¤´åƒåº“é…ç½®
// ============================================
const AVATAR_LIBRARY = [
    'player',
    'wild',
    'gloria',
    'rosa',
    'dawn',
    'akari',
    'serena',
    'lusamine',
    'lillie',
    'mallow',
    'lana',
    'irida',
    'roxie',
    'iono',
    'erika',
    'nessa',
    'marnie',
    'hexmaniac',
    'bea',
    'cynthia',
    'sonia',
    'juliana',
    'selene'
];
const AVATAR_ALIAS_MAP = {
    hex: 'hexmaniac'
};
const NORMALIZED_AVATARS = AVATAR_LIBRARY.map(name => ({
    original: name,
    normalized: name.toLowerCase().replace(/[^a-z0-9]/g, '')
}));
// ç”¨äºè®­ç»ƒå®¶å¤´åƒç¼ºå¤±æ—¶çš„é—®å·å¤‡ç”¨å›¾
const MISSING_AVATAR = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Crect width='200' height='200' fill='%23f1f3f6'/%3E%3Cpath fill='%23dde1e7' d='M0,0 L200,200 L200,0 Z' opacity='0.3'/%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' font-weight='900' font-size='120' fill='%23cbd5e1'%3E?%3C/text%3E%3Crect x='10' y='10' width='180' height='180' rx='20' fill='none' stroke='%23cbd5e1' stroke-width='8' stroke-dasharray='15,15'/%3E%3C/svg%3E";
// ============================================
// å¤´åƒ ID è§£æ
// ============================================
/**
 * è§£æå¤´åƒ ID
 * @param {string} source åŸå§‹æ¥æºï¼ˆè®­ç»ƒå®¶åç§°æˆ– IDï¼‰
 * @returns {string|null} è§£æåçš„å¤´åƒ ID
 */
function resolveAvatarId(source) {
    const slug = String(source || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]/g, '');
    if (!slug) return null;
    if (AVATAR_ALIAS_MAP[slug]) {
        return AVATAR_ALIAS_MAP[slug];
    }
    const exact = NORMALIZED_AVATARS.find(entry => entry.normalized === slug);
    if (exact) return exact.original;
    const partial = NORMALIZED_AVATARS.find(entry =>
        entry.normalized.includes(slug) || slug.includes(entry.normalized)
    );
    return partial ? partial.original : null;
}
// ============================================
// è®­ç»ƒå®¶åç§°æ ¼å¼åŒ–
// ============================================
/**
 * æ ¼å¼åŒ–è®­ç»ƒå®¶åç§°
 * @param {Object} trainer è®­ç»ƒå®¶å¯¹è±¡
 * @returns {string} æ ¼å¼åŒ–åçš„åç§°
 */
function formatTrainerName(trainer) {
    if (!trainer) return 'TRAINER';
    if (trainer.displayName) return trainer.displayName;
    if (trainer.name_en) return trainer.name_en;
    if (trainer.id && trainer.id !== 'wild') {
        return trainer.id
            .split(/[-_]/)
            .filter(Boolean)
            .map(part => part.charAt(0).toUpperCase() + part.slice(1))
            .join(' ');
    }
    return 'TRAINER';
}
// ============================================
// è®­ç»ƒå®¶ HUD æ›´æ–°
// ============================================
/**
 * æ›´æ–°è®­ç»ƒå®¶ HUD æ˜¾ç¤º
 */
function updateTrainerHud() {
    const hud = document.getElementById('trainer-hud');
    const nameEl = document.getElementById('trainer-name');
    const avatarEl = document.getElementById('trainer-avatar');
    if (!hud || !nameEl || !avatarEl) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const t = battle?.trainer;
    if (!t) {
        hud.classList.add('hidden');
        return;
    }
    const isWild = t.id === 'wild' || !t.id;
    if (isWild) {
        hud.classList.add('hidden');
        return;
    }
    const displayName = (t.name || '').trim();
    if (displayName) {
        nameEl.textContent = displayName.replace(/^./, match => match.toUpperCase());
    } else {
        nameEl.textContent = 'Unknown';
    }
    const resolvedFromName = resolveAvatarId(displayName);
    const resolvedFromId = resolveAvatarId(t.id);
    const rawId = String(t.id || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    const candidates = [];
    if (resolvedFromId) candidates.push(resolvedFromId);
    if (resolvedFromName) candidates.push(resolvedFromName);
    if (rawId) candidates.push(rawId);
    if (displayName) candidates.push(displayName.toLowerCase());
    const uniqueCandidates = [...new Set(candidates)].filter(Boolean);
    let attemptIndex = 0;
    avatarEl.onload = null;
    avatarEl.onerror = null;
    const tryNext = () => {
        if (attemptIndex >= uniqueCandidates.length) {
            avatarEl.onload = null;
            avatarEl.onerror = () => { hud.classList.add('hidden'); };
            avatarEl.src = MISSING_AVATAR;
            hud.classList.remove('hidden');
            return;
        }
        const candidate = uniqueCandidates[attemptIndex++];
        avatarEl.onload = () => {
            hud.classList.remove('hidden');
        };
        avatarEl.onerror = () => {
            tryNext();
        };
        avatarEl.src = `data/avatar/${candidate}.png`;
    };
    tryNext();
}
// ============================================
// Cut-in å‰§åœºåŒ–æ¼”å‡ºç³»ç»Ÿ
// ============================================
/**
 * æ’­æ”¾ Cut-in æ¼”å‡º
 * @param {string} text æ¼”å‡ºæ–‡æœ¬
 * @param {number} duration æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 */
function playCutIn(text, duration = 3000) {
    if (!text) return;
    const stage = document.getElementById('cutin-stage');
    const nameEl = document.getElementById('cutin-name');
    const textEl = document.getElementById('cutin-text');
    const imgEl = document.getElementById('cutin-avatar');
    if (!stage || !nameEl || !textEl || !imgEl) return;
    const battle = typeof window !== 'undefined' ? window.battle : null;
    const trainer = battle?.trainer;
    const trainerName = trainer?.name || trainer?.title || 'ENEMY';
    nameEl.textContent = trainerName;
    textEl.textContent = text;
    const isWild = trainer?.id === 'wild';
    let targetSrc = '';
    if (isWild) {
        const enemySprite = document.getElementById('enemy-sprite');
        if (enemySprite?.src) {
            targetSrc = enemySprite.src;
        }
    } else {
        const trainerHudImg = document.getElementById('trainer-avatar');
        if (trainerHudImg?.src) {
            targetSrc = trainerHudImg.src;
        }
    }
    if (targetSrc && !targetSrc.includes('html')) {
        imgEl.style.opacity = '';
        imgEl.src = targetSrc;
    } else {
        imgEl.style.opacity = 0;
    }
    stage.classList.remove('hidden', 'outro');
    void stage.offsetWidth;
    stage.classList.add('active');
    clearTimeout(stage._cutinTimer);
    stage._cutinTimer = setTimeout(() => {
        stage.classList.remove('active');
        stage.classList.add('outro');
        clearTimeout(stage._cutinHideTimer);
        stage._cutinHideTimer = setTimeout(() => {
            stage.classList.add('hidden');
            stage.classList.remove('outro');
        }, 650);
    }, duration);
}
// ============================================
// å¯¼å‡º
// ============================================
// æµè§ˆå™¨ç¯å¢ƒ
if (typeof window !== 'undefined') {
    window.AVATAR_LIBRARY = AVATAR_LIBRARY;
    window.AVATAR_ALIAS_MAP = AVATAR_ALIAS_MAP;
    window.NORMALIZED_AVATARS = NORMALIZED_AVATARS;
    window.MISSING_AVATAR = MISSING_AVATAR;
    window.resolveAvatarId = resolveAvatarId;
    window.formatTrainerName = formatTrainerName;
    window.updateTrainerHud = updateTrainerHud;
    window.playCutIn = playCutIn;
}
// Node.js ç¯å¢ƒ
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        AVATAR_LIBRARY,
        AVATAR_ALIAS_MAP,
        NORMALIZED_AVATARS,
        MISSING_AVATAR,
        resolveAvatarId,
        formatTrainerName,
        updateTrainerHud,
        playCutIn
    };
}
]]></file>
    </directory>
    <file name="form-change-system.js"><![CDATA[/**
 * =============================================
 * FORM CHANGE SYSTEM - é€šç”¨å½¢æ€å˜åŒ–ç³»ç»Ÿ
 * =============================================
 * 
 * æ”¯æŒçš„å½¢æ€å˜åŒ–ç±»å‹ï¼š
 * 1. Mega Evolutionï¼ˆè¶…è¿›åŒ–ï¼‰- æŒ‰é’®è§¦å‘
 * 2. Ultra Burstï¼ˆç©¶æçˆ†å‘ï¼‰- æŒ‰é’®è§¦å‘ï¼Œå¤ç”¨ Mega æŒ‰é’®
 * 3. Primal Reversionï¼ˆåŸå§‹å›å½’ï¼‰- è¿›åœºè‡ªåŠ¨è§¦å‘
 * 4. Crowned Formï¼ˆå‰‘ç›¾ä¹‹ç‹ï¼‰- è¿›åœºè‡ªåŠ¨è§¦å‘
 * 5. Battle Bondï¼ˆç¾ç»Šè¿›åŒ–ï¼‰- å‡»æ€è§¦å‘
 * 6. HP-Threshold Formsï¼ˆè¡€é‡é˜ˆå€¼å½¢æ€ï¼‰- HP å˜åŒ–è§¦å‘
 */
/**
 * æ‰§è¡Œé€šç”¨å½¢æ€å˜åŒ–ï¼ˆå¼•æ“å±‚é¢ï¼‰
 * @param {Pokemon} pokemon - è¦å˜å½¢çš„å®å¯æ¢¦
 * @param {string} targetFormId - ç›®æ ‡å½¢æ€ IDï¼ˆå¦‚ 'charizardmegax', 'kyogreprimal'ï¼‰
 * @param {string} formType - å½¢æ€ç±»å‹ï¼ˆ'mega', 'primal', 'ultra', 'crowned' ç­‰ï¼‰
 * @returns {object|null} - å˜åŒ–ç»“æœä¿¡æ¯ï¼Œæˆ– null å¦‚æœå¤±è´¥
 */
function performFormChange(pokemon, targetFormId, formType = 'mega') {
    if (!targetFormId) {
        console.warn(`[FORM] No target form ID provided for ${pokemon.name}`);
        return null;
    }
    const formData = getPokemonData(targetFormId);
    if (!formData) {
        console.warn(`[FORM] Form data not found: ${targetFormId}`);
        return null;
    }
    // ä¿å­˜æ—§æ•°æ®ç”¨äºæ—¥å¿—
    const oldName = pokemon.cnName;
    const oldTypes = [...pokemon.types];
    const oldAbility = pokemon.ability;
    // æ›´æ–°åŸºç¡€æ•°æ®
    pokemon.name = formData.name;
    // [BUG FIX] é‡æ–°ç¿»è¯‘æ–°å½¢æ€çš„åå­—
    if (typeof window !== 'undefined' && window.Locale) {
        const transName = window.Locale.get(formData.name);
        // æ™ºèƒ½åå¤‡ï¼šå¦‚æœç¿»è¯‘åº“é‡Œæ²¡æœ‰è¿™ä¸ªå½¢æ€çš„ä¸“æœ‰åè¯
        if (transName === formData.name && formType === 'minior') {
            // å°é™¨æ˜Ÿå†…æ ¸ï¼Œå¼ºè¡Œç¿»è¯‘
            pokemon.cnName = `å°é™¨æ˜Ÿ-${transName.split('-')[1] || 'æ ¸å¿ƒ'}`;
        } 
        else if (transName === formData.name && formData.name.includes("-Hisui")) {
            // æ´—ç¿ å½¢æ€æ™ºèƒ½æ‹¼è£…
            const baseName = window.Locale.get(formData.name.split('-')[0]);
            pokemon.cnName = `${baseName}-æ´—ç¿ `;
        }
        else {
            pokemon.cnName = transName;
        }
    } else {
        pokemon.cnName = formData.name;
    }
    pokemon.types = formData.types || pokemon.types;
    pokemon.baseStats = formData.baseStats;
    // è·å–æ–°å½¢æ€çš„ç‰¹æ€§
    const formPokedexData = typeof POKEDEX !== 'undefined' ? POKEDEX[targetFormId] : null;
    if (formPokedexData && formPokedexData.abilities) {
        pokemon.ability = formPokedexData.abilities['0'] || formPokedexData.abilities['H'] || pokemon.ability;
    }
    // é‡æ–°è®¡ç®—èƒ½åŠ›å€¼
    const oldHp = pokemon.currHp;
    const oldMaxHp = pokemon.maxHp;
    let autoEv = Math.floor(pokemon.level * 1.5);
    if (autoEv > 85) autoEv = 85;
    const newStats = calcStats(formData.baseStats, pokemon.level, 31, autoEv);
    // HP å¤„ç†ï¼šå¤§éƒ¨åˆ†å½¢æ€å˜åŒ–ä¿æŒ HP ä¸å˜ï¼Œä½†åŸºæ ¼å°”å¾·å®Œå…¨ä½“ä¾‹å¤–
    const isZygardeComplete = targetFormId === 'zygardecomplete';
    if (isZygardeComplete) {
        // åŸºæ ¼å°”å¾·å®Œå…¨ä½“ï¼šHP æœ€å¤§å€¼å¢åŠ ï¼Œå½“å‰ HP æŒ‰æ¯”ä¾‹å¢åŠ 
        const hpRatio = oldHp / oldMaxHp;
        pokemon.maxHp = newStats.hp;
        pokemon.currHp = Math.floor(pokemon.maxHp * hpRatio);
    } else {
        // å…¶ä»–å½¢æ€ï¼šHP ä¿æŒä¸å˜
        pokemon.maxHp = oldMaxHp;
        pokemon.currHp = oldHp;
    }
    // æ›´æ–°å…¶ä»–èƒ½åŠ›å€¼
    pokemon.atk = newStats.atk;
    pokemon.def = newStats.def;
    pokemon.spa = newStats.spa;
    pokemon.spd = newStats.spd;
    pokemon.spe = newStats.spe;
    // æ ‡è®°å·²å˜å½¢
    pokemon.isTransformed = true;
    pokemon.currentForm = targetFormId;
    pokemon.formType = formType;
    // å‘åå…¼å®¹ï¼šå¦‚æœæ˜¯ Mega/Ultraï¼Œä¹Ÿæ ‡è®° isMega
    if (formType === 'mega' || formType === 'ultra') {
        pokemon.isMega = true;
    }
    // è¿”å›å˜åŒ–ä¿¡æ¯
    const typeChanged = JSON.stringify(oldTypes) !== JSON.stringify(pokemon.types);
    const abilityChanged = oldAbility !== pokemon.ability;
    return {
        success: true,
        oldName,
        newName: pokemon.cnName,
        formType,
        typeChanged,
        newTypes: pokemon.types,
        abilityChanged,
        newAbility: pokemon.ability
    };
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºæ—¶çš„è‡ªåŠ¨å½¢æ€å˜åŒ–ï¼ˆInit-Transformï¼‰
 * ç”¨äºï¼šPrimal Reversion, Crowned Form
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkInitTransform(pokemon) {
    // ä½¿ç”¨æ–°çš„ needsInitTransform æ ‡è®°
    if (pokemon.needsInitTransform && pokemon.initTransformTarget && !pokemon.isTransformed) {
        console.log(`[FORM] Init-Transform triggered for ${pokemon.name} -> ${pokemon.initTransformTarget} (type: ${pokemon.initTransformType})`);
        const result = performFormChange(pokemon, pokemon.initTransformTarget, pokemon.initTransformType);
        pokemon.needsInitTransform = false; // æ ‡è®°å·²å®Œæˆ
        return result;
    }
    return null;
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œå‡»æ€è§¦å‘çš„å½¢æ€å˜åŒ–ï¼ˆBattle Bondï¼‰
 * ç”¨äºï¼šGreninja (Ash-Greninja)
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkBattleBondTransform(pokemon) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç”²è´ºå¿è›™ä¸”æœ‰ç¾ç»Šç‰¹æ€§
    if (pokemon.ability !== 'Battle Bond') {
        return null;
    }
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ Ash å½¢æ€
    const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (baseId === 'greninjaash' || pokemon.isTransformed) {
        return null;
    }
    // å˜ä¸º Ash-Greninja
    const targetId = 'greninjaash';
    const targetData = getPokemonData(targetId);
    if (!targetData) {
        return null;
    }
    console.log(`[FORM] Battle Bond triggered: ${pokemon.name} -> Ash-Greninja`);
    return performFormChange(pokemon, targetId, 'battlebond');
}
/**
 * æ£€æŸ¥å¹¶æ‰§è¡Œè¡€é‡é˜ˆå€¼è§¦å‘çš„å½¢æ€å˜åŒ–
 * ç”¨äºï¼šWishiwashi (School/Solo), Zygarde (Complete), Minior (Shields Down)
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @returns {object|null} - å˜åŒ–ç»“æœ
 */
function checkHPThresholdTransform(pokemon) {
    const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const hpRatio = pokemon.currHp / pokemon.maxHp;
    // å¼±ä¸é±¼ (Wishiwashi) - é±¼ç¾¤ç‰¹æ€§
    if (pokemon.ability === 'Schooling' && baseId.includes('wishiwashi')) {
        const currentlySchool = baseId === 'wishiwashischool';
        if (hpRatio > 0.25 && !currentlySchool) {
            // å˜ä¸ºé±¼ç¾¤å½¢æ€
            console.log(`[FORM] Schooling: ${pokemon.name} -> School Form`);
            return performFormChange(pokemon, 'wishiwashischool', 'schooling');
        } else if (hpRatio <= 0.25 && currentlySchool) {
            // å˜å›å•ç‹¬å½¢æ€
            console.log(`[FORM] Schooling: ${pokemon.name} -> Solo Form`);
            return performFormChange(pokemon, 'wishiwashi', 'schooling');
        }
    }
    // åŸºæ ¼å°”å¾· (Zygarde) - ç¾¤èšå˜å½¢ç‰¹æ€§
    if (pokemon.ability === 'Power Construct' && baseId.includes('zygarde')) {
        const currentlyComplete = baseId === 'zygardecomplete';
        // åªæœ‰ 10% æˆ– 50% å½¢æ€å¯ä»¥å˜ä¸ºå®Œå…¨ä½“ï¼Œä¸”åªèƒ½å˜ä¸€æ¬¡
        if (hpRatio < 0.5 && !currentlyComplete && !pokemon._zygardeTransformed) {
            console.log(`[FORM] Power Construct: ${pokemon.name} -> Complete Forme`);
            pokemon._zygardeTransformed = true; // æ ‡è®°å·²å˜å½¢ï¼Œä¸å¯é€†
            return performFormChange(pokemon, 'zygardecomplete', 'powerconstruct');
        }
    }
    // å°é™¨æ˜Ÿ (Minior) - ç•Œé™ç›¾ç‰¹æ€§
    if (pokemon.ability === 'Shields Down' && baseId.includes('minior')) {
        const currentlyShielded = !baseId.includes('core');
        if (hpRatio > 0.5 && !currentlyShielded) {
            // å˜å›æµæ˜Ÿå½¢æ€ï¼ˆæœ‰ç›¾ï¼‰
            console.log(`[FORM] Shields Down: ${pokemon.name} -> Meteor Form`);
            return performFormChange(pokemon, 'minior', 'shieldsdown');
        } else if (hpRatio <= 0.5 && currentlyShielded) {
            // å˜ä¸ºæ ¸å¿ƒå½¢æ€ï¼ˆæ— ç›¾ï¼‰
            console.log(`[FORM] Shields Down: ${pokemon.name} -> Core Form`);
            // Minior æœ‰å¤šç§é¢œè‰²ï¼Œè¿™é‡Œç®€åŒ–ä¸ºçº¢è‰²æ ¸å¿ƒ
            return performFormChange(pokemon, 'miniorcoreform', 'shieldsdown');
        }
    }
    return null;
}
// å¯¼å‡ºåˆ°å…¨å±€ï¼ˆå¦‚æœåœ¨æµè§ˆå™¨ç¯å¢ƒï¼‰
if (typeof window !== 'undefined') {
    window.performFormChange = performFormChange;
    window.checkInitTransform = checkInitTransform;
    window.checkBattleBondTransform = checkBattleBondTransform;
    window.checkHPThresholdTransform = checkHPThresholdTransform;
}
// å¯¼å‡ºåˆ° Node.js ç¯å¢ƒï¼ˆå¦‚æœéœ€è¦ï¼‰
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        performFormChange,
        checkInitTransform,
        checkBattleBondTransform,
        checkHPThresholdTransform
    };
}
]]></file>
    <file name="index.css"><![CDATA[/* ============================================
   Web Font Imports - è§†è§‰å‡çº§
   ============================================ */
/* M PLUS Rounded 1c - æ—¥ç³»åœ†ä½“ï¼Œå®Œç¾å¥‘åˆå®å¯æ¢¦UIé£æ ¼ */
@import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700;800;900&display=swap');
/* Noto Sans SC - æ€æºé»‘ä½“ï¼Œä¸­æ–‡æ˜¾ç¤ºæ›´ä¼˜ */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700;900&display=swap');
.trainer-avatar-wrap img {
    text-indent: -9999px;
    color: transparent;
}
.trainer-avatar-wrap img:not([src]),
.trainer-avatar-wrap img[src=""] {
    opacity: 0;
}
.hidden {
    display: none !important;
}
:root {
    --bg-base: #f4f6fd;
    --primary-white: #ffffff;
    --primary-pink: #fa709a;
    --primary-dark: #403b4a;
    --accent-yellow: #fee140;
    --accent-blue: #00f2fe;
    --hp-high: #4fd1c5;
    --hp-mid: #fbc63e;
    --hp-low: #ff6b6b;
    /* å­—ä½“å‡çº§ï¼šä¼˜å…ˆåœ†ä½“ï¼Œå›é€€åˆ°ç³»ç»Ÿå­—ä½“ */
    --font-main: 'M PLUS Rounded 1c', 'Noto Sans SC', 'Microsoft YaHei UI', 'PingFang SC', 'Hiragino Sans GB', sans-serif;
    --font-number: 'Rubik', 'M PLUS Rounded 1c', monospace;
    --radius-l: 18px;
    --radius-m: 12px;
    --color-fight: #ff5e78;
    --color-pokemon: #4fabff;
    --color-run: #ffb830;
    --color-catch: #4ade80;
    --ui-glass: rgba(255, 255, 255, 0.95);
}
@keyframes spawn-rise {
    0% {
        opacity: 0;
        transform: translateY(40px) scale(calc(var(--sprite-scale, 1) * 0.45));
    }
    50% {
        opacity: 0.85;
        transform: translateY(-10px) scale(calc(var(--sprite-scale, 1) * 1.05));
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
    }
}
@keyframes spawn-rise-enemy {
    0% {
        opacity: 0;
        transform: translateY(-20px) scale(calc(var(--sprite-scale, 1) * 1.35)) rotate(-3deg);
    }
    40% {
        opacity: 0.65;
        transform: translateY(25px) scale(calc(var(--sprite-scale, 1) * 0.8)) rotate(2deg);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1)) rotate(0deg);
    }
}
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    /* å­—ä½“æŠ—é”¯é½¿ä¼˜åŒ– */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background: transparent;
    width: 100vw;
    height: 100vh;
}
.ui-root {
    position: relative;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, rgba(20,20,30,0.1), transparent), #000;
    overflow: hidden;
}
.bg-gradient {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 120vmax;
    height: 120vmax;
    transform: translate(-50%, -50%);
    z-index: 0;
    opacity: 0.3;
}
.ui-scale {
    width: 1100px !important;
    height: 720px !important;
    flex-shrink: 0;
    position: relative;
    z-index: 10;
    margin: 0;
    border-radius: 32px;
    overflow: hidden;
    box-shadow: none;
    transform-origin: center center;
    transform: scale(var(--ui-scale, 1));
    background: #eef1f5;
    text-shadow:
        1.5px 0px 1px rgba(255, 0, 80, 0.15),
        -1.5px 0px 1px rgba(0, 240, 255, 0.15);
}
/* å¤å¤ç”µè§†å“‘å…‰é®ç½© */
.screen-filters {
    position: absolute;
    inset: 0;
    z-index: 9999;
    pointer-events: none;
    backdrop-filter: brightness(1.05) contrast(0.92) grayscale(0.1) sepia(0.05) blur(0.5px);
    background:
        linear-gradient(rgba(0, 0, 0, 0) 66%, rgba(0, 0, 0, 0.15) 66%),
        radial-gradient(circle at center, transparent 50%, rgba(10, 20, 30, 0.25) 90%, rgba(0, 0, 0, 0.4) 100%);
    background-size: 100% 3px, 100% 100%;
    mix-blend-mode: normal;
}
.screen-filters::before {
    content: "";
    position: absolute;
    inset: -10px;
    z-index: 10;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.5'/%3E%3C/svg%3E");
    box-shadow: inset 1px 0px 1px rgba(255, 0, 0, 0.15), inset -1px 0px 1px rgba(0, 255, 255, 0.15);
    opacity: 0.12;
    pointer-events: none;
    animation: noise-move 0.2s steps(4) infinite;
}
.screen-filters::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, transparent 40%, rgba(255,255,255,0.02) 100%);
    pointer-events: none;
    z-index: 11;
}
@keyframes noise-move {
    0%, 100% { transform: translate(0, 0); }
    10% { transform: translate(-3px, -2px); }
    50% { transform: translate(2px, 3px); }
    80% { transform: translate(-2px, 1px); }
}
.ui-scale::after {
    content: "";
    position: absolute;
    inset: 0;
    z-index: 9998;
    pointer-events: none;
    background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPjxyZWN0IHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNmZmYiLz48cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjY2NjIi8+PC9zdmc+');
    background-size: 2px 2px;
    opacity: 0.1;
    mix-blend-mode: multiply;
}
.overlay-screen {
    position: absolute;
    inset: 0;
    background: rgba(250, 250, 250, 0.85);
    backdrop-filter: blur(15px);
    z-index: 800;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.5s ease;
}
.result-screen {
    position: absolute;
    inset: 0;
    z-index: 999;
    background: rgba(15, 20, 25, 0.85);
    backdrop-filter: blur(15px);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.result-screen.active {
    opacity: 1;
    pointer-events: auto;
}
.start-card {
    background: white;
    padding: 60px 100px;
    border-radius: 40px;
    box-shadow: 0 20px 60px rgba(250, 112, 154, 0.2);
    text-align: center;
    border: 4px solid var(--primary-pink);
    transform: rotate(-2deg);
}
.logo-title {
    font-size: 3.5rem;
    margin: 0;
    color: var(--primary-dark);
    font-weight: 900;
    text-shadow: -2px 0 var(--accent-blue), 2px 0 var(--primary-pink);
    letter-spacing: -2px;
}
.logo-title .accent {
    color: var(--primary-pink);
}
.loader-notch {
    width: 120px;
    height: 10px;
    border-radius: 999px;
    margin: 22px auto 18px;
    background: linear-gradient(90deg, rgba(250,112,154,0.2), rgba(250,112,154,0.9), rgba(0,242,254,0.65));
    filter: blur(0.2px);
}
.sys-msg {
    color: #999;
    font-size: 0.9rem;
    letter-spacing: 2px;
    margin-top: 10px;
    font-weight: 700;
}
.start-btn {
    margin-top: 30px;
    background: var(--primary-pink);
    color: white;
    border: none;
    padding: 15px 50px;
    font-size: 1.5rem;
    cursor: pointer;
    font-family: inherit;
    font-weight: 900;
    border-radius: 50px;
    box-shadow: 0 5px 0 #d64d78;
    transition: transform 0.1s;
}
.start-btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #d64d78; }
.start-btn:disabled {
    cursor: default;
    background: #ccc;
    box-shadow: none;
    opacity: 0.5;
}
.game-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.game-container.hidden {
    display: none;
}
.battle-stage {
    position: relative;
    flex: 1;
    overflow: hidden;
}
.sprite-wrapper {
    position: absolute;
    pointer-events: none;
}
.p-sprite {
    --sprite-scale: 1;
    opacity: 0;
    transition: opacity 0.5s ease-out, transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}
.p-sprite.mega-player {
    --sprite-scale: 1.5;
    filter: drop-shadow(0 0 18px rgba(147, 197, 253, 0.55));
}
.p-sprite.mega-enemy {
    --sprite-scale: 1.2;
    filter: drop-shadow(0 0 16px rgba(250, 113, 113, 0.55));
}
/* éå®˜æ–¹ Megaï¼ˆRadical Red / ROM Hackï¼‰- ä½¿ç”¨åŸå§‹å›¾ç‰‡ + ç‰¹æ®Šæ»¤é•œ */
.p-sprite.unofficial-mega {
    --sprite-scale: 1.15;
    filter: 
        drop-shadow(0 0 20px rgba(220, 38, 127, 0.8))
        drop-shadow(0 0 10px rgba(147, 51, 234, 0.6))
        saturate(1.4)
        brightness(1.1)
        contrast(1.2);
    animation: unofficial-mega-pulse 2s ease-in-out infinite;
}
@keyframes unofficial-mega-pulse {
    0%, 100% {
        filter: 
            drop-shadow(0 0 20px rgba(220, 38, 127, 0.8))
            drop-shadow(0 0 10px rgba(147, 51, 234, 0.6))
            saturate(1.4)
            brightness(1.1)
            contrast(1.2);
    }
    50% {
        filter: 
            drop-shadow(0 0 25px rgba(220, 38, 127, 1))
            drop-shadow(0 0 15px rgba(147, 51, 234, 0.8))
            saturate(1.5)
            brightness(1.15)
            contrast(1.25);
    }
}
.p-sprite {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: pixelated;
    filter: contrast(1.15) brightness(1.05) drop-shadow(4px 8px 6px rgba(0, 0, 0, 0.3));
    transform: translateY(0) scale(var(--sprite-scale));
    animation:
        var(--sprite-animation, none),
        var(--sprite-faint-animation, none),
        var(--sprite-entry-animation, none);
}
.p-sprite.loaded { opacity: 1; }
.p-sprite.fainted-hidden {
    opacity: 0 !important;
    visibility: hidden;
}
.p-sprite.entering {
    --sprite-entry-animation: spawn-rise 0.55s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}
.enemy-pos .p-sprite.entering {
    --sprite-entry-animation: spawn-rise-enemy 0.65s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}
.sprite-wrapper::after {
    content: '';
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 15px;
    background: rgba(60, 50, 80, 0.18);
    border-radius: 50%;
    z-index: -1;
    opacity: 0.35;
    filter: blur(2px);
    transition: opacity 0.25s ease;
}
.sprite-wrapper.sprite-empty::after {
    opacity: 0;
}
.enemy-pos {
    top: 15%;
    right: 10%;
    width: 250px;
    height: 250px;
    z-index: 2;
}
.player-pos {
    bottom: 200px;
    left: 150px;
    width: 260px;
    height: 270px;
    z-index: 5;
}
.shadow-base {
    display: none;
}
.player-scale {
    --sprite-scale: 1.4;
    transform-origin: center bottom;
}
.hud {
    position: absolute;
    z-index: 10;
    width: 320px;
    filter: drop-shadow(4px 10px 0 rgba(70, 70, 80, 0.1));
    background: var(--primary-white);
    border-radius: var(--radius-l);
    padding: 15px 20px;
    border: none;
    box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.15);
}
.panel-enemy {
    top: 40px;
    left: 40px;
}
.panel-player {
    bottom: 250px;
    right: 40px;
    z-index: 11;
}
.hud-top {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    margin-bottom: 6px;
}
.hud-top.right-align {
    justify-content: space-between;
}
.p-name {
    font-family: var(--font-main);
    font-size: 1.4rem;
    font-weight: 800;
    color: var(--primary-dark);
}
.p-lv {
    color: #888;
    font-size: 1rem;
    font-weight: 700;
    white-space: nowrap;
}
.p-lv-capsule {
    background: var(--accent-yellow);
    color: #5d5122;
    padding: 2px 10px;
    border-radius: 20px;
    font-weight: 800;
    font-size: 0.9em;
    white-space: nowrap;
}
.ball-slots {
    display: flex;
    gap: 6px;
}
.ball-slots.right {
    justify-content: flex-end;
}
.dot {
    width: 12px;
    height: 12px;
    background: #e0e0e0;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 0 1px #ddd;
    transition: 0.3s;
}
.dot.alive {
    background: var(--primary-pink);
    box-shadow: 0 0 0 1px var(--primary-pink);
}
.dot.dead {
    background: #555;
}
.dot.active {
    outline: 2px solid rgba(250, 112, 154, 0.35);
    outline-offset: 2px;
}
.hp-badge {
    position: absolute;
    right: 0;
    bottom: -30px;
    background: var(--primary-dark);
    color: white;
    padding: 4px 12px;
    border-radius: 0 0 10px 10px;
    font-size: 1rem;
    font-weight: 700;
    pointer-events: none;
}
.hp-nums {
    text-align: right;
    font-size: 0.9rem;
    font-weight: 800;
    margin-top: 6px;
    color: #6d6874;
}
.hp-container {
    height: 12px;
    background: #444;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: none;
    box-shadow: none;
}
.panel-enemy .hp-container {
    height: 10px;
    margin-top: 10px;
}
.hp-bar-bg {
    width: 100%;
    height: 12px;
    background: transparent;
    border-radius: 20px;
}
.main-hp .hp-bar-bg {
    height: 18px;
    border-radius: 10px;
}
.hp-fill {
    height: 100%;
    width: 100%;
    background: var(--hp-high);
    transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.4s;
    box-shadow: none;
    border-right: 2px solid rgba(255, 255, 255, 0.85);
}
.command-dashboard {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 220px;
    display: flex;
    gap: 16px;
    padding: 10px 10px 10px 10px;
    box-sizing: border-box;
    background: linear-gradient(to top, rgba(255, 255, 255, 0.95), transparent);
    z-index: 50;
    clip-path: polygon(0 20%, 5% 0, 100% 0, 100% 100%, 0 100%);
}
.log-entry {
    margin-bottom: 6px;
    padding-left: 10px;
    border-left: 3px solid rgba(250, 112, 154, 0.35);
    position: relative;
}
.log-entry:last-child {
    font-weight: 800;
    color: #2e2a35;
}
/* =========================================
   ä¸»èœå• (æˆ˜æ–—/å®å¯æ¢¦/é€ƒè·‘)
   ========================================= */
.main-menu {
    flex: 2;
    display: flex;
    flex-direction: column;
    gap: 12px;
    height: 100%;
}
.menu-btn {
    flex: 1;
    border: none;
    background: white;
    color: var(--primary-dark);
    cursor: pointer;
    font-family: inherit;
    font-size: 1.6rem;
    font-weight: 900;
    border: 3px solid #eee;
    border-radius: 14px;
    box-shadow: 4px 4px 0 #bbb;
    transition: all 0.12s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}
.menu-btn::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    border-radius: 10px 0 0 10px;
}
.menu-btn.fight::before { background: var(--primary-pink); }
.menu-btn.pokemon::before { background: var(--accent-blue); }
.menu-btn.run::before { background: var(--accent-yellow); }
.menu-btn:hover {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
}
.menu-btn:active {
    transform: translate(3px, 3px);
    box-shadow: 1px 1px 0 #888;
}
.menu-label {
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.08);
    opacity: 0;
}
/* =========================================
   ç»“ç®—ç”»é¢ (RESULT SCREEN)
   ========================================= */
/* =========================================
   MODERN RESULT CARD (Switch / SV style)
   ========================================= */
.result-screen.hidden {
    display: none;
}
.res-modern-card {
    width: 680px;
    background: #f7f9fc;
    border-radius: 24px;
    overflow: hidden;
    position: relative;
    box-shadow:
        0 25px 50px -12px rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    transform: scale(0.95);
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    display: flex;
    flex-direction: column;
}
.result-screen.active .res-modern-card {
    transform: scale(1);
}
.res-header-banner {
    background: var(--res-color, #718093);
    color: white;
    padding: 20px 30px 50px;
    position: relative;
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0% 100%);
}
.res-header-content {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.res-modern-card.theme-win { --res-color: #f1c40f; --res-color-dark: #d35400; }
.res-modern-card.theme-win .res-header-banner {
    background: linear-gradient(135deg, #fbc531 0%, #e1b12c 100%);
    color: #2f3640;
}
.res-modern-card.theme-loss { --res-color: #e74c3c; --res-color-dark: #c0392b; }
.res-modern-card.theme-loss .res-header-banner {
    background: linear-gradient(135deg, #ff7675 0%, #d63031 100%);
}
.res-modern-card.theme-escape { --res-color: #95a5a6; --res-color-dark: #7f8c8d; }
.res-modern-card.theme-escape .res-header-banner {
    background: linear-gradient(135deg, #b2bec3 0%, #636e72 100%);
}
.res-flag {
    font-size: 0.8rem;
    font-weight: 900;
    letter-spacing: 2px;
    opacity: 0.8;
}
.res-big-title {
    margin: 5px 0 0;
    font-size: 3.5rem;
    font-style: italic;
    font-weight: 900;
    text-transform: uppercase;
    line-height: 0.9;
    transform: skewX(-5deg);
    text-shadow: 3px 3px 0 rgba(0,0,0,0.1);
}
.res-header-pattern {
    position: absolute;
    right: 0; top: 0; bottom: 0; left: 40%;
    background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.08) 0, rgba(255,255,255,0.08) 10px, transparent 10px, transparent 20px);
    pointer-events: none;
}
.res-rank-stamp-wrap {
    position: absolute;
    top: 25px;
    right: 40px;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
}
.res-rank-ring {
    width: 90px;
    height: 90px;
    background: #fff;
    border: 5px solid var(--res-color-dark, #ccc);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: rotate(15deg);
    color: var(--res-color-dark, #ccc);
    animation: stamp-bounce 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) 0.2s both;
}
@keyframes stamp-bounce {
    from { opacity: 0; transform: scale(3) rotate(-30deg); }
    to { opacity: 1; transform: scale(1) rotate(15deg); }
}
#res-grade-letter {
    font-size: 3rem;
    font-weight: 900;
    line-height: 0.8;
}
#res-grade-sub {
    font-size: 0.65em;
    font-weight: 800;
    background: var(--res-color-dark, #ccc);
    color: white;
    padding: 1px 6px;
    border-radius: 4px;
    line-height: 1;
    margin-top: 2px;
}
.res-body {
    padding: 0 35px 20px;
}
.res-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: -10px;
    z-index: 10;
    position: relative;
}
.res-info-tile {
    background: white;
    border-radius: 12px;
    padding: 12px 18px;
    box-shadow: 0 4px 0 #edf0f5;
    border: 1px solid #eef2f7;
    display: flex;
    flex-direction: column;
}
.res-info-tile.full-width {
    grid-column: span 2;
}
.res-info-tile.description-tile {
    background: #fff;
    border-left: 5px solid var(--res-color, #999);
    flex-direction: row;
    align-items: center;
    gap: 12px;
}
.tile-label {
    font-size: 0.7rem;
    font-weight: 900;
    color: #b2bec3;
    margin-bottom: 4px;
    letter-spacing: 0.5px;
}
.tile-val {
    font-weight: 800;
    color: #2d3436;
    font-size: 1.1rem;
    line-height: 1.2;
}
.tile-val.major {
    font-size: 1.3rem;
}
.tile-icon {
    font-size: 1.5rem;
}
.tile-val.text-desc {
    font-weight: 600;
    font-size: 1rem;
    color: #636e72;
}
.mini-party-dots {
    display: flex;
    gap: 6px;
    height: 18px;
    align-items: center;
}
.res-info-tile.team-tile {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}
.mini-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 0 1px #ddd;
    background: #eee;
}
.mini-dot.hp-100 { background: #4fd1c5; }
.mini-dot.hp-mid { background: #fbc63e; }
.mini-dot.hp-low { background: #ff6b6b; }
.mini-dot.hp-dead {
    background: #444;
    position: relative;
    opacity: 0.6;
}
.mini-dot.hp-dead::after {
    content: "Ã—";
    position: absolute;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    line-height: 12px;
    font-weight: bold;
}
.res-pills-action {
    padding: 24px 35px 30px;
    display: flex;
    gap: 16px;
    background: #fff;
    border-top: 1px solid #f0f0f0;
}
.pill-btn {
    border: none;
    border-radius: 500px;
    height: 64px;
    cursor: pointer;
    font-family: inherit;
    font-weight: 800;
    font-size: 1.1rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
}
.pill-btn:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.1);
}
.pill-btn:active {
    transform: translateY(-1px);
}
.pill-btn.restart,
.pill-btn.sec {
    background: #f0f2f5;
    color: #636e72;
    padding: 0 24px;
}
.pill-btn.restart {
    flex: 0.7;
    font-size: 0.85rem;
    color: #999;
}
.pill-btn.restart svg {
    margin-bottom: 4px;
}
.pill-btn.sec {
    flex: 1;
}
.pill-btn.primary {
    flex: 2;
    background: var(--res-color, #2d3436);
    color: white;
    box-shadow: 0 8px 15px -4px currentColor;
}
.res-modern-card.theme-win .pill-btn.primary {
    color: #000;
    box-shadow: 0 8px 15px -4px rgba(241, 196, 15, 0.5);
}
.pill-btn.primary .btn-text {
    font-size: 1.25rem;
    letter-spacing: 0.5px;
}
.pill-btn.primary .btn-sub {
    font-size: 0.75rem;
    opacity: 0.7;
    font-weight: normal;
    margin-top: 2px;
}
#res-clipboard-text {
    position: absolute;
    width: 1px;
    height: 1px;
    opacity: 0;
    pointer-events: none;
    border: none;
    resize: none;
}
.moves-menu {
    flex: 2;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 12px;
    height: 100%;
}
.moves-menu.hidden,
.main-menu.hidden {
    display: none;
}
/* è¿”å›æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
.action-btn.back {
    background: #f5f5f5;
    border-color: #ddd;
    color: #888;
}
.action-btn.back:hover:enabled {
    background: #eee;
    color: #666;
}
/* =========================================
   æ”¹è‰¯ç‰ˆèœå•æ ·å¼ - P5 x SWSH Refined
   ========================================= */
.main-menu {
    flex: 2.2;
    position: relative;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-start;
    gap: 0;
    pointer-events: none;
    margin-left: 0;
}
.radical-menu-container {
    display: flex;
    align-items: stretch;
    justify-content: flex-start;
    gap: 16px;
    width: 100%;
    height: 100%;
    padding: 10px 5px;
    perspective: 1000px;
    pointer-events: auto;
    box-sizing: border-box;
}
.radical-btn {
    border: 1px solid rgba(55, 65, 81, 0.3);
    cursor: pointer;
    position: relative;
    background: #fff;
    padding: 0;
    outline: none;
    transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.25), box-shadow 0.2s;
    border-radius: 16px;
    transform: skewX(-15deg);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    box-shadow: 4px 4px 0 rgba(0,0,0,0.1);
}
.skew-fix {
    width: 100%;
    height: 100%;
    transform: skewX(15deg);
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: flex-end;
    padding-right: 20px;
    position: relative;
    z-index: 2;
}
.btn-fight {
    flex: 1.5;
    color: var(--color-fight);
    background: #fff;
    z-index: 10;
}
.btn-fight .skew-fix {
    justify-content: flex-end;
    padding-right: 35px;
}
.r-icon-bg {
    display: none;
}
.btn-fight .r-icon {
    width: 200px;
    height: 200px;
    opacity: 0.22;
    position: absolute;
    right: -25px;
    bottom: -60px;
    transform: rotate(5deg) scale(1.1);
    fill: color-mix(in srgb, var(--color-fight) 85%, #000);
    transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
}
.btn-fight .r-label {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    z-index: 5;
    transform: translateY(2px);
}
.btn-fight .en {
    font-family: var(--font-main);
    font-size: 3.8rem;
    font-weight: 900;
    line-height: 0.85;
    letter-spacing: -2px;
    display: block;
    text-transform: uppercase;
    font-style: italic;
    text-shadow: 2px 2px 0px rgba(0,0,0,0.05);
}
.btn-fight .jp {
    font-size: 1rem;
    font-weight: 800;
    opacity: 0.4;
    letter-spacing: 0.4em;
    margin-top: 6px;
    margin-right: 4px;
    border-bottom: 3px solid rgba(255, 94, 120, 0.3);
}
.btn-fight:hover {
    background: var(--color-fight); 
    color: white; 
    border-color: var(--color-fight); 
    box-shadow: 6px 6px 0 rgba(0,0,0,0.15); 
    transform: skewX(-15deg) scale(1.05) translateY(-3px); 
    z-index: 20;
}
.btn-fight:hover .r-icon {
    opacity: 0.3;
    transform: rotate(-10deg) scale(1.0) translateX(-20px);
    fill: #000;
}
.radical-sub-group {
    flex: 1.1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.radical-sub-group.two-btn .radical-btn {
    flex: 0 0 45%;
}
.radical-sub-group .radical-btn {
    flex: 1;
    border-radius: 12px;
    border: 1px solid rgba(55, 65, 81, 0.3);
    background: #fff;
}
.radical-sub-group .radical-btn .skew-fix {
    justify-content: flex-start;
    padding-left: 20px;
}
.btn-pokemon {
    color: var(--color-pokemon);
    margin-left: 16px;
}
.btn-run {
    color: var(--color-run);
    margin-left: -10px;
    width: 96%;
    align-self: flex-end;
}
.r-icon.small {
    width: 90px;
    height: 90px;
    opacity: 0.22;
    position: absolute;
    right: 5px;
    bottom: -25px;
    transform: rotate(5deg);
    transition: 0.3s;
    fill: rgba(0,0,0,0.25);
}
.r-label-min {
    font-size: 1.9rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: -1px;
    font-style: italic;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.05);
}
.btn-pokemon .r-icon.small {
    fill: color-mix(in srgb, var(--color-pokemon) 80%, #000);
}
.btn-run .r-icon.small {
    fill: color-mix(in srgb, var(--color-run) 80%, #000);
}
.btn-pokemon:hover {
    background: var(--color-pokemon);
    color: white;
    border-color: var(--color-pokemon);
    box-shadow: 6px 6px 0 rgba(20, 50, 80, 0.15);
    transform: skewX(-15deg) scale(1.05) translateX(5px);
}
.btn-pokemon:hover .r-icon.small {
    opacity: 0.3;
    fill: #000;
    transform: rotate(-10deg) scale(1.1);
}
.btn-run:hover {
    background: var(--color-run);
    color: white;
    border-color: var(--color-run);
    box-shadow: 6px 6px 0 rgba(80, 60, 20, 0.12);
    transform: skewX(-15deg) scale(1.05) translateX(5px);
}
.btn-run:hover .r-label-min {
    color: #fff;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
}
.btn-run:hover .r-icon.small {
    opacity: 0.3;
    fill: #000;
    transform: translateX(5px) rotate(0deg);
}
.btn-catch {
    color: var(--color-catch) !important;
    background: #fff;
    margin-left: 25px;
}
.btn-catch .r-icon.small {
    color: color-mix(in srgb, var(--color-catch) 80%, #000);
    fill: currentColor;
    transform: rotate(8deg) scale(1);
    transition: transform 0.35s ease, opacity 0.35s ease, color 0.35s ease;
    opacity: 0.35;
}
.btn-catch:hover {
    background: var(--color-catch) !important;
    color: #fff !important;
    border-color: var(--color-catch) !important;
    box-shadow: 6px 6px 0 rgba(40, 160, 80, 0.15) !important;
    transform: skewX(-15deg) scale(1.05) translateX(5px) !important;
}
.btn-catch:hover .r-icon.small {
    color: #000;
    fill: #000 !important;
    opacity: 1 !important;
    transform: rotate(-12deg) scale(1.15);
}
.radical-btn:active {
    transition: 0.05s;
    transform: skewX(-15deg) scale(0.98);
    box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
}
.radical-sub-group .r-label-min {
    position: relative;
    z-index: 5;
}
.radical-sub-group .radical-btn:hover .r-icon.small {
    opacity: 1;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));
}
.r-label-min {
    font-family: var(--font-main);
    font-size: 1.6rem;
    font-weight: 800;
    font-style: normal;
    text-transform: uppercase;
    letter-spacing: 0;
}
.radical-btn .en,
.radical-btn .jp,
.r-label-min {
    font-weight: 900;
}
.radical-btn .en,
.radical-btn .jp {
    text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.15);
}
.radical-btn:active {
    filter: none;
}
.btn-fight:active .r-icon {
    transform: scale(0.9);
}
.action-btn {
    border: none;
    background: white;
    color: var(--primary-dark);
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    font-family: inherit;
    position: relative;
    border: 3px solid #eee;
    border-radius: 12px;
    box-shadow: 4px 4px 0 #bbb;
}
.action-btn:hover:enabled {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
    color: var(--primary-pink);
    background: #fffafa;
}
.action-btn:active:enabled {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #999;
}
.action-btn:disabled {
    opacity: 0.5;
    cursor: default;
    filter: grayscale(1);
}
.action-btn .move-name {
    font-size: 1.3rem;
    font-weight: 900;
    margin-bottom: 4px;
    pointer-events: none;
    text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
    font-family: var(--font-main);
}
.action-btn .move-type {
    font-size: 0.8em;
    opacity: 0.6;
    pointer-events: none;
    text-transform: uppercase;
    font-weight: bold;
    font-family: var(--font-main);
}
.action-btn.util {
    background: var(--accent-blue);
    color: white;
    box-shadow: 0 8px 0 #00bfcb, 0 15px 15px rgba(0, 242, 254, 0.3);
}
.action-btn.util .move-name {
    color: #024;
}
.action-btn .badge-type {
    position: absolute;
    bottom: 8px;
    right: 15px;
    pointer-events: none;
    border: none;
    box-shadow: none;
    border-radius: 8px;
    font-size: 0.7em;
    font-family: var(--font-main);
}
.overlay-modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(245, 246, 253, 0.92);
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
}
.overlay-modal.hidden {
    display: none;
}
.cutin-overlay {
    position: absolute;
    inset: 0;
    z-index: 2000;
    pointer-events: none;
    display: flex;
    justify-content: flex-end;
    align-items: flex-start;
    padding-top: 3%;
    padding-right: 25px;
    overflow: hidden;
}
.compact-bar {
    position: relative;
    background: rgba(30, 39, 46, 0.90);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 60px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    display: flex;
    align-items: center;
    box-shadow:
        0 10px 25px rgba(0,0,0,0.4),
        0 4px 10px rgba(0,0,0,0.1);
    min-width: 260px;
    max-width: 360px;
    height: 70px;
    transform: translateX(150%);
    opacity: 0;
    transition:
        transform 0.5s cubic-bezier(0.22, 1, 0.36, 1),
        opacity 0.4s ease;
}
.compact-bar.hidden {
    display: none;
}
.compact-bar.active {
    display: flex;
    transform: translateX(0);
    opacity: 1;
}
.compact-bar.outro {
    transform: translateX(120%);
    opacity: 0;
    transition:
        transform 0.4s cubic-bezier(0.55, 0.085, 0.68, 0.53),
        opacity 0.3s ease;
}
.deco-edge {
    width: 6px;
    height: 60%;
    background: var(--accent-yellow);
    border-radius: 10px;
    margin-left: 20px;
    margin-right: 15px;
    box-shadow: 0 0 10px rgba(254, 225, 64, 0.3);
}
.compact-content {
    display: flex;
    align-items: center;
    gap: 12px;
    padding-right: 28px;
    max-width: 100%;
}
.avatar-slot {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.9);
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    overflow: hidden;
    background: #555;
    flex-shrink: 0;
}
.c-avatar-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #e0e0e0;
}
.text-slot {
    display: flex;
    flex-direction: column;
    justify-content: center;
    color: white;
    min-width: 160px;
    max-width: 320px;
}
.c-name-strip {
    font-size: 0.65rem;
    color: #dfe6e9;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1px;
    line-height: 1.2;
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    font-family: var(--font-main);
}
.container-enemy .party-track.enemy-side {
    margin-bottom: -4px;
    margin-left: 6px;
    transform: skewX(-22deg);
    height: 24px;
}
.container-player .party-track.player-side {
    margin-top: 2px;
    margin-left: -4px;
    justify-content: flex-end;
    height: 28px;
    transform: translateX(-22px) skewX(-22deg);
}
.container-player .party-track .poke-slot {
    width: 19px;
    height: 19px;
}
.container-enemy .party-track .poke-slot {
    width: 17px;
    height: 17px;
}
.c-name-strip::before {
    content: 'â—†';
    font-size: 0.6em;
    color: var(--primary-pink);
    margin-right: 4px;
}
.c-dialogue {
    font-family: var(--font-main);
    font-size: 0.98rem;
    font-weight: 600;
    line-height: 1.35;
    color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    overflow: hidden;
    display: -webkit-box;
    line-clamp: 2;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}
.switch-header {
    text-align: center;
    color: var(--primary-dark);
}
.switch-header h2 {
    font-size: 2rem;
    margin-bottom: 5px;
}
.switch-grid-v2 {
    display: grid;
    gap: 20px;
    grid-template-columns: repeat(2, 1fr);
    padding: 20px;
}
.p-card {
    background: white;
    border-radius: 20px;
    padding: 15px;
    display: flex;
    gap: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    border: 3px solid transparent;
    transition: 0.2s;
}
.p-card.active {
    border-color: var(--accent-blue);
    background: #f7feff;
}
.p-card:hover:not(.active) {
    border-color: var(--primary-pink);
    transform: scale(1.02);
}
.card-icon {
    width: 70px;
    height: 70px;
    background: #f4f4f4;
    border-radius: 50%;
    margin-right: 10px;
}
.card-info .name {
    color: var(--primary-dark);
}
.card-info .lvl {
    color: #bbb;
}
.switch-hp-bar {
    background: #eee;
    height: 8px;
    border-radius: 4px;
}
.shake-hit-anim,
.shake-hit {
    --sprite-animation: shake-hard 0.4s cubic-bezier(.36, .07, .19, .97) both;
}
@keyframes shake-hard {
    10% { transform: translateX(-10px) scale(var(--sprite-scale, 1)); }
    50% { transform: translateX(10px) scale(var(--sprite-scale, 1)); }
    100% { transform: translateX(0) scale(var(--sprite-scale, 1)); }
}
.p-sprite.fainting {
    --sprite-faint-animation: faint-blip 0.7s ease forwards;
}
@keyframes faint-blip {
    0% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
    }
    15% {
        opacity: 0.25;
        transform: translateY(0) scale(calc(var(--sprite-scale, 1) * 0.92));
    }
    35% {
        opacity: 0.85;
        transform: translateY(-6px) scale(calc(var(--sprite-scale, 1) * 0.85));
    }
    55% {
        opacity: 0.2;
        transform: translateY(12px) scale(calc(var(--sprite-scale, 1) * 0.55));
    }
    100% {
        opacity: 0;
        transform: translateY(40px) scale(calc(var(--sprite-scale, 1) * 0.25));
    }
}
/* =========================================================
   ä¿®æ­£ç‰ˆå¸ƒå±€ - å½»åº•è§£å†³é‡å é—®é¢˜
   ========================================================= */
/* 1. ä»ªè¡¨ç›˜æ€»å®¹å™¨ */
.command-dashboard {
    position: absolute;
    bottom: 24px;
    left: 24px;
    right: 24px;
    height: 190px;
    display: flex;
    gap: 30px; 
    padding: 0;
    box-sizing: border-box;
    background: transparent;
    z-index: 50;
    clip-path: none;
    perspective: 1000px;
}
.msg-box-modern {
    flex: 0 0 40%; 
    width: 40%; 
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    background: #fff;
    border: 1px solid rgba(55, 65, 81, 0.2);
    transform: skewX(-15deg);
    margin-left: -39px;
    border-radius: 16px;
    box-shadow:
        8px 8px 0 rgba(20, 30, 40, 0.15), 
        inset 0 0 0 1px rgba(255, 255, 255, 0.8);
    overflow: hidden;
    transition: all 0.3s ease;
    padding: 0;
    font-family: var(--font-main);
}
.msg-header,
.msg-content-area {
    transform: skewX(15deg);
    transform-origin: center center;
    margin: 0 16px;
}
.msg-header {
    flex: 0 0 42px;
    width: 112%;
    margin-left: -6%;
    background: #f1f3f6;
    border-bottom: 3px solid #e0e4eb;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-left: 30px;
    padding-right: 50px;
    box-sizing: border-box;
    position: relative;
    z-index: 5;
}
.sys-label {
    font-size: 0.9rem;
    font-weight: 950;
    letter-spacing: 1px;
    color: var(--primary-dark);
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: var(--font-main);
}
.sys-label::before {
    content: '';
    width: 14px;
    height: 14px;
    background: var(--accent-blue);
    border: 2px solid #fff;
    box-shadow: 2px 2px 0 rgba(0,0,0,0.15);
    border-radius: 4px;
    transform: rotate(15deg);
}
.sys-dots { display: none; }
.msg-content-area {
    flex: 1;
    padding: 12px 10px;
    overflow-y: auto;
    font-size: 0.95rem;
    line-height: 1.6;
    color: #334155;
    scrollbar-width: none;
    padding-right: 20px;
    margin-right: -10px;
    font-family: var(--font-main);
    mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 100%);
    margin: 0 10px;
    margin-right: -10px;
}
.msg-content-area::-webkit-scrollbar {
    display: none;
}
.log-entry {
    margin-bottom: 6px;
    font-size: 1rem;
    color: #64748b;
    line-height: 1.4;
    font-weight: 600;
    opacity: 0.7;
    padding-left: 2px;
    font-family: var(--font-main);
}
.log-entry:last-child {
    font-size: 1.25rem;
    color: #333;
    font-weight: 800;
    margin-top: 8px;
    padding-left: 12px;
    border-left: 6px solid var(--accent-blue);
    background: linear-gradient(90deg, rgba(82, 226, 255, 0.1) 0%, transparent 100%);
    opacity: 1;
    border-radius: 0 8px 8px 0;
    text-shadow: 1px 1px 0 #fff;
    animation: simpleSlideIn 0.25s ease-out;
}
@keyframes simpleSlideIn {
    from {
        opacity: 0;
        transform: translateX(-10px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}
.hl-dmg {
    color: white;
    background: #ef4444;
    padding: 0 5px;
    border-radius: 4px;
    box-shadow: 1px 1px 0 rgba(0,0,0,0.2);
}
.hl-crit {
    color: #b45309;
    padding: 2px 6px;
    border: 2px solid var(--accent-yellow);
    background: #fffbeb;
    font-weight: 900;
    font-style: italic;
    display: inline-block;
    transform: rotate(-3deg);
}
.next-cursor {
    position: absolute;
    bottom: -5px;
    right: -5px;
    width: 0;
    height: 0;
    border-bottom: 30px solid var(--accent-blue);
    border-left: 30px solid transparent;
    animation: cursor-bounce 1s infinite;
    opacity: 1;
    z-index: 10;
}
@keyframes cursor-bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(5px);
    }
}
.hl-sup {
    color: #fff;
    background: var(--color-fight);
    padding: 1px 8px;
    clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
    font-size: 0.85em;
    margin-left: 6px;
}
.hl-res {
    color: #475569;
    background: #cbd5e1;
    padding: 1px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    margin-left: 6px;
}
.hl-sys {
    color: var(--accent-blue);
    font-weight: 800;
}
.main-menu {
    margin-left: 5px;
    z-index: 60;
}
/* 
   2. å³ä¾§æ“ä½œé¢æ¿é€šç”¨å¤–å£³ (æ ¸å¿ƒä¿®æ­£ç‚¹)
   ä¸å†å¼ºåˆ¶æ‹‰ä¼¸å®½åº¦ï¼Œä¸¥æ ¼éµå®ˆ flex è¾¹ç•Œ 
*/
.main-menu, .moves-menu {
    flex: 1; 
    width: auto; 
    height: 100%;
    margin-left: 0; 
    background: #fff;
    border: 1px solid rgba(55, 65, 81, 0.2);
    border-radius: 16px;
    transform: skewX(-15deg);
    box-shadow: 6px 6px 0 rgba(20, 30, 40, 0.08);
    padding: 0;
    overflow: hidden; 
    pointer-events: auto;
    animation: simpleOpacity 0.3s ease-out;
    font-family: Rubik;
}
@keyframes simpleOpacity { from { opacity: 0; } to { opacity: 1; } }
.main-menu.hidden, .moves-menu.hidden {
    display: none;
}
/* =========================================
   ä¸»èœå• (FIGHT/RUN) - ä»…éœ€åŒæ­¥å†…éƒ¨è¾¹è·
   ========================================= */
.radical-menu-container {
     transform: skewX(15deg); /* åå‘æ‰¶æ­£ */
     height: 100%;
     width: 100%; 
     display: flex;
     margin: 0;
     padding: 10px 25px; 
     box-sizing: border-box;
     font-family: Rubik;
}
/* =========================================
   B. æŠ€èƒ½èœå• (Moves Menu) - é«˜åº¦ç˜¦èº« & æ ·å¼é‡æ„
   ========================================= */ 
.moves-menu {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 12px;
    padding: 20px 30px;
    box-sizing: border-box;
    width: auto;
    margin-left: 0; 
    height: 100%;
    position: relative;
    overflow: visible;
    font-family: var(--font-main);
}
/* æŠ€èƒ½æŒ‰é’® - é‡å†™ */
.action-btn {
    display: flex;
    /* æ”¹ä¸ºå·¦å³æ¨ªæ’ï¼Œå·¦è¾¹å½©æ¡å³è¾¹å­—ï¼Œæ›´çœé«˜ */
    flex-direction: row; 
    align-items: center; 
    justify-content: space-between; /* åå­—é å·¦ï¼Œæ ‡ç­¾é å³ */
    border: none;
    cursor: pointer;
    font-family: inherit;
    position: relative;
    overflow: hidden; /* å…³é”®ï¼šåˆ‡æ‰æº¢å‡ºçš„é¢œè‰²æ¡ */
    /* åŸºç¡€æ ·å¼ */
    background: #f8fafc;
    /* è¾¹æ¡†ç»†ä¸€ç‚¹ */
    border: 1px solid rgba(55, 65, 81, 0.3);
    border-radius: 10px; /* ç¨å¾®æ–¹ä¸€ç‚¹ */
    transition: all 0.15s ease-out;
    padding: 0 12px 0 0; /* å³è¾¹ç•™ç©ºç»™èƒ¶å›Š */
    /* 
      å…³é”®ä¿®æ­£ï¼šé«˜åº¦è‡ªé€‚åº”å¡«æ»¡ Grid Cellï¼Œ
      é¿å…å›ºå®š padding å¯¼è‡´çš„æ’‘ç ´ 
    */
    width: 100%;
    height: 100%; 
    box-sizing: border-box;
    font-family: var(--font-main);
}
/* æŒ‰é’®å†…éƒ¨çš„å†…å®¹å®¹å™¨ - ç”¨æ¥ä¿®æ­£ Skew */
/* 
   å› ä¸ºçˆ¶çº§ skew äº† -15degï¼Œ.moves-menu æ²¡æœ‰ skew(åå‘)ï¼Œ
   æ‰€ä»¥ .action-btn æ˜¯æ–œçš„ï¼ˆå¦‚æ‚¨æ‰€æ„¿ï¼‰ã€‚
   ä½†é‡Œé¢çš„ æ–‡æœ¬ å¿…é¡»ç›´ç«‹ã€‚
*/
.action-btn .move-name, 
.action-btn .badge-type {
    /* å†æ¬¡æŠŠæ–‡å­—æ‰¶æ­£ï¼Œä¾¿äºé˜…è¯» */
    transform: skewX(15deg);
    position: relative;
    z-index: 2;
    font-family: var(--font-main);
}
/* [æ”¹åŠ¨] å·¦ä¾§è£…é¥°æ¡ - å˜ä¸ºçœŸæ­£çš„æ–œåˆ‡è‰²å—å¡«å…… */
.action-btn::before {
    content: '';
    position: absolute;
    left: -1px;
    top: -1px;
    bottom: -1px;
    width: 20px; 
    background: hsl(var(--hue, 0), 75%, 65%);
    border: 1px solid rgba(55, 65, 81, 0.3); 
    border-right: 1px solid rgba(55, 65, 81, 0.3);
    opacity: 1; 
    box-sizing: content-box;
}
/* å®šä¹‰ä¸‰ä¸ªæ§½ä½çš„è‰²ç›¸ */
.moves-menu .action-btn:nth-child(1) { --hue: 0;   /* çº¢ */ } 
.moves-menu .action-btn:nth-child(2) { --hue: 200; /* è“ */ }
.moves-menu .action-btn:nth-child(3) { --hue: 45;  /* é‡‘è‰² */ }
.moves-menu .action-btn:nth-child(4) { --hue: 280; /* ç´« */ }
.back-btn-pill {
    position: absolute;
    top: -15px;
    left: -10px;
    width: 44px;
    height: 44px;
    background: #f8fafc;
    color: #334155;
    border: 3px solid rgba(255,255,255,0.85);
    border-radius: 50%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: transform 0.2s, background 0.2s;
    transform: skewX(15deg); /* è¡¥å¿çˆ¶çº§å€¾æ–œ */
    font-family: var(--font-main);
}
.back-btn-pill:hover {
    transform: skewX(15deg) scale(1.15) rotate(-10deg);
    background: #e2e8f0;
}
.back-btn-pill svg {
    width: 22px;
    height: 22px;
    fill: currentColor;
}
/* ===========================
   Mega Evolution Button
   =========================== */
 .mega-btn-pill {
    position: absolute;
    top: -35px;
    left: 50px;
    right: auto;
    width: 56px;
    height: 56px;
    background: linear-gradient(135deg, #FF00CC 0%, #6366f1 50%, #333399 100%);
    color: #fff;
    border: 3px solid rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    box-shadow: 0 0 15px rgba(255, 0, 204, 0.5), inset 0 0 10px rgba(255,255,255,0.2);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 101;
    transition: all 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    transform: skewX(15deg);
    overflow: hidden;
    font-family: var(--font-main);
}
.mega-btn-pill:hover {
    transform: skewX(15deg) scale(1.1);
    box-shadow: 0 0 25px rgba(255, 0, 204, 0.7), inset 0 0 15px rgba(255,255,255,0.3);
}
.mega-btn-pill.armed {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 0 0 30px #FF00CC, 0 0 60px rgba(99, 102, 241, 0.5);
    border-color: #fff;
    animation: mega-pulse 0.8s infinite alternate ease-in-out;
}
@keyframes mega-pulse {
    0% { 
        box-shadow: 0 0 20px #FF00CC, 0 0 40px rgba(255, 0, 204, 0.4); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 35px #00ffff, 0 0 60px rgba(0, 255, 255, 0.5); 
        filter: brightness(1.15);
    }
}
.mega-btn-pill .mega-icon {
    width: 36px;
    height: 36px;
    transform: skewX(-15deg);
}
.mega-btn-pill.hidden {
    display: none;
}
/* å·¦ä¾§ç•™ç™½ç»™æ–‡å­—ï¼Œé¿å¼€è‰²å— */
.action-btn .move-name {
    margin-left: 22px; /* è®©å¼€è‰²æ¡ */
    font-size: 1.15rem;   /* ä¸­æ–‡å­—å·å¢å¤§ */
    font-weight: 700;
    color: #374151; /* æ›´æŸ”å’Œçš„æ·±ç°ï¼Œä¸­æ–‡é˜…è¯»æ›´å‹å¥½ */
    letter-spacing: -0.02em;
    line-height: 1.2;
    text-align: left;
    font-family: var(--font-main);
    white-space: nowrap; /* ä¸å…è®¸æ¢è¡Œæ’‘å¼€é«˜åº¦ */
}
/* [æ”¹åŠ¨] æŠ€èƒ½å³ä¾§çš„å°æ ‡ç­¾ - æ¢å¤ä¸ºå°èƒ¶å›Š */
.action-btn .badge-type {
    font-size: 0.85rem; /* å±æ€§æ ‡ç­¾å­—å·å†åŠ å¤§ */
    font-weight: 800;
    text-transform: uppercase;
    padding: 4px 12px;
    border-radius: 6px;
    background: rgba(100, 116, 139, 0.15);
    color: #475569;
    letter-spacing: 0.5px;
    position: absolute;
    bottom: 8px;
    right: 12px;
    font-family: var(--font-main);
    z-index: 3;
}
/* æ‚¬åœæ•ˆæœ: æ•´ä½“ç¨å¾®å˜äº®å¹¶ä¸Šæµ® */
.action-btn:hover:enabled {
    border-color: #334155; 
    background: #fff;
    transform: translateY(-2px); 
    box-shadow: 4px 4px 0 rgba(0,0,0,0.15);
}
.action-btn:hover:enabled::before {
    filter: brightness(1.1); /* è‰²æ¡å˜äº® */
    width: 25px; /* è‰²æ¡å˜å®½ä¸€ç‚¹ç‚¹ä½œä¸ºäº’åŠ¨åé¦ˆ */
    transition: 0.2s;
}
/* ======================
   Back (è¿”å›) æŒ‰é’®ç‰¹æ®Šæ ·å¼
   ====================== */
.action-btn.back {
    /* è¿”å›æŒ‰é’®é“ºæ»¡èƒŒæ™¯ */
    background: #fff;
    border-color: #cbd5e1;
    justify-content: center; /* æ–‡å­—å±…ä¸­ */
    padding: 0;
}
.action-btn.back::before {
    display: none; /* æ²¡æœ‰è‰²æ¡ */
}
.action-btn.back .move-name {
    margin-left: 0;
    color: #94a3b8;
    font-size: 0.9rem;
}
.action-btn.back:hover {
    background: #f1f5f9;
    border-color: #94a3b8;
}
.action-btn.back .move-name::before {
    content: 'â†© '; /* åŠ ä¸ªç®€å•çš„è¿”å›ç®­å¤´ */
    font-size: 1.1em;
}
/* =========================================
   NEW HUD DESIGN: æ— è¾¹æ¡†æ‚¬æµ®æ–œåˆ‡é£æ ¼
   ========================================= */
.hud-modern {
    position: absolute;
    z-index: 20;
    font-family: var(--font-main);
    color: var(--primary-dark);
    background: transparent;
    border: none;
    padding: 0;
    box-shadow: none;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.15));
}
.hud-enemy {
    top: 50px;
    left: env(safe-area-inset-left, 40px);
    width: 340px;
}
.hud-player {
    bottom: 220px;
    right: env(safe-area-inset-right, 40px);
    width: 380px;
    text-align: right;
}
.info-group, .main-info {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 2px;
}
.hud-player .main-info {
    justify-content: flex-end;
}
.hud-modern .card-name {
    font-size: 1.3rem;
    font-weight: 800;
    color: #2d3436;
    letter-spacing: -0.5px;
    margin-bottom: 4px;
    font-family: var(--font-main);
}
.hud-modern .p-lv {
    font-size: 1.1rem;
    font-weight: 900;
    color: #999;
    text-shadow: 1px 1px 0 #fff;
}
.p-lv-tag {
    background: #2d3436;
    color: var(--accent-yellow);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 1rem;
    font-weight: 800;
    transform: skewX(-15deg);
    box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
}
.p-lv-tag span {
    display: inline-block;
    transform: skewX(15deg);
}
.hp-track {
    position: relative;
    height: 14px;
    width: 100%;
    margin-top: 4px;
    display: flex;
    align-items: center;
}
.hp-track.is-player {
    justify-content: flex-end;
    height: 18px;
    gap: 6px;
}
.hp-intro-label {
    background: #fecea8;
    color: #cb5309;
    font-size: 0.7em;
    font-weight: 900;
    padding: 2px 4px;
    border-radius: 2px;
    transform: skewX(-20deg);
}
.hp-bar-shape {
    flex-grow: 1;
    height: 100%;
    background: rgba(45, 52, 54, 0.8);
    position: relative;
    clip-path: polygon(0 0, 100% 0, 95% 100%, 0% 100%);
    transform: skewX(-20deg);
    border-radius: 4px;
    border: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    overflow: hidden;
}
.hud-enemy .hp-bar-shape {
    transform: skewX(-20deg);
    clip-path: polygon(0 0, 100% 0, 100% 100%, 5% 100%);
}
.hp-fill-modern {
    height: 100%;
    background: linear-gradient(90deg, #4fd1c5 0%, #38b2ac 100%);
    width: 100%;
    transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.4s;
    position: relative;
}
.hp-shine {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 100%);
    pointer-events: none;
    z-index: 5;
}
.hp-val-floating {
    position: absolute;
    right: 0;
    bottom: -18px;
    font-size: 1.1rem;
    font-weight: 700;
    color: #555;
    text-shadow: 1px 1px 0 #fff;
    font-style: italic;
}
.ball-track-modern {
    display: flex;
    gap: 4px;
    margin-top: 8px;
    opacity: 0.8;
}
.ball-track-modern.is-right {
    justify-content: flex-end;
}
.ball-track-modern .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #dcdde1;
    border: 1px solid #718093;
    transition: 0.3s;
}
.ball-track-modern .dot.alive {
    background: var(--primary-pink);
    border-color: white;
    filter: drop-shadow(0 0 3px var(--primary-pink));
}
.ball-track-modern .dot.dead {
    background: #353b48;
    border-color: #353b48;
    opacity: 0.3;
}
.ball-track-modern .dot.active {
    transform: scale(1.5);
    background: white;
    border-color: var(--primary-pink);
    box-shadow: 0 0 4px var(--primary-pink);
}
/* ==============================================
   SHARP ANGULAR HUD ( J-RPG å°–è§’é£æ ¼ )
   ============================================== */
.hud {
    position: absolute;
    z-index: 20;
    pointer-events: none;
}
.container-enemy {
    top: 30px;
    left: env(safe-area-inset-left, 30px);
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}
.container-player {
    bottom: 240px;
    right: env(safe-area-inset-right, 30px);
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}
.sharp-panel {
    position: relative;
    transform: skewX(-15deg);
    padding: 12px 35px 12px 25px;
    background: rgba(255, 255, 255, 0.95);
    border: none;
    box-shadow:
        0 18px 30px rgba(15, 23, 42, 0.18),
        0 10px 0 rgba(15, 23, 42, 0.10);
    min-width: 320px;
    backdrop-filter: blur(8px);
}
.sharp-panel::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,255,255,0));
    opacity: 0.9;
    mix-blend-mode: soft-light;
}
.container-enemy .sharp-panel {
    background: rgba(255, 255, 255, 0.95);
    border: none;
    color: #1e293b;
    border-left-width: 0;
}
.container-player .sharp-panel {
    border: none;
}
.container-player .sharp-panel {
    box-shadow:
        0 -10px 20px rgba(15, 23, 42, 0.08),
        0 18px 28px rgba(15, 23, 42, 0.08),
        0 8px 0 rgba(15, 23, 42, 0.07);
}
.container-player .sharp-panel::before {
    opacity: 1;
    background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0));
}
.panel-content.unskew {
    transform: skewX(15deg);
}
.deco-strip {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 8px;
    background: var(--primary-pink);
}
.container-enemy .deco-strip {
    left: -11px;
    border: none;
    transform: skewX(0deg);
}
.player-strip {
    right: -11px;
    left: auto;
    background: var(--accent-blue);
    border: 2px solid rgba(255, 255, 255, 0.9);
    transform: skewX(0deg);
}
.info-row {
    display: flex;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 6px;
    white-space: nowrap;
}
.right-align {
    justify-content: flex-end;
}
.p-name {
    font-size: 1.6rem;
    font-weight: 800;
    letter-spacing: -0.02em;
    /* å¢å¼ºæ–‡å­—ç«‹ä½“æ„Ÿ */
    text-shadow: 2px 2px 0 rgba(255,255,255,0.9), 0px 0px 1px rgba(0,0,0,0.1);
    /* é˜²æ­¢è¿‡é•¿åç§°æ¢è¡Œ */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
    max-width: 220px;
}
.container-enemy .p-name { 
    color: #1e293b; 
}
.container-player .p-name { 
    color: #1e293b; 
}
/* ç¡®ä¿ç­‰çº§æ˜¾ç¤ºä¸è¢«å‹ç¼© */
.sw-top-row {
    display: flex;
    align-items: baseline;
    gap: 8px;
    overflow: hidden;
}
.sw-row-right-group,
.p-lv {
    flex-shrink: 0;
}
.p-lv {
    font-size: 1rem;
    font-family: var(--font-number);
    color: #94a3b8;
    font-weight: 700;
}
.p-lv-badge {
    background: #0f172a;
    color: var(--accent-yellow);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.9rem;
    display: inline-block;
    vertical-align: middle;
}
.hp-nums-floating {
    position: absolute;
    right: 0;
    top: -24px;
    font-weight: 800;
    font-size: 1.1rem;
    color: #475569;
    text-shadow: 1px 1px 0 #fff;
    font-style: italic;
}
.hp-track-wrapper {
    width: 100%;
    margin-top: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
}
.hp-intro {
    font-size: 0.75rem;
    font-weight: 900;
    background: #000;
    color: var(--accent-yellow);
    padding: 1px 4px;
    border-radius: 2px;
}
.hp-border-frame {
    flex: 1;
    background: #334155;
    border: none;
    height: 14px;
    position: relative;
    box-shadow: inset 2px 2px 4px rgba(0,0,0,0.5);
    border-radius: 2px;
    overflow: hidden;
}
.container-player .hp-border-frame {
    height: 18px;
    background: #e2e8f0;
}
.hp-fill-colors {
    height: 100%;
    background: linear-gradient(180deg, #4fd1c5 0%, #2c7a7b 90%);
    box-shadow: 0 0 10px rgba(79, 209, 197, 0.4);
    transition: width 0.6s cubic-bezier(0.25, 1, 0.5, 1), background 0.3s;
    position: relative;
    border-right: none;
}
.hp-gloss {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(to bottom, rgba(255,255,255,0.25), transparent);
    z-index: 5;
    pointer-events: none;
}
/* =========================================
   [æ”¹] 6æ§½ç²¾çµçƒ HUD è®¾è®¡ (Black Glass UI)
   ========================================= */
.party-track {
    display: flex;
    gap: 8px;
    margin-bottom: 5px;
    transform: skewX(-15deg);
    height: 32px;
    align-items: center;
    padding: 2px 12px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.35);
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-sizing: border-box;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}
.player-side {
    margin-top: 5px;
    margin-bottom: 0px;
    justify-content: flex-end;
}
.poke-slot {
    width: 20px;
    height: 20px;
    transform: skewX(15deg) rotate(-10deg);
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    transition: all 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}
.ball-menu-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(5px);
    z-index: 250;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}
.ball-menu-overlay.hidden {
    display: none;
}
.ball-menu-card {
    background: #fff;
    border-radius: 16px;
    padding: 20px 30px;
    width: 320px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.4);
    transform: skewX(-5deg);
    border-right: 6px solid var(--color-catch);
}
.ball-header {
    font-size: 1.2rem;
    font-weight: 800;
    color: #333;
    margin-bottom: 20px;
    border-bottom: 2px solid #eee;
    padding-bottom: 10px;
}
.ball-option {
    width: 100%;
    padding: 15px;
    margin-bottom: 10px;
    border: 2px solid #eee;
    border-radius: 10px;
    background: #fff;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    transition: 0.2s;
}
.ball-option:hover {
    background: #f0fdf4;
    border-color: var(--color-catch);
    color: #166534;
    transform: translateX(5px);
}
.ball-multi {
    font-size: 0.8rem;
    background: #333;
    color: #fff;
    padding: 2px 6px;
    border-radius: 4px;
}
.close-ball-menu {
    margin-top: 15px;
    background: transparent;
    border: none;
    color: #999;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
}
.close-ball-menu:hover {
    color: #555;
}
.poke-slot.alive {
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23eee' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 A46,46 0 0,1 96,50' fill='%23fe6b6b'/%3E%3Cpath d='M4,50 L96,50' stroke='%23333' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='14' fill='%23fff' stroke='%23333' stroke-width='4'/%3E%3C/svg%3E");
    opacity: 0.9;
    filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.3));
}
.poke-slot.dead {
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%235E5E5E' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 L96,50' stroke='%23111' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='14' fill='%23999' stroke='%23111' stroke-width='4'/%3E%3Cpath d='M30,30 L70,70 M70,30 L30,70' stroke='%23222' stroke-width='8' opacity='0.5'/%3E%3C/svg%3E");
    opacity: 0.6;
    transform: skewX(15deg) rotate(-15deg) scale(0.85);
    filter: grayscale(1);
}
.poke-slot.active {
    transform: skewX(15deg) rotate(-15deg) scale(1.3) translateY(-4px);
    z-index: 10;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23f5f5f5' stroke='%23333' stroke-width='6'/%3E%3Cpath d='M4,50 A46,46 0 0,1 96,50' fill='%23FFCB05'/%3E%3Cpath d='M4,50 L96,50' stroke='%23333' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='15' fill='%23fff' stroke='%23333' stroke-width='4'/%3E%3Cpath d='M25,25 L40,40 M75,25 L60,40' stroke='%23C13E3E' stroke-width='5' stroke-linecap='round'/%3E%3C/svg%3E");
    filter: drop-shadow(0 0 6px rgb(255, 230, 91)) drop-shadow(0 4px 6px rgba(0,0,0,0.3));
}
.poke-slot.empty::after {
    content: "";
    display: block;
    width: 6px;
    height: 6px;
    background: linear-gradient(135deg, #fff 0%, #ddd 100%);
    border-radius: 50%;
    box-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
    opacity: 0.6;
}
/* ==========================================================
   MODERN SWITCH MENU REVAMP (ç°ä»£æ— è¾¹æ¡†é£æ ¼)
   ========================================================== */
.overlay-modal.modern-layer {
    background: rgba(240, 242, 245, 0.4);
    backdrop-filter: blur(25px) saturate(160%) brightness(1.1);
    -webkit-backdrop-filter: blur(25px) saturate(160%) brightness(1.1);
}
.sharp-panel,
.container-enemy .sharp-panel,
.container-player .sharp-panel {
    background: rgba(0, 0, 0, 0.35) !important;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.12);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    color: #fff;
    transform: skewX(-15deg);
    padding: 10px 25px;
}
.sharp-panel::before,
.container-player .sharp-panel::before {
    display: none !important;
}
.deco-strip {
    left: 0;
    width: 4px;
}
.container-player .deco-strip {
    right: 0;
    left: auto;
    border: none;
    to { opacity: 1; }
}
.switch-container-modern {
    width: min(95vw, 640px);
    max-width: 640px;
    height: 100%;
    max-height: none;
    margin: 0 auto;
    padding: 25px 35px 35px;
    position: relative;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    background: rgba(255, 255, 255, 0.85);
    border-radius: 24px;
    overflow-y: auto;
}
.switch-header-modern {
    margin-bottom: 25px;
    padding-left: 20px;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 15px;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 15px;
    font-family: var(--font-main);
}
.switch-header-modern h2 {
    font-size: 2.2rem;
    color: #2d3436;
    margin: 0;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: var(--font-main);
}
.switch-header-subtitle {
    font-weight: 500;
    color: #a4b0be;
    font-size: 1rem;
    margin-top: 8px;
    letter-spacing: 1px;
    font-family: var(--font-main);
}
.party-grid-modern {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 5px 0 20px;
    overflow-y: auto;
    overflow-x: hidden;
    width: 100%;
    max-height: none;
    flex: 1;
    box-sizing: border-box;
}
.party-grid-modern::-webkit-scrollbar {
    width: 10px;
}
.party-grid-modern::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.12);
    border-radius: 999px;
}
.party-grid-modern::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.04);
    border-radius: 999px;
}
.party-card-modern {
    position: relative;
    background: #ffffff;
    border-radius: 20px;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 18px;
    flex-shrink: 0;
    min-height: 86px;
    box-shadow:
        0 10px 20px rgba(0,0,0,0.03),
        0 2px 5px rgba(0,0,0,0.02);
    transition: all 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
    cursor: pointer;
    overflow: hidden;
    opacity: 0;
    animation: slide-up-card 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}
@keyframes slide-up-card {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
.party-card-modern:hover:not(.disabled) {
    transform: translateY(-4px) scale(1.02);
    box-shadow:
        0 15px 30px rgba(0,0,0,0.08),
        0 5px 10px rgba(0,0,0,0.03);
    z-index: 10;
}
.party-card-modern:active:not(.disabled) {
    transform: scale(0.98);
}
.party-card-modern.current {
    background: #f1f3f6;
    box-shadow: inset 0 0 0 2px #dcdde1;
    pointer-events: none;
    opacity: 0.8;
}
.party-card-modern.dead {
    background: #fdfdfd;
    filter: grayscale(1);
    opacity: 0.7;
    cursor: not-allowed;
}
.party-card-modern.dead:not(.disabled) {
    cursor: default;
}
.card-icon-modern {
    width: 65px;
    height: 65px;
    flex-shrink: 0;
    border-radius: 50%;
    background: #fafafa;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
.card-icon-modern img {
    width: 130%;
    height: auto;
    transform: translateY(-2px);
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.15));
}
/* Mega å½¢æ€å›¾æ ‡æ”¾å¤§ */
.card-icon-modern img.mega-icon {
    width: 165% !important;
    transform: translateY(-4px) scale(1.55) !important;
    filter: drop-shadow(0 0 8px rgba(168, 85, 247, 0.4)) drop-shadow(0 4px 6px rgba(0,0,0,0.2)) !important;
}
.card-info-modern {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.card-top-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 6px;
}
.card-name {
    font-size: 1.3rem;
    font-weight: 800;
    color: #2d3436;
}
.card-lv {
    font-size: 0.9rem;
    font-weight: 700;
    color: #b2bec3;
    font-style: italic;
}
.card-hp-nums {
    font-size: 0.8rem;
    font-weight: 700;
    color: #636e72;
    letter-spacing: 0.5px;
    font-family: var(--font-number);
}
.modern-hp-track {
    height: 8px;
    width: 100%;
    background: #eaeaea;
    border-radius: 10px;
    overflow: hidden;
}
.modern-hp-fill {
    height: 100%;
    border-radius: 10px;
    transition: width 0.3s;
    background: var(--hp-high);
}
.status-tag {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    font-size: 0.8rem;
    font-weight: 900;
    color: #d63031;
    border: 2px solid rgba(214, 48, 49, 0.2);
    padding: 2px 8px;
    border-radius: 8px;
    transform: rotate(5deg) translateY(-50%);
}
.current-tag {
    position: absolute;
    right: 0;
    top: 0;
    background: var(--accent-blue);
    color: white;
    font-size: 0.6rem;
    font-weight: 900;
    padding: 2px 10px;
    border-radius: 0 20px 0 10px;
}
/* =========================================================
   [æ”¹] SWSH å‰‘ç›¾é£æ ¼ç™½è‰²é¢æ¿é‡æ„
   ========================================================= */
body {
    font-family: var(--font-main);
}
/* ä¸»èœå•æŒ‰é’®ä¿æŒåŸè‹±æ–‡å­—ä½“ */
.radical-btn,
.radical-btn .en,
.radical-btn .jp,
.r-label,
.r-label-min {
    font-family: 'Rubik', sans-serif !important;
}
.hud {
    position: absolute;
    z-index: 10;
    width: 330px;
    background: var(--primary-white);
    border-radius: var(--radius-l);
    padding: 15px 20px;
    border: 2px solid #ffffff;
    box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.08),
        4px 4px 0 rgba(70, 70, 80, 0.08);
    filter: none;
    transform: translateX(5px);
}
.sharp-panel,
.container-player .sharp-panel,
.container-enemy .sharp-panel {
    position: relative;
    transform: skewX(-22deg);
    background: rgba(255, 255, 255, 0.98) !important;
    border: 2px solid rgba(255, 255, 255, 1);
    border-radius: 6px;
    padding: 8px 30px 8px 40px;
    min-width: 290px;
    box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.1),
        2px 4px 6px rgba(0, 0, 0, 0.12),
        0 10px 25px rgba(0, 0, 0, 0.15);
    z-index: 10;
}
.panel-content.unskew {
    transform: skewX(22deg);
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.deco-strip {
    background: var(--primary-pink);
    width: 6px;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 2px 0 0 2px;
    box-shadow: 1px 0 2px rgba(0,0,0,0.2);
    filter: brightness(0.95);
    z-index: 2;
}
.deco-strip.player {
    background: var(--accent-blue);
    left: auto;
    right: 0;
    border-radius: 0 2px 2px 0;
    border: none;
}
.sw-top-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    width: 100%;
    margin-bottom: 2px;
    line-height: 1;
}
.p-name {
    font-size: 1.55rem;
    font-weight: 800;
    color: #2c3e50;
    text-shadow: 2px 2px 0px #fff, -1px -1px 0 #fff;
    letter-spacing: -0.5px;
    margin-right: 15px;
}
.sw-row-right-group {
    display: flex;
    align-items: baseline;
    gap: 10px;
}
.hp-v-nums {
    font-size: 1.1rem;
    font-weight: 700;
    font-family: "Menlo", "Consolas", monospace;
    color: #7f8c8d;
    letter-spacing: -0.5px;
}
.p-lv {
    font-size: 1.2rem;
    font-weight: 500;
    color: #2c3e50;
}
.p-lv span {
    font-weight: 800;
    margin-left: 1px;
}
.hp-track-wrappersw {
    width: 100%;
    height: 13px;
    position: relative;
    margin-bottom: 2px;
}
.container-player .hp-track-wrappersw {
    height: 13px;
}
.hp-border-frame {
    width: 100%;
    height: 100%;
    background: #e6eaea;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    border: none;
    box-shadow: none;
}
.hp-fill-colors {
    border-radius: 20px;
    height: 100%;
    background: #4cd137;
    transition: width 0.4s ease-out;
    box-shadow: none;
    border: none;
}
.hp-intro,
.p-lv-badge,
.hp-nums-floating,
.hp-gloss,
.sw-bot-row {
    display: none !important;
}
.party-track {
    height: 26px;
    background: rgba(0, 0, 0, 0.45);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.15);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    padding: 2px 12px;
    gap: 8px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    transform: skewX(-22deg);
}
.switch-footer {
    margin-top: 30px;
    display: flex;
    justify-content: center;
}
.btn-close-modern {
    background: #fff;
    border: none;
    padding: 12px 30px;
    border-radius: 50px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: inherit;
    font-weight: 800;
    font-size: 1.1rem;
    color: #636e72;
    box-shadow: 0 5px 15px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: 0.2s;
}
.btn-close-modern:hover {
    transform: scale(1.05);
    background: #fff0f5;
    color: var(--primary-pink);
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
}
.key-hint {
    background: #dfececb6;
    color: #555;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 0.8rem;
}
.trainer-hud {
    position: absolute;
    top: 22px;
    right: 22px;
    z-index: 30;
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: none;
}
.trainer-panel {
    transform: skewX(-15deg);
    padding: 10px 18px;
    background: rgba(255, 255, 255, 0.92);
    border: none;
    border-radius: 14px;
    box-shadow:
        0 18px 30px rgba(15, 23, 42, 0.14),
        0 10px 0 rgba(15, 23, 42, 0.08);
    backdrop-filter: blur(8px);
}
.trainer-panel-content {
    transform: skewX(15deg);
}
.trainer-name {
    font-family: var(--font-main);
    font-weight: 900;
    font-size: 1rem;
    color: #1e293b;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    white-space: nowrap;
}
.trainer-avatar-wrap {
    width: 58px;
    height: 58px;
    border-radius: 16px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.75);
    box-shadow:
        0 14px 24px rgba(15, 23, 42, 0.14),
        0 8px 0 rgba(15, 23, 42, 0.06);
}
#trainer-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
    image-rendering: pixelated;
}
/* =========================================
   [ADDON] BATTLE EVOLUTION UI - ä¸´åœºè¿›åŒ–æŒ‰é’®
   ä½äº Mega æŒ‰é’®å³ä¾§ï¼Œé‡‡ç”¨é—ªè€€çš„é‡‘è‰²æµå…‰é£æ ¼
   ========================================= */
.mega-btn-pill.evo-style {
    left: 120px;
    background: linear-gradient(135deg, #FFD700 0%, #FDB931 50%, #FFFACD 100%);
    box-shadow: 
        0 0 15px rgba(255, 215, 0, 0.6), 
        inset 0 0 10px rgba(255,255,255,0.4);
    border: 3px solid #FFF;
    z-index: 105;
    animation: gold-pulse 2s infinite ease-in-out;
}
.mega-btn-pill.evo-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(255, 215, 0, 0.9), 
        inset 0 0 15px rgba(255,255,255,0.6);
}
.evo-particles {
    position: absolute;
    width: 60%;
    height: 60%;
    background: radial-gradient(circle, rgba(255,255,255,0.9), transparent 70%);
    opacity: 0.5;
    animation: spin-shine 3s linear infinite;
}
.evo-text {
    font-size: 0.8rem;
    font-weight: 900;
    color: #8B4513;
    font-style: italic;
    transform: skewX(-15deg);
    letter-spacing: 1px;
}
@keyframes gold-pulse {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.2) drop-shadow(0 0 5px gold); }
    100% { filter: brightness(1); }
}
@keyframes spin-shine {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
/* =========================================
   Mega Evolution DNA-Style Visual Effects
   ========================================= */
.p-sprite.loaded {
    opacity: 1;
    filter: drop-shadow(0 2px 5px rgba(0,0,0,0.4));
}
.p-sprite.evo-silhouette {
    filter:
        brightness(0)
        contrast(200%)
        drop-shadow(0 0 10px #ff00ff)
        drop-shadow(2px 2px 4px #00ffff)
        drop-shadow(-2px -2px 4px #ffff00);
    opacity: 0.9;
    animation: dna-struggle 0.12s linear infinite alternate;
}
.p-sprite.evo-burst {
    filter: brightness(10) contrast(0.5) blur(2px) drop-shadow(0 0 30px rgba(255,255,255,0.9));
    transform: scale(1.1);
    opacity: 1;
}
.p-sprite.evo-finish {
    animation: evolve-cooldown 0.8s ease-out forwards;
}
@keyframes dna-struggle {
    from { transform: translateX(-1px) scale(0.98); }
    to { transform: translateX(1px) scale(1.02); }
}
@keyframes evolve-cooldown {
    0% {
        filter: brightness(2) saturate(1.5) drop-shadow(0 0 20px #5ee7ff);
        transform: scale(1.05);
    }
    100% {
        filter: brightness(1.05) saturate(1.05) drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        transform: scale(1);
    }
}
/* ============================================ */
/* æ™®é€šè¿›åŒ–åŠ¨ç”»ï¼ˆä¸ Mega è¿›åŒ–åŒºåˆ†ï¼‰*/
/* ============================================ */
.p-sprite.bio-evo-glow {
    filter: brightness(2) saturate(0.3) drop-shadow(0 0 15px rgba(255,255,255,0.8));
    animation: bio-evo-pulse 0.4s ease-in-out infinite alternate;
}
.p-sprite.bio-evo-burst {
    filter: brightness(5) contrast(0.8) blur(1px) drop-shadow(0 0 25px rgba(255,255,255,0.95));
    transform: scale(1.08);
    opacity: 1;
}
.p-sprite.bio-evo-finish {
    animation: bio-evo-cooldown 0.6s ease-out forwards;
}
@keyframes bio-evo-pulse {
    from { 
        filter: brightness(1.8) saturate(0.3) drop-shadow(0 0 12px rgba(255,255,255,0.7));
        transform: scale(1.0);
    }
    to { 
        filter: brightness(2.2) saturate(0.3) drop-shadow(0 0 18px rgba(255,255,255,0.9));
        transform: scale(1.02);
    }
}
@keyframes bio-evo-cooldown {
    0% {
        filter: brightness(3) saturate(1.3) drop-shadow(0 0 20px #ffffff);
        transform: scale(1.08);
    }
    100% {
        filter: brightness(1.05) saturate(1.05) drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        transform: scale(1);
    }
}
/* Bond Resonance ç¾ç»Šå…±é¸£çŠ¶æ€ */
.p-sprite.bond-resonance {
    filter: drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15);
    animation: bond-pulse 2s ease-in-out infinite;
}
@keyframes bond-pulse {
    0%, 100% {
        filter: drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15);
    }
    50% {
        filter: drop-shadow(0 0 20px #fbbf24) brightness(1.2) saturate(1.3);
    }
}
/* EVO æŒ‰é’® Bond æ¨¡å¼æ ·å¼ */
#btn-evolved.bond-mode {
    background: linear-gradient(135deg, #22c55e 0%, #4ade80 50%, #86efac 100%);
    box-shadow: 0 0 15px rgba(74, 222, 128, 0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    animation: bond-btn-pulse 1.5s ease-in-out infinite;
}
#btn-evolved.bond-mode::before {
    content: 'âˆ';
    font-size: 1.2em;
}
@keyframes bond-btn-pulse {
    0%, 100% {
        box-shadow: 0 0 15px rgba(74, 222, 128, 0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    }
    50% {
        box-shadow: 0 0 25px rgba(74, 222, 128, 0.9), inset 0 1px 0 rgba(255,255,255,0.5);
    }
}
/* =========================================
   [DYNAMAX] æå·¨åŒ–ä¸“ç”¨æ ·å¼
   ========================================= */
/* 1. æå·¨åŒ–çŠ¶æ€ä¸‹çš„ç²¾çµï¼šå·¨å¤§åŒ– + çº¢è‰²æš—äº‘æ»¤é•œ */
.p-sprite.state-dynamax {
    --sprite-scale: 1.8 !important;
    transform: scale(1.8) !important;
    filter: 
        drop-shadow(0 0 25px #ff0055) 
        drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
        brightness(1.05)
        contrast(1.15) 
        saturate(1.25);
    animation: dynamax-breath 3s ease-in-out infinite;
    z-index: 100 !important;
    position: relative;
}
/* ç©å®¶æ–¹æå·¨åŒ–ï¼šå‘ä¸Šç§»åŠ¨ */
#player-sprite.state-dynamax {
    transform: translateY(-30px) scale(1.8) !important;
}
/* æ•Œæ–¹æå·¨åŒ–ï¼šå‘ä¸‹ç§»åŠ¨ä»¥ä¿æŒåœ¨ç”»é¢å†… */
#enemy-sprite.state-dynamax {
    transform: translateY(20px) scale(1.8) !important;
}
/* æå·¨åŒ–å‘¼å¸åŠ¨ç”» - ç©å®¶æ–¹ */
@keyframes dynamax-breath {
    0%, 100% { 
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* ç©å®¶æ–¹å‘¼å¸åŠ¨ç”»ï¼ˆå¸¦ä¸Šä¸‹æµ®åŠ¨ï¼‰*/
#player-sprite.state-dynamax {
    animation: dynamax-breath-player 3s ease-in-out infinite;
}
@keyframes dynamax-breath-player {
    0%, 100% { 
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        transform: translateY(-35px) scale(1.85);
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* æ•Œæ–¹å‘¼å¸åŠ¨ç”»ï¼ˆå¸¦ä¸Šä¸‹æµ®åŠ¨ï¼‰*/
#enemy-sprite.state-dynamax {
    animation: dynamax-breath-enemy 3s ease-in-out infinite;
}
@keyframes dynamax-breath-enemy {
    0%, 100% { 
        transform: translateY(20px) scale(1.8);
        filter: 
            drop-shadow(0 0 25px #ff0055) 
            drop-shadow(0 0 50px rgba(255, 0, 85, 0.6))
            brightness(1.05)
            contrast(1.15) 
            saturate(1.25);
    }
    50% { 
        transform: translateY(25px) scale(1.85);
        filter: 
            drop-shadow(0 0 35px #ff0055) 
            drop-shadow(0 0 70px rgba(255, 0, 85, 0.8))
            brightness(1.1)
            contrast(1.2) 
            saturate(1.35);
    }
}
/* 2. æå·¨åŒ–æŒ‰é’®ï¼šç²‰çº¢/çº¢è‰²èºæ—‹é£æ ¼ */
.mega-btn-pill.dynamax-style {
    background: linear-gradient(135deg, #ff0055 0%, #cc0033 50%, #990022 100%);
    box-shadow: 
        0 0 15px rgba(255, 0, 85, 0.6), 
        0 0 30px rgba(255, 0, 85, 0.3),
        inset 0 0 5px rgba(0, 0, 0, 0.2);
    border: 3px solid #ff99aa;
}
.mega-btn-pill.dynamax-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(255, 0, 85, 0.8), 
        0 0 50px rgba(255, 0, 85, 0.4),
        inset 0 0 10px rgba(0, 0, 0, 0.2);
}
.mega-btn-pill.dynamax-style.armed {
    transform: skewX(15deg) scale(1.2);
    box-shadow: 
        0 0 35px #ff0055, 
        0 0 70px rgba(255, 0, 85, 0.6);
    border-color: #fff;
    animation: dynamax-btn-pulse 0.6s infinite alternate ease-in-out;
}
@keyframes dynamax-btn-pulse {
    0% { 
        box-shadow: 0 0 25px #ff0055, 0 0 50px rgba(255, 0, 85, 0.5); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 40px #ff3377, 0 0 80px rgba(255, 51, 119, 0.6); 
        filter: brightness(1.2);
    }
}
/* æå·¨åŒ–æŒ‰é’®å†…çš„ X å›¾æ ‡ */
.mega-btn-pill.dynamax-style .mega-icon text {
    font-size: 55px;
}
/* 3. æå·¨åŒ–çˆ†å‘åŠ¨ç”»ï¼ˆè§¦å‘æ—¶çš„è§†è§‰æ•ˆæœï¼‰*/
.p-sprite.dynamax-burst {
    animation: dynamax-explosion 0.8s ease-out forwards;
}
@keyframes dynamax-explosion {
    0% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
    30% {
        transform: scale(1.2);
        filter: brightness(3) saturate(0.5) drop-shadow(0 0 50px #ff0055);
    }
    60% {
        transform: translateY(-20px) scale(1.6);
        filter: brightness(1.5) saturate(1.5) drop-shadow(0 0 40px #ff0055);
    }
    100% {
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 20px #ff0055) 
            drop-shadow(0 0 40px rgba(255, 0, 85, 0.5))
            contrast(1.1) 
            saturate(1.2);
    }
}
/* 4. æå·¨åŒ–ç»“æŸæ”¶ç¼©åŠ¨ç”» */
.p-sprite.dynamax-shrink {
    animation: dynamax-shrink 0.6s ease-in forwards;
}
@keyframes dynamax-shrink {
    0% {
        transform: translateY(-30px) scale(1.8);
        filter: 
            drop-shadow(0 0 20px #ff0055) 
            drop-shadow(0 0 40px rgba(255, 0, 85, 0.5))
            contrast(1.1) 
            saturate(1.2);
    }
    50% {
        transform: translateY(-10px) scale(1.3);
        filter: brightness(2) drop-shadow(0 0 30px #ffffff);
    }
    100% {
        transform: translateY(0) scale(var(--sprite-scale, 1));
        filter: contrast(1.15) brightness(1.05) drop-shadow(4px 8px 6px rgba(0, 0, 0, 0.3));
    }
}
/* 5. æå·¨åŒ–å›åˆå€’è®¡æ—¶æŒ‡ç¤ºå™¨ */
.dynamax-turns-indicator {
    position: absolute;
    top: -60px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #ff0055, #cc0033);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 800;
    box-shadow: 0 2px 8px rgba(255, 0, 85, 0.5);
    z-index: 101;
    animation: indicator-pulse 1s ease-in-out infinite;
}
@keyframes indicator-pulse {
    0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
    50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); }
}
/* =========================================
   [Z-MOVE] Zæ‹›å¼æŒ‰é’®æ ·å¼
   ========================================= */
/* Zæ‹›å¼æŒ‰é’®åŸºç¡€æ ·å¼ (æ¨¡æ‹Ÿæ™¶ä½“å…‰æ³½) */
.action-btn.z-move-btn {
    background: linear-gradient(135deg, #FFF 0%, #f3f4f6 40%, rgba(255,255,255,0.8) 100%);
    border: 2px solid transparent !important;
    position: relative;
    overflow: visible;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
/* åŠ¨æ€å½©è™¹è¾¹æ¡† (ç”¨ä¼ªå…ƒç´ è£åˆ‡) */
.action-btn.z-move-btn::after {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(45deg, 
        #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
    z-index: -1;
    border-radius: 9px;
    animation: z-border-spin 3s linear infinite;
}
/* å½©è™¹å†…å®¹åº•æ¿ */
.action-btn.z-move-btn .z-bg-overlay {
    position: absolute;
    inset: 2px;
    background: white;
    border-radius: 8px;
    z-index: 0;
}
/* åå­—å’Œå±æ€§æ ‡ç­¾æé«˜å±‚çº§ */
.action-btn.z-move-btn span {
    position: relative;
    z-index: 2;
}
.action-btn.z-move-btn .move-name {
    font-weight: 800;
    font-style: italic;
    background: linear-gradient(90deg, #333, #666);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-family: var(--font-main);
}
/* Zæ‹›å¼å±æ€§æ ‡ç­¾ç»Ÿä¸€åœ¨å³ä¸‹è§’ */
.action-btn.z-move-btn .badge-type {
    position: absolute;
    bottom: 8px;
    right: 12px;
    z-index: 3;
}
.action-btn.z-move-btn::before {
    display: none !important;
}
/* å³ä¸Šè§’æ‰“æ ‡ Z */
.action-btn.z-move-btn .z-badge-icon {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 20px;
    height: 20px;
    background: #333;
    border-radius: 50%;
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    z-index: 10;
}
/* å·²ä½¿ç”¨çŠ¶æ€ (Burned Out) */
.action-btn.z-move-used {
    background: #e5e7eb !important;
    border: 2px solid #d1d5db !important;
    opacity: 0.6;
    cursor: not-allowed;
    animation: none;
}
.action-btn.z-move-used::after { display: none; }
.action-btn.z-move-used .move-name {
    -webkit-text-fill-color: #9ca3af;
    text-decoration: line-through;
}
@keyframes z-border-spin {
    0% { filter: hue-rotate(0deg); }
    100% { filter: hue-rotate(360deg); }
}
/* =========================================
   [MAX-MOVE] æå·¨æ‹›å¼æŒ‰é’®æ ·å¼
   ========================================= */
/* æå·¨æ‹›å¼æŒ‰é’® (çº¢è‰²ä¸»é¢˜) */
.action-btn.max-move-btn {
    background: linear-gradient(135deg, #fff5f5 0%, #fee2e2 40%, rgba(255,255,255,0.9) 100%);
    border: 2px solid transparent !important;
    position: relative;
    overflow: visible;
    box-shadow: 0 4px 6px rgba(255,0,85,0.2);
}
.action-btn.max-move-btn::after {
    content: '';
    position: absolute;
    inset: -2px;
    background: linear-gradient(45deg, #ff0055, #ff3377, #ff0055, #cc0033, #ff0055);
    z-index: -1;
    border-radius: 9px;
    animation: max-border-pulse 2s ease-in-out infinite;
}
.action-btn.max-move-btn .z-bg-overlay {
    position: absolute;
    inset: 2px;
    background: linear-gradient(135deg, #fff 0%, #fff5f5 100%);
    border-radius: 8px;
    z-index: 0;
}
.action-btn.max-move-btn span {
    position: relative;
    z-index: 2;
}
.action-btn.max-move-btn .move-name {
    font-weight: 800;
    background: linear-gradient(90deg, #e11d48, #be123c);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-family: var(--font-main);
}
/* æå·¨æ‹›å¼å±æ€§æ ‡ç­¾ç»Ÿä¸€åœ¨å³ä¸‹è§’ */
.action-btn.max-move-btn .badge-type {
    position: absolute;
    bottom: 8px;
    right: 12px;
    z-index: 3;
}
.action-btn.max-move-btn::before {
    display: none !important;
}
.action-btn.max-move-btn .z-badge-icon {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 24px;
    height: 24px;
    background: linear-gradient(135deg, #ff0055, #cc0033);
    border-radius: 50%;
    color: white;
    font-size: 10px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(255,0,85,0.4);
    z-index: 10;
}
@keyframes max-border-pulse {
    0%, 100% { 
        filter: brightness(1);
        opacity: 1;
    }
    50% { 
        filter: brightness(1.2);
        opacity: 0.9;
    }
}
/* =========================================================
   å¤ªæ™¶åŒ– (Terastallization) æ ·å¼ç³»ç»Ÿ
   ========================================================= */
/* 1. å¤ªæ™¶åŒ–æŒ‰é’®ï¼šé’»çŸ³/æ°´æ™¶é£æ ¼ - é’è“è‰²æ¸å˜ */
.mega-btn-pill.tera-style {
    background: linear-gradient(135deg, #06b6d4 0%, #0891b2 50%, #0e7490 100%);
    box-shadow: 
        0 0 15px rgba(6, 182, 212, 0.6), 
        0 0 30px rgba(6, 182, 212, 0.3),
        inset 0 0 5px rgba(255, 255, 255, 0.3);
    border: 3px solid #67e8f9;
}
.mega-btn-pill.tera-style:hover {
    transform: skewX(15deg) scale(1.15);
    box-shadow: 
        0 0 25px rgba(6, 182, 212, 0.8), 
        0 0 50px rgba(6, 182, 212, 0.4),
        inset 0 0 10px rgba(255, 255, 255, 0.4);
}
.mega-btn-pill.tera-style.armed {
    transform: skewX(15deg) scale(1.2);
    box-shadow: 
        0 0 35px #22d3ee, 
        0 0 70px rgba(34, 211, 238, 0.6);
    border-color: #fff;
    animation: tera-btn-pulse 0.6s infinite alternate ease-in-out;
}
@keyframes tera-btn-pulse {
    0% { 
        box-shadow: 0 0 25px #22d3ee, 0 0 50px rgba(34, 211, 238, 0.5); 
        filter: brightness(1);
    }
    100% { 
        box-shadow: 0 0 40px #67e8f9, 0 0 80px rgba(103, 232, 249, 0.6); 
        filter: brightness(1.2);
    }
}
/* å¤ªæ™¶åŒ–æŒ‰é’®å†…çš„ T å›¾æ ‡ */
.mega-btn-pill.tera-style .mega-icon text {
    font-size: 50px;
}
/* 2. å¤ªæ™¶åŒ–ç²¾çµå›¾æ•ˆæœï¼šæ°´æ™¶å‘å…‰æ»¤é•œ */
.p-sprite.state-terastal {
    filter: 
        brightness(1.3) 
        saturate(1.2)
        drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
        drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    animation: tera-crystal-shimmer 2s infinite ease-in-out;
}
@keyframes tera-crystal-shimmer {
    0%, 100% {
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    50% {
        filter: 
            brightness(1.5) 
            saturate(1.4)
            drop-shadow(0 0 12px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 25px var(--tera-glow-color, #22d3ee));
    }
}
/* 3. å¤ªæ™¶åŒ–çˆ†å‘åŠ¨ç”»ï¼ˆè§¦å‘æ—¶çš„è§†è§‰æ•ˆæœï¼‰*/
.p-sprite.tera-burst {
    animation: tera-crystallize 0.8s ease-out forwards;
}
@keyframes tera-crystallize {
    0% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
    30% {
        transform: scale(1.15);
        filter: brightness(2) saturate(0.5) hue-rotate(180deg);
    }
    60% {
        transform: scale(1.1);
        filter: brightness(1.8) saturate(1.5);
    }
    100% {
        transform: scale(1);
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
}
/* 4. å¤ªæ™¶å±æ€§é¢œè‰²æ˜ å°„ (ç”¨äºå‘å…‰æ•ˆæœ) */
.tera-type-normal { --tera-glow-color: #a8a878; }
.tera-type-fire { --tera-glow-color: #f08030; }
.tera-type-water { --tera-glow-color: #6890f0; }
.tera-type-electric { --tera-glow-color: #f8d030; }
.tera-type-grass { --tera-glow-color: #78c850; }
.tera-type-ice { --tera-glow-color: #98d8d8; }
.tera-type-fighting { --tera-glow-color: #c03028; }
.tera-type-poison { --tera-glow-color: #a040a0; }
.tera-type-ground { --tera-glow-color: #e0c068; }
.tera-type-flying { --tera-glow-color: #a890f0; }
.tera-type-psychic { --tera-glow-color: #f85888; }
.tera-type-bug { --tera-glow-color: #a8b820; }
.tera-type-rock { --tera-glow-color: #b8a038; }
.tera-type-ghost { --tera-glow-color: #705898; }
.tera-type-dragon { --tera-glow-color: #7038f8; }
.tera-type-dark { --tera-glow-color: #705848; }
.tera-type-steel { --tera-glow-color: #b8b8d0; }
.tera-type-fairy { --tera-glow-color: #ee99ac; }
/* =========================================
   [ADDON] Stellar (æ˜Ÿæ™¶) å±æ€§è§†è§‰é£æ ¼
   æµåŠ¨çš„å½©è™¹å…‰æ•ˆ + çš‡å† è´¨æ„Ÿ
   ========================================= */
.tera-type-stellar { 
    --tera-glow-color: #ffffff;
}
/* è¦†ç›–é»˜è®¤çš„ filter åŠ¨ç”»ï¼Œå®ç°å½©è™¹æµå…‰ */
.p-sprite.state-terastal.tera-type-stellar {
    filter: 
        brightness(1.1)
        contrast(1.1)
        drop-shadow(0 0 5px rgba(255, 0, 0, 0.4))
        drop-shadow(0 0 10px rgba(0, 255, 0, 0.4))
        drop-shadow(0 0 15px rgba(0, 0, 255, 0.4));
    animation: stellar-rainbow-pulse 3s linear infinite;
}
/* å¦‚æœæ˜¯æ˜Ÿæ™¶çˆ†å‘ç¬é—´ */
.p-sprite.tera-burst.tera-type-stellar {
    animation: stellar-crystallize 1s ease-out forwards;
}
@keyframes stellar-rainbow-pulse {
    0% { filter: drop-shadow(0 0 8px #ff0000) brightness(1.2); }
    15% { filter: drop-shadow(0 0 8px #ffbd00) brightness(1.2); }
    30% { filter: drop-shadow(0 0 8px #00ff00) brightness(1.2); }
    45% { filter: drop-shadow(0 0 8px #00ffff) brightness(1.2); }
    60% { filter: drop-shadow(0 0 8px #0000ff) brightness(1.2); }
    75% { filter: drop-shadow(0 0 8px #d400ff) brightness(1.2); }
    100% { filter: drop-shadow(0 0 8px #ff0000) brightness(1.2); }
}
@keyframes stellar-crystallize {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.3); filter: brightness(5) hue-rotate(360deg) saturate(2); }
    100% { transform: scale(1); filter: brightness(1.2) drop-shadow(0 0 15px white); }
}
/* åå­—æ ‡ç­¾çš„ç‰¹æ®Šæ ·å¼ */
.tera-name-badge.stellar {
    background: linear-gradient(90deg, #ff0000, #ffff00, #00fbff, #d400ff);
    background-size: 200% 200%;
    animation: gradient-scroll 2s ease infinite;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    border: 1px solid white;
}
@keyframes gradient-scroll {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
/* 5. å¤ªæ™¶åŒ–åå­—æ ‡ç­¾æ ·å¼ */
.tera-name-badge {
    display: inline-block;
    padding: 2px 6px;
    margin-left: 4px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: bold;
    background: linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%);
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    box-shadow: 0 0 5px rgba(34, 211, 238, 0.5);
}
/* 6. å¤ªæ™¶åŒ–æˆ˜è´¥åŠ¨ç”»ï¼šæ°´æ™¶ç¢è£‚æ•ˆæœ */
.p-sprite.state-terastal.fainting {
    --sprite-faint-animation: tera-shatter 0.9s ease forwards;
}
@keyframes tera-shatter {
    0% {
        opacity: 1;
        transform: translateY(0) scale(var(--sprite-scale, 1));
        filter: 
            brightness(1.3) 
            saturate(1.2)
            drop-shadow(0 0 8px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    20% {
        opacity: 1;
        transform: translateY(-5px) scale(calc(var(--sprite-scale, 1) * 1.05));
        filter: 
            brightness(2) 
            saturate(0.5)
            drop-shadow(0 0 20px var(--tera-glow-color, #22d3ee))
            drop-shadow(0 0 40px var(--tera-glow-color, #22d3ee));
    }
    40% {
        opacity: 0.8;
        transform: translateY(0) scale(calc(var(--sprite-scale, 1) * 0.9));
        filter: 
            brightness(1.5) 
            saturate(1.5)
            hue-rotate(30deg)
            drop-shadow(0 0 15px var(--tera-glow-color, #22d3ee));
    }
    60% {
        opacity: 0.5;
        transform: translateY(10px) scale(calc(var(--sprite-scale, 1) * 0.6));
        filter: 
            brightness(1.2) 
            saturate(2)
            hue-rotate(-30deg)
            drop-shadow(0 0 10px var(--tera-glow-color, #22d3ee));
    }
    80% {
        opacity: 0.2;
        transform: translateY(25px) scale(calc(var(--sprite-scale, 1) * 0.35));
        filter: 
            brightness(0.8) 
            saturate(0.5)
            drop-shadow(0 0 5px var(--tera-glow-color, #22d3ee));
    }
    100% {
        opacity: 0;
        transform: translateY(45px) scale(calc(var(--sprite-scale, 1) * 0.15));
        filter: 
            brightness(0.3) 
            saturate(0)
            drop-shadow(0 0 0px transparent);
    }
}
/* =========================================================
   ã€å¿ƒçœ¼ç³»ç»Ÿã€‘å±æ€§å…‹åˆ¶æç¤ºæ ·å¼ (enable_insight)
   ========================================================= */
.insight-hint {
    display: inline-block;
    margin-left: 4px;
    font-weight: bold;
    font-size: 0.9em;
    vertical-align: middle;
}
.insight-super {
    color: #22c55e;
    text-shadow: 0 0 4px rgba(34, 197, 94, 0.6);
    animation: insight-pulse 1.2s ease-in-out infinite;
}
.insight-resist {
    color: #f97316;
    text-shadow: 0 0 4px rgba(249, 115, 22, 0.5);
}
.insight-immune {
    color: #ef4444;
    text-shadow: 0 0 4px rgba(239, 68, 68, 0.6);
    font-size: 1em;
}
@keyframes insight-pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.15); }
}
/* =========================================================
   ã€å¤æ­¦ç³»ç»Ÿ V4ã€‘å¤ªæå®šå¼ç  (The Taiji Orb)
   è§†è§‰é€»è¾‘ï¼šç±»ä¼¼ Mega æŒ‰é’®çš„åœ†å½¢æµ®é›•ï¼Œç‚¹å‡»åé˜´é˜³æµè½¬
   ========================================================= */
.taiji-orb {
    position: absolute;
    top: -40px;
    right: 100px;
    z-index: 50;
    appearance: none;
    border: none;
    cursor: pointer;
    background: transparent;
    padding: 0;
    width: 58px;
    height: 58px;
    border-radius: 50%;
    transform: skewX(-15deg);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.2s ease;
    box-shadow: 0 6px 12px rgba(0,0,0,0.25);
}
.taiji-orb.hidden {
    opacity: 0;
    pointer-events: none;
    transform: skewX(-15deg) scale(0);
}
.taiji-orb:hover {
    transform: skewX(-15deg) scale(1.08);
    filter: brightness(1.1);
}
.taiji-orb .spinner {
    position: absolute;
    inset: 4px;
    border-radius: 50%;
    overflow: hidden;
    background: conic-gradient(
        from 90deg,
        #0fb6f2 0% 50%,
        #ff5050 50% 100%
    );
    box-shadow: inset 0 0 12px rgba(0,0,0,0.4);
    transition: transform 0.6s cubic-bezier(0.18, 0.89, 0.32, 1.28), background 0.4s ease;
    transform: rotate(0deg);
}
.taiji-orb::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 3px solid rgba(255, 230, 200, 0.85);
    box-shadow:
        inset 0 0 8px rgba(255,255,255,0.4),
        0 2px 5px rgba(0,0,0,0.3);
    pointer-events: none;
}
.taiji-orb .center-content {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5;
}
.taiji-orb .label-kanji {
    font-weight: 900;
    font-size: 1.4rem;
    color: white;
    text-shadow:
        0 2px 6px rgba(0,0,0,0.7),
        0 0 8px rgba(0,0,0,0.5);
    transform: skewX(15deg);
    transition: transform 0.15s ease, opacity 0.15s ease;
}
.taiji-orb .aura-ring {
    position: absolute;
    inset: -4px;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
}
/* çŠ¶æ€ï¼šNormal */
.taiji-orb.normal .spinner {
    transform: rotate(0deg);
    filter: grayscale(0.4);
}
.taiji-orb.normal .label-kanji {
    opacity: 0.8;
}
/* çŠ¶æ€ï¼šAgile */
.taiji-orb.agile .spinner {
    transform: rotate(360deg);
    background: #0ea5e9;
    box-shadow: inset 0 0 20px rgba(255,255,255,0.5);
}
.taiji-orb.agile .label-kanji {
    transform: skewX(15deg) scale(1.1);
    text-shadow: 0 0 12px #38bdf8, 0 0 6px rgba(0,0,0,0.7);
}
.taiji-orb.agile .aura-ring {
    opacity: 0.6;
    box-shadow: 0 0 20px #22d3ee, 0 0 35px rgba(56,189,248,0.7);
    animation: pulse-blue 1.5s infinite;
}
/* çŠ¶æ€ï¼šStrong */
.taiji-orb.strong .spinner {
    transform: rotate(-200deg);
    background: #dc2626;
    box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
}
.taiji-orb.strong .label-kanji {
    transform: skewX(15deg) scale(1.15);
    text-shadow: 0 0 10px rgba(220,38,38,0.8), 0 0 4px rgba(0,0,0,0.8);
}
.taiji-orb.strong .aura-ring {
    opacity: 0.6;
    box-shadow: 0 0 22px #f87171, 0 0 35px rgba(248,113,113,0.8);
    animation: pulse-red 1.1s infinite alternate;
}
@keyframes pulse-blue {
    0% { transform: scale(1); opacity: 0.45; }
    50% { transform: scale(1.08); opacity: 0.75; }
    100% { transform: scale(1); opacity: 0.45; }
}
@keyframes pulse-red {
    0% { transform: scale(1); opacity: 0.5; }
    100% { transform: scale(1.05); opacity: 0.85; }
}
/* =========================================
   COMMANDER SYSTEM STYLES (æœºæ¢°å¿«é—¨é£æ ¼)
   Designer Note: 
   é‡‡ç”¨æ—‹è½¬åå­—å¸ƒå±€ + åœ†å½¢æŒ–å­” + æœºæ¢°è´¨æ„Ÿ
   ========================================= */
/* 1. Commander Layer (å®¹å™¨) */
#commander-overlay {
    position: absolute;
    inset: 0;
    z-index: 9000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.4);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
}
#commander-overlay:not(.hidden) {
    opacity: 1;
    pointer-events: auto;
    animation: overlay-fade-in 0.3s ease-out;
}
@keyframes overlay-fade-in {
    0% {
        opacity: 0;
        backdrop-filter: blur(0px);
    }
    100% {
        opacity: 1;
        backdrop-filter: blur(4px);
    }
}
/* 2. Center Core (æœºæ¢°å¿«é—¨æ ¸å¿ƒ) */
.cmd-hub {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    z-index: 20;
    pointer-events: none;
    border-radius: 50%;
    background: #1e1e1e;
    box-shadow: 
        0 0 0 3px #2d3436,
        0 0 0 5px #121417;
    display: flex;
    align-items: center;
    justify-content: center;
}
.pulse-ring {
    width: 10px;
    height: 10px;
    background: #333;
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 50%;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
    transition: background 0.3s;
}
#commander-overlay:hover .pulse-ring {
    background: #747d8c;
}
/* 3. The Radial System (æ—‹è½¬åå­—å¸ƒå±€) */
.commander-container {
    position: relative;
    width: 360px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 40px;
}
.commander-title {
    display: none;
}
.commander-wheel {
    position: relative;
    width: 360px;
    height: 360px;
    transform: rotate(-45deg);
}
/* é€šç”¨æŒ‰é’®å½¢æ€ */
.cmd-btn {
    position: absolute;
    width: calc(50% - 8px);
    height: calc(50% - 8px);
    background: #fff;
    border: none;
    padding: 0;
    margin: 0;
    cursor: pointer;
    overflow: visible;
    outline: none;
    transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), background-color 0.2s;
    -webkit-mask: radial-gradient(circle at var(--org-x) var(--org-y), transparent 45px, black 46px);
    mask: radial-gradient(circle at var(--org-x) var(--org-y), transparent 45px, black 46px);
    opacity: 0;
    animation: btn-slide-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) both;
}
@keyframes btn-slide-in {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}
/* æŒ‰é’®å†…å®¹å¸ƒå±€ */
.cmd-content {
    width: 100%;
    height: 100%;
    transform: rotate(45deg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    position: relative;
}
/* å››ä¸ªæ–¹ä½å®šä½ */
.pos-top {
    top: 0;
    right: 0;
    border-radius: 0 100px 0 0;
    --org-x: 0%;
    --org-y: 100%;
    transform-origin: -20% 120%;
    animation-delay: 0.1s;
}
.pos-right {
    bottom: 0;
    right: 0;
    border-radius: 0 0 100px 0;
    --org-x: 0%;
    --org-y: 0%;
    transform-origin: -20% -20%;
    animation-delay: 0.15s;
}
.pos-bottom {
    bottom: 0;
    left: 0;
    border-radius: 0 0 0 100px;
    --org-x: 100%;
    --org-y: 0%;
    transform-origin: 120% -20%;
    animation-delay: 0.2s;
}
.pos-left {
    top: 0;
    left: 0;
    border-radius: 100px 0 0 0;
    --org-x: 100%;
    --org-y: 100%;
    transform-origin: 120% 120%;
    animation-delay: 0.25s;
}
/* Typography */
.cmd-label {
    font-family: var(--font-main);
    font-size: 1.8rem;
    font-weight: 900;
    color: var(--active-c);
    margin: 0;
    padding: 0;
    line-height: 0.9;
    letter-spacing: -1px;
    font-style: italic;
    text-transform: uppercase;
    transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
    display: inline-block;
    transform-origin: center;
}
.cmd-sub {
    font-family: var(--font-main);
    font-size: 0.8rem;
    font-weight: 800;
    color: var(--active-c);
    opacity: 0.8;
    margin-top: 6px;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    transition: color 0.2s;
}
/* SVG å›¾æ ‡èƒŒæ™¯ */
.icon-bg {
    position: absolute;
    top: 65%;
    left: 65%;
    transform: translate(-50%, -50%) rotate(45deg);
    width: 200px;
    height: 200px;
    opacity: 0.15;
    pointer-events: none;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    z-index: 0;
}
/* SVG é»˜è®¤å¡«å……è‰² - ä½¿ç”¨ä¸»é¢˜è‰² */
.theme-insight .icon-bg,
.theme-insight .icon-bg path,
.theme-insight .icon-bg g { fill: #00d2d3; }
.theme-trust .icon-bg,
.theme-trust .icon-bg path,
.theme-trust .icon-bg g { fill: #ff9f43; }
.theme-passion .icon-bg,
.theme-passion .icon-bg path,
.theme-passion .icon-bg g { fill: #ff6b6b; }
.theme-devotion .icon-bg,
.theme-devotion .icon-bg path,
.theme-devotion .icon-bg g { fill: #a55eea; }
.cmd-emoji {
    display: none;
}
/* é¢œè‰²ä¸»é¢˜ */
.theme-insight  { --active-c: #00d2d3; }
.theme-trust    { --active-c: #ff9f43; }
.theme-passion  { --active-c: #ff6b6b; }
.theme-devotion { --active-c: #a55eea; }
/* Hover äº¤äº’ - ä»…èƒŒæ™¯è‰²å˜åŒ–ï¼Œç§»é™¤æ•´ä½“æŒ‰é’®ç¼©æ”¾ */
.cmd-btn:hover {
    z-index: 50;
    background: var(--active-c);
    box-shadow: 0 0 0 6px rgba(255,255,255,0.1);
}
/* é€†è½¬è£åˆ¤å¼æ–‡å­—å–Šå‡ºæ•ˆæœ - åªé’ˆå¯¹æ–‡å­— */
@keyframes text-shout {
    0% {
        transform: scale(1) rotate(0deg);
        text-shadow: 0 0 0 transparent;
    }
    20% {
        transform: scale(1.5) rotate(-3deg);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
    }
    40% {
        transform: scale(1.2) rotate(2deg);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
    }
    60% {
        transform: scale(1.35) rotate(-1deg);
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
    }
    80% {
        transform: scale(1.25) rotate(0deg);
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }
    100% {
        transform: scale(1.3);
        text-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
    }
}
.cmd-btn:hover .cmd-label {
    color: #121417;
    /* æ›´åŠ å‰§çƒˆçš„æ–‡å­—å¼¹è·³åŠ¨ç”» */
    animation: text-shout 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}
.cmd-btn:hover .cmd-sub {
    color: #121417;
    opacity: 0.9;
}
.cmd-btn:hover .icon-bg,
.cmd-btn:hover .icon-bg path,
.cmd-btn:hover .icon-bg g {
    fill: #000 !important;
}
.cmd-btn:hover .icon-bg {
    opacity: 0.2;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(30deg) scale(1.1);
}
.cmd-btn:active {
    transform: scale(0.98);
    background: #f1f2f6;
    transition: 0.05s;
}
/* ç¦ç”¨çŠ¶æ€ */
.cmd-btn:disabled {
    opacity: 0.4;
    pointer-events: none;
    filter: grayscale(1);
}
/* åº•éƒ¨å–æ¶ˆæŒ‰é’® */
.cmd-cancel-hint {
    position: relative;
    background: #2d3436;
    border: 2px solid #57606f;
    border-radius: 99px;
    padding: 12px 40px;
    color: #fff;
    font-family: 'M PLUS Rounded 1c', sans-serif;
    font-weight: 900;
    font-size: 1rem;
    letter-spacing: 2px;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    transition: 0.2s;
    animation: cancel-fade-in 0.4s ease-out 0.3s both;
}
@keyframes cancel-fade-in {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}
.cmd-cancel-hint:hover {
    background: #fff;
    border-color: #fff;
    color: #2d3436;
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(255,255,255,0.3);
}
.cmd-cancel-hint .key {
    display: inline-block;
    padding: 3px 10px;
    background: #333;
    border: 1px solid #666;
    border-radius: 4px;
    margin-right: 8px;
    font-family: 'M PLUS Rounded 1c', sans-serif;
    font-weight: 900;
    font-size: 0.85rem;
    transition: 0.2s;
}
.cmd-cancel-hint:hover .key {
    background: #e0e0e0;
    border-color: #ccc;
    color: #2d3436;
}
]]></file>
    <file name="index.html"><![CDATA[<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PKM Battle System - Switch Style</title>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:ital,wght@0,700;0,800;0,900;1,900&family=Rubik:ital,wght@0,400;0,500;0,700;0,900;1,700&family=M+PLUS+Rounded+1c:wght@500;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./index.css">
    <!-- Pokemon Showdown å®Œæ•´æ•°æ®åº“ -->
    <script src="./data/pokedex-data.js"></script>
    <script src="./data/moves-data.js"></script>
    <!-- æ‹›å¼ç¡¬ç¼–ç å¸¸é‡ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./data/move-constants.js"></script>
    <!-- é“å…·æ•°æ®åº“ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/items-data.js"></script>
    <!-- æˆ˜æ–—æœºåˆ¶æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./mechanics/move-styles.js"></script>
    <script src="./mechanics/z-moves.js"></script>
    <script src="./mechanics/mechanic-checker.js"></script>
    <script src="./mechanics/dynamax.js"></script>
    <script src="./mechanics/mega-evolution.js"></script>
    <!-- UI æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./ui/ui-renderer.js"></script>
    <script src="./ui/ui-sprites.js"></script>
    <script src="./ui/sprite-duplicate-fix.js"></script>
    <script src="./ui/ui-trainer-hud.js"></script>
    <script src="./ui/ui-menus.js"></script>
    <!-- ç³»ç»Ÿæ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./systems/translations.js"></script>
    <script src="./systems/data-loader.js"></script>
    <script src="./systems/catch-system.js"></script>
    <script src="./systems/bgm-system.js"></script>
    <script src="./systems/audio-manager.js"></script>
    <script src="./systems/preloader.js"></script>
    <!-- æˆ˜æ–—æ¨¡å— (å¿…é¡»åœ¨ index.js ä¹‹å‰åŠ è½½) -->
    <script src="./battle/battle-calc.js"></script>
    <script src="./battle/battle-effects.js"></script>
    <script src="./battle/battle-damage.js"></script>
    <script src="./battle/battle-switch.js"></script>
    <script src="./battle/battle-turns.js"></script>
    <!-- æ‹›å¼å¤„ç†å™¨ - ç­–ç•¥æ¨¡å¼ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/move-handlers.js"></script>
    <!-- ç‰¹æ€§å¤„ç†å™¨ (å¿…é¡»åœ¨ battle-engine.js ä¹‹å‰åŠ è½½) -->
    <script src="./engine/ability-handlers.js"></script>
    <!-- æˆ˜æ–—å¼•æ“ -->
    <script src="./engine/battle-engine.js"></script>
    <!-- AI å¼•æ“ -->
    <script src="./engine/ai-engine.js"></script>
    <!-- å½¢æ€å˜åŒ–ç³»ç»Ÿ -->
    <script src="./form-change-system.js"></script>
    <!-- Mega å½¢æ€é€‰æ‹©å¯¹è¯æ¡† -->
    <script src="./mega-selection-dialog.js"></script>
    <!-- æŠ€èƒ½æ•ˆæœæ‰©å±•æ¨¡å— -->
    <script src="./engine/move-effects.js"></script>
    <!-- è®­ç»ƒå®¶ AVs é…ç½® (æ´›è¿ªäºšç‰¹åŒºä¸“å±ç³»ç»Ÿ) -->
    <script src="./data/trainer-avs.js"></script>
</head>
<body>
    <div class="ui-root" id="ui-root">
        <div class="ui-scale" id="ui-scale">
            <div class="screen-filters"></div>
            <div class="bg-gradient"></div>
            <div id="start-view" class="overlay-screen">
                <div class="start-card">
                    <h1 class="logo-title">BATTLE <span class="accent">LINK</span></h1>
                    <div class="loader-notch"></div>
                    <p class="sys-msg">PRESS START TO INITIALIZE</p>
                    <button class="start-btn" onclick="initGame()" id="btn-start" disabled>è¿æ¥ä¸­...</button>
                </div>
            </div>
            <div id="game-view" class="game-container hidden">
                <div class="battle-stage">
                    <div class="trainer-hud hidden" id="trainer-hud">
                        <div class="trainer-panel">
                            <div class="trainer-panel-content">
                                <div class="trainer-name" id="trainer-name">TRAINER</div>
                            </div>
                        </div>
                        <div class="trainer-avatar-wrap">
                            <img id="trainer-avatar" alt="trainer" />
                        </div>
                    </div>
                    <div class="hud container-enemy">
                        <div class="party-track enemy-side" id="ui-enemy-dots"></div>
                        <div class="sharp-panel panel-enemy-bg">
                            <div class="panel-content unskew">
                                <div class="sw-top-row">
                                    <span class="p-name" id="enemy-name">Pokemon</span>
                                    <span class="p-lv">Lv.<span id="enemy-lvl">50</span></span>
                                </div>
                                <div class="hp-track-wrappersw">
                                    <div class="hp-border-frame">
                                        <div class="hp-fill-colors" id="enemy-hp-fill" style="width: 100%;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="deco-strip enemy"></div>
                        </div>
                    </div>
                    <div class="sprite-wrapper enemy-pos">
                        <img id="enemy-sprite" class="p-sprite" src="" alt="">
                        <div class="shadow-base"></div>
                    </div>
                    <div class="sprite-wrapper player-pos">
                        <img id="player-sprite" class="p-sprite player-scale" src="" alt="">
                        <div class="shadow-base"></div>
                    </div>
                    <div class="hud container-player">
                        <div class="sharp-panel panel-player-bg">
                            <div class="panel-content unskew">
                                <div class="sw-top-row">
                                    <span class="p-name" id="player-name">Pokemon</span>
                                    <div class="sw-row-right-group">
                                        <span class="hp-v-nums" id="player-hp-txt">--/--</span>
                                        <span class="p-lv">Lv.<span id="player-lvl">80</span></span>
                                    </div>
                                </div>
                                <div class="hp-track-wrappersw">
                                    <div class="hp-border-frame bg-player">
                                        <div class="hp-fill-colors" id="player-hp-fill" style="width: 100%;"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="deco-strip player"></div>
                        </div>
                        <div class="party-track player-side" id="ui-player-dots"></div>
                    </div>
                </div>
                <!-- ============================================== -->
                <!-- COMMANDER SHOUT UI (è®­ç»ƒå®¶æˆ˜æœ¯æŒ‡æŒ¥å±‚) -->
                <!-- ============================================== -->
                <div id="commander-overlay" class="cmd-layer hidden">
                    <div class="commander-container">
                        <div class="commander-wheel">
                            <!-- ä¸Šæ–¹æŒ‰é’®: DODGE (Insight) -->
                            <button class="cmd-btn pos-top theme-insight" onclick="triggerCommand('dodge')">
                                <!-- Wing / Evasion SVG -->
                                <svg class="icon-bg" viewBox="0 0 244 273.75">
                                    <path d="M232 39c0 77-129 3-170 114 16-129 163-72 170-114z"/>
                                    <path d="M244 0c1 80-133 4-176 117-10 34-31 108-68 101 66-19 11-196 161-200-25 5-43 16-56 29 51-38 134-15 139-47z"/>
                                    <path d="M211 81c-10 80-115 0-151 95 18-110 137-53 151-95z"/>
                                </svg>
                                <div class="cmd-content">
                                    <span class="cmd-label">DODGE!</span>
                                    <span class="cmd-sub">å›é¿è¡ŒåŠ¨</span>
                                </div>
                            </button>
                            <!-- å³ä¾§æŒ‰é’®: FOCUS (Passion) -->
                            <button class="cmd-btn pos-right theme-passion" onclick="triggerCommand('crit')">
                                <!-- Crosshair / Scope SVG -->
                                <svg class="icon-bg" viewBox="0 0 48 60">
                                    <path d="M39 13l-1.6 1.6c2.3 3.1 3.6 6.9 3.6 11 0 10.3-8.3 18.6-18.6 18.6S3.7 35.9 3.7 25.6C3.7 15.4 12.1 7 22.3 7c4.1 0 8 1.4 11.1 3.7l1.6-1.6.1-1.7c-3.6-2.5-8-4-12.8-4C10 3.3 0 13.3 0 25.6S10 48 22.3 48c12.3 0 22.3-10 22.3-22.3 0-4.7-1.5-9.1-4-12.7L39 13z"/>
                                    <path d="M30.4 13.7c-2.3-1.6-5.1-2.5-8.1-2.5-8 0-14.4 6.5-14.4 14.4 0 8 6.5 14.4 14.4 14.4 8 0 14.4-6.5 14.4-14.4 0-2.9-.9-5.7-2.4-8l-2.7 2.7c.9 1.6 1.4 3.3 1.4 5.3 0 5.9-4.8 10.7-10.7 10.7-5.9 0-10.7-4.8-10.7-10.7 0-5.9 4.8-10.7 10.7-10.7 2 0 3.8.5 5.4 1.5l2.7-2.7z"/>
                                    <path d="M23.8 20.3c-.5-.1-1-.2-1.5-.2-3.1 0-5.6 2.5-5.6 5.6 0 3.1 2.5 5.6 5.6 5.6 3.1 0 5.6-2.5 5.6-5.6 0-.5-.1-.9-.2-1.4l-3.3 3.3c-.5.5-1.2.8-2 .8-.8 0-1.5-.3-2-.8-1.1-1.1-1.1-2.9 0-3.9l3.4-3.4z"/>
                                    <path d="M47 5.7l-3.5.2 1.4-1.4c.4-.4.4-1 0-1.3-.4-.4-1-.4-1.3 0l-1.4 1.4L42.4 1c0-.5-.4-1-1-.9-.5 0-1 .4-1 .9l-.3 5.6-1.4 1.4-.3-2.5c0-.5-.4-1-.9-1-.5 0-1 .4-1 .9l-.3 5.6L21.8 25c-.4.4-.4 1 0 1.3.2.2.7.5 1.3 0l15.1-15.1 5.6-.3c.5 0 .9-.5.9-1 0-.5-.5-.9-1-.9l-3.5.2 1.4-1.4 5.6-.3c.5 0 .9-.5.9-1 .1-.6-.4-1-1-.9z"/>
                                </svg>
                                <div class="cmd-content">
                                    <span class="cmd-label">FOCUS!</span>
                                    <span class="cmd-sub">å¿…æ€ä¸€å‡»</span>
                                </div>
                            </button>
                            <!-- ä¸‹æ–¹æŒ‰é’®: ENDURE (Devotion) -->
                            <button class="cmd-btn pos-bottom theme-devotion" onclick="triggerCommand('endure')">
                                <!-- Shield SVG -->
                                <svg class="icon-bg" viewBox="0 0 100 125">
                                    <g transform="translate(0,-952.36218)">
                                        <path d="m51.1339 955.36611a2.9995345 3.0001855 0 0 1 1.43713.4375c4.4064 2.6807 9.61209 6.1381 14.83996 8.3747 5.22788 2.2365 10.22474 3.1499 14.4963 1.4686a2.9995345 3.0001855 0 0 1 12.09271 2.7812c0 31.60899-7.04861 50.60179-16.68324 62.30999-9.63463 11.7083-21.67399 15.8706-30.42974 18.4993a2.9995345 3.0001855 0 0 1-2.87426-.6562c-7.30294-6.5034-14.4164-11.4997-18.4328-22.2491-4.01639-10.7495-4.88977-26.60879-1.40589-55.37279a2.9995345 3.0001855 0 0 1 3.74904-2.5312c4.32204 1.1795 9.44291-.3576 14.68376-3.1562 5.24084-2.7983 10.3515-6.7103 14.80872-9.4683a2.9995345 3.0001855 0 0 1 1.71831-.4375zm-.0625 6.5622c-3.82197 2.4944-8.4668 5.8556-13.65276 8.6247-4.80862 2.5676-10.15153 4.4718-15.58977 4.0936-2.96179 26.25779-1.91794 40.77949 1.37465 49.59179 3.20751 8.5845 8.64616 12.702 15.52728 18.718 8.24206-2.5511 17.93077-6.2707 25.96213-16.0306 8.15816-9.9141 14.6568-26.4095 15.21486-54.68539-5.07588.7184-10.17975-.5375-14.83996-2.5311-5.26895-2.2541-10.01929-5.3101-13.99643-7.781zm-1.43713 12.9682 5.62357 15.4995 15.74598 3.8124-12.71551 10.24949 1.31217 16.4368-13.49656-9.1247-14.93369 6.3124 4.37389-15.8743-10.52857-12.56209 16.18337-.6562 8.43535-14.0933z"/>
                                    </g>
                                </svg>
                                <div class="cmd-content">
                                    <span class="cmd-label">ENDURE!</span>
                                    <span class="cmd-sub">ç»å¢ƒåšå®ˆ</span>
                                </div>
                            </button>
                            <!-- å·¦ä¾§æŒ‰é’®: LISTEN (Trust) -->
                            <button class="cmd-btn pos-left theme-trust" onclick="triggerCommand('cure')">
                                <!-- Linked Rings SVG -->
                                <svg class="icon-bg" viewBox="0 0 100 125">
                                    <path d="M87.395 12.618c9.161 9.177 9.183 24.065-.012 33.252L70.758 62.493c-1.427 1.427-3.004 2.609-4.666 3.593-5.491 3.258-12.014 4.088-18.035 2.482-3.864-1.028-7.523-3.036-10.549-6.067-2.061-2.056-3.604-4.415-4.742-6.913l7.276-7.274c.681-.675 1.518-1.168 2.426-1.565.184 2.709 1.276 5.361 3.354 7.434 3.083 3.083 7.427 4.046 11.344 2.99 1.933-.516 3.766-1.484 5.277-2.997l6.129-6.122 10.493-10.499c4.587-4.594 4.591-12.013.004-16.62-4.598-4.58-12.038-4.595-16.626 0l-7.717 7.719c-.622-.213-1.232-.457-1.868-.629-4.692-1.253-9.637-1.167-14.262.122l15.531-15.528c9.192-9.199 24.075-9.187 33.275.99zM61.339 71.878c-5.271 1.459-10.889 1.277-16.078-.511l-7.699 7.703c-4.596 4.578-12.035 4.578-16.629-.006-4.587-4.601-4.58-12.024-.005-16.627l16.634-16.626c1.516-1.506 3.34-2.469 5.266-2.984 3.919-1.05 8.261-.087 11.355 2.991 2.079 2.093 3.171 4.761 3.348 7.485.87-.395 1.695-.924 2.41-1.637l7.283-7.278c-1.13-2.493-2.671-4.843-4.718-6.895-3.037-3.026-6.692-5.036-10.552-6.065-6.029-1.607-12.546-.775-18.044 2.48-1.659.979-3.235 2.159-4.666 3.585l-16.63 16.628c-9.182 9.189-9.188 24.08-.004 33.262 9.187 9.185 24.07 9.185 33.263 0l16.215-16.212z"/>
                                </svg>
                                <div class="cmd-content">
                                    <span class="cmd-label">LISTEN!</span>
                                    <span class="cmd-sub">æ¸…é†’æ„å¿—</span>
                                </div>
                            </button>
                            <!-- ä¸­å¿ƒè£…é¥°æ ¸å¿ƒ -->
                            <div class="cmd-hub">
                                <div class="pulse-ring"></div>
                            </div>
                        </div>
                        <!-- åº•éƒ¨å–æ¶ˆæŒ‰é’® -->
                        <div class="cmd-cancel-hint" onclick="closeCommanderMenu()">
                            <span class="key">X</span> æ”¾å¼ƒæŒ‡ä»¤
                        </div>
                    </div>
                </div>
                <div class="command-dashboard">
                    <div class="msg-box-modern">
                        <div class="msg-header">
                            <span class="sys-label">BATTLE LOG</span>
                            <div class="sys-dots">
                                <span></span><span></span><span></span>
                            </div>
                        </div>
                        <div class="msg-content-area" id="log-box"></div>
                        <div class="next-cursor"></div>
                    </div>
                    <!-- ä¸»èœå• (P5 x å‰‘ç›¾ æ··åˆé£æ ¼) -->
                    <div class="main-menu" id="main-menu">
                        <div class="radical-menu-container">
                            <button class="radical-btn btn-fight" id="btn-fight" onclick="showMovesMenu()">
                                <div class="skew-fix">
                                    <div class="r-icon-bg"></div>
                                    <svg class="r-icon" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                                        <path d="M168,16H120A56,56,0,0,0,64,72v31.73A8.17,8.17,0,0,1,56.53,112,8,8,0,0,1,48,104V78.7a4,4,0,0,0-5.63-3.65A32,32,0,0,0,24,104v29.19a16.14,16.14,0,0,0,3.5,10q.3.36.63.69L64,179.34V216a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V177.12l15.38-53.84a16,16,0,0,0,.62-4.4V72A56,56,0,0,0,168,16Zm3.58,168.84a8,8,0,0,1-7.16,14.32L136,184.94l-28.42,14.22a8,8,0,1,1-7.16-14.32L118.11,176l-17.69-8.84a8,8,0,1,1,7.16-14.32L136,167.06l28.42-14.22a8,8,0,1,1,7.16,14.32L153.89,176Z"/>
                                    </svg>
                                    <div class="r-label">
                                        <span class="en">FIGHT</span>
                                        <span class="jp">æˆ¦é—˜</span>
                                    </div>
                                </div>
                            </button>
                            <div class="radical-sub-group" id="menu-right-col">
                                <button class="radical-btn btn-catch hidden" id="btn-catch" onclick="openBallMenu()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="0 0 100 125">
                                            <g><path d="M50,70.2c-9.2,0-16.9-6.4-19-14.9H6.6c2.3,21.9,20.8,39,43.4,39s41.1-17.1,43.4-39H68.9C66.9,63.8,59.2,70.2,50,70.2z"/></g><circle cx="50" cy="50.7" r="12"/><path d="M30.9,46C33,37.4,40.7,31,50,31S67,37.4,69,46h24.5c-0.4-4.1-1.4-8-2.9-11.6c0.5-0.7,0.9-1.5,1.1-2.4c0.5-1.9,0.1-4-0.9-5.8  c-3.6-6-9.8-12.2-13.8-15c-1.2-0.9-2.6-1.4-4.1-1.4h0c-1.5,0-2.8,0.5-3.9,1.4C63.3,8.4,56.8,6.8,50,6.8c-6.8,0-13.3,1.6-19.1,4.4  c-1.1-0.9-2.5-1.4-3.9-1.4c-1.5,0-2.9,0.5-4.1,1.4c-4,2.9-10.2,9.1-13.8,15C8,28,7.6,30.1,8.1,32c0.2,0.9,0.6,1.7,1.1,2.4  C7.8,38.1,6.8,42,6.4,46H30.9z M68,24.7C68,24.7,68,24.7,68,24.7l4-9c0.2-0.4,0.6-0.6,1-0.6c0.3,0,0.7,0.1,1,0.4  c3.7,2.6,9.4,8.5,12.5,13.5c0.6,1.1,0.5,2.3-0.4,2.8l-6.5,3.8c-0.3,0.2-0.6,0.2-0.9,0.2c-0.5,0-1.1-0.2-1.4-0.7  c-2.4-3.2-5.3-6-8.5-8.4C68,26.2,67.7,25.4,68,24.7z M13.5,29c3.1-5.1,8.7-10.9,12.5-13.5c0.3-0.2,0.7-0.4,1-0.4  c0.4,0,0.8,0.2,1,0.6l4,9c0,0,0,0,0,0c0.3,0.7,0,1.6-0.6,2c-3.2,2.4-6.1,5.2-8.5,8.4c-0.3,0.5-0.9,0.7-1.4,0.7  c-0.3,0-0.6-0.1-0.9-0.2L14,31.8C13.1,31.2,12.9,30,13.5,29z"/>
                                        </svg>
                                        <span class="r-label-min">CATCH</span>
                                    </div>
                                </button>
                                <button class="radical-btn btn-pokemon" id="btn-pokemon" onclick="renderSwitchMenu()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="22 28 56 48" fill="currentColor" aria-hidden="true">
                                            <path fill-rule="evenodd" d="m50.004 29.184c10.695 0 19.656 8.0234 20.699 18.609h-13.609c-0.92969-3.0234-3.7188-5.2383-7.0938-5.2383-3.3711 0-6.1602 2.2148-7.0938 5.2383h-13.605c1.1641-10.586 10.113-18.609 20.703-18.609zm0 16.512c2.4453 0 4.4219 1.8594 4.4219 4.3047s-1.9766 4.4219-4.4219 4.4219c-2.4414 0-4.3047-1.9766-4.3047-4.4219 0-2.4414 1.8594-4.3047 4.3047-4.3047zm20.695 6.5195c-1.0391 10.582-10 18.602-20.695 18.602-10.586 0-19.535-8.0234-20.703-18.605l13.609 0.003906c0.92969 3.0195 3.7188 5.2305 7.0938 5.2305s6.1602-2.2148 7.0938-5.2305z"/>
                                        </svg>
                                        <span class="r-label-min">POKÃ‰MON</span>
                                    </div>
                                </button>
                                <button class="radical-btn btn-run" id="btn-run" onclick="tryRun()">
                                    <div class="skew-fix">
                                        <svg class="r-icon small" viewBox="0 0 100 100" fill="currentColor" aria-hidden="true">
                                            <path d="M71.738,94.995c-0.03-0.001-0.06-0.001-0.091-0.003C71.677,94.993,71.707,94.994,71.738,94.995z"/>
                                            <path d="M27.068,30.372c-0.239,0.239-0.487,0.492-0.733,0.739c0.591-0.563,1.195-1.09,1.811-1.586   C27.785,29.797,27.425,30.075,27.068,30.372z"/>
                                            <path d="M71.04,22.853c0.205-0.186,0.396-0.385,0.586-0.585c-1.787,1.653-4.176,2.653-6.788,2.653   C67.283,24.92,69.351,24.17,71.04,22.853z"/>
                                            <path d="M72.329,43.413c-0.086,0.007-0.172,0.011-0.257,0.017C72.158,43.424,72.244,43.42,72.329,43.413z"/>
                                            <path d="M68.214,43.376c-0.211-0.02-0.422-0.037-0.634-0.062C67.791,43.339,68.002,43.357,68.214,43.376z"/>
                                            <path d="M75.362,32.625c-0.024,0.024-0.046,0.038-0.07,0.056c0.338-0.13,0.672-0.28,1.004-0.44   C75.986,32.385,75.674,32.514,75.362,32.625z"/>
                                            <path d="M73.767,43.251c-0.031,0.005-0.063,0.01-0.094,0.014C73.704,43.261,73.736,43.256,73.767,43.251z"/>
                                            <path d="M61.835,30.935c-0.189-0.188-0.566-0.375-0.755-0.375c0.229,0.135,0.455,0.249,0.683,0.375H61.835z"/>
                                            <path d="M83.421,39.525c-0.074,0.049-0.15,0.094-0.224,0.142C83.272,39.619,83.347,39.573,83.421,39.525z"/>
                                            <path d="M22.886,34.977c0.206-0.269,0.415-0.531,0.625-0.791C23.299,34.445,23.092,34.709,22.886,34.977z"/>
                                            <path d="M72.258,94.986c-0.013,0.001-0.026,0.001-0.04,0.002C72.231,94.988,72.244,94.987,72.258,94.986z"/>
                                            <path d="M75.362,93.888c0.108-0.108,0.202-0.228,0.299-0.345c-0.69,0.629-1.552,1.08-2.472,1.301   C73.965,94.666,74.711,94.34,75.362,93.888z"/>
                                            <path d="M57.136,62.318c-0.357-0.238-0.737-0.476-1.125-0.714c0.374,0.232,0.749,0.472,1.124,0.715L57.136,62.318z"/>
                                            <path d="M64.886,42.847c-0.578-0.132-1.156-0.275-1.736-0.448C63.73,42.571,64.309,42.717,64.886,42.847z"/>
                                            <path d="M66.597,43.174c-0.292-0.047-0.585-0.099-0.878-0.157C66.012,43.074,66.305,43.128,66.597,43.174z"/>
                                            <path d="M71.264,94.957c-0.061-0.008-0.123-0.013-0.184-0.023C71.141,94.943,71.203,94.949,71.264,94.957z"/>
                                            <path d="M72.81,94.923c-0.018,0.003-0.035,0.005-0.053,0.008C72.775,94.928,72.793,94.926,72.81,94.923z"/>
                                            <path d="M57.51,28.492c-6.577-3.946-13.152-5.073-19.166-3.946c0,0.028-0.012,0.046-0.019,0.067   C44.361,23.365,50.934,24.602,57.51,28.492z"/>
                                            <path d="M83.802,25.422c-0.12,0.078-0.24,0.159-0.356,0.249c-0.188,0.189-0.376,0.379-0.563,0.755   C83.163,26.033,83.474,25.704,83.802,25.422z"/>
                                            <path d="M67.471,92.197c0.797,1.594,2.056,2.43,3.417,2.698C69.545,94.619,68.287,93.777,67.471,92.197z"/>
                                            <path d="M58.457,7.356c-0.129,0.091-0.26,0.18-0.383,0.275c-0.288,0.288-0.557,0.6-0.815,0.921   C57.625,8.122,58.025,7.721,58.457,7.356z"/>
                                            <path d="M85.887,37.701c0.096-0.086,0.185-0.179,0.28-0.266c-0.174,0.15-0.345,0.31-0.521,0.455   C85.726,37.824,85.807,37.766,85.887,37.701z"/>
                                            <path d="M85.126,38.296c-0.26,0.204-0.524,0.399-0.788,0.591C84.603,38.697,84.865,38.498,85.126,38.296z"/>
                                            <path d="M76.43,32.178c0.233-0.115,0.465-0.231,0.694-0.361C76.894,31.944,76.662,32.068,76.43,32.178z"/>
                                            <path d="M83.802,25.422c-0.328,0.282-0.639,0.611-0.919,1.004c-1.759,2.44-3.692,4.217-5.758,5.391   c-0.229,0.13-0.462,0.246-0.694,0.361c-0.044,0.022-0.089,0.042-0.133,0.064c-0.332,0.16-0.666,0.31-1.004,0.44   c-4.132,1.583-8.728,0.912-13.529-1.746c-0.228-0.126-0.454-0.24-0.683-0.375c-0.563-0.376-3.007-1.881-3.57-2.069   c-6.576-3.889-13.15-5.126-19.185-3.879c-3.627,0.749-7.059,2.398-10.179,4.912c-0.616,0.496-1.22,1.023-1.811,1.586   c-0.979,0.933-1.921,1.96-2.824,3.076c-0.21,0.26-0.42,0.521-0.625,0.791c-0.302,0.396-0.601,0.801-0.893,1.218   c-3.757,5.263,5.075,10.337,8.647,5.077c4.695-6.578,10.523-8.458,16.914-6.391c-3.195,5.826-6.202,11.462-10.15,19.357   c-4.136,8.08-12.966,14.469-21.614,9.582c-6.198-3.757-11.649,5.263-5.635,8.834c11.837,6.764,25.557,2.631,32.509-6.202   c0.188,0,0.563,0.186,0.751,0.186c5.826,2.069,13.344,7.329,15.6,9.212c2.253,1.877,6.199,11.462,8.456,16.346   c0.815,1.58,2.074,2.422,3.417,2.698c0.064,0.013,0.127,0.028,0.191,0.039c0.061,0.01,0.123,0.015,0.184,0.023   c0.127,0.016,0.255,0.028,0.383,0.035c0.03,0.002,0.06,0.002,0.091,0.003c0.16,0.005,0.32,0.003,0.48-0.006   c0.013-0.001,0.026-0.001,0.04-0.002c0.167-0.011,0.334-0.029,0.5-0.056c0.018-0.003,0.036-0.005,0.053-0.008   c0.128-0.022,0.254-0.049,0.379-0.079c0.92-0.221,1.782-0.672,2.472-1.301c1.423-1.296,2.11-3.339,1.019-5.668   c-2.633-5.449-7.142-16.349-10.524-19.167c-2.064-1.515-5.539-4.134-9.022-6.388c-0.375-0.243-0.75-0.483-1.124-0.715   c-0.896-0.557-1.782-1.079-2.635-1.541c3.195-6.014,6.391-11.838,9.773-17.664c0.58,0.173,1.159,0.316,1.736,0.448   c0.278,0.064,0.555,0.116,0.833,0.17c0.293,0.057,0.586,0.11,0.878,0.157c0.328,0.053,0.656,0.101,0.983,0.14   c0.212,0.026,0.423,0.042,0.634,0.062c1.3,0.123,2.587,0.14,3.858,0.054c0.086-0.006,0.172-0.01,0.257-0.017   c0.45-0.036,0.898-0.085,1.344-0.147c0.031-0.004,0.063-0.01,0.094-0.014c3.309-0.475,6.481-1.674,9.43-3.585   c0.074-0.048,0.15-0.093,0.224-0.142c0.308-0.204,0.613-0.418,0.917-0.638c0.265-0.192,0.528-0.387,0.788-0.591   c0.173-0.136,0.348-0.266,0.52-0.407c0.176-0.145,0.347-0.305,0.521-0.455c1.915-1.652,3.716-3.619,5.359-5.936   C95.002,26.631,87.866,21.929,83.802,25.422z"/>
                                            <path d="M64.838,24.92c2.612,0,5.001-0.999,6.788-2.653c1.943-1.798,3.174-4.37,3.174-7.307c0-5.448-4.511-9.958-9.962-9.958   c-2.417,0-4.645,0.891-6.381,2.354c-0.432,0.365-0.833,0.765-1.199,1.197c-1.476,1.74-2.376,3.979-2.376,6.408   C54.882,20.6,59.39,24.92,64.838,24.92z"/>
                                        </svg>
                                        <span class="r-label-min">ESCAPE</span>
                                    </div>
                                </button>
                            </div>
                        </div>
                    </div>
                    <!-- æŠ€èƒ½èœå• (ç‚¹å‡»æˆ˜æ–—åæ˜¾ç¤º) -->
                    <div class="moves-menu hidden" id="moves-menu">
                        <!-- å¤æ­¦æµæ´¾åˆ‡æ¢ï¼šé˜´é˜³å®šå¼çƒ (Taiji Orb) -->
                        <button class="taiji-orb normal hidden" id="btn-style-taiji" onclick="cycleMoveStyle()" title="å¤æ­¦æ¶åŠ¿ï¼šç‚¹å‡»åˆ‡æ¢ åˆš/è¿…">
                            <div class="spinner">
                                <span class="yang"></span>
                                <span class="yin"></span>
                            </div>
                            <div class="center-content">
                                <span class="label-kanji" id="taiji-text">é“</span>
                            </div>
                            <div class="aura-ring"></div>
                        </button>
                        <button class="action-btn" id="btn-m0" onclick="handleAttack(0)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m1" onclick="handleAttack(1)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m2" onclick="handleAttack(2)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="action-btn" id="btn-m3" onclick="handleAttack(3)">
                            <span class="move-name">---</span>
                            <span class="move-type">---</span>
                        </button>
                        <button class="back-btn-pill" id="btn-back" onclick="showMainMenu()" title="Back">
                            <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                <path d="M19 11H7.83l4.88-4.88a1 1 0 0 0-1.42-1.42l-6.59 6.59a1 1 0 0 0 0 1.41l6.59 6.59a1 1 0 0 0 1.42-1.41L7.83 13H19a1 1 0 0 0 0-2z"/>
                            </svg>
                        </button>
                        <!-- Mega Evolution Button -->
                        <button class="mega-btn-pill hidden" id="btn-mega" onclick="toggleMega()" title="Mega Evolution">
                            <svg viewBox="0 0 100 100" class="mega-icon">
                                <circle cx="50" cy="50" r="42" stroke="currentColor" stroke-width="6" fill="none" opacity="0.4"/>
                                <text x="50" y="68" font-size="50" text-anchor="middle" fill="currentColor" font-weight="900" style="font-family: inherit;">M</text>
                            </svg>
                        </button>
                        <!-- âœ¨ ä¸´åœºè¿›åŒ–æŒ‰é’® âœ¨ -->
                        <button class="mega-btn-pill evo-style hidden" id="btn-evolved" onclick="triggerBattleEvolution()" title="Evolution">
                            <div class="evo-particles"></div>
                            <span class="evo-text">EVO</span>
                        </button>
                    </div>
                </div>
                <!-- ç»“ç®—ç”»é¢ Overlay -->
                <div id="result-overlay" class="result-screen hidden">
                    <div class="res-modern-card" id="res-card-bg">
                        <div class="res-header-banner">
                            <div class="res-header-content">
                                <span class="res-flag">BATTLE RESULT</span>
                                <h1 class="res-big-title" id="res-title">VICTORY</h1>
                            </div>
                            <div class="res-header-pattern"></div>
                        </div>
                        <div class="res-rank-stamp-wrap">
                            <div class="res-rank-ring">
                                <span id="res-grade-letter">S</span>
                                <span id="res-grade-sub">RANK</span>
                            </div>
                        </div>
                        <div class="res-body">
                            <div class="res-info-grid">
                                <div class="res-info-tile full-width">
                                    <span class="tile-label">STATUS</span>
                                    <span class="tile-val major" id="col-status">Victory against Cynthia</span>
                                </div>
                                <div class="res-info-tile full-width description-tile">
                                    <span class="tile-icon">ğŸ’¬</span>
                                    <span class="tile-val text-desc" id="col-desc">ä¸€åœºå‹å€’æ€§çš„å®Œèƒœã€‚</span>
                                </div>
                                <div class="res-info-tile team-tile">
                                    <span class="tile-label">PARTY</span>
                                    <div class="mini-party-dots" id="res-party-viz"></div>
                                </div>
                                <div class="res-info-tile">
                                    <span class="tile-label">REASON</span>
                                    <span class="tile-val" id="col-reason">Total Domination</span>
                                </div>
                            </div>
                            <textarea id="res-clipboard-text" readonly></textarea>
                        </div>
                        <div class="res-pills-action">
                            <button class="pill-btn restart" onclick="restartBattle()">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" class="pill-icon">
                                    <path d="M4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4V2M12 4L8 8M12 4L16 8" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                RETRY
                            </button>
                            <button class="pill-btn sec" onclick="copyResultOnly()">
                                DATA ONLY
                            </button>
                            <button class="pill-btn primary" onclick="copyFullProcess()">
                                <span class="btn-text">COPY FULL LOG</span>
                                <span class="btn-sub">RP Mode</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="overlay-modal hidden" id="switch-menu-layer"></div>
                <div id="ball-layer" class="ball-menu-overlay hidden">
                    <div class="ball-menu-card">
                        <div class="ball-header">SELECT BALL</div>
                        <button class="ball-option" onclick="tryCatch(1)">
                            <span>Poke Ball</span> <span class="ball-multi">x1.0</span>
                        </button>
                        <button class="ball-option" onclick="tryCatch(1.5)">
                            <span>Great Ball</span> <span class="ball-multi">x1.5</span>
                        </button>
                        <button class="ball-option" onclick="tryCatch(2.0)">
                            <span>Ultra Ball</span> <span class="ball-multi">x2.0</span>
                        </button>
                        <button class="ball-option" style="border-color:#a855f7;color:#9333ea" onclick="tryCatch(255)">
                            <span style="font-weight:900">Master Ball</span> <span class="ball-multi" style="background:#9333ea">MAX</span>
                        </button>
                        <button class="close-ball-menu" onclick="closeBallMenu()">CANCEL</button>
                    </div>
                </div>
            </div>
            <!-- å‰§åœºåŒ–åˆ‡å…¥å±‚ -->
            <div id="theater-layer" class="cutin-overlay pointer-events-none">
                <div id="cutin-stage" class="compact-bar hidden">
                    <div class="deco-edge"></div>
                    <div class="compact-content">
                        <div class="avatar-slot">
                            <img id="cutin-avatar" src="" class="c-avatar-img" alt="cutin avatar" onerror="this.style.opacity=0">
                        </div>
                        <div class="text-slot">
                            <div class="c-name-strip" id="cutin-name">TRAINER</div>
                            <div class="c-dialogue" id="cutin-text">Battle text goes here...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<script>
    (function () {
        function handleInjectedData(data) {
            if (!data) return;
            window.globalBattleData = data;
            if (typeof window.onBattleDataInjected === 'function' && window.onBattleDataInjected !== handleInjectedData) {
                try {
                    window.onBattleDataInjected(data);
                } catch (e) {
                    console.warn('[PKM] onBattleDataInjected error:', e);
                }
            }
        }
        window.globalBattleData = window.globalBattleData || null;
        window.onBattleDataInjected = handleInjectedData;
        window.addEventListener('message', (event) => {
            const payload = event?.data;
            if (!payload || payload.type !== 'pkm-battle-data') return;
            handleInjectedData(payload.payload);
        });
        window.requestBattleDataFromParent = function () {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'pkm-battle-data-request' }, '*');
                } catch (e) {
                    console.warn('[PKM] requestBattleDataFromParent failed:', e);
                }
            }
        };
        window.requestBattleDataFromParent();
    })();
</script>
<script src="./index.js"></script>
</body>
</html>]]></file>
    <file name="index.js"><![CDATA[/**
 * ===========================================
 * INDEX.JS - UI æ§åˆ¶å™¨ & å…¥å£
 * ===========================================
 * 
 * ä¾èµ–: pokedex-data.js, moves-data.js, battle-engine.js
 * 
 * èŒè´£:
 * - UI æ¸²æŸ“ (è¡€æ¡ã€ç²¾çµå›¾ã€æŒ‰é’®)
 * - ç”¨æˆ·äº¤äº’å¤„ç†
 * - æˆ˜æ–—æµç¨‹æ§åˆ¶
 * - JSON åŠ è½½å…¥å£
 */
// å…¨å±€æˆ˜æ–—çŠ¶æ€
let battle = new BattleState();
window.battle = battle;  // å¯¼å‡ºåˆ°å…¨å±€ï¼Œä¾›æ¨¡å—è®¿é—®
// ============================================
// ã€å·²è¿ç§»ã€‘å¤æ­¦ç³»ç»Ÿ -> mechanics/move-styles.js
// ã€å·²è¿ç§»ã€‘Z-Move/Max Move æ¨å¯¼ -> mechanics/z-moves.js
// ============================================
// ============================================
// ã€å·²è¿ç§»ã€‘è®­ç»ƒå®¶å¤´åƒç³»ç»Ÿ -> ui/ui-trainer-hud.js
// ã€å·²è¿ç§»ã€‘Cut-in æ¼”å‡ºç³»ç»Ÿ -> ui/ui-trainer-hud.js
// ã€å·²è¿ç§»ã€‘UI ç¼©æ”¾ -> ui/ui-renderer.js
// ============================================
// é¢„åŠ è½½æ¨¡æ‹Ÿ
setTimeout(() => {
    document.getElementById('btn-start').innerText = "START GAME";
    document.getElementById('btn-start').disabled = false;
    document.getElementById('btn-start').style.fontWeight = "900";
}, 800);
window.addEventListener('resize', updateUIScale);
updateUIScale();
/**
 * åˆå§‹åŒ–æ¸¸æˆ - åŠ è½½ç¤ºä¾‹å¯¹æˆ˜
 */
async function initGame() {
    const startBtn = document.getElementById('btn-start');
    const sysMsg = document.querySelector('.sys-msg');
    // === é¢„åŠ è½½é˜¶æ®µ ===
    startBtn.disabled = true;
    startBtn.innerText = "LOADING...";
    if (sysMsg) sysMsg.textContent = "PRELOADING RESOURCES...";
    // è·å–æˆ˜æ–—æ•°æ®
    // è®¾ç½®ä¸º true å¯å¼ºåˆ¶ä½¿ç”¨ data-loader.js ä¸­çš„é»˜è®¤æ•°æ®ï¼ˆç”¨äºæµ‹è¯•ï¼‰
    const FORCE_USE_DEFAULT_DATA = false;
    let json;
    if (!FORCE_USE_DEFAULT_DATA && typeof globalBattleData !== 'undefined' && globalBattleData) {
        json = globalBattleData;
        console.log('[PKM] ä½¿ç”¨å¤–éƒ¨æ³¨å…¥æ•°æ® (globalBattleData)');
    } else {
        json = getDefaultBattleData();
        console.log('[PKM] ä½¿ç”¨é»˜è®¤æ•°æ® (data-loader.js)');
    }
    // é¢„åŠ è½½æœ¬å±€èµ„æº
    const playerParty = (json.player && json.player.party) || [];
    const enemyParty = json.party || (json.enemy && json.enemy.party) || [];
    const trainerId = (json.enemy && json.enemy.id) || (json.trainer && json.trainer.id) || null;
    if (typeof preloadBattleResources === 'function' && (playerParty.length > 0 || enemyParty.length > 0)) {
        try {
            await preloadBattleResources(playerParty, enemyParty, trainerId, (loaded, total) => {
                if (sysMsg) sysMsg.textContent = `LOADING... ${Math.floor(loaded/total*100)}%`;
            });
        } catch (e) {
            console.warn('[PRELOAD] Error:', e);
        }
    }
    if (sysMsg) sysMsg.textContent = "READY!";
    // éšè—åŠ è½½é¡µï¼Œæ˜¾ç¤ºæ¸¸æˆç•Œé¢
    document.getElementById('start-view').style.opacity = 0;
    setTimeout(() => document.getElementById('start-view').style.display = 'none', 500);
    document.getElementById('game-view').classList.remove('hidden');
    resetSpriteState();
    // åŠ è½½å¯¹æˆ˜ JSON (å·²åœ¨é¢„åŠ è½½é˜¶æ®µè·å–)
    try {
        console.log('[PKM] ä½¿ç”¨æˆ˜æ–—æ•°æ®:', json);
        // ä» JSON åŠ è½½ç©å®¶é˜Ÿä¼
        if (json.player && json.player.party) {
            // === è§£é”ç³»ç»Ÿ (Unlock System) ===
            // è§£æ unlocks å¯¹è±¡ï¼Œå†³å®šç©å®¶æ˜¯å¦æœ‰èµ„æ ¼ä½¿ç”¨å„æœºåˆ¶
            const unlocks = json.player.unlocks || {};
            battle.playerUnlocks = {
                enable_bond: unlocks.enable_bond !== false,        // ç¾ç»Šå…±é¸£
                enable_styles: unlocks.enable_styles !== false,    // åˆšçŒ›/è¿…ç–¾
                enable_insight: unlocks.enable_insight !== false,  // å¿ƒçœ¼/AVsçªç ´
                enable_mega: unlocks.enable_mega !== false,        // Megaè¿›åŒ–
                enable_z_move: unlocks.enable_z_move !== false,    // Zæ‹›å¼
                enable_dynamax: unlocks.enable_dynamax !== false,  // æå·¨åŒ–
                enable_tera: unlocks.enable_tera !== false         // å¤ªæ™¶åŒ–
            };
            console.log('[UNLOCK] ç©å®¶è§£é”çŠ¶æ€:', battle.playerUnlocks);
            // ã€æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿã€‘è¯»å–è®­ç»ƒå®¶ç†Ÿç»ƒåº¦
            // JSON æ ¼å¼: player.trainerProficiency (0-255)
            if (json.player.trainerProficiency !== undefined) {
                battle.trainerProficiency = Math.min(255, Math.max(0, json.player.trainerProficiency));
                console.log('[COMMANDER] ä» JSON è¯»å–è®­ç»ƒå®¶ç†Ÿç»ƒåº¦:', battle.trainerProficiency);
            }
            // ã€æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿã€‘åˆå§‹åŒ–
            if (typeof initCommanderSystem === 'function') {
                initCommanderSystem();
            }
            // æ£€æŸ¥ç©å®¶æ˜¯å¦æœ‰ Mega æƒé™ (ç›´æ¥ä» unlocks è¯»å–)
            const playerCanMega = battle.playerUnlocks.enable_mega;
            battle.setPlayerParty(json.player.party, playerCanMega);
            battle.playerName = json.player.name || 'ä¸»è§’';
            log(`<b>${battle.playerName}</b> å‡†å¤‡æˆ˜æ–—ï¼`);
        } else {
            // Fallback: é»˜è®¤ç©å®¶é˜Ÿä¼
            battle.setPlayerParty([
                { name: 'Charmander', lv: 5, moves: ['Scratch', 'Ember'] },
                { name: 'Pikachu', lv: 5, moves: ['Thunder Shock', 'Quick Attack'] },
            ], false);
            battle.playerName = 'ä¸»è§’';
        }
        // åŠ è½½æ•Œæ–¹æ•°æ®
        battle.loadFromJSON(json);
        updateTrainerHud();
        const t = battle.trainer;
        const btnCatch = document.getElementById('btn-catch');
        const rightCol = document.getElementById('menu-right-col');
        const catchLayer = document.getElementById('ball-layer');
        if (btnCatch && rightCol) {
            if (t && (t.id === 'wild' || !t.id)) {
                btnCatch.classList.remove('hidden');
                rightCol.classList.remove('two-btn');
            } else {
                btnCatch.classList.add('hidden');
                rightCol.classList.add('two-btn');
                if (catchLayer) catchLayer.classList.add('hidden');
            }
        }
        if (t) {
            const isWild = t.id === 'wild';
            if (isWild) {
                log(`é‡ç”Ÿå®å¯æ¢¦ã€${battle.getEnemy().cnName}ã€‘å‡ºç°äº†ï¼`);
            } else {
                log(`<b style="color:#e74c3c">ã€${t.name}ã€‘</b>å‘èµ·æŒ‘æˆ˜ï¼`);
            }
            if (t.lines?.start) {
                log(`<i>${t.name}: "${t.lines.start}"</i>`);
            }
        }
        log(`æ•Œæ–¹æ´¾å‡ºäº† <b>${battle.getEnemy().cnName}</b> (Lv.${battle.getEnemy().level})!`);
        if (battle.scriptedResult === 'loss') {
            log(`<span style="color:#e67e22">[å‰§æƒ…æˆ˜] è¿™æ˜¯ä¸€åœºå¿…è´¥çš„æˆ˜æ–—...</span>`);
        }
    } catch (e) {
        console.error('Failed to load battle JSON:', e);
        // Fallback: ç®€å•å¯¹æˆ˜
        battle.setPlayerParty([
            { name: 'Pikachu', lv: 5, moves: ['Thunder Shock', 'Quick Attack'] }
        ]);
        battle.loadFromJSON({
            trainer: { name: 'é‡ç”Ÿå®å¯æ¢¦', id: 'wild', line: '' },
            party: [{ name: 'Rattata', lv: 3, moves: ['Tackle'] }]
        });
        log("é‡ç”Ÿçš„å°æ‹‰è¾¾å‡ºç°äº†ï¼");
    }
    const openingPoke = battle.getPlayer();
    const openingEnemy = battle.getEnemy();
    if (openingPoke) {
        log(`å»å§ï¼${openingPoke.cnName}ï¼ˆLv.${openingPoke.level}ï¼‰ï¼`);
    }
    // === æ’­æ”¾åŒæ–¹å®å¯æ¢¦å«å£° ===
    setTimeout(() => {
        if (openingPoke && typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(openingPoke.name);
        }
    }, 500);
    setTimeout(() => {
        if (openingEnemy && typeof window.playPokemonCry === 'function') {
            window.playPokemonCry(openingEnemy.name);
        }
    }, 1200);
    // === æ£€æŸ¥å¹¶æ‰§è¡Œè¿›åœºè‡ªåŠ¨å˜å½¢ (Primal/Crowned) ===
    const checkInitTransformFunc = typeof window.checkInitTransform === 'function' ? window.checkInitTransform : null;
    if (checkInitTransformFunc) {
        // æ£€æŸ¥ç©å®¶å®å¯æ¢¦
        if (openingPoke && openingPoke.needsInitTransform) {
            console.log('[FORM] Checking player init transform:', openingPoke.name);
            const result = checkInitTransformFunc(openingPoke);
            if (result) {
                log(`<span style="color:#a855f7">âœ¦ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                // é¢„åŠ è½½æ–°å½¢æ€çš„ç²¾çµå›¾ï¼Œé¿å…é—ªçƒ
                const newSpriteUrl = openingPoke.getSprite(true); // ç©å®¶æ˜¯èƒŒé¢
                const preloader = new Image();
                preloader.src = newSpriteUrl;
            }
        }
        // æ£€æŸ¥æ•Œæ–¹å®å¯æ¢¦
        if (openingEnemy && openingEnemy.needsInitTransform) {
            console.log('[FORM] Checking enemy init transform:', openingEnemy.name);
            const result = checkInitTransformFunc(openingEnemy);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
                // é¢„åŠ è½½æ–°å½¢æ€çš„ç²¾çµå›¾ï¼Œé¿å…é—ªçƒ
                const newSpriteUrl = openingEnemy.getSprite(false); // æ•Œæ–¹æ˜¯æ­£é¢
                const preloader = new Image();
                preloader.src = newSpriteUrl;
            }
        }
    }
    // å»¶è¿Ÿä¸€å¸§å†æ›´æ–°è§†è§‰ï¼Œç¡®ä¿é¢„åŠ è½½å®Œæˆ
    setTimeout(() => {
        updateAllVisuals();
    }, 50);
    // === æ’­æ”¾æˆ˜æ–— BGM ===
    if (typeof playBattleBgm === 'function') {
        playBattleBgm();
    }
    // === è§¦å‘åŒæ–¹å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰) ===
    if (openingEnemy) {
        triggerEntryAbilities(openingEnemy, openingPoke);
    }
    if (openingPoke) {
        triggerEntryAbilities(openingPoke, openingEnemy);
    }
    const trainerHud = document.getElementById('trainer-hud');
    if (trainerHud) {
        trainerHud.classList.add('hidden');
        trainerHud.style.opacity = '0';
    }
    const trainer = battle.trainer;
    if (trainer && trainer.id !== 'wild') {
        const introLine = trainer.lines?.start || `${trainer.name || 'Opponent'} is challenging you!`;
        setTimeout(() => {
            playCutIn(introLine, 3500);
            setTimeout(() => {
                updateTrainerHud();
                if (trainerHud) {
                    trainerHud.classList.remove('hidden');
                    trainerHud.style.transition = 'opacity 1s';
                    trainerHud.style.opacity = '1';
                }
            }, 3800);
        }, 500);
    }
}
// =========================================================
// ã€å·²è¿ç§»ã€‘æœºåˆ¶äº’æ–¥ç³»ç»Ÿ -> mechanics/mechanic-checker.js
// ã€å·²è¿ç§»ã€‘æå·¨åŒ–çŠ¶æ€ç®¡ç† -> mechanics/dynamax.js
// =========================================================
// =========================================================
// ã€å·²è¿ç§»ã€‘é»˜è®¤æˆ˜æ–—æ•°æ® -> systems/data-loader.js
// ã€å·²è¿ç§»ã€‘JSON æ•°æ®åŠ è½½ -> systems/data-loader.js
// =========================================================
/**
 * ç•Œé¢åˆ·æ–°ï¼šæ¸²æŸ“æ–‡æœ¬ã€è¡€é‡ã€å›¾ç‰‡
 * @param {string|boolean} forceSpriteAnim - false: ä¸å¼ºåˆ¶åŠ¨ç”», 'player': åªæœ‰ç©å®¶åŠ¨ç”», 'enemy': åªæœ‰æ•Œæ–¹åŠ¨ç”», true: ä¸¤è¾¹éƒ½åŠ¨ç”»
 */
function updateAllVisuals(forceSpriteAnim = false) {
    const p = battle.getPlayer();
    const e = battle.getEnemy();
    if (!p || !e) return;
    // 1. åå­— LV (æ•Œæ–¹é«˜ç­‰çº§ç”¨çº¢è‰²å¼ºè°ƒ)
    document.getElementById('player-name').innerText = p.cnName;
    document.getElementById('player-lvl').innerText = p.level;
    const enemyNameEl = document.getElementById('enemy-name');
    // é‡ç”Ÿæˆ˜æ–—æ—¶æ˜¾ç¤ºå½“å‰æ•Œæ–¹å®å¯æ¢¦çš„åå­—ï¼Œè®­ç»ƒå®¶æˆ˜æ–—æ—¶æ˜¾ç¤ºå®å¯æ¢¦åå­—
    enemyNameEl.innerText = e.cnName;
    const enemyLvEl = document.getElementById('enemy-lvl');
    enemyLvEl.innerText = e.level;
    enemyLvEl.style.color = (e.level > p.level + 20) ? '#e74c3c' : '';
    enemyLvEl.style.fontWeight = (e.level > p.level + 20) ? '900' : '';
    // 2. è¡€æ¡æ¸²æŸ“
    renderHp('player', p.currHp, p.maxHp);
    renderHp('enemy', e.currHp, e.maxHp);
    // 3. å›¾ç‰‡æ™ºèƒ½åŠ è½½ (é˜²é—ªçƒ: åŠ è½½å®Œå†æ˜¾ç¤º)
    // forceSpriteAnim å¯ä»¥æ˜¯ 'player' æˆ– 'enemy' æ¥æŒ‡å®šåªæœ‰ä¸€æ–¹æ’­æ”¾åŠ¨ç”»
    const playerAnim = (forceSpriteAnim === true || forceSpriteAnim === 'player');
    const enemyAnim = (forceSpriteAnim === true || forceSpriteAnim === 'enemy');
    // æå·¨åŒ–çŠ¶æ€ä¸‹ä¸é‡æ–°åŠ è½½ç²¾çµå›¾ï¼ˆä¿æŒ G-Max å›¾ç‰‡ï¼‰
    if (!p.isDynamaxed) {
        smartLoadSprite('player-sprite', p.getSprite(true), playerAnim);
    }
    if (!e.isDynamaxed) {
        smartLoadSprite('enemy-sprite', e.getSprite(false), enemyAnim);
    }
    const playerSpriteEl = document.getElementById('player-sprite');
    if (playerSpriteEl) {
        playerSpriteEl.classList.toggle('mega-player', !!p.isMega);
        playerSpriteEl.classList.toggle('mega-enemy', false);
        // æå·¨åŒ–çŠ¶æ€
        playerSpriteEl.classList.toggle('state-dynamax', !!p.isDynamaxed);
        // ã€ä¿®å¤ã€‘å¤ªæ™¶åŒ–çŠ¶æ€å’Œå±æ€§é¢œè‰²ç±»ç®¡ç†
        playerSpriteEl.classList.toggle('state-terastal', !!p.isTerastallized);
        // æ¸…é™¤æ‰€æœ‰å¤ªæ™¶å±æ€§é¢œè‰²ç±»
        const allTeraTypes = ['normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy', 'stellar'];
        allTeraTypes.forEach(type => playerSpriteEl.classList.remove(`tera-type-${type}`));
        // å¦‚æœå¤ªæ™¶åŒ–ï¼Œæ·»åŠ å¯¹åº”å±æ€§é¢œè‰²ç±»
        if (p.isTerastallized && p.teraType) {
            playerSpriteEl.classList.add(`tera-type-${p.teraType.toLowerCase()}`);
        }
        // æ¸…é™¤éå®˜æ–¹ Mega æ•ˆæœï¼ˆå¦‚æœå½“å‰å®å¯æ¢¦ä¸æ˜¯éå®˜æ–¹ Megaï¼‰
        if (!p.isUnofficialMega) {
            playerSpriteEl.classList.remove('unofficial-mega');
        }
        // ç¾ç»Šå…±é¸£çŠ¶æ€ï¼šåªæœ‰å½“å‰å®å¯æ¢¦æœ‰ hasBondResonance æ ‡è®°æ—¶æ‰ä¿ç•™æ ·å¼
        if (p.hasBondResonance) {
            playerSpriteEl.classList.add('bond-resonance');
            playerSpriteEl.style.filter = 'drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15)';
        } else {
            playerSpriteEl.classList.remove('bond-resonance');
            // æ¸…é™¤å¯èƒ½æ®‹ç•™çš„ filter æ ·å¼
            if (playerSpriteEl.style.filter && playerSpriteEl.style.filter.includes('gold')) {
                playerSpriteEl.style.filter = '';
            }
        }
    }
    const enemySpriteEl = document.getElementById('enemy-sprite');
    if (enemySpriteEl) {
        enemySpriteEl.classList.toggle('mega-enemy', !!e.isMega);
        enemySpriteEl.classList.toggle('mega-player', false);
        // æå·¨åŒ–çŠ¶æ€
        enemySpriteEl.classList.toggle('state-dynamax', !!e.isDynamaxed);
        // ã€ä¿®å¤ã€‘å¤ªæ™¶åŒ–çŠ¶æ€å’Œå±æ€§é¢œè‰²ç±»ç®¡ç†
        enemySpriteEl.classList.toggle('state-terastal', !!e.isTerastallized);
        // æ¸…é™¤æ‰€æœ‰å¤ªæ™¶å±æ€§é¢œè‰²ç±»
        const allTeraTypes = ['normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy', 'stellar'];
        allTeraTypes.forEach(type => enemySpriteEl.classList.remove(`tera-type-${type}`));
        // å¦‚æœå¤ªæ™¶åŒ–ï¼Œæ·»åŠ å¯¹åº”å±æ€§é¢œè‰²ç±»
        if (e.isTerastallized && e.teraType) {
            enemySpriteEl.classList.add(`tera-type-${e.teraType.toLowerCase()}`);
        }
        // æ¸…é™¤éå®˜æ–¹ Mega æ•ˆæœï¼ˆå¦‚æœå½“å‰å®å¯æ¢¦ä¸æ˜¯éå®˜æ–¹ Megaï¼‰
        if (!e.isUnofficialMega) {
            enemySpriteEl.classList.remove('unofficial-mega');
        }
        // ã€ä¿®å¤ã€‘ç¾ç»Šå…±é¸£çŠ¶æ€ï¼šåªæœ‰å½“å‰å®å¯æ¢¦æœ‰ hasBondResonance æ ‡è®°æ—¶æ‰ä¿ç•™æ ·å¼
        if (e.hasBondResonance) {
            enemySpriteEl.classList.add('bond-resonance');
            enemySpriteEl.style.filter = 'drop-shadow(0 0 12px gold) brightness(1.1) saturate(1.15)';
        } else {
            enemySpriteEl.classList.remove('bond-resonance');
            // æ¸…é™¤å¯èƒ½æ®‹ç•™çš„ filter æ ·å¼
            if (enemySpriteEl.style.filter && enemySpriteEl.style.filter.includes('gold')) {
                enemySpriteEl.style.filter = '';
            }
        }
    }
    // 4. é˜Ÿä¼çŠ¶æ€çƒ
    renderDots('ui-player-dots', battle.playerParty, battle.playerActive);
    renderDots('ui-enemy-dots', battle.enemyParty, battle.enemyActive);
    updateTrainerHud();
    // 5. æŒ‰é’®åŒº
    document.getElementById('switch-menu-layer').classList.add('hidden');
    if (p.currHp <= 0) {
        // æ­»äº¡çŠ¶æ€ï¼Œç­‰å¾…å¼ºåˆ¶æ¢äºº
    } else {
        // æ¸²æŸ“æŠ€èƒ½æŒ‰é’®ï¼ˆæ”¯æŒ 4 æŠ€ï¼‰
        const btnIds = ['btn-m0', 'btn-m1', 'btn-m2', 'btn-m3'];
        btnIds.forEach((id, i) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            // é‡ç½®æ‰€æœ‰ç‰¹æ®Šæ ·å¼
            btn.className = 'action-btn';
            btn.style.opacity = '1';
            if (i < p.moves.length) {
                const m = p.moves[i];
                // =========================================================
                // Z-Move / Max Move è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿ
                // åŸºäº mechanic å­—æ®µå’Œæ•°æ®åº“è‡ªåŠ¨åˆ¤æ–­æ‹›å¼å˜æ¢
                // =========================================================
                const mId = (m.name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
                const mData = (typeof MOVES !== 'undefined' && MOVES[mId]) ? MOVES[mId] : {};
                // ä½¿ç”¨æ–°çš„è‡ªåŠ¨æ¨å¯¼å‡½æ•°
                const zTarget = getZMoveTarget(m, p);  // è¿”å› { name, type, power } æˆ– null
                const maxTarget = p.isDynamaxed ? getMaxMoveTarget(m, p) : null; // åªæœ‰æå·¨åŒ–çŠ¶æ€æ‰æ¨å¯¼
                // åˆ¤æ–­å½“å‰æ‹›å¼åº”è¯¥æ˜¾ç¤ºä»€ä¹ˆæ ·å¼
                const showZStyle = zTarget && !battle.playerZUsed;
                const showMaxStyle = maxTarget !== null;
                // ç¦ç”¨é€»è¾‘
                let isDisabled = false;
                if (showZStyle && battle.playerZUsed) isDisabled = true;
                // è·å–æ˜¾ç¤ºåç§°å’Œç±»å‹
                let displayName = m.cn || m.name;
                let displayType = m.type || 'Normal';
                if (showZStyle) {
                    // Z æ‹›å¼æ ·å¼
                    displayName = (window.Locale) ? window.Locale.get(zTarget.name) : zTarget.name;
                    displayType = zTarget.type;
                } else if (showMaxStyle) {
                    // Max æ‹›å¼æ ·å¼
                    displayName = (window.Locale) ? window.Locale.get(maxTarget.name) : maxTarget.name;
                    displayType = maxTarget.type;
                }
                // =========================================================
                // ã€å¿ƒçœ¼ç³»ç»Ÿã€‘å±æ€§å…‹åˆ¶æç¤º (enable_insight)
                // æ˜¾ç¤º â–²(æ•ˆæœç»ä½³) / â–¼(æ•ˆæœä¸å¥½) / Ã—(æ— æ•ˆ)
                // =========================================================
                let insightHint = '';
                const insightUnlocked = battle.playerUnlocks && battle.playerUnlocks.enable_insight !== false;
                if (insightUnlocked && e && e.types) {
                    const moveType = displayType || m.type || 'Normal';
                    const eff = window.getTypeEffectiveness ? 
                        window.getTypeEffectiveness(moveType, e.types) : 1;
                    if (eff === 0) {
                        insightHint = '<span class="insight-hint insight-immune" title="æ— æ•ˆ">Ã—</span>';
                    } else if (eff >= 2) {
                        insightHint = '<span class="insight-hint insight-super" title="æ•ˆæœç»ä½³">â–²</span>';
                    } else if (eff <= 0.5) {
                        insightHint = '<span class="insight-hint insight-resist" title="æ•ˆæœä¸å¥½">â–¼</span>';
                    }
                }
                if (showZStyle || showMaxStyle) {
                    // åº”ç”¨ç‰¹æ®Šæ ·å¼
                    if (showZStyle) {
                        btn.classList.add('z-move-btn');
                    } else {
                        btn.classList.add('max-move-btn');
                    }
                    if (isDisabled) {
                        btn.classList.add('z-move-used');
                    }
                    const labelText = showZStyle ? 'Z' : 'MAX';
                    const typeNameCN = (window.Locale) ? window.Locale.get(displayType) : displayType;
                    btn.innerHTML = `
                        <div class="z-bg-overlay"></div>
                        <div class="z-badge-icon">${labelText}</div>
                        <span class="move-name">${displayName}${insightHint}</span>
                        <span class="badge-type type-${displayType}">${typeNameCN}</span>
                    `;
                } else {
                    // æ™®é€šæŠ€èƒ½
                    const typeNameCN = (window.Locale) ? window.Locale.get(displayType) : displayType;
                    btn.innerHTML = `
                        <span class="move-name">${displayName}${insightHint}</span>
                        <span class="badge-type type-${displayType}">${typeNameCN}</span>
                    `;
                }
                // äº¤äº’äº‹ä»¶
                if (isDisabled) {
                    btn.disabled = true;
                    btn.onclick = null;
                } else {
                    btn.disabled = false;
                    // å¦‚æœæ˜¯ Z æ‹›å¼æ¨¡å¼ï¼Œä¼ é€’ useZ æ ‡è®°å’Œæ¨å¯¼ç»“æœ
                    if (showZStyle) {
                        btn.onclick = () => handleAttack(i, { useZ: true, zTarget: zTarget });
                    } else {
                        btn.onclick = () => handleAttack(i);
                    }
                }
                btn.style.visibility = 'visible';
            } else {
                btn.disabled = true;
                btn.style.visibility = 'hidden';
                btn.innerHTML = '<span class="move-name">---</span><span class="move-type">---</span>';
            }
        });
    }
    // 6. æ›´æ–°è¿›åŒ–æŒ‰é’®å¯è§æ€§
    if (typeof updateEvolutionButtonVisuals === 'function') {
        updateEvolutionButtonVisuals();
    }
}
// ============================================
// ã€å·²è¿ç§»ã€‘ç²¾çµå›¾åŠ è½½ -> ui/ui-sprites.js
// ã€å·²è¿ç§»ã€‘è¡€æ¡/ç²¾çµçƒæ§½æ¸²æŸ“ -> ui/ui-renderer.js
// ============================================
/**
 * æ ¸å¿ƒé€»è¾‘ï¼šå‘èµ·æ”»å‡»å¤„ç† (æ”¯æŒå…ˆåˆ¶æŠ€ä¼˜å…ˆçº§)
 * @param {number} moveIndex æ‹›å¼ç´¢å¼•
 * @param {object} options å¯é€‰å‚æ•° { useZ: boolean, zConfig: object }
 */
async function handleAttack(moveIndex, options = {}) {
    if (typeof window.playSFX === 'function') window.playSFX('CONFIRM');
    if (battle.locked) return;
    battle.locked = true;
    // ã€ç»Ÿä¸€å›åˆå¼€å§‹å¤„ç†ã€‘è°ƒç”¨ battle-turns.js ä¸­çš„ onTurnStart
    if (typeof window.onTurnStart === 'function') {
        window.onTurnStart();
    }
    // ä¿å­˜ Mega é¢„å¤‡çŠ¶æ€ï¼ˆåœ¨ showMainMenu é‡ç½®ä¹‹å‰ï¼‰
    const megaArmedThisTurn = battle.playerMegaArmed;
    // æ”»å‡»åè¿”å›ä¸»èœå•
    showMainMenu();
    let p = battle.getPlayer();  // ä½¿ç”¨ letï¼Œå› ä¸º pivot æ¢äººæ—¶éœ€è¦æ›´æ–°å¼•ç”¨
    let e = battle.getEnemy();   // ä½¿ç”¨ letï¼Œå› ä¸º AI æ¢äººæ—¶éœ€è¦æ›´æ–°å¼•ç”¨
    let playerMove = p.moves[moveIndex];
    // === ã€ä¿®å¤ã€‘æ£€æŸ¥ Taunt ç­‰ Volatile çŠ¶æ€æ˜¯å¦é˜»æ­¢ä½¿ç”¨è¯¥æŠ€èƒ½ ===
    if (typeof MoveEffects !== 'undefined' && MoveEffects.canUseMove) {
        const canUseResult = MoveEffects.canUseMove(p, playerMove);
        if (!canUseResult.canUse) {
            log(`<span style="color:#e74c3c">${canUseResult.reason}</span>`);
            battle.locked = false;
            return;
        }
    }
    // =========================================================
    // Z-Move è½¬æ¢é€»è¾‘ï¼šä½¿ç”¨è‡ªåŠ¨æ¨å¯¼ç³»ç»Ÿ
    // ã€äº’æ–¥æ£€æŸ¥ã€‘Mega/æå·¨åŒ–çŠ¶æ€ä¸‹ç¦æ­¢ä½¿ç”¨ Z æ‹›å¼
    // =========================================================
    if (options.useZ && options.zTarget && !battle.playerZUsed) {
        // ã€å®‰å…¨æ£€æŸ¥ã€‘å¦‚æœå·²ç» Mega æˆ–æå·¨åŒ–ï¼Œç¦æ­¢ä½¿ç”¨ Z æ‹›å¼
        if (p.isMega || p.isDynamaxed || p.hasBondResonance) {
            console.warn(`[CHEAT BLOCK] è¯•å›¾åœ¨ Mega/æå·¨åŒ– çŠ¶æ€ä¸‹ä½¿ç”¨ Z æ‹›å¼ï¼å·²å¼ºåˆ¶æ‹¦æˆªã€‚`);
            log(`<b style="color:#aaa">...ä½†åœ¨ç›®å‰çš„å½¢æ€ä¸‹æ— æ³•å¼•å‡º Z åŠ›é‡ï¼</b>`);
            // ä¸è½¬æ¢ï¼Œä½¿ç”¨åŸå§‹æ‹›å¼
        } else {
            const zTarget = options.zTarget;
            const zMoveId = zTarget.name.toLowerCase().replace(/[^a-z0-9]/g, '');
            const zMoveData = (typeof MOVES !== 'undefined' && MOVES[zMoveId]) ? MOVES[zMoveId] : {};
            // ä½¿ç”¨è‡ªåŠ¨æ¨å¯¼çš„ Z æ‹›å¼æ•°æ®
            playerMove = {
                name: zTarget.name,
                cn: zMoveData.cn || zTarget.name,
                type: zTarget.type || playerMove.type || 'Normal',
                power: zTarget.power || 180,
                basePower: zTarget.power || 180,
                accuracy: 100,
                pp: 1,
                isZ: true,
                priority: zMoveData.priority || 0,
                cat: zMoveData.category === 'Physical' ? 'phys' : 'spec',
                category: zMoveData.category || 'Special'
            };
            console.log(`[Z-MOVE] è‡ªåŠ¨æ¨å¯¼ Z æ‹›å¼: ${playerMove.name} (å¨åŠ›: ${playerMove.power})`);
        }
    }
    // =========================================================
    // ã€å¤æ­¦ç³»ç»Ÿ v2.1ã€‘åˆšçŒ›/è¿…ç–¾ é£æ ¼ä¿®æ­£ (enable_styles)
    // åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®é€Ÿåº¦ä¼˜åŠ¿å†³å®šæƒ©ç½šç¨‹åº¦
    // è¿…ç–¾ (Agile): é€Ÿåº¦å¿«æ—¶0.75x(ä¿å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶0.5x(æŠ¢èŠ‚å¥)
    // åˆšçŒ› (Strong): é€Ÿåº¦å¿«æ—¶å¿…ä¸­(å–å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8x(ç™½å«–)
    // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
    // =========================================================
    if (currentMoveStyle !== 'normal' && battle.playerUnlocks?.enable_styles) {
        // ã€å†·å´æ£€æŸ¥ã€‘å¦‚æœåœ¨å†·å´ä¸­ï¼Œå¼ºåˆ¶ä½¿ç”¨æ™®é€šé£æ ¼
        if (battle.playerStyleCooldown > 0) {
            log(`<span style="color:#aaa">é£æ ¼ç³»ç»Ÿå†·å´ä¸­ï¼Œæœ¬å›åˆåªèƒ½ä½¿ç”¨æ™®é€šé£æ ¼</span>`);
            currentMoveStyle = 'normal';
        } else {
            const originalPower = playerMove.basePower || playerMove.power || 0;
            const originalPriority = playerMove.priority || 0;
            const originalAccuracy = playerMove.accuracy;
            const isStatus = (playerMove.category === 'Status' || playerMove.cat === 'status' || originalPower === 0);
            // ã€v2.1ã€‘è®¡ç®—æœ‰æ•ˆé€Ÿåº¦ï¼Œåˆ¤æ–­é€Ÿåº¦ä¼˜åŠ¿
            let mySpe = (typeof p.getStat === 'function') ? p.getStat('spe') : (p.spe || 100);
            let enemySpe = (typeof e.getStat === 'function') ? e.getStat('spe') : (e.spe || 100);
            // éº»ç—¹å‡é€Ÿ
            if (p.status === 'par') mySpe = Math.floor(mySpe * 0.5);
            if (e.status === 'par') enemySpe = Math.floor(enemySpe * 0.5);
            // æˆæ³•ç©ºé—´åˆ¤å®š
            const isTrickRoom = battle.field && battle.field.trickRoom > 0;
            let haveSpeedAdvantage = false;
            if (isTrickRoom) {
                haveSpeedAdvantage = mySpe < enemySpe; // ç©ºé—´ä¸‹ï¼šæ…¢å°±æ˜¯å¿«
            } else {
                haveSpeedAdvantage = mySpe > enemySpe; // æ­£å¸¸ï¼šå¿«å°±æ˜¯å¿«
            }
            // ============================================
            // âš¡ è¿…ç–¾é£æ ¼ (Agile Style)
            // ============================================
            if (currentMoveStyle === 'agile') {
                // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘å˜åŒ–æŠ€ç¦æ­¢ä½¿ç”¨è¿…ç–¾
                if (isStatus) {
                    log(`<span style="color:#aaa">å˜åŒ–ç±»æ‹›å¼æ— æ³•ä½¿ç”¨è¿…ç–¾é£æ ¼ï¼(è‡ªåŠ¨åˆ‡æ¢å›æ™®é€š)</span>`);
                    currentMoveStyle = 'normal';
                } else {
                    playerMove = { ...playerMove };
                    playerMove.priority = originalPriority + 1;
                    playerMove.styleUsed = 'agile';
                    const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                    if (haveSpeedAdvantage) {
                        // åœºæ™¯ A: æ‹¥æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ä¹°ä¿é™©æ±‚ç¨³ï¼Œé˜²å…ˆåˆ¶
                        playerMove.basePower = Math.floor(originalPower * 0.75);
                        playerMove.accuracy = Math.floor(oldAcc * 0.9); // å‘½ä¸­ç‡ 0.9x
                        log(`<span style="color:#3b82f6">âš¡ è¿…ç–¾Â·åˆ¶å˜ï¼šé€Ÿåº¦å‹åˆ¶ä¸‹ç¡®ä¿å…ˆæ‰‹ - å¨åŠ›Ã—0.75ï¼Œå‘½ä¸­Ã—0.9</span>`);
                        console.log(`[STYLES] è¿…ç–¾(å¿«): power 0.75x, acc 0.9x (${mySpe} vs ${enemySpe})`);
                    } else {
                        // åœºæ™¯ B: æ²¡æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ç»åœ°åå‡»ï¼Œå·å›åˆ
                        playerMove.basePower = Math.floor(originalPower * 0.50);
                        playerMove.accuracy = Math.floor(oldAcc * 0.85); // å‘½ä¸­ç‡ 0.85x
                        log(`<span style="color:#60a5fa">âš¡ è¿…ç–¾Â·ç¥é€Ÿï¼šé€†è½¬è¡ŒåŠ¨é¡ºä½ - å¨åŠ›Ã—0.50ï¼Œå‘½ä¸­Ã—0.85</span>`);
                        console.log(`[STYLES] è¿…ç–¾(æ…¢): power 0.5x, acc 0.85x (${mySpe} vs ${enemySpe})`);
                    }
                    playerMove.power = playerMove.basePower;
                    // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                    battle.playerStyleCooldown = 1;
                }
            } 
            // ============================================
            // ğŸ’ª åˆšçŒ›é£æ ¼ (Strong Style)
            // ============================================
            else if (currentMoveStyle === 'strong') {
                playerMove = { ...playerMove };
                playerMove.priority = originalPriority - 1;
                playerMove.basePower = Math.floor(originalPower * 1.30);
                playerMove.power = playerMove.basePower;
                playerMove.breaksProtect = true; // å¯ç©¿é€å®ˆä½
                playerMove.styleUsed = 'strong';
                if (!haveSpeedAdvantage) {
                    // åœºæ™¯ A: é€Ÿåº¦åŠ£åŠ¿ (æœ¬æ¥å°±æ…¢) - æ²¡ä»˜å‡ºä»£ä»·ï¼Œé™å‘½ä¸­
                    const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                    playerMove.accuracy = Math.floor(oldAcc * 0.8);
                    log(`<span style="color:#ef4444">ğŸ’ª åˆšçŒ›Â·èˆèº«ï¼šé€Ÿåº¦åŠ£åŠ¿ä¸‹çš„å¼ºæ”» - å¨åŠ›Ã—1.3ï¼Œå‘½ä¸­Ã—0.8</span>`);
                    console.log(`[STYLES] åˆšçŒ›(æ…¢): power 1.3x, acc 0.8x (${mySpe} vs ${enemySpe})`);
                } else {
                    // åœºæ™¯ B: é€Ÿåº¦ä¼˜åŠ¿ (æœ¬æ¥è¯¥æˆ‘å…ˆ) - å–å…ˆæ‰‹æ¢ä¼¤å®³ï¼Œä¸ä¿®æ­£å‘½ä¸­
                    // ã€v2.3ã€‘ä¸å†å¿…ä¸­ï¼Œä¿æŒåŸå‘½ä¸­ç‡
                    log(`<span style="color:#b91c1c">ğŸ’ª åˆšçŒ›Â·è“„åŠ›ï¼šæ”¾å¼ƒå…ˆæ‰‹ï¼Œå…¨åŠ›ä¸€å‡»ï¼(å¨åŠ›Ã—1.3ï¼Œè´¯ç©¿å®ˆä½)</span>`);
                    console.log(`[STYLES] åˆšçŒ›(å¿«): power 1.3x, acc unchanged (${mySpe} vs ${enemySpe})`);
                }
                // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                battle.playerStyleCooldown = 1;
            }
        }
        // ä½¿ç”¨åé‡ç½®ä¸ºæ™®é€šé£æ ¼
        setMoveStyle('normal');
    }
    // === å›åˆå¼€å§‹ï¼šæ¸…é™¤åŒæ–¹çš„ Protect çŠ¶æ€ï¼ˆæ–°å›åˆå¼€å§‹ï¼Œå®ˆä½å¤±æ•ˆï¼‰===
    if (p.volatile) p.volatile.protect = false;
    if (e.volatile) e.volatile.protect = false;
    // === Mega/Dynamax è¿›åŒ–å¤„ç† (å›åˆå¼€å§‹æ—¶ï¼Œå‡ºæ‹›å‰) ===
    // ç©å®¶ Mega/Dynamax è¿›åŒ– - ä½¿ç”¨ä¿å­˜çš„çŠ¶æ€ï¼ˆå› ä¸º showMainMenu ä¼šé‡ç½® battle.playerMegaArmedï¼‰
    const canMegaEvolveFunc = window.canMegaEvolve;
    const performMegaEvolutionFunc = window.performMegaEvolution;
    // æ£€æŸ¥æ˜¯å¦æ˜¯æå·¨åŒ–æ¨¡å¼
    // ã€ä¿®å¤ã€‘mechanic å­—æ®µæ˜¯æœ€é«˜æƒå¨ï¼Œå¦‚æœ mechanic === 'mega'ï¼Œåˆ™ä¸åº”è§¦å‘æå·¨åŒ–
    const isDynamaxMode = p && p.mechanic !== 'mega' && (p.canDynamax || (p.megaTargetId && p.megaTargetId.toLowerCase().includes('gmax')));
    if (megaArmedThisTurn && isDynamaxMode && !battle.playerMaxUsed && !p.isDynamaxed) {
        // === æå·¨åŒ–å¤„ç† ===
        battle.playerMegaArmed = false;
        battle.playerMaxUsed = true;
        const oldName = p.cnName;
        const oldMaxHp = p.maxHp;
        const oldCurrHp = p.currHp;
        log(`<div style="border-bottom: 2px solid #e11d48; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
        log(`${oldName} çš„èº«ä½“å¼€å§‹æ€¥å‰§è†¨èƒ€ï¼ä»¿ä½›è¦å†²ç ´å¤©é™…ï¼`);
        await wait(600);
        // æ’­æ”¾æå·¨åŒ–çˆ†å‘åŠ¨ç”»
        await playDynamaxAnimation(p, true);
        // ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å½¢æ€ï¼Œåˆ‡æ¢ç²¾çµå›¾
        // ã€å…³é”®ã€‘é€šç”¨æå·¨åŒ– (isGenericDynamax) ä¸åˆ‡æ¢å›¾ç‰‡ï¼Œåªç”¨ CSS æ”¾å¤§
        const gmaxFormId = p.megaTargetId;
        if (gmaxFormId && gmaxFormId.includes('gmax') && !p.isGenericDynamax) {
            // ä¿å­˜åŸå§‹åç§°ï¼Œç”¨äºå›é€€
            p.originalName = p.name;
            // [BUG FIX] æ ¼å¼è½¬æ¢ï¼šcharizardgmax -> Charizard-Gmax
            const baseName = gmaxFormId.replace(/gmax$/i, '');
            const formattedName = baseName.charAt(0).toUpperCase() + baseName.slice(1) + '-Gmax';
            p.name = formattedName;
            // ã€å¼ºåˆ¶ä¿®æ­£ã€‘G-Max å½¢æ€ä¸­æ–‡åï¼šä¼˜å…ˆç¿»è¯‘ï¼Œå›é€€æ—¶å¼ºåˆ¶åŠ "è¶…æå·¨"å‰ç¼€
            if (window.Locale) {
                const translatedName = window.Locale.get(formattedName);
                // æ£€æŸ¥æ˜¯å¦æˆåŠŸç¿»è¯‘ï¼ˆç¿»è¯‘åä¸ç­‰äºåŸåï¼Œä¸”ä¸ç­‰äºåŸºç¡€å½¢æ€åï¼‰
                const baseTranslated = window.Locale.get(baseName.charAt(0).toUpperCase() + baseName.slice(1));
                if (translatedName !== formattedName && translatedName !== baseTranslated) {
                    // æˆåŠŸç¿»è¯‘åˆ° G-Max å½¢æ€ï¼ˆå¦‚ "è¶…æå·¨å–·ç«é¾™"ï¼‰
                    p.cnName = translatedName;
                } else {
                    // ç¿»è¯‘å¤±è´¥ï¼Œå¼ºåˆ¶æ·»åŠ "è¶…æå·¨"å‰ç¼€
                    p.cnName = 'è¶…æå·¨' + baseTranslated;
                }
            } else {
                p.cnName = formattedName;
            }
            // G-Max ç²¾çµå›¾æ ¼å¼: laprasgmax -> lapras-gmax (å¸¦æ¨ªæ )
            const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
            const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani-back/${gmaxSpriteId}.gif`;
            smartLoadSprite('player-sprite', gmaxSpriteUrl, true);
            console.log(`[DYNAMAX] åˆ‡æ¢ç©å®¶ç²¾çµå›¾: ${gmaxSpriteUrl}`);
        } else if (p.isGenericDynamax) {
            console.log(`[DYNAMAX] é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${p.name}`);
        }
        // HP å€ç‡ x1.5
        const hpMultiplier = 1.5;
        p.maxHp = Math.floor(oldMaxHp * hpMultiplier);
        p.currHp = Math.floor(oldCurrHp * hpMultiplier);
        // è®¾ç½®æå·¨åŒ–çŠ¶æ€
        p.isDynamaxed = true;
        p.dynamaxTurns = 3; // 3 å›åˆåå˜å›
        p.preDynamaxMaxHp = oldMaxHp;
        p.preDynamaxCurrHp = oldCurrHp;
        // ç©å®¶æå·¨åŒ–æ˜¯åœ¨è‡ªå·±å›åˆæ¿€æ´»çš„ï¼Œä¸éœ€è¦ justActivated æ ‡è®°
        // å› ä¸ºæ¿€æ´»åä¼šç«‹å³è¡ŒåŠ¨ï¼Œç„¶åå›åˆç»“æŸæ—¶æ­£å¸¸ tick
        // ã€å…³é”®ã€‘æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼
        applyDynamaxState(p, true);
        // ã€ä¿®å¤ã€‘é‡æ–°è·å–å½“å‰å›åˆçš„æ‹›å¼ï¼ˆå› ä¸ºæ‹›å¼åˆ—è¡¨å·²ç»è¢«æ›¿æ¢ï¼‰
        playerMove = p.moves[moveIndex];
        log(`<b style="color:#e11d48">${oldName} æå·¨åŒ–äº†ï¼(HP x${hpMultiplier})</b>`);
        log(`<span style="color:#ff6b8a">[æå·¨åŒ–å‰©ä½™å›åˆ: ${p.dynamaxTurns}]</span>`);
        updateAllVisuals('player');
        await wait(800);
    } else if (megaArmedThisTurn && canMegaEvolveFunc && canMegaEvolveFunc(p) && !battle.playerMegaUsed && p.mechanic !== 'tera') {
        // === æ™®é€š Mega è¿›åŒ–å¤„ç† ===
        // ã€ä¿®å¤ã€‘å¿…é¡»æ’é™¤ mechanic='tera' çš„å®å¯æ¢¦ï¼Œé¿å…ä¸å¤ªæ™¶åŒ–å†²çª
        battle.playerMegaArmed = false;
        battle.playerMegaUsed = true;
        const oldName = p.cnName;
        log(`<div style="border-bottom: 2px solid #c084fc; margin-bottom: 5px;"></div>`);
        log(`${oldName} çš„è¿›åŒ–çŸ³å¯¹ ${battle.playerName || 'è®­ç»ƒå®¶'} çš„é’¥çŸ³äº§ç”Ÿäº†ååº”ï¼`);
        await wait(600);
        const megaResult = performMegaEvolutionFunc(p);
        if (megaResult) {
            await playMegaEvolutionAnimation(p, true);
            log(`<b style="color:#d8b4fe">${oldName} Mega è¿›åŒ–æˆäº† ${megaResult.newName}ï¼</b>`);
            if (megaResult.typeChanged) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">${megaResult.newName} å˜æˆäº† ${megaResult.newTypes.join('/')} å±æ€§ï¼</span>`);
            }
            if (megaResult.abilityChanged && megaResult.newAbility) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">è·å¾—äº†ç‰¹æ€§ <b>${megaResult.newAbility}</b>ï¼</span>`);
                triggerEntryAbilities(p, e);
            }
        }
        updateAllVisuals('player');
        await wait(800);
    } else if (megaArmedThisTurn && p.mechanic === 'tera' && p.canTera && !battle.playerTeraUsed && !p.isTerastallized) {
        // === å¤ªæ™¶åŒ–å¤„ç† ===
        battle.playerMegaArmed = false;
        battle.playerTeraUsed = true;
        const oldName = p.cnName;
        const oldTypes = [...p.types];
        const teraType = p.teraType;
        log(`<div style="border-bottom: 2px solid #22d3ee; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#22d3ee">ğŸ’ TERASTALLIZE !!! ğŸ’</b>`);
        log(`${oldName} çš„èº«ä½“å¼€å§‹ç»“æ™¶åŒ–ï¼é—ªè€€ç€ ${teraType} å±æ€§çš„å…‰èŠ’ï¼`);
        await wait(600);
        // æ’­æ”¾å¤ªæ™¶åŒ–åŠ¨ç”»
        const playerSprite = document.getElementById('player-sprite');
        if (playerSprite) {
            // æ·»åŠ å±æ€§é¢œè‰²ç±»
            playerSprite.classList.add('tera-burst', `tera-type-${teraType.toLowerCase()}`);
            await wait(800);
            playerSprite.classList.remove('tera-burst');
            playerSprite.classList.add('state-terastal');
        }
        // æ‰§è¡Œå¤ªæ™¶åŒ–ï¼šå±æ€§å˜æ›´
        p.isTerastallized = true;
        p.originalTypes = oldTypes; // ä¿å­˜åŸå§‹å±æ€§ï¼ˆç”¨äº STAB å›æº¯ï¼‰
        p.types = [teraType]; // å±æ€§å˜ä¸ºå•ä¸€å¤ªæ™¶å±æ€§
        log(`<b style="color:#22d3ee">${oldName} å¤ªæ™¶åŒ–äº†ï¼</b>`);
        log(`<span style="color:#67e8f9">å±æ€§å˜åŒ–: ${oldTypes.join('/')} â†’ <b>${teraType}</b></span>`);
        updateAllVisuals('player');
        await wait(800);
    }
    // =====================================================
    // === æ•Œæ–¹ AI Mega/Dynamax/Tera è§¦å‘é€»è¾‘ ===
    // =====================================================
    // ã€ä¿®å¤ã€‘ä¸‰ç§æœºåˆ¶ç‹¬ç«‹è®¡æ•°ï¼Œä¸å†å…±ç”¨ enemyMegaUsed
    // ã€è§£é”æ£€æŸ¥ã€‘å¿…é¡»æ£€æŸ¥ enemyUnlocks é…ç½®
    const enemyUnlocks = battle.enemyUnlocks || {};
    const isEnemyDynamax = (e.mechanic === 'dynamax') ||
                           (e.evolutionType === 'dynamax') || 
                           (e.canDynamax && e.mechanic !== 'mega' && e.mechanic !== 'tera') || 
                           (e.megaTargetId && e.megaTargetId.includes('gmax') && e.mechanic !== 'mega');
    // ã€è§£é”æ£€æŸ¥ã€‘Mega éœ€è¦ enable_megaï¼ŒDynamax éœ€è¦ enable_dynamax
    const canEnemyMega = enemyUnlocks.enable_mega && e.mechanic === 'mega' && (canMegaEvolveFunc && canMegaEvolveFunc(e));
    const canEnemyDynamax = enemyUnlocks.enable_dynamax && isEnemyDynamax && !e.isDynamaxed;
    // Mega è¿›åŒ–ï¼šæ£€æŸ¥ enemyMegaUsed
    // Dynamaxï¼šæ£€æŸ¥ enemyMaxUsed
    // Teraï¼šæ£€æŸ¥ enemyTeraUsedï¼ˆå·²åœ¨ä¸‹æ–¹å•ç‹¬å¤„ç†ï¼‰
    const shouldTriggerMega = canEnemyMega && !battle.enemyMegaUsed;
    const shouldTriggerDynamax = canEnemyDynamax && !battle.enemyMaxUsed;
    // === æ•Œæ–¹æå·¨åŒ–å¤„ç† ===
    if (shouldTriggerDynamax) {
        battle.enemyMaxUsed = true;
        const oldEnemyName = e.cnName;
        const oldMaxHp = e.maxHp;
        const oldCurrHp = e.currHp;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        // è¯»å–è®­ç»ƒå®¶ç‰¹æ®Šå°è¯
        if (battle.trainer && battle.trainer.lines && battle.trainer.lines.gmax_trigger) {
            log(`<i>${trainerName}: "${battle.trainer.lines.gmax_trigger}"</i>`);
        }
        log(`<div style="border-bottom: 2px solid #e11d48; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#e11d48">â–‚â–ƒâ–…â–†â–‡ DYNAMAX !!! â–‡â–†â–…â–ƒâ–‚</b>`);
        log(`${trainerName} çš„ ${oldEnemyName} å¼€å§‹æ€¥å‰§è†¨èƒ€ï¼ç©ºæ°”åœ¨éœ‡åŠ¨ï¼`);
        await wait(600);
        // ä¿å­˜åŸå§‹åç§°ï¼Œç”¨äºå›é€€
        e.originalName = e.name;
        // æ’­æ”¾æå·¨åŒ–çˆ†å‘åŠ¨ç”» + åˆ‡æ¢å›¾ç‰‡
        const spriteEl = document.getElementById('enemy-sprite');
        if (spriteEl) {
            spriteEl.classList.add('dynamax-burst');
            await wait(400);
            // æ£€æŸ¥æ˜¯å¦æœ‰ G-Max å½¢æ€ï¼ˆmegaTargetId åŒ…å« gmaxï¼‰
            // ã€å…³é”®ã€‘é€šç”¨æå·¨åŒ– (isGenericDynamax) ä¸åˆ‡æ¢å›¾ç‰‡ï¼Œåªç”¨ CSS æ”¾å¤§
            const gmaxFormId = e.megaTargetId;
            if (gmaxFormId && gmaxFormId.includes('gmax') && !e.isGenericDynamax) {
                // [BUG FIX] æ ¼å¼è½¬æ¢ï¼šcharizardgmax -> Charizard-Gmax
                const baseName = gmaxFormId.replace(/gmax$/i, '');
                const formattedName = baseName.charAt(0).toUpperCase() + baseName.slice(1) + '-Gmax';
                e.name = formattedName;
                // ã€å¼ºåˆ¶ä¿®æ­£ã€‘G-Max å½¢æ€ä¸­æ–‡åï¼šä¼˜å…ˆç¿»è¯‘ï¼Œå›é€€æ—¶å¼ºåˆ¶åŠ "è¶…æå·¨"å‰ç¼€
                if (window.Locale) {
                    const translatedName = window.Locale.get(formattedName);
                    // æ£€æŸ¥æ˜¯å¦æˆåŠŸç¿»è¯‘ï¼ˆç¿»è¯‘åä¸ç­‰äºåŸåï¼Œä¸”ä¸ç­‰äºåŸºç¡€å½¢æ€åï¼‰
                    const baseTranslated = window.Locale.get(baseName.charAt(0).toUpperCase() + baseName.slice(1));
                    if (translatedName !== formattedName && translatedName !== baseTranslated) {
                        // æˆåŠŸç¿»è¯‘åˆ° G-Max å½¢æ€ï¼ˆå¦‚ "è¶…æå·¨å–·ç«é¾™"ï¼‰
                        e.cnName = translatedName;
                    } else {
                        // ç¿»è¯‘å¤±è´¥ï¼Œå¼ºåˆ¶æ·»åŠ "è¶…æå·¨"å‰ç¼€
                        e.cnName = 'è¶…æå·¨' + baseTranslated;
                    }
                } else {
                    e.cnName = formattedName;
                }
                const gmaxSpriteId = gmaxFormId.replace(/gmax$/i, '-gmax');
                const gmaxSpriteUrl = `https://play.pokemonshowdown.com/sprites/ani/${gmaxSpriteId}.gif`;
                smartLoadSprite('enemy-sprite', gmaxSpriteUrl, false);
            } else if (e.isGenericDynamax) {
                console.log(`[DYNAMAX] æ•Œæ–¹é€šç”¨æå·¨åŒ–ï¼Œä¿æŒåŸå§‹ç²¾çµå›¾: ${e.name}`);
            }
            // å¦åˆ™ä¿æŒåŸç²¾çµå›¾ï¼Œåªåº”ç”¨æ”¾å¤§æ•ˆæœ
            await wait(400);
            spriteEl.classList.remove('dynamax-burst');
            spriteEl.classList.add('state-dynamax');
        }
        // HP å€ç‡ x1.5
        const hpMultiplier = 1.5;
        e.maxHp = Math.floor(oldMaxHp * hpMultiplier);
        e.currHp = Math.floor(oldCurrHp * hpMultiplier);
        // è®¾ç½®æå·¨åŒ–çŠ¶æ€
        e.isDynamaxed = true;
        e.dynamaxTurns = 3;
        e.preDynamaxMaxHp = oldMaxHp;
        e.preDynamaxCurrHp = oldCurrHp;
        // ã€å…³é”®ã€‘æ‹›å¼è½¬æ¢ä¸ºæå·¨æ‹›å¼
        applyDynamaxState(e, true);
        log(`<b style="color:#e11d48">${oldEnemyName} æå·¨åŒ–äº†ï¼(HP x${hpMultiplier})</b>`);
        log(`<span style="color:#ff6b8a">[æ•Œæ–¹æå·¨åŒ–å‰©ä½™å›åˆ: ${e.dynamaxTurns}]</span>`);
        updateAllVisuals('enemy');
        await wait(800);
    }
    // === æ•Œæ–¹ Mega è¿›åŒ–å¤„ç† ===
    if (shouldTriggerMega) {
        battle.enemyMegaUsed = true;
        const oldEnemyName = e.cnName;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        log(`<div style="border-bottom: 2px solid #ef4444; margin-bottom: 5px;"></div>`);
        log(`å¯¹æ‰‹çš„ ${oldEnemyName} çš„è¿›åŒ–çŸ³å¯¹ ${trainerName} çš„é’¥çŸ³äº§ç”Ÿäº†ååº”ï¼`);
        await wait(600);
        // å°è¯•æ‰§è¡Œ Mega è¿›åŒ–
        const megaResult = performMegaEvolutionFunc ? performMegaEvolutionFunc(e) : null;
        if (megaResult) {
            await playMegaEvolutionAnimation(e, false);
            log(`<b style="color:#fca5a5">å¯¹æ‰‹çš„ ${oldEnemyName} Mega è¿›åŒ–æˆäº† ${megaResult.newName}ï¼</b>`);
            if (megaResult.typeChanged) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">å¯¹æ‰‹çš„ ${megaResult.newName} å˜æˆäº† ${megaResult.newTypes.join('/')} å±æ€§ï¼</span>`);
            }
            if (megaResult.abilityChanged && megaResult.newAbility) {
                log(`<span style="font-size:0.9em; color:#9ca3af;">è·å¾—äº†ç‰¹æ€§ <b>${megaResult.newAbility}</b>ï¼</span>`);
                triggerEntryAbilities(e, p);
            }
        } else {
            // mechanic è®¾ç½®ä¸º mega ä½†æ²¡æœ‰å®é™… Mega æ•°æ®ï¼Œè·³è¿‡æ¼”å‡º
            console.warn(`[MEGA] ${e.name} è®¾ç½®äº† mechanic: 'mega' ä½†æ²¡æœ‰ Mega å½¢æ€æ•°æ®ï¼Œè·³è¿‡`);
            battle.enemyMegaUsed = false; // å›æ»šä½¿ç”¨æ ‡è®°
        }
        updateAllVisuals('enemy');
        await wait(800);
    }
    // === æ•Œæ–¹ AI å¤ªæ™¶åŒ–å¤„ç† ===
    // ã€è§£é”æ£€æŸ¥ã€‘Tera éœ€è¦ enable_tera
    if (enemyUnlocks.enable_tera && e.mechanic === 'tera' && e.canTera && !battle.enemyTeraUsed && !e.isTerastallized) {
        // AI å†³ç­–ï¼šç¬¬ä¸€å›åˆç«‹å³å¤ªæ™¶åŒ–
        battle.enemyTeraUsed = true;
        const oldEnemyName = e.cnName;
        const oldTypes = [...e.types];
        const teraType = e.teraType;
        const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
        log(`<div style="border-bottom: 2px solid #22d3ee; margin-bottom: 5px;"></div>`);
        log(`<b style="font-size:1.2em; color:#22d3ee">ğŸ’ TERASTALLIZE !!! ğŸ’</b>`);
        log(`${trainerName} çš„ ${oldEnemyName} å¼€å§‹ç»“æ™¶åŒ–ï¼é—ªè€€ç€ ${teraType} å±æ€§çš„å…‰èŠ’ï¼`);
        await wait(600);
        // æ’­æ”¾å¤ªæ™¶åŒ–åŠ¨ç”»
        const enemySprite = document.getElementById('enemy-sprite');
        if (enemySprite) {
            enemySprite.classList.add('tera-burst', `tera-type-${teraType.toLowerCase()}`);
            await wait(800);
            enemySprite.classList.remove('tera-burst');
            enemySprite.classList.add('state-terastal');
        }
        // æ‰§è¡Œå¤ªæ™¶åŒ–ï¼šå±æ€§å˜æ›´
        e.isTerastallized = true;
        e.originalTypes = oldTypes;
        e.types = [teraType];
        log(`<b style="color:#22d3ee">${trainerName} çš„ ${oldEnemyName} å¤ªæ™¶åŒ–äº†ï¼</b>`);
        log(`<span style="color:#67e8f9">å±æ€§å˜åŒ–: ${oldTypes.join('/')} â†’ <b>${teraType}</b></span>`);
        updateAllVisuals('enemy');
        await wait(800);
    }
    // =====================================================
    // === æ•Œæ–¹ AI ç¾ç»Šå…±é¸£ (Bond Resonance) è§¦å‘é€»è¾‘ ===
    // =====================================================
    // ã€è§£é”æ£€æŸ¥ã€‘Bond éœ€è¦ enable_bond
    // ã€å…¨å±€é™åˆ¶ã€‘æ¯åœºæˆ˜æ–—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ Bond Resonance
    if (enemyUnlocks.enable_bond && e.isAce && !battle.enemyBondUsed && !e.hasBondResonance && !e.hasEvolvedThisBattle) {
        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³è§¦å‘æ¡ä»¶
        const eHpRatio = e.currHp / e.maxHp;
        const eAvs = e.avs || { trust: 0, passion: 0, insight: 0, devotion: 0 };
        const eTotalAVs = (e.getEffectiveAVs?.('trust') || eAvs.trust || 0) + 
                         (e.getEffectiveAVs?.('passion') || eAvs.passion || 0) + 
                         (e.getEffectiveAVs?.('insight') || eAvs.insight || 0) + 
                         (e.getEffectiveAVs?.('devotion') || eAvs.devotion || 0);
        // æ¡ä»¶ï¼šAce å®å¯æ¢¦ + AVs >= 300
        const meetsAVsReq = eTotalAVs >= 300;
        // ã€ä¸¥æ ¼åŠ£åŠ¿åˆ¤æ–­ã€‘
        // è®¡ç®—åŒæ–¹æ€»è¡€é‡
        let enemyTotalHp = 0, enemyTotalMaxHp = 0;
        let playerTotalHp = 0, playerTotalMaxHp = 0;
        battle.enemyParty.forEach(ep => {
            if (ep && typeof ep.isAlive === 'function') {
                enemyTotalMaxHp += ep.maxHp || 0;
                enemyTotalHp += Math.max(0, ep.currHp || 0);
            }
        });
        battle.playerParty.forEach(pp => {
            if (pp && typeof pp.isAlive === 'function') {
                playerTotalMaxHp += pp.maxHp || 0;
                playerTotalHp += Math.max(0, pp.currHp || 0);
            }
        });
        const aliveEnemies = battle.enemyParty.filter(ep => ep && typeof ep.isAlive === 'function' && ep.isAlive()).length;
        const alivePlayers = battle.playerParty.filter(pp => pp && typeof pp.isAlive === 'function' && pp.isAlive()).length;
        const isLastStand = aliveEnemies === 1;
        // ã€ä¸¥æ ¼åŠ£åŠ¿æ¡ä»¶ã€‘
        // æ ¸å¿ƒæ¡ä»¶ï¼šå¿…é¡»æ˜¯æœ€åä¸€åªå®å¯æ¢¦ ä¸” HP <= 50%
        // å°è§„æ¨¡æˆ˜æ–—ï¼ˆåŒæ–¹å„ <= 2 åªï¼‰æ—¶ï¼Œå…è®¸è¡€é‡åŠ£åŠ¿è§¦å‘
        const currentPokemonCritical = eHpRatio <= 0.50;
        const isSmallBattle = (battle.enemyParty.length <= 2 && battle.playerParty.length <= 2);
        const isHpDisadvantage = enemyTotalHp < playerTotalHp * 0.5;
        // è§¦å‘æ¡ä»¶ï¼š
        // 1. æœ€åä¸€åªå®å¯æ¢¦ + HP <= 50%
        // 2. æˆ–è€… å°è§„æ¨¡æˆ˜æ–— + è¡€é‡åŠ£åŠ¿ + HP <= 50%
        const canTriggerBond = meetsAVsReq && currentPokemonCritical && (isLastStand || (isSmallBattle && isHpDisadvantage));
        if (canTriggerBond) {
            e.hasBondResonance = true;
            battle.enemyBondUsed = true; // ã€å…¨å±€é™åˆ¶ã€‘æ ‡è®°å·²ä½¿ç”¨
            const trainerName = battle.trainer?.name || 'å¯¹æ‰‹';
            log(`<div style="border-top: 2px solid #ef4444; border-bottom: 2px solid #ef4444; padding: 8px; text-align: center; margin: 10px 0; background: linear-gradient(90deg, rgba(239,68,68,0.1), rgba(239,68,68,0.3), rgba(239,68,68,0.1));">`);
            log(`<b style="font-size:1.4em; color:#ef4444; text-shadow: 0 0 10px #dc2626;">âˆ BOND RESONANCE âˆ</b>`);
            log(`</div>`);
            await wait(500);
            log(`${trainerName} ä¸ ${e.cnName} çš„å¿ƒè·³å®Œå…¨é‡åˆäº†â€¦â€¦`);
            await wait(400);
            log(`ä¸ºäº†å›åº”å½»åº•çš„ä¿¡èµ– <span style="color:#facc15">(Total AVs: ${eTotalAVs})</span>ï¼Œæ²‰ç¡åœ¨ä½“å†…çš„ç•Œé™è¢«æ‰“ç ´äº†ï¼`);
            // åŠ¨ç”»ï¼šçº¢è‰²å…‰æ™•çˆ†å‘
            const enemySprite = document.getElementById('enemy-sprite');
            if (enemySprite) {
                enemySprite.classList.add('evo-burst');
                enemySprite.style.filter = 'brightness(3) drop-shadow(0 0 20px #ef4444)';
            }
            await wait(400);
            if (enemySprite) {
                enemySprite.classList.remove('evo-burst');
                enemySprite.classList.add('evo-finish');
                enemySprite.style.filter = 'drop-shadow(0 0 15px #ef4444) brightness(1.15) saturate(1.2)';
            }
            await wait(600);
            if (enemySprite) {
                enemySprite.classList.remove('evo-finish');
                enemySprite.classList.add('bond-resonance');
            }
            // æ•°æ®å˜æ›´
            // 1. HP å›å¤ +60%
            const healAmount = Math.floor(e.maxHp * 0.6);
            e.currHp = Math.min(e.currHp + healAmount, e.maxHp);
            // 2. æ¸…é™¤å¼‚å¸¸
            e.status = null;
            // 3. å…¨èƒ½åŠ›+1
            if (typeof e.applyBoost === 'function') {
                e.applyBoost('atk', 1);
                e.applyBoost('def', 1);
                e.applyBoost('spa', 1);
                e.applyBoost('spd', 1);
                e.applyBoost('spe', 1);
            }
            log(`<b style="color:#ef4444">âœ¦ ${trainerName} çš„ ${e.cnName} æ½œèƒ½è¢«å”¤é†’! å…¨å±æ€§æå¤§å¹…æå‡!</b>`);
            log(`<span style="color:#60a5fa">âœ¦ æ°”åŠ¿(HP)å¤§å¹…å›å¤ï¼(+${healAmount})</span>`);
            if (isLastStand) {
                log(`<span style="color:#f87171; font-style:italic;">ã€Œ${trainerName}: è¿™æ˜¯æˆ‘ä»¬æœ€åçš„åå‡»ï¼ã€</span>`);
            }
            updateAllVisuals('enemy');
            await wait(800);
        }
    }
    // === è·å–æ•Œæ–¹ AI å†³ç­– (æ”¯æŒæ¢äºº) ===
    let enemyMove = null;
    let enemyAction = null;
    let enemyWillSwitch = false;
    let switchTargetIndex = -1;
    // ä¼˜å…ˆä½¿ç”¨æ–°çš„ AI å¼•æ“
    if (typeof window.getAiAction === 'function') {
        enemyAction = window.getAiAction(e, p, battle.aiDifficulty || 'normal', battle.enemyParty, {
            turnCount: battle.turnCount || 1
        });
    }
    // æ£€æŸ¥ AI æ˜¯å¦å†³å®šæ¢äºº
    if (enemyAction && enemyAction.type === 'switch' && typeof enemyAction.index === 'number') {
        const switchTarget = battle.enemyParty[enemyAction.index];
        // ä¸¥æ ¼æ£€æŸ¥ï¼šç›®æ ‡å¿…é¡»å­˜åœ¨ã€å­˜æ´»ã€ä¸æ˜¯å½“å‰å®å¯æ¢¦ã€HP > 0
        const targetIsValid = switchTarget && 
            typeof switchTarget.isAlive === 'function' && 
            switchTarget.isAlive() && 
            switchTarget.currHp > 0 &&
            switchTarget !== e;
        // ã€æŠ“äººæœºåˆ¶ã€‘æ£€æŸ¥æ•Œæ–¹æ˜¯å¦è¢«å›°ä½
        let enemyCanSwitch = true;
        if (typeof window.canEnemySwitch === 'function') {
            const switchCheck = window.canEnemySwitch();
            if (!switchCheck.canSwitch) {
                enemyCanSwitch = false;
                console.log(`[AI] Enemy cannot switch: ${switchCheck.reason}`);
            }
        }
        if (targetIsValid && enemyCanSwitch) {
            enemyWillSwitch = true;
            switchTargetIndex = enemyAction.index;
            if (enemyAction.reasoning) {
                console.log(`[AI] Switch reasoning: ${enemyAction.reasoning}`);
            }
        }
    }
    // è·å–æ•Œæ–¹æ”»å‡»æ‹›å¼ï¼ˆå¦‚æœä¸æ¢äººï¼‰
    if (!enemyWillSwitch) {
        if (enemyAction && enemyAction.move) {
            enemyMove = enemyAction.move;
            if (enemyAction.reasoning) {
                console.log(`[AI] Move reasoning: ${enemyAction.reasoning}`);
            }
        }
        // å›é€€åˆ°æ—§ AI
        if (!enemyMove && typeof window.getAiMove === 'function') {
            enemyMove = window.getAiMove(e, p, battle.aiDifficulty || 'normal');
        }
        if (!enemyMove) {
            enemyMove = e.moves[Math.floor(Math.random() * e.moves.length)];
        }
        // === ã€ä¿®å¤ã€‘æ£€æŸ¥ Taunt ç­‰ Volatile çŠ¶æ€æ˜¯å¦é˜»æ­¢ AI ä½¿ç”¨è¯¥æŠ€èƒ½ ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.canUseMove && enemyMove) {
            const canUseResult = MoveEffects.canUseMove(e, enemyMove);
            if (!canUseResult.canUse) {
                log(`<span style="color:#e74c3c">${canUseResult.reason}</span>`);
                // å°è¯•é€‰æ‹©å…¶ä»–å¯ç”¨æŠ€èƒ½
                const availableMoves = e.moves.filter(m => {
                    const check = MoveEffects.canUseMove(e, m);
                    return check.canUse;
                });
                if (availableMoves.length > 0) {
                    enemyMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    console.log(`[AI] Taunt é˜»æ­¢äº†åŸæŠ€èƒ½ï¼Œæ”¹ç”¨: ${enemyMove.name}`);
                } else {
                    // æ²¡æœ‰å¯ç”¨æŠ€èƒ½ï¼Œä½¿ç”¨æŒ£æ‰
                    enemyMove = { name: 'Struggle', cn: 'æŒ£æ‰', power: 50, type: 'Normal', cat: 'phys' };
                    log(`<span style="color:#aaa">${e.cnName} æ— æŠ€å¯ç”¨ï¼Œåªèƒ½æŒ£æ‰!</span>`);
                }
            }
        }
        // =====================================================
        // === ã€AI Z æ‹›å¼æ¨å¯¼ã€‘ ===
        // =====================================================
        // å¦‚æœæ•Œæ–¹é…ç½®äº† mechanic='zmove' ä¸”è¿˜æ²¡ç”¨è¿‡ Z æ‹›å¼
        // ã€è§£é”æ£€æŸ¥ã€‘Z æ‹›å¼éœ€è¦ enable_z_move
        // ä¼˜å…ˆå¯»æ‰¾èƒ½è§¦å‘ä¸“å± Z çš„æ‹›å¼ï¼Œå¦åˆ™å°è¯•è½¬æ¢å½“å‰æ‹›å¼
        const enemyUnlocksForZ = battle.enemyUnlocks || {};
        if (enemyUnlocksForZ.enable_z_move && e.mechanic === 'zmove' && !battle.enemyZUsed && enemyMove) {
            let zTarget = null;
            let zBaseMove = null;
            // 1. ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æœ‰èƒ½è§¦å‘ä¸“å± Z çš„æ‹›å¼
            for (const move of e.moves) {
                const potentialZ = typeof getZMoveTarget === 'function' 
                    ? getZMoveTarget(move, e) 
                    : null;
                if (potentialZ && potentialZ.isExclusive) {
                    // æ‰¾åˆ°ä¸“å± Z æ‹›å¼ï¼
                    zTarget = potentialZ;
                    zBaseMove = move;
                    console.log(`[AI Z-MOVE] æ‰¾åˆ°ä¸“å± Z æ‹›å¼: ${move.name} -> ${potentialZ.name}`);
                    break;
                }
            }
            // 2. å¦‚æœæ²¡æœ‰ä¸“å± Zï¼Œå°è¯•ç”¨å½“å‰é€‰ä¸­çš„æ‹›å¼è½¬æ¢
            if (!zTarget) {
                zTarget = typeof getZMoveTarget === 'function' 
                    ? getZMoveTarget(enemyMove, e) 
                    : null;
                zBaseMove = enemyMove;
            }
            if (zTarget) {
                console.log(`[AI Z-MOVE] æ•Œæ–¹ AI æ¨å¯¼ Z æ‹›å¼: ${zBaseMove.name} -> ${zTarget.name} (å¨åŠ›: ${zTarget.power})`);
                // åˆ›å»º Z æ‹›å¼å¯¹è±¡
                enemyMove = {
                    name: zTarget.name,
                    type: zTarget.type || zBaseMove.type,
                    power: zTarget.power,
                    cat: zBaseMove.cat || 'phys',
                    accuracy: true, // Z æ‹›å¼å¿…ä¸­
                    isZ: true,
                    baseMove: zBaseMove.name // ä¿ç•™åŸå§‹æ‹›å¼å
                };
            }
        }
        // =====================================================
        // === ã€AI åˆšçŒ›/è¿…ç–¾é£æ ¼ v2.1ã€‘ (enable_styles) ===
        // =====================================================
        // åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®é€Ÿåº¦ä¼˜åŠ¿å†³å®šæƒ©ç½šç¨‹åº¦
        // è¿…ç–¾ (Agile): é€Ÿåº¦å¿«æ—¶0.75x(ä¿å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶0.5x(æŠ¢èŠ‚å¥)
        // åˆšçŒ› (Strong): é€Ÿåº¦å¿«æ—¶å¿…ä¸­(å–å…ˆæ‰‹)ï¼Œé€Ÿåº¦æ…¢æ—¶å‘½ä¸­0.8x(ç™½å«–)
        // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
        const enemyUnlocksForStyles = battle.enemyUnlocks || {};
        if (enemyUnlocksForStyles.enable_styles && enemyMove && !enemyMove.isZ) {
            // ã€å†·å´æ£€æŸ¥ã€‘å¦‚æœåœ¨å†·å´ä¸­ï¼ŒAI ä¸ä½¿ç”¨é£æ ¼
            if (battle.enemyStyleCooldown > 0) {
                console.log(`[AI STYLES] æ•Œæ–¹é£æ ¼ç³»ç»Ÿå†·å´ä¸­ï¼Œæœ¬å›åˆä½¿ç”¨æ™®é€šé£æ ¼`);
            } else {
                const originalPower = enemyMove.basePower || enemyMove.power || 0;
                const originalPriority = enemyMove.priority || 0;
                const originalAccuracy = enemyMove.accuracy;
                const isStatus = (enemyMove.category === 'Status' || enemyMove.cat === 'status' || originalPower === 0);
                // ã€v2.1ã€‘è®¡ç®—æœ‰æ•ˆé€Ÿåº¦ï¼Œåˆ¤æ–­é€Ÿåº¦ä¼˜åŠ¿
                let aiSpe = (typeof e.getStat === 'function') ? e.getStat('spe') : (e.spe || 100);
                let playerSpe = (typeof p.getStat === 'function') ? p.getStat('spe') : (p.spe || 100);
                // éº»ç—¹å‡é€Ÿ
                if (e.status === 'par') aiSpe = Math.floor(aiSpe * 0.5);
                if (p.status === 'par') playerSpe = Math.floor(playerSpe * 0.5);
                // æˆæ³•ç©ºé—´åˆ¤å®š
                const isTrickRoom = battle.field && battle.field.trickRoom > 0;
                let aiHasSpeedAdvantage = false;
                if (isTrickRoom) {
                    aiHasSpeedAdvantage = aiSpe < playerSpe; // ç©ºé—´ä¸‹ï¼šæ…¢å°±æ˜¯å¿«
                } else {
                    aiHasSpeedAdvantage = aiSpe > playerSpe; // æ­£å¸¸ï¼šå¿«å°±æ˜¯å¿«
                }
                // ã€v2.1ã€‘ä¼˜å…ˆä½¿ç”¨ AI å¼•æ“è¿”å›çš„é£æ ¼é€‰æ‹©
                let aiStyle = 'normal';
                if (enemyAction && enemyAction.style) {
                    aiStyle = enemyAction.style;
                    console.log(`[AI STYLES] ä½¿ç”¨ AI å¼•æ“æ¨èçš„é£æ ¼: ${aiStyle}`);
                }
                // ============================================
                // âš¡ AI è¿…ç–¾é£æ ¼ (Agile Style)
                // ============================================
                if (aiStyle === 'agile') {
                    // ã€å¹³è¡¡æ€§æ”¹åŠ¨ã€‘å˜åŒ–æŠ€ç¦æ­¢ä½¿ç”¨è¿…ç–¾
                    if (isStatus) {
                        console.log(`[AI STYLES] å˜åŒ–æŠ€æ— æ³•ä½¿ç”¨è¿…ç–¾ï¼Œæ”¹ç”¨æ™®é€šé£æ ¼`);
                    } else {
                        enemyMove = { ...enemyMove };
                        enemyMove.priority = originalPriority + 1;
                        enemyMove.styleUsed = 'agile';
                        const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                        if (aiHasSpeedAdvantage) {
                            // åœºæ™¯ A: æ‹¥æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ä¹°ä¿é™©æ±‚ç¨³ï¼Œé˜²å…ˆåˆ¶
                            enemyMove.basePower = Math.floor(originalPower * 0.75);
                            enemyMove.accuracy = Math.floor(oldAcc * 0.9); // å‘½ä¸­ç‡ 0.9x
                            log(`<span style="color:#3b82f6">âš¡ æ•Œæ–¹è¿…ç–¾Â·åˆ¶å˜ï¼šé€Ÿåº¦å‹åˆ¶ä¸‹ç¡®ä¿å…ˆæ‰‹ - å¨åŠ›Ã—0.75ï¼Œå‘½ä¸­Ã—0.9</span>`);
                            console.log(`[AI STYLES] è¿…ç–¾(å¿«): power 0.75x, acc 0.9x (${aiSpe} vs ${playerSpe})`);
                        } else {
                            // åœºæ™¯ B: æ²¡æœ‰é€Ÿåº¦ä¼˜åŠ¿ - ç»åœ°åå‡»ï¼Œå·å›åˆ
                            enemyMove.basePower = Math.floor(originalPower * 0.50);
                            enemyMove.accuracy = Math.floor(oldAcc * 0.85); // å‘½ä¸­ç‡ 0.85x
                            log(`<span style="color:#60a5fa">âš¡ æ•Œæ–¹è¿…ç–¾Â·ç¥é€Ÿï¼šé€†è½¬è¡ŒåŠ¨é¡ºä½ - å¨åŠ›Ã—0.50ï¼Œå‘½ä¸­Ã—0.85</span>`);
                            console.log(`[AI STYLES] è¿…ç–¾(æ…¢): power 0.5x, acc 0.85x (${aiSpe} vs ${playerSpe})`);
                        }
                        enemyMove.power = enemyMove.basePower;
                        // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                        battle.enemyStyleCooldown = 1;
                    }
                } 
                // ============================================
                // ğŸ’ª AI åˆšçŒ›é£æ ¼ (Strong Style)
                // ============================================
                else if (aiStyle === 'strong') {
                    enemyMove = { ...enemyMove };
                    enemyMove.priority = originalPriority - 1;
                    enemyMove.basePower = Math.floor(originalPower * 1.30);
                    enemyMove.power = enemyMove.basePower;
                    enemyMove.breaksProtect = true; // å¯ç©¿é€å®ˆä½
                    enemyMove.styleUsed = 'strong';
                    if (!aiHasSpeedAdvantage) {
                        // åœºæ™¯ A: é€Ÿåº¦åŠ£åŠ¿ (æœ¬æ¥å°±æ…¢) - æ²¡ä»˜å‡ºä»£ä»·ï¼Œé™å‘½ä¸­
                        const oldAcc = (typeof originalAccuracy === 'number') ? originalAccuracy : 100;
                        enemyMove.accuracy = Math.floor(oldAcc * 0.8);
                        log(`<span style="color:#ef4444">ğŸ’ª æ•Œæ–¹åˆšçŒ›Â·èˆèº«ï¼šé€Ÿåº¦åŠ£åŠ¿ä¸‹çš„å¼ºæ”» - å¨åŠ›Ã—1.3ï¼Œå‘½ä¸­Ã—0.8</span>`);
                        console.log(`[AI STYLES] åˆšçŒ›(æ…¢): power 1.3x, acc 0.8x (${aiSpe} vs ${playerSpe})`);
                    } else {
                        // åœºæ™¯ B: é€Ÿåº¦ä¼˜åŠ¿ (æœ¬æ¥è¯¥AIå…ˆ) - å–å…ˆæ‰‹æ¢ä¼¤å®³ï¼Œä¸ä¿®æ­£å‘½ä¸­
                        // ã€v2.3ã€‘ä¸å†å¿…ä¸­ï¼Œä¿æŒåŸå‘½ä¸­ç‡
                        log(`<span style="color:#b91c1c">ğŸ’ª æ•Œæ–¹åˆšçŒ›Â·è“„åŠ›ï¼šæ”¾å¼ƒå…ˆæ‰‹ï¼Œå…¨åŠ›ä¸€å‡»ï¼(å¨åŠ›Ã—1.3ï¼Œè´¯ç©¿å®ˆä½)</span>`);
                        console.log(`[AI STYLES] åˆšçŒ›(å¿«): power 1.3x, acc unchanged (${aiSpe} vs ${playerSpe})`);
                    }
                    // ã€å†·å´ã€‘ä½¿ç”¨åè¿›å…¥ 1 å›åˆå†·å´
                    battle.enemyStyleCooldown = 1;
                }
            }
        }
    }
    // ========================================
    // å›åˆæ‰§è¡Œé¡ºåºï¼ˆæ­£ç¡®çš„å®å¯æ¢¦æˆ˜æ–—æµç¨‹ï¼‰ï¼š
    // 1. æ¢äººå…ˆæ‰§è¡Œï¼ˆæ¢äººä¼˜å…ˆçº§æœ€é«˜ï¼Œåœ¨æ”»å‡»ä¹‹å‰ï¼‰
    // 2. ç„¶åæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§æ‰§è¡Œæ”»å‡»
    // ========================================
    // === é˜¶æ®µ 1ï¼šæ•Œæ–¹æ¢äººï¼ˆåœ¨ç©å®¶æ”»å‡»ä¹‹å‰ï¼‰ ===
    if (enemyWillSwitch) {
        log(`<span style="color:#ef4444">æ•Œæ–¹æ”¶å›äº† ${e.cnName}ï¼</span>`);
        // ã€ä¿®å¤ã€‘æ¸…é™¤ Choice é”æ‹›çŠ¶æ€ï¼ˆæ¢äººè§£é™¤é”æ‹›ï¼‰
        if (e.choiceLockedMove) {
            console.log(`[CHOICE] ${e.name} æ¢ä¸‹ï¼Œè§£é™¤ ${e.choiceLockedMove} é”å®š`);
            delete e.choiceLockedMove;
        }
        // é‡ç½®å½“å‰å®å¯æ¢¦èƒ½åŠ›ç­‰çº§
        if (typeof e.resetBoosts === 'function') {
            e.resetBoosts();
        }
        battle.enemyActive = switchTargetIndex;
        const newE = battle.getEnemy();
        log(`<span style="color:#ef4444">æ•Œæ–¹æ´¾å‡ºäº† ${newE.cnName}ï¼</span>`);
        // ã€æ ‡è®°æ¢äººã€‘ç”¨äºé‡å¤ç²¾çµå›¾ä¿®å¤
        if (typeof window.markEnemySwitch === 'function') {
            window.markEnemySwitch();
        }
        // æ£€æŸ¥è¿›åœºå˜å½¢
        const checkInitTransformFunc = typeof window.checkInitTransform === 'function' ? window.checkInitTransform : null;
        if (checkInitTransformFunc && newE.needsInitTransform) {
            const result = checkInitTransformFunc(newE);
            if (result) {
                log(`<span style="color:#ef4444">âœ¦ æ•Œæ–¹ ${result.oldName} å˜ä¸º ${result.newName}ï¼</span>`);
            }
        }
        updateAllVisuals('enemy');
        await wait(500);
        triggerEntryAbilities(newE, p);
        // === ç»“ç®—æ•Œæ–¹åœºåœ°é’‰å­ä¼¤å®³ ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
            const hazardLogs = MoveEffects.applyEntryHazards(newE, false, battle);
            hazardLogs.forEach(msg => log(msg));
            if (hazardLogs.length > 0) updateAllVisuals();
        }
        // æ›´æ–°æ•Œæ–¹å¼•ç”¨ä¸ºæ–°å®å¯æ¢¦
        e = newE;
    }
    // === é˜¶æ®µ 2ï¼šæ‰§è¡Œæ”»å‡»ï¼ˆæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§é¡ºåºï¼‰ ===
    // å¦‚æœæ•Œæ–¹æ¢äººäº†ï¼Œå®ƒè¿™å›åˆä¸æ”»å‡»ï¼Œåªæœ‰ç©å®¶æ”»å‡»
    if (enemyWillSwitch) {
        console.log('[handleAttack] Enemy switched, player attacks only');
        // ç©å®¶æ”»å‡»æ¢å…¥çš„å®å¯æ¢¦
        const playerResult = await executePlayerTurn(p, e, playerMove);
        if (!e.isAlive()) {
            await handleEnemyFainted(e);
            return;
        }
        // ç©å®¶ä½¿ç”¨äº† pivot æŠ€èƒ½ï¼Œè§¦å‘æ¢äºº
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            console.log('[handleAttack] Player pivot in enemySwitch branch, calling handlePlayerPivot...');
            try {
                await handlePlayerPivot();
                console.log('[handleAttack] handlePlayerPivot Promise resolved successfully');
            } catch (err) {
                console.error('[handleAttack] handlePlayerPivot error:', err);
            }
        }
        // å›åˆæœ«ç»“ç®—
        console.log('[handleAttack] Calling executeEndPhase...');
        const currentP = battle.getPlayer();
        const currentE = battle.getEnemy();
        await executeEndPhase(currentP, currentE);
        console.log('[handleAttack] executeEndPhase returned');
        return;
    }
    // === é˜¶æ®µ 2bï¼šåŒæ–¹éƒ½æ”»å‡»ï¼ŒæŒ‰é€Ÿåº¦/ä¼˜å…ˆçº§é¡ºåº ===
    // === è®¡ç®—è¡ŒåŠ¨é¡ºåº (Priority + Speed) ===
    // æ³¨æ„ï¼šGen7+ è§„åˆ™ï¼ŒMega è¿›åŒ–åé€Ÿåº¦ç«‹å³ç”Ÿæ•ˆ
    const playerPriority = typeof window.getMovePriority === 'function' 
        ? window.getMovePriority(playerMove) : 0;
    const enemyPriority = typeof window.getMovePriority === 'function' 
        ? window.getMovePriority(enemyMove) : 0;
    let playerFirst = true;
    if (playerPriority !== enemyPriority) {
        // ä¼˜å…ˆçº§ä¸åŒï¼Œé«˜ä¼˜å…ˆçº§å…ˆåŠ¨
        playerFirst = playerPriority > enemyPriority;
        console.log(`[Speed Check] Priority differs: P(${playerMove?.name || playerMove?.cn}) prio=${playerPriority} vs E(${enemyMove?.name || enemyMove?.cn}) prio=${enemyPriority} => PlayerFirst? ${playerFirst}`);
    } else {
        // ä¼˜å…ˆçº§ç›¸åŒï¼Œæ¯”è¾ƒé€Ÿåº¦
        let playerSpeed = p.getStat('spe');
        let enemySpeed = e.getStat('spe');
        // =========================================================
        // åœºåœ°çŠ¶æ€å¯¹é€Ÿåº¦çš„å½±å“
        // =========================================================
        // Tailwind (é¡ºé£): é€Ÿåº¦ç¿»å€
        if (battle.playerSide && battle.playerSide.tailwind > 0) {
            playerSpeed *= 2;
            console.log(`[Speed Check] Player has Tailwind! Speed doubled.`);
        }
        if (battle.enemySide && battle.enemySide.tailwind > 0) {
            enemySpeed *= 2;
            console.log(`[Speed Check] Enemy has Tailwind! Speed doubled.`);
        }
        console.log(`[Speed Check] ${p.cnName}(base spe=${p.spe}, effective=${playerSpeed}) vs ${e.cnName}(base spe=${e.spe}, effective=${enemySpeed})`);
        // Trick Room (æˆæ³•ç©ºé—´): é€Ÿåº¦æ…¢çš„å…ˆåŠ¨
        const isTrickRoom = battle.field && battle.field.trickRoom > 0;
        if (playerSpeed !== enemySpeed) {
            if (isTrickRoom) {
                // ç©ºé—´ä¸‹ï¼šæ…¢çš„å…ˆåŠ¨
                playerFirst = playerSpeed < enemySpeed;
                console.log(`[Speed Check] TRICK ROOM active! Slower moves first. PlayerFirst? ${playerFirst}`);
            } else {
                // æ­£å¸¸ï¼šå¿«çš„å…ˆåŠ¨
                playerFirst = playerSpeed > enemySpeed;
            }
        } else {
            // é€Ÿåº¦ç›¸åŒï¼Œéšæœºå†³å®š
            playerFirst = Math.random() < 0.5;
            console.log(`[Speed Check] Same speed, random result: PlayerFirst? ${playerFirst}`);
        }
        console.log(`[Speed Check] Result: PlayerFirst? ${playerFirst}${isTrickRoom ? ' (Trick Room)' : ''}`);
    }
    // === æ‰§è¡Œå›åˆ ===
    // æ­£ç¡®çš„ Pivot æ—¶åºï¼šå…ˆæ‰‹æ”»å‡» -> å…ˆæ‰‹ Pivot æ¢äºº -> åæ‰‹æ”»å‡»æ‰“æ–°æ€ª -> åæ‰‹ Pivot æ¢äºº
    if (playerFirst) {
        // ========== ç©å®¶å…ˆåŠ¨ ==========
        console.log('[handleAttack] Player moves first');
        const playerResult = await executePlayerTurn(p, e, playerMove);
        // ã€ä¿®å¤ã€‘Post-Move Check: ç©å®¶ä½¿ç”¨è‡ªæ€æ‹›å¼åç«‹å³å¤„ç†å€’ä¸‹
        if (!p.isAlive()) {
            console.log('[handleAttack] Player fainted after self-KO move in player-first branch');
            await handlePlayerFainted(p);
            // ã€ä¿®å¤ã€‘ç©å®¶è‡ªæ€æ‹›å¼åå€’ä¸‹ï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆæ•Œæ–¹æå·¨åŒ– tick ç­‰ï¼‰
            const newP = battle.getPlayer();
            const currentE = battle.getEnemy();
            if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
                await executeEndPhase(newP, currentE);
            }
            return;
        }
        // ã€ä¿®å¤ã€‘U-turn/Volt Switch æ—¶åºï¼šå…ˆå¤„ç† Pivot æ¢äººï¼Œå†å¤„ç†æ•Œæ–¹å€’ä¸‹
        // æ­£ä½œé€»è¾‘ï¼šå³ä½¿å‡»æ€å¯¹æ‰‹ï¼Œä½¿ç”¨è€…ä¹Ÿå¿…é¡»å…ˆæ¢äºº
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            const oldP = battle.getPlayer();
            const moveName = playerMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldP.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldP.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldP.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            console.log('[handleAttack] Player pivot triggered, waiting for switch...');
            await handlePlayerPivot();
            p = battle.getPlayer();
            console.log('[handleAttack] Player pivot complete, new pokemon:', p?.cnName);
        } else if (playerResult?.pivot) {
            log(`<span style="color:#999">ä½†æ˜¯æ²¡æœ‰å¯ä»¥æ¢å…¥çš„å®å¯æ¢¦äº†!</span>`);
        }
        // æ•Œæ–¹å€’ä¸‹åˆ¤å®šï¼ˆåœ¨ pivot æ¢äººä¹‹åï¼‰
        // ã€å…³é”®ä¿®å¤ã€‘åŒæ—¶æ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹ï¼ˆç²—ç³™çš®è‚¤/é“åˆºç­‰æ¥è§¦ä¼¤å®³å¯¼è‡´åŒæ–¹åŒæ—¶å€’ä¸‹ï¼‰
        if (!e.isAlive()) {
            // å…ˆæ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹
            if (!p.isAlive()) {
                console.log('[handleAttack] DOUBLE KO after player attack (Rough Skin/Iron Barbs)!');
                await handleEnemyFainted(e);
                await handlePlayerFainted(p);
                return;
            }
            await handleEnemyFainted(e);
            // ã€ä¿®å¤ã€‘æ•Œæ–¹å€’ä¸‹æ¢äººåï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆG-Max DOT ç­‰ï¼‰
            const newE = battle.getEnemy();
            if (newE && newE.isAlive()) {
                await executeEndPhase(p, newE);
            }
            return;
        }
        // ========== æ•Œæ–¹ååŠ¨ï¼ˆæ”»å‡»æ–°æ¢å…¥çš„å®å¯æ¢¦ï¼‰ ==========
        // ã€ä¿®å¤ã€‘Pre-Move Check: æ£€æŸ¥æ•Œæ–¹è‡ªå·±æ˜¯å¦è¿˜æ´»ç€ï¼ˆä¸´åˆ«ç¤¼ç‰©/å¤§çˆ†ç‚¸ç­‰è‡ªæ€æ‹›å¼ï¼‰
        if (!e.isAlive()) {
            console.log('[handleAttack] Enemy already fainted (self-KO move like Memento), skipping enemy turn');
            log(`<span style="color:#999">ä½†æ˜¯ ${e.cnName} å·²ç»å€’ä¸‹äº†...</span>`);
            await handleEnemyFainted(e);
            return;
        }
        console.log('[handleAttack] Enemy turn starting, move:', enemyMove?.name || enemyMove?.cn);
        const enemyResult = await executeEnemyTurn(e, p, enemyMove);
        console.log('[handleAttack] Enemy turn complete');
        // ã€ä¿®å¤ã€‘Post-Move Check: æ•Œæ–¹ä½¿ç”¨è‡ªæ€æ‹›å¼åç«‹å³å¤„ç†å€’ä¸‹
        // ã€å…³é”®ä¿®å¤ã€‘åŒæ—¶æ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹ï¼ˆåä¼¤/ç²—ç³™çš®è‚¤ç­‰å¯¼è‡´åŒæ–¹åŒæ—¶å€’ä¸‹ï¼‰
        if (!e.isAlive()) {
            console.log('[handleAttack] Enemy fainted after self-KO move (Memento/Explosion/Recoil)');
            // å…ˆæ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹
            if (!p.isAlive()) {
                console.log('[handleAttack] DOUBLE KO: Both player and enemy fainted!');
                // åŒæ–¹åŒæ—¶å€’ä¸‹ï¼šå…ˆå¤„ç†æ•Œæ–¹ï¼Œå†å¤„ç†ç©å®¶æ¢äºº
                await handleEnemyFainted(e);
                await handlePlayerFainted(p);
                return;
            }
            await handleEnemyFainted(e);
            return;
        }
        // ã€ä¿®å¤ã€‘æ•Œæ–¹ Pivot ä¹Ÿè¦å…ˆå¤„ç†ï¼Œå†åˆ¤å®šç©å®¶å€’ä¸‹
        if (enemyResult?.pivot && hasAliveSwitch(battle.enemyParty, battle.enemyActive)) {
            const oldE = battle.getEnemy();
            const moveName = enemyMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldE.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldE.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else if (moveName === 'Baton Pass') {
                log(`${oldE.cnName} ä½¿ç”¨æ¥åŠ›æ£’æ’¤é€€äº†!`);
            } else {
                log(`${oldE.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handleEnemyPivot(enemyResult?.passBoosts || false);
            e = battle.getEnemy();
        }
        if (!p.isAlive()) {
            await handlePlayerFainted(p);
            // ã€ä¿®å¤ã€‘ç©å®¶å…ˆåŠ¨åˆ†æ”¯ä¸­ï¼Œæ•Œæ–¹æ”»å‡»åç©å®¶å€’ä¸‹ï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆæ•Œæ–¹æå·¨åŒ– tick ç­‰ï¼‰
            const newP = battle.getPlayer();
            const currentE = battle.getEnemy();
            if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
                await executeEndPhase(newP, currentE);
            }
            return;
        }
    } else {
        // ========== æ•Œæ–¹å…ˆåŠ¨ ==========
        const enemyResult = await executeEnemyTurn(e, p, enemyMove);
        // ã€ä¿®å¤ã€‘Post-Move Check: æ•Œæ–¹ä½¿ç”¨è‡ªæ€æ‹›å¼åç«‹å³å¤„ç†å€’ä¸‹
        // ã€å…³é”®ä¿®å¤ã€‘åŒæ—¶æ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹ï¼ˆåä¼¤/ç²—ç³™çš®è‚¤ç­‰å¯¼è‡´åŒæ–¹åŒæ—¶å€’ä¸‹ï¼‰
        if (!e.isAlive()) {
            console.log('[handleAttack] Enemy fainted after self-KO move in enemy-first branch');
            // å…ˆæ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹
            if (!p.isAlive()) {
                console.log('[handleAttack] DOUBLE KO in enemy-first branch!');
                await handleEnemyFainted(e);
                await handlePlayerFainted(p);
                return;
            }
            await handleEnemyFainted(e);
            return;
        }
        // ã€ä¿®å¤ã€‘æ•Œæ–¹ Pivot å…ˆå¤„ç†ï¼Œå†åˆ¤å®šç©å®¶å€’ä¸‹
        if (enemyResult?.pivot && hasAliveSwitch(battle.enemyParty, battle.enemyActive)) {
            const oldE = battle.getEnemy();
            const moveName = enemyMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldE.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldE.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else if (moveName === 'Baton Pass') {
                log(`${oldE.cnName} ä½¿ç”¨æ¥åŠ›æ£’æ’¤é€€äº†!`);
            } else {
                log(`${oldE.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handleEnemyPivot(enemyResult?.passBoosts || false);
            e = battle.getEnemy();
        }
        if (!p.isAlive()) {
            await handlePlayerFainted(p);
            // ã€ä¿®å¤ã€‘ç©å®¶å€’ä¸‹æ¢äººåï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆæ•Œæ–¹æå·¨åŒ– tick ç­‰ï¼‰
            const newP = battle.getPlayer();
            const currentE = battle.getEnemy();
            if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
                await executeEndPhase(newP, currentE);
            }
            return;
        }
        // ========== ç©å®¶ååŠ¨ï¼ˆæ”»å‡»æ–°æ¢å…¥çš„å®å¯æ¢¦ï¼‰ ==========
        // ã€ä¿®å¤ã€‘Pre-Move Check: æ£€æŸ¥ç©å®¶è‡ªå·±æ˜¯å¦è¿˜æ´»ç€ï¼ˆä¸´åˆ«ç¤¼ç‰©/å¤§çˆ†ç‚¸ç­‰è‡ªæ€æ‹›å¼ï¼‰
        if (!p.isAlive()) {
            console.log('[handleAttack] Player already fainted (self-KO move), skipping player turn');
            log(`<span style="color:#999">ä½†æ˜¯ ${p.cnName} å·²ç»å€’ä¸‹äº†...</span>`);
            await handlePlayerFainted(p);
            // ã€ä¿®å¤ã€‘ç©å®¶å€’ä¸‹æ¢äººåï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—
            const newP2 = battle.getPlayer();
            const currentE2 = battle.getEnemy();
            if (newP2 && newP2.isAlive() && currentE2 && currentE2.isAlive()) {
                await executeEndPhase(newP2, currentE2);
            }
            return;
        }
        // ã€ä¿®å¤ã€‘Pre-Move Check: æ£€æŸ¥ç›®æ ‡æ˜¯å¦è¿˜æ´»ç€ï¼ˆæ•Œæ–¹å¯èƒ½ç”¨äº†è‡ªæ€æ‹›å¼ï¼‰
        if (!e.isAlive()) {
            console.log('[handleAttack] Enemy already fainted before player turn, skipping to faint handling');
            log(`<span style="color:#999">ä½†æ˜¯æ²¡æœ‰ç›®æ ‡äº†...</span>`);
            await handleEnemyFainted(e);
            return;
        }
        // ã€ä¿®å¤ã€‘æ•Œæ–¹å…ˆåŠ¨åï¼Œç©å®¶ååŠ¨å‰å†æ¬¡æ£€æŸ¥ Taunt ç­‰ Volatile çŠ¶æ€
        // å› ä¸ºæ•Œæ–¹å¯èƒ½åœ¨è¿™å›åˆä½¿ç”¨äº†æŒ‘è¡…ï¼Œé˜»æ­¢ç©å®¶ä½¿ç”¨å˜åŒ–æŠ€
        if (typeof MoveEffects !== 'undefined' && MoveEffects.canUseMove) {
            const canUseResult = MoveEffects.canUseMove(p, playerMove);
            if (!canUseResult.canUse) {
                log(`<span style="color:#e74c3c">${canUseResult.reason}</span>`);
                await wait(500);
                // è·³è¿‡ç©å®¶è¡ŒåŠ¨ï¼Œç›´æ¥è¿›å…¥å›åˆç»“ç®—
                await executeEndPhase(p, e);
                battle.locked = false;
                return;
            }
        }
        const playerResult = await executePlayerTurn(p, e, playerMove);
        // ã€ä¿®å¤ã€‘Post-Move Check: ç©å®¶ä½¿ç”¨è‡ªæ€æ‹›å¼åç«‹å³å¤„ç†å€’ä¸‹
        if (!p.isAlive()) {
            console.log('[handleAttack] Player fainted after self-KO move in enemy-first branch');
            await handlePlayerFainted(p);
            // ã€ä¿®å¤ã€‘ç©å®¶è‡ªæ€æ‹›å¼åå€’ä¸‹ï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆæ•Œæ–¹æå·¨åŒ– tick ç­‰ï¼‰
            const newP = battle.getPlayer();
            const currentE = battle.getEnemy();
            if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
                await executeEndPhase(newP, currentE);
            }
            return;
        }
        // ã€ä¿®å¤ã€‘ç©å®¶ Pivot å…ˆå¤„ç†ï¼Œå†åˆ¤å®šæ•Œæ–¹å€’ä¸‹
        if (playerResult?.pivot && hasAliveSwitch(battle.playerParty, battle.playerActive)) {
            const oldP = battle.getPlayer();
            const moveName = playerMove?.name || '';
            if (moveName === 'Volt Switch') {
                log(`${oldP.cnName} ä¼ç‰¹æ›¿æ¢ï¼Œè¿…é€Ÿæ’¤é€€äº†!`);
            } else if (moveName === 'Flip Turn') {
                log(`${oldP.cnName} å¿«é€Ÿç¿»è½¬ï¼Œæ’¤é€€äº†!`);
            } else {
                log(`${oldP.cnName} æ‰“å®Œåæ€¥é€ŸæŠ˜è¿”å›æ¥äº†!`);
            }
            await handlePlayerPivot();
            p = battle.getPlayer();
        } else if (playerResult?.pivot) {
            log(`<span style="color:#999">ä½†æ˜¯æ²¡æœ‰å¯ä»¥æ¢å…¥çš„å®å¯æ¢¦äº†!</span>`);
        }
        // ã€å…³é”®ä¿®å¤ã€‘åŒæ—¶æ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹ï¼ˆç²—ç³™çš®è‚¤/é“åˆºç­‰æ¥è§¦ä¼¤å®³å¯¼è‡´åŒæ–¹åŒæ—¶å€’ä¸‹ï¼‰
        if (!e.isAlive()) {
            // å…ˆæ£€æŸ¥ç©å®¶æ˜¯å¦ä¹Ÿå€’ä¸‹
            if (!p.isAlive()) {
                console.log('[handleAttack] DOUBLE KO after player attack in enemy-first branch!');
                await handleEnemyFainted(e);
                await handlePlayerFainted(p);
                return;
            }
            await handleEnemyFainted(e);
            // ã€ä¿®å¤ã€‘æ•Œæ–¹å€’ä¸‹æ¢äººåï¼Œä»éœ€æ‰§è¡Œå›åˆæœ«ç»“ç®—ï¼ˆG-Max DOT ç­‰ï¼‰
            const newE = battle.getEnemy();
            if (newE && newE.isAlive()) {
                await executeEndPhase(p, newE);
            }
            return;
        }
    }
    // === å›åˆæœ«ç»“ç®— ===
    // é‡æ–°è·å–æœ€æ–°å¼•ç”¨ï¼ˆpivot æ¢äººåå¯èƒ½å·²å˜åŒ–ï¼‰
    const currentP = battle.getPlayer();
    const currentE = battle.getEnemy();
    await executeEndPhase(currentP, currentE);
}
// ============================================
// ã€å·²è¿ç§»ã€‘å›åˆæ‰§è¡Œ -> battle/battle-turns.js
// ============================================
// ============================================
// ã€å·²è¿ç§»ã€‘æ¢äººç³»ç»Ÿ -> battle/battle-switch.js
// ============================================
// ã€å·²è¿ç§»ã€‘handleEnemyFainted -> battle/battle-switch.js
// ã€å·²è¿ç§»ã€‘handlePlayerFainted -> battle/battle-switch.js
// ã€å·²è¿ç§»ã€‘enemyTurn -> battle/battle-turns.js
// ã€å·²è¿ç§»ã€‘triggerEntryAbilities -> battle/battle-switch.js
/**
 * å›åˆæœ«ç»“ç®—
 */
async function executeEndPhase(p, e) {
    console.log('[executeEndPhase] Starting with:', p?.cnName, 'vs', e?.cnName);
    try {
        await wait(300);
        // å®‰å…¨æ£€æŸ¥
        if (!p || !e) {
            console.warn('[executeEndPhase] Invalid pokemon reference:', { p, e });
            battle.locked = false;
            return;
        }
        if (typeof window.getEndTurnStatusLogs === 'function') {
        // ç»“ç®—ç©å®¶çš„çŠ¶æ€ä¼¤å®³ï¼ˆisPlayerPoke = trueï¼ŒAVs æ•ˆæœç”Ÿæ•ˆï¼‰
        if (p.isAlive()) {
            const pLogs = window.getEndTurnStatusLogs(p, e, true);
            if (pLogs.length > 0) {
                pLogs.forEach(txt => {
                    // Devotion æ²»æ„ˆæ—¥å¿—å·²ç»æœ‰æ ·å¼ï¼Œç›´æ¥è¾“å‡º
                    if (txt.includes('Devotion')) {
                        log(txt);
                    } else {
                        log(`<span style="color:#d35400">${txt}</span>`);
                    }
                });
                updateAllVisuals();
                await wait(400);
                if (!p.isAlive()) {
                    await handlePlayerFainted(p);
                    return;
                }
            }
        }
        // ç»“ç®—æ•Œæ–¹çš„çŠ¶æ€ä¼¤å®³ï¼ˆisPlayerPoke = falseï¼ŒAVs æ•ˆæœä¸ç”Ÿæ•ˆï¼‰
        if (e.isAlive()) {
            const eLogs = window.getEndTurnStatusLogs(e, p, false);
            if (eLogs.length > 0) {
                eLogs.forEach(txt => {
                    // Devotion æ²»æ„ˆæ—¥å¿—å·²ç»æœ‰æ ·å¼ï¼Œç›´æ¥è¾“å‡º
                    if (txt.includes('Devotion')) {
                        log(txt);
                    } else {
                        log(`<span style="color:#d35400">${txt}</span>`);
                    }
                });
                updateAllVisuals();
                await wait(400);
                if (!e.isAlive()) {
                    await handleEnemyFainted(e);
                    return;
                }
            }
        }
    }
    // =========================================================
    // G-Max æŒç»­ä¼¤å®³æ•ˆæœ (Wildfire/Vine Lash/Cannonade/Volcalith)
    // =========================================================
    const applyGMaxDOT = async (pokemon, side, isPlayer) => {
        if (!pokemon || !pokemon.isAlive() || !side) return;
        const types = pokemon.types || [];
        const dotDamage = Math.max(1, Math.floor(pokemon.maxHp / 6));
        // G-Max Wildfire (ç«) - éç«å±æ€§å—ä¼¤
        if (side.gmaxWildfire && side.gmaxWildfire.turns > 0) {
            if (!types.includes('Fire')) {
                pokemon.currHp = Math.max(0, pokemon.currHp - dotDamage);
                log(`<span style="color:#ef4444">ğŸ”¥ ${pokemon.cnName} è¢«åœ°ç‹±ç­ç„°ç¼çƒ§ï¼(-${dotDamage})</span>`);
                updateAllVisuals();
                await wait(300);
            }
            side.gmaxWildfire.turns--;
            if (side.gmaxWildfire.turns <= 0) {
                log(`<span style="color:#94a3b8">ğŸ”¥ åœ°ç‹±ç­ç„°æ¶ˆæ•£äº†ã€‚</span>`);
                delete side.gmaxWildfire;
            }
        }
        // G-Max Vine Lash (è‰) - éè‰å±æ€§å—ä¼¤
        if (side.gmaxVineLash && side.gmaxVineLash.turns > 0) {
            if (!types.includes('Grass')) {
                pokemon.currHp = Math.max(0, pokemon.currHp - dotDamage);
                log(`<span style="color:#22c55e">ğŸŒ¿ ${pokemon.cnName} è¢«è—¤è”“ç¼ ç»•ï¼(-${dotDamage})</span>`);
                updateAllVisuals();
                await wait(300);
            }
            side.gmaxVineLash.turns--;
            if (side.gmaxVineLash.turns <= 0) {
                log(`<span style="color:#94a3b8">ğŸŒ¿ ç°é£é­ç­æ¶ˆæ•£äº†ã€‚</span>`);
                delete side.gmaxVineLash;
            }
        }
        // G-Max Cannonade (æ°´) - éæ°´å±æ€§å—ä¼¤
        if (side.gmaxCannonade && side.gmaxCannonade.turns > 0) {
            if (!types.includes('Water')) {
                pokemon.currHp = Math.max(0, pokemon.currHp - dotDamage);
                log(`<span style="color:#3b82f6">ğŸ’§ ${pokemon.cnName} è¢«æ¿€æµå†²å‡»ï¼(-${dotDamage})</span>`);
                updateAllVisuals();
                await wait(300);
            }
            side.gmaxCannonade.turns--;
            if (side.gmaxCannonade.turns <= 0) {
                log(`<span style="color:#94a3b8">ğŸ’§ æ°´ç‚®è½°ç­æ¶ˆæ•£äº†ã€‚</span>`);
                delete side.gmaxCannonade;
            }
        }
        // G-Max Volcalith (å²©) - éå²©å±æ€§å—ä¼¤
        if (side.gmaxVolcalith && side.gmaxVolcalith.turns > 0) {
            if (!types.includes('Rock')) {
                pokemon.currHp = Math.max(0, pokemon.currHp - dotDamage);
                log(`<span style="color:#f97316">ï¿½ite ${pokemon.cnName} è¢«ç‚½çƒ­å²©çŸ³ç¼ä¼¤ï¼(-${dotDamage})</span>`);
                updateAllVisuals();
                await wait(300);
            }
            side.gmaxVolcalith.turns--;
            if (side.gmaxVolcalith.turns <= 0) {
                log(`<span style="color:#94a3b8">ğŸª¨ ç‚çŸ³å–·å‘æ¶ˆæ•£äº†ã€‚</span>`);
                delete side.gmaxVolcalith;
            }
        }
        // æ£€æŸ¥æ˜¯å¦å›  DOT å€’ä¸‹
        if (!pokemon.isAlive()) {
            if (isPlayer) {
                await handlePlayerFainted(pokemon);
            } else {
                await handleEnemyFainted(pokemon);
            }
            return true; // è¡¨ç¤ºæœ‰å®å¯æ¢¦å€’ä¸‹
        }
        return false;
    };
    // ç©å®¶åœºåœ°çš„ G-Max DOT (æ•Œæ–¹æ–½åŠ çš„æ•ˆæœä½œç”¨äºç©å®¶)
    if (p && p.isAlive() && battle.playerSide) {
        const fainted = await applyGMaxDOT(p, battle.playerSide, true);
        if (fainted) return;
    }
    // æ•Œæ–¹åœºåœ°çš„ G-Max DOT (ç©å®¶æ–½åŠ çš„æ•ˆæœä½œç”¨äºæ•Œæ–¹)
    if (e && e.isAlive() && battle.enemySide) {
        const fainted = await applyGMaxDOT(e, battle.enemySide, false);
        if (fainted) return;
    }
    // å¢åŠ åŒæ–¹ä¸Šåœºå›åˆæ•°ï¼ˆç”¨äº Fake Out ç­‰é¦–å›åˆé™åˆ¶æŠ€èƒ½ï¼‰
    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºå®ˆä½ç±»æŠ€èƒ½ï¼ˆæ•°æ®é©±åŠ¨ï¼‰
    const isProtectMove = (moveName) => {
        if (!moveName) return false;
        const moveId = moveName.toLowerCase().replace(/[^a-z0-9]/g, '');
        const moveData = (typeof MOVES !== 'undefined' && MOVES[moveId]) ? MOVES[moveId] : null;
        return moveData?.stallingMove || false;
    };
    if (p && p.isAlive()) {
        p.turnsOnField = (p.turnsOnField || 0) + 1;
        // é‡ç½®å®ˆä½è®¡æ•°å™¨ï¼ˆå¦‚æœä¸Šå›åˆæ²¡ç”¨å®ˆä½ç±»æŠ€èƒ½ï¼‰
        if (!isProtectMove(p.lastMoveUsed)) {
            p.protectCounter = 0;
        }
        // === ã€ä¿®å¤ã€‘é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨ (Taunt, Disable ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.tickVolatileStatus) {
            const volatileLogs = MoveEffects.tickVolatileStatus(p);
            volatileLogs.forEach(txt => log(txt));
        }
        // === ã€æ–°å¢ã€‘é“å…·å›åˆæœ«æ•ˆæœ (å‰§æ¯’å®ç ã€ç«ç„°å®ç ã€å‰©é¥­ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.processEndTurnItemEffects) {
            const itemLogs = MoveEffects.processEndTurnItemEffects(p);
            itemLogs.forEach(txt => log(txt));
            if (itemLogs.length > 0) updateAllVisuals();
        }
    }
    if (e && e.isAlive()) {
        e.turnsOnField = (e.turnsOnField || 0) + 1;
        // é‡ç½®å®ˆä½è®¡æ•°å™¨ï¼ˆå¦‚æœä¸Šå›åˆæ²¡ç”¨å®ˆä½ç±»æŠ€èƒ½ï¼‰
        if (!isProtectMove(e.lastMoveUsed)) {
            e.protectCounter = 0;
        }
        // === ã€ä¿®å¤ã€‘é€’å‡ Volatile çŠ¶æ€è®¡æ•°å™¨ (Taunt, Disable ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.tickVolatileStatus) {
            const volatileLogs = MoveEffects.tickVolatileStatus(e);
            volatileLogs.forEach(txt => log(txt));
        }
        // === ã€æ–°å¢ã€‘é“å…·å›åˆæœ«æ•ˆæœ (å‰§æ¯’å®ç ã€ç«ç„°å®ç ã€å‰©é¥­ç­‰) ===
        if (typeof MoveEffects !== 'undefined' && MoveEffects.processEndTurnItemEffects) {
            const itemLogs = MoveEffects.processEndTurnItemEffects(e);
            itemLogs.forEach(txt => log(txt));
            if (itemLogs.length > 0) updateAllVisuals();
        }
    }
    // =========================================================
    // ç‰¹æ€§å›åˆæœ«æ•ˆæœ (Speed Boost, Slow Start ç­‰)
    // =========================================================
    if (typeof AbilityHandlers !== 'undefined') {
        // ç©å®¶ç‰¹æ€§å›åˆæœ«æ•ˆæœ
        if (p && p.isAlive() && p.ability) {
            const pAbilityHandler = AbilityHandlers[p.ability];
            if (pAbilityHandler && pAbilityHandler.onEndTurn) {
                const abilityLogs = [];
                pAbilityHandler.onEndTurn(p, abilityLogs);
                abilityLogs.forEach(txt => log(txt));
                if (abilityLogs.length > 0) updateAllVisuals();
            }
        }
        // æ•Œæ–¹ç‰¹æ€§å›åˆæœ«æ•ˆæœ
        if (e && e.isAlive() && e.ability) {
            const eAbilityHandler = AbilityHandlers[e.ability];
            if (eAbilityHandler && eAbilityHandler.onEndTurn) {
                const abilityLogs = [];
                eAbilityHandler.onEndTurn(e, abilityLogs);
                abilityLogs.forEach(txt => log(txt));
                if (abilityLogs.length > 0) updateAllVisuals();
            }
        }
    }
    // ã€å¤æ­¦ç³»ç»Ÿã€‘é£æ ¼å†·å´å·²ç§»è‡³ handleAttack å¼€å§‹æ—¶é€’å‡ï¼Œæ­¤å¤„ä¸å†å¤„ç†
    // =========================================================
    // æå·¨åŒ–å›åˆå€’è®¡æ—¶ (Dynamax Turn Tick) - ç»Ÿä¸€è°ƒç”¨ dynamax.js
    // =========================================================
    // ç©å®¶æå·¨åŒ–
    if (p && p.isAlive() && p.isDynamaxed && p.dynamaxTurns > 0) {
        const result = await processDynamaxEndTurn(p, true, log);
        result.logs.forEach(msg => log(msg));
        if (result.ended) {
            await endDynamaxAnimation(p, true);
            const originalSpriteUrl = p.getSprite(true);
            smartLoadSprite('player-sprite', originalSpriteUrl, true);
            updateAllVisuals();
            await wait(500);
        }
    }
    // æ•Œæ–¹æå·¨åŒ–
    if (e && e.isAlive() && e.isDynamaxed && e.dynamaxTurns > 0) {
        const result = await processDynamaxEndTurn(e, false, log);
        result.logs.forEach(msg => log(msg));
        if (result.ended) {
            await endDynamaxAnimation(e, false);
            const originalSpriteUrl = e.getSprite(false);
            smartLoadSprite('enemy-sprite', originalSpriteUrl, false);
            updateAllVisuals();
            await wait(500);
        }
    }
    // =========================================================
    // åœºåœ°çŠ¶æ€å€’è®¡æ—¶ (Field Condition Tick)
    // =========================================================
    if (battle.tickFieldConditions) {
        const fieldLogs = battle.tickFieldConditions();
        if (fieldLogs && fieldLogs.length > 0) {
            for (const txt of fieldLogs) {
                log(`<span style="color:#a78bfa">${txt}</span>`);
            }
            await wait(300);
        }
    }
    // ã€æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿã€‘å›åˆç»“æŸæ—¶æ¸…ç†æŒ‡ä»¤çŠ¶æ€
    if (typeof clearCommandEffects === 'function') {
        clearCommandEffects();
    }
    battle.locked = false;
    console.log('[executeEndPhase] Complete, battle.locked = false');
    } catch (err) {
        console.error('[executeEndPhase] Error:', err);
        battle.locked = false;
    }
}
// å¯¼å‡º executeEndPhase ä¾› battle-switch.js è°ƒç”¨
window.executeEndPhase = executeEndPhase;
// ============================================
// ã€å·²è¿ç§»ã€‘ä¼¤å®³ç³»ç»Ÿ -> battle/battle-damage.js
// ============================================
/**
 * ===========================================
 * Part C: Switch System (Manual & Forced)
 * ===========================================
 */
function checkPlayerDefeatOrForceSwitch() {
    const battleEnd = battle.checkBattleEnd();
    if (battleEnd === 'loss') {
        log("ğŸ’€ <b style='color:#e74c3c'>çœ¼å‰ä¸€ç‰‡æ¼†é»‘... ä½ è¾“äº†.</b>");
        if (battle.trainer && battle.trainer.id !== 'wild' && battle.trainer.lines?.win) {
            log(`<i>${battle.trainer.name}: "${battle.trainer.lines.win}"</i>`);
        } else if (battle.scriptedResult === 'loss' && battle.trainer) {
            log(`<i>"æ­£å¦‚æˆ‘æ‰€é¢„æ–™çš„..." ${battle.trainer.name}è½»å£°è¯´é“ã€‚</i>`);
        }
        setTimeout(() => battleEndSequence('loss'), 2000);
        return Promise.resolve('loss');
    }
    // å¼ºåˆ¶æ¢äºº - è¿”å› Promise ç­‰å¾…ç©å®¶é€‰æ‹©
    battle.phase = 'force_switch';
    renderSwitchMenu(false);
    // ã€å…³é”®ä¿®å¤ã€‘è¿”å› Promiseï¼Œç­‰å¾…ç©å®¶å®Œæˆæ¢äºº
    return new Promise((resolve) => {
        battle.forceSwitchResolve = resolve;
    });
}
// æ¸²æŸ“åˆ‡æ¢åˆ—è¡¨
function renderSwitchMenu(allowCancel = true) {
    if (battle.locked && battle.phase !== 'force_switch' && battle.phase !== 'pivot_switch') return;
    // ã€æŠ“äººæœºåˆ¶ã€‘æ£€æŸ¥æ˜¯å¦è¢«å›°ä½ï¼ˆå¼ºåˆ¶æ¢äººå’Œ Pivot æ¢äººé™¤å¤–ï¼‰
    if (allowCancel && battle.phase !== 'force_switch' && battle.phase !== 'pivot_switch') {
        if (typeof window.canPlayerSwitch === 'function') {
            const switchCheck = window.canPlayerSwitch();
            if (!switchCheck.canSwitch) {
                log(`<span style="color:#ef4444">${switchCheck.reason}</span>`);
                return;
            }
        }
    }
    const layer = document.getElementById('switch-menu-layer');
    layer.className = 'overlay-modal modern-layer';
    layer.classList.remove('hidden');
    layer.style.display = 'flex';
    layer.innerHTML = '';
    const container = document.createElement('div');
    container.className = 'switch-container-modern';
    const header = document.createElement('div');
    header.className = 'switch-header-modern';
    const actionColor = !allowCancel ? 'var(--primary-pink)' : 'var(--accent-blue)';
    header.innerHTML = `
        <div style="width:6px; height:40px; background:${actionColor}; border-radius:10px;"></div>
        <div>
            <h2>pokÃ©mon</h2>
            <div class="switch-header-subtitle">
                ${!allowCancel ? 'Choose a replacement (Must Switch)' : 'Select a partner to switch in'}
            </div>
        </div>
    `;
    const grid = document.createElement('div');
    grid.className = 'party-grid-modern';
    battle.playerParty.forEach((pm, idx) => {
        const card = document.createElement('div');
        const isCurrent = (idx === battle.playerActive);
        const isDead = (pm.currHp <= 0);
        const hpRatio = pm.maxHp ? (pm.currHp / pm.maxHp) : 0;
        card.className = 'party-card-modern';
        card.style.animationDelay = `${idx * 0.05}s`;
        if (isCurrent) card.classList.add('current');
        if (isDead) card.classList.add('dead');
        if (!allowCancel && isDead) card.classList.add('disabled');
        let hpColor = '#4fd1c5';
        if (hpRatio < 0.5) hpColor = '#fbc63e';
        if (hpRatio <= 0.2) hpColor = '#ff6b6b';
        // =========================================================
        // æ•°æ®é©±åŠ¨çš„ Sprite URL ç”Ÿæˆ
        // ä½¿ç”¨ pokedex-data.js ä¸­çš„ forme å­—æ®µåˆ¤æ–­å½¢æ€ç±»å‹
        // =========================================================
        const seedIdWithHyphen = pm.name.toLowerCase().replace(/[^a-z0-9-]/g, '');
        const seedIdCompact = pm.name.toLowerCase().replace(/[^a-z0-9]/g, '');
        // ä» pokedex-data.js è·å–å®å¯æ¢¦æ•°æ®
        const pokeData = (typeof POKEDEX !== 'undefined' && POKEDEX[seedIdCompact]) 
            ? POKEDEX[seedIdCompact] : null;
        const forme = pokeData?.forme || '';
        const baseSpecies = pokeData?.baseSpecies || '';
        // åŸºç¡€å½¢æ€ IDï¼ˆç”¨äº fallbackï¼‰
        const baseId = baseSpecies ? baseSpecies.toLowerCase().replace(/[^a-z0-9]/g, '') : seedIdCompact;
        const fallbackId = typeof getFallbackSpriteId === 'function' 
            ? getFallbackSpriteId(pm.name) 
            : baseId;
        // =========================================================
        // å½¢æ€ç±»å‹æ£€æµ‹ï¼ˆæ•°æ®é©±åŠ¨ + åç§°æ£€æµ‹åŒä¿é™©ï¼‰
        // =========================================================
        const formeLower = forme.toLowerCase();
        // åœ°åŒºå½¢æ€ï¼šAlola, Galar, Hisui, Paldea
        const regionalForms = ['alola', 'galar', 'hisui', 'paldea'];
        const isRegionalForm = regionalForms.some(r => formeLower.includes(r)) ||
            regionalForms.some(r => seedIdWithHyphen.includes(`-${r}`));
        // Mega å½¢æ€
        const isMegaForm = formeLower.includes('mega') || seedIdWithHyphen.includes('-mega');
        // åŸå§‹å›å½’å½¢æ€
        const isPrimalForm = formeLower === 'primal' || seedIdWithHyphen.includes('-primal');
        // ç‹å† å½¢æ€ï¼ˆZacian/Zamazentaï¼‰
        const isCrownedForm = formeLower === 'crowned' || seedIdWithHyphen.includes('-crowned');
        // ç©¶æå½¢æ€ï¼ˆNecrozmaï¼‰
        const isUltraForm = formeLower === 'ultra' || seedIdWithHyphen.includes('-ultra');
        // ç‰¹æ®Šå½¢æ€ï¼šRotom, Necrozma åˆä½“, Calyrex éª‘ä¹˜, Darmanitan Zen ç­‰
        const specialForms = ['wash', 'heat', 'mow', 'frost', 'fan', // Rotom
            'dusk-mane', 'dawn-wings', // Necrozma
            'ice', 'shadow', // Calyrex
            'zen', 'therian', 'origin', 'sky', 'attack', 'defense', 'speed', // å„ç§å½¢æ€
            'combat', 'blaze', 'aqua']; // Tauros-Paldea
        const isOtherSpecialForm = specialForms.some(f => formeLower.includes(f)) ||
            specialForms.some(f => seedIdWithHyphen.includes(`-${f}`));
        // å¸½å­çš®å¡ä¸˜ç‰¹æ®Šå¤„ç†ï¼ˆpokesprite icons ç›®å½•ï¼‰
        const pikachuCapForms = ['original', 'hoenn', 'sinnoh', 'unova', 'kalos', 'alola', 'partner', 'world'];
        const isPikachuCap = baseSpecies === 'Pikachu' && pikachuCapForms.includes(formeLower);
        // Cosplay çš®å¡ä¸˜
        const pikachuCosplayForms = ['cosplay', 'rock-star', 'belle', 'pop-star', 'phd', 'libre'];
        const isPikachuCosplay = baseSpecies === 'Pikachu' && pikachuCosplayForms.some(f => formeLower.includes(f));
        // æ˜¯å¦éœ€è¦ä½¿ç”¨ pokesprite å›¾åº“
        const needsPokesprite = isRegionalForm || isMegaForm || isPrimalForm || isUltraForm || isOtherSpecialForm;
        // =========================================================
        // ç”Ÿæˆ Sprite URL
        // =========================================================
        let imgSrc;
        if (isPikachuCap) {
            // å¸½å­çš®å¡ä¸˜ä½¿ç”¨ pokesprite icons ç›®å½•
            const capName = `pikachu-${formeLower}-cap`;
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/icons/pokemon/regular/${capName}.png`;
        } else if (isPikachuCosplay) {
            // Cosplay çš®å¡ä¸˜
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/icons/pokemon/regular/${seedIdWithHyphen}.png`;
        } else if (isCrownedForm) {
            // Crowned å½¢æ€ä½¿ç”¨ pokespriteï¼ˆzacian-crowned, zamazenta-crownedï¼‰
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${seedIdWithHyphen}.png`;
        } else if (needsPokesprite) {
            // å…¶ä»–ç‰¹æ®Šå½¢æ€ä½¿ç”¨ pokesprite
            let pokespriteId = seedIdWithHyphen;
            // Mega X/Y æ ¼å¼ä¿®æ­£
            if (isMegaForm && !pokespriteId.includes('-mega')) {
                pokespriteId = pokespriteId.replace(/mega([xy])$/i, '-mega-$1');
                if (!pokespriteId.includes('-mega')) {
                    pokespriteId = pokespriteId.replace(/mega$/i, '-mega');
                }
            }
            // Primal æ ¼å¼ä¿®æ­£
            if (isPrimalForm && !pokespriteId.includes('-primal')) {
                pokespriteId = pokespriteId.replace(/primal$/i, '-primal');
            }
            // Necrozma ç‰¹æ®Šå½¢æ€æ ¼å¼ä¿®æ­£ (pokesprite ä½¿ç”¨ç®€åŒ–æ ¼å¼)
            // necrozma-dusk-mane -> necrozma-dusk
            // necrozma-dawn-wings -> necrozma-dawn
            pokespriteId = pokespriteId.replace(/-dusk-mane$/, '-dusk');
            pokespriteId = pokespriteId.replace(/-dawn-wings$/, '-dawn');
            imgSrc = `https://raw.githubusercontent.com/msikma/pokesprite/master/pokemon-gen8/regular/${pokespriteId}.png`;
        } else {
            // æ™®é€šå½¢æ€ä½¿ç”¨ Showdown spritesï¼ˆä¸å¸¦æ¨ªæ ï¼‰
            imgSrc = `https://play.pokemonshowdown.com/sprites/gen5/${seedIdCompact}.png`;
        }
        const fallbackSrc = `https://play.pokemonshowdown.com/sprites/gen5/${fallbackId}.png`;
        card.innerHTML = `
            ${isCurrent ? '<div class="current-tag">ACTIVE</div>' : ''}
            <div class="card-icon-modern">
                <img class="${isMegaForm ? 'mega-icon' : ''}" src="${imgSrc}" onerror="if(this.src!=='${fallbackSrc}'){this.src='${fallbackSrc}'}else{this.style.display='none'}">
            </div>
            <div class="card-info-modern">
                <div class="card-top-row">
                    <span class="card-name">${pm.cnName}</span>
                    <span class="card-lv">Lv.<span style="color:#2d3436;margin-left:2px">${pm.level}</span></span>
                </div>
                <div class="card-hp-nums">
                    ${pm.currHp} <span style="color:#b2bec3;font-weight:400">/ ${pm.maxHp}</span>
                </div>
                <div class="modern-hp-track">
                    <div class="modern-hp-fill" style="width:${hpRatio * 100}%; background:${hpColor}"></div>
                </div>
            </div>
            ${isDead ? '<div class="status-tag">FANT</div>' : ''}
        `;
        if (!isDead && !isCurrent) {
            card.onclick = () => {
                console.log('[renderSwitchMenu] Card clicked, calling performSwitch with index:', idx);
                layer.classList.add('hidden');
                layer.style.display = '';
                layer.className = 'overlay-modal hidden';
                performSwitch(idx);
            };
        }
        grid.appendChild(card);
    });
    container.appendChild(header);
    container.appendChild(grid);
    if (allowCancel) {
        const footer = document.createElement('div');
        footer.className = 'switch-footer';
        footer.innerHTML = `
            <button class="btn-close-modern">
                <span class="key-hint">Ã—</span> CANCEL
            </button>
        `;
        footer.querySelector('button').onclick = () => {
            layer.classList.add('hidden');
            layer.style.display = '';
            layer.className = 'overlay-modal hidden';
        };
        container.appendChild(footer);
    }
    layer.appendChild(container);
    if (allowCancel) {
        layer.onclick = (e) => {
            if (e.target === layer) {
                layer.classList.add('hidden');
                layer.style.display = '';
                layer.className = 'overlay-modal hidden';
            }
        };
    } else {
        layer.onclick = null;
    }
}
async function performSwitch(newIndex) {
    console.log('[performSwitch] Called with index:', newIndex);
    console.log('[performSwitch] battle.phase:', battle.phase);
    console.log('[performSwitch] battle.pivotResolve:', !!battle.pivotResolve);
    console.log('[performSwitch] battle.locked:', battle.locked);
    document.getElementById('switch-menu-layer').classList.add('hidden');
    const oldP = battle.getPlayer();
    const isForced = !oldP.isAlive();
    const isPivot = battle.phase === 'pivot_switch';
    const newPoke = battle.playerParty[newIndex];
    console.log('[performSwitch] isPivot:', isPivot, 'isForced:', isForced, 'hasPivotResolve:', !!battle.pivotResolve);
    // æ¢ä¸‹åœºçš„å®å¯æ¢¦é‡ç½®èƒ½åŠ›ç­‰çº§
    if (oldP.isAlive()) {
        // ã€ä¿®å¤ã€‘å¦‚æœæ¢ä¸‹çš„å®å¯æ¢¦å¤„äºæå·¨åŒ–çŠ¶æ€ï¼Œæ¢å¤æ‹›å¼
        if (oldP.isDynamaxed) {
            console.log(`[SWITCH] Player ${oldP.name} was Dynamaxed, restoring moves`);
            applyDynamaxState(oldP, false);
        }
        oldP.resetBoosts();
    }
    // Pivot æ¢äººä½¿ç”¨ä¸åŒçš„æ—¥å¿—
    if (isPivot) {
        log(`${oldP.cnName} æ’¤å›ï¼${newPoke.cnName} ç™»åœºï¼`);
    } else {
        log(isForced 
            ? `å»å§! ${newPoke.cnName}!` 
            : `å›æ¥å§ ${oldP.cnName}! ${newPoke.cnName}, ä¸Š!`);
    }
    // === æ’­æ”¾æ–°ä¸Šåœºå®å¯æ¢¦å«å£° ===
    if (typeof window.playPokemonCry === 'function') {
        window.playPokemonCry(newPoke.name);
    }
    // === è§¦å‘å…¥åœºç‰¹æ€§ (å¨å“ã€å¤©æ°”ç­‰) ===
    // æ³¨æ„ï¼šåœ¨è®¾ç½® playerActive ä¹‹å‰å…ˆè§¦å‘ç‰¹æ€§ï¼Œé¿å…æ’’è±å‡»å€’æ—¶ç´¢å¼•é”™è¯¯
    triggerEntryAbilities(newPoke, battle.getEnemy());
    // === ç»“ç®—åœºåœ°é’‰å­ä¼¤å®³ ===
    if (typeof MoveEffects !== 'undefined' && MoveEffects.applyEntryHazards) {
        const hazardLogs = MoveEffects.applyEntryHazards(newPoke, true, battle);
        hazardLogs.forEach(msg => log(msg));
        // å¦‚æœé’‰å­ä¼¤å®³å¯¼è‡´å®å¯æ¢¦å€’ä¸‹ï¼Œéœ€è¦å¼ºåˆ¶æ¢äºº
        if (newPoke.currHp <= 0) {
            log(`ç³Ÿç³•! ${newPoke.cnName} è¢«åœºåœ°ä¼¤å®³å‡»å€’äº†!`);
            updateAllVisuals();
            // ã€å…³é”®ä¿®å¤ã€‘ç­‰å¾…å¼ºåˆ¶æ¢äººå®Œæˆ
            await checkPlayerDefeatOrForceSwitch();
            return;
        }
    }
    // åªæœ‰åœ¨å®å¯æ¢¦å­˜æ´»çš„æƒ…å†µä¸‹æ‰è®¾ç½®ä¸ºå½“å‰æ´»è·ƒå®å¯æ¢¦
    battle.playerActive = newIndex;
    // === ç¾ç»Šå…±é¸£çŠ¶æ€æ¢å¤ ===
    // å¦‚æœæ¢ä¸Šåœºçš„å®å¯æ¢¦æœ‰ç¾ç»Šå…±é¸£æ ‡è®°ï¼Œé‡æ–°åº”ç”¨èƒ½åŠ›æå‡
    if (newPoke.hasBondResonance && typeof newPoke.applyBoost === 'function') {
        // ã€å¹³è¡¡è°ƒæ•´ã€‘å…±é¸£æ€å…¨èƒ½åŠ› +1ï¼ˆåŸ +2ï¼‰
        newPoke.applyBoost('atk', 1);
        newPoke.applyBoost('def', 1);
        newPoke.applyBoost('spa', 1);
        newPoke.applyBoost('spd', 1);
        newPoke.applyBoost('spe', 1);
        log(`<span style="color:#4ade80"><b>${newPoke.cnName} çš„ç¾ç»Šå…±é¸£ä»åœ¨å»¶ç»­ï¼Œå…¨å±æ€§ç»´æŒæå‡!</b></span>`);
    }
    // Pivot æ¢äººï¼šresolve Promise å¹¶è¿”å›ï¼Œä¸è§¦å‘æ•Œæ–¹æ”»å‡»
    if (isPivot) {
        console.log('[performSwitch] Pivot switch detected');
        battle.phase = 'battle';
        updateAllVisuals();
        battle.locked = false;
        if (battle.pivotResolve) {
            console.log('[performSwitch] Resolving pivot Promise');
            const resolve = battle.pivotResolve;
            battle.pivotResolve = null;
            battle.pivotSide = null;
            console.log('[performSwitch] Calling resolve()');
            resolve();
            console.log('[performSwitch] resolve() called');
        }
        console.log('[performSwitch] Pivot handling complete, returning');
        return;
    }
    battle.phase = 'battle';
    if (!isForced) {
        // ä¸»åŠ¨æ¢äººè¦æŒ¨æ‰“
        log("ç”±äºäº¤æ¢å®å¯æ¢¦ï¼Œæ•Œæ–¹å‘èµ·äº†æ”»å‡»ï¼");
        battle.locked = true;
        await enemyTurn();
    } else {
        // å¼ºåˆ¶æ¢äººå®Œæˆåï¼Œåˆ·æ–°ç•Œé¢å¹¶è§£é”
        updateAllVisuals();
        // ã€åŒæ€åœºæ™¯ä¿®å¤ã€‘å¦‚æœæ•Œæ–¹ä¹Ÿåˆšæ¢äººï¼ˆåŒæ€åœºæ™¯ï¼‰ï¼Œè§¦å‘æ•Œæ–¹å…¥åœºç‰¹æ€§
        if (battle.enemyJustSwitchedInDoubleKO) {
            const newP = battle.getPlayer();
            const currentE = battle.getEnemy();
            if (newP && newP.isAlive() && currentE && currentE.isAlive()) {
                // è§¦å‘æ•Œæ–¹å…¥åœºç‰¹æ€§ï¼ˆå¦‚å¨å“ç­‰ï¼‰
                if (typeof triggerEntryAbilities === 'function') {
                    triggerEntryAbilities(currentE, newP);
                }
            }
            // æ¸…é™¤æ ‡è®°
            battle.enemyJustSwitchedInDoubleKO = false;
        }
        battle.locked = false;
        // ã€å…³é”®ä¿®å¤ã€‘resolve å¼ºåˆ¶æ¢äºº Promiseï¼Œé€šçŸ¥ handlePlayerFainted æ¢äººå·²å®Œæˆ
        if (battle.forceSwitchResolve) {
            console.log('[performSwitch] Resolving forceSwitchResolve');
            const resolve = battle.forceSwitchResolve;
            battle.forceSwitchResolve = null;
            resolve('switched');
        }
    }
}
// è¾…åŠ© LOG
function log(msg) {
    const box = document.getElementById('log-box');
    let formatMsg = msg;
    formatMsg = formatMsg.replace(/(\d+)\s*(ä¼¤å®³)/g, '<span class="hl-dmg">$1</span> <span style="font-size:0.9em;color:#888">$2</span>');
    formatMsg = formatMsg.replace(/(æ•ˆæœæ‹”ç¾¤|æ•ˆæœç»ä½³!|Super Effective!)/gi, '<span class="hl-sup">æ•ˆæœç»ä½³</span>');
    formatMsg = formatMsg.replace(/(æ•ˆæœä¸å¥½|æ”¶æ•ˆç”šå¾®|Not Very Effective\.\.\.)/gi, '<span class="hl-res">æ•ˆæœä¸å¥½</span>');
    formatMsg = formatMsg.replace(/(ä¼šå¿ƒä¸€å‡»!|Critical Hit!)/gi, '<span class="hl-crit">CRITICAL HIT!!</span>');
    formatMsg = formatMsg.replace(/(å€’ä¸‹äº†|å¤±å»æˆ˜æ–—èƒ½åŠ›)/gi, '<b style="color:#e11d48; text-decoration:underline; text-decoration-color:rgba(225,29,72,0.4)">$1</b>');
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.innerHTML = formatMsg;
    box.appendChild(div);
    requestAnimationFrame(() => {
        box.scrollTop = box.scrollHeight;
    });
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
// =========================================
// ã€å·²è¿ç§»ã€‘èœå•åˆ‡æ¢ -> ui/ui-menus.js
// ã€å·²è¿ç§»ã€‘Mega/Dynamax æŒ‰é’®æ§åˆ¶ -> ui/ui-menus.js
// ã€å·²è¿ç§»ã€‘è¿›åŒ–åŠ¨ç”» -> ui/ui-menus.js
// =========================================
// é€ƒè·‘åŠŸèƒ½
function tryRun() {
    if (battle.locked && battle.phase !== 'battle') return;
    const playerLabel = battle.playerName || 'ç©å®¶';
    if (battle.trainer && battle.trainer.id !== 'wild') {
        log(`é¢å¯¹å¼ºæ•Œï¼Œ${playerLabel} é€‰æ‹©äº†æˆ˜ç•¥æ€§æ’¤é€€ï¼ (æŠ•é™)`);
        const escapeLine = battle.trainer.lines?.escape || battle.trainer.lines?.win;
        if (escapeLine) {
            log(`<i>${battle.trainer.name}: "${escapeLine}"</i>`);
        }
    } else {
        log(`${playerLabel} å¸¦ç€åŒä¼´æˆåŠŸé€ƒç¦»äº†æˆ˜åœºï¼`);
    }
    battle.phase = 'ended';
    battle.locked = true;
    setTimeout(() => battleEndSequence('escape'), 600);
}
// =========================================================
// ã€å·²è¿ç§»ã€‘æ•è·ç³»ç»Ÿ -> systems/catch-system.js
// =========================================================
// ä¾› HTML inline handler è°ƒç”¨
// æ³¨ï¼šéƒ¨åˆ†å‡½æ•°å·²è¿ç§»åˆ°ç‹¬ç«‹æ¨¡å—ï¼Œé€šè¿‡æ¨¡å—è‡ªèº«å¯¼å‡ºåˆ° window
window.initGame = initGame;
window.handleAttack = handleAttack;
window.renderSwitchMenu = renderSwitchMenu;
window.tryRun = tryRun;
/* ===========================================
   æ–°å¢åŠŸèƒ½ï¼šæˆ˜æ–—ç»“ç®—ä¸æ€»ç»“ç”Ÿæˆ
=========================================== */
function battleEndSequence(result) {
    battle.phase = 'ended';
    battle.locked = true;
    // === BGM å¤„ç† ===
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    // èƒœåˆ©æ—¶æ’­æ”¾èƒœåˆ©éŸ³ä¹ (win/caught)
    if (result === 'win' || result === 'caught') {
        if (typeof playVictoryBgm === 'function') {
            playVictoryBgm(isTrainer);
        }
    } else {
        // å¤±è´¥/é€ƒè·‘æ—¶åœæ­¢BGM
        if (typeof stopBgm === 'function') {
            stopBgm(500);
        }
    }
    const analysis = generateBattleReport(result);
    const overlay = document.getElementById('result-overlay');
    const card = document.getElementById('res-card-bg');
    const titleEl = document.getElementById('res-title');
    const rankLetterEl = document.getElementById('res-grade-letter');
    const rankSubEl = document.getElementById('res-grade-sub');
    const statusEl = document.getElementById('col-status');
    const descEl = document.getElementById('col-desc');
    const reasonEl = document.getElementById('col-reason');
    const dotsEl = document.getElementById('res-party-viz');
    const clipEl = document.getElementById('res-clipboard-text');
    if (!overlay || !card) return;
    overlay.classList.remove('active');
    card.classList.remove('theme-win', 'theme-loss', 'theme-escape');
    const enemyName = analysis.enemyName || 'Opponent';
    let titleCopy = 'VICTORY';
    let statusCopy = `Victory vs. ${enemyName}`;
    let themeClass = 'theme-win';
    if (result === 'loss') {
        titleCopy = 'DEFEATED';
        statusCopy = `Overwhelmed by ${enemyName}`;
        themeClass = 'theme-loss';
    } else if (result === 'escape') {
        titleCopy = 'ESCAPED';
        statusCopy = `Retreated from ${enemyName}`;
        themeClass = 'theme-escape';
    } else if (result === 'caught') {
        titleCopy = 'CAPTURED';
        statusCopy = `Captured ${enemyName}`;
        themeClass = 'theme-win';
    }
    card.classList.add(themeClass);
    if (titleEl) titleEl.textContent = titleCopy;
    if (statusEl) statusEl.textContent = statusCopy;
    const rankMatch = typeof analysis.rank === 'string'
        ? analysis.rank.match(/^([A-Z][A-Z\+\-]*)\s*(?:\((.+)\))?/i)
        : null;
    const rankLetter = rankMatch ? rankMatch[1] : analysis.rank || '?';
    const rankDescriptor = rankMatch && rankMatch[2] ? rankMatch[2] : 'RANK';
    if (rankLetterEl) rankLetterEl.textContent = rankLetter.toUpperCase();
    if (rankSubEl) rankSubEl.textContent = rankDescriptor;
    if (reasonEl) reasonEl.textContent = rankDescriptor;
    if (descEl) descEl.textContent = analysis.description || 'æš‚æ— æˆ˜å†µæè¿°ã€‚';
    if (dotsEl) {
        dotsEl.innerHTML = '';
        battle.playerParty.forEach(p => {
            const dot = document.createElement('div');
            const ratio = p.maxHp > 0 ? p.currHp / p.maxHp : 0;
            let state = 'hp-low';
            if (p.currHp <= 0) state = 'hp-dead';
            else if (ratio > 0.6) state = 'hp-100';
            else if (ratio > 0.25) state = 'hp-mid';
            dot.className = `mini-dot ${state}`;
            dotsEl.appendChild(dot);
        });
    }
    if (clipEl) {
        clipEl.value = analysis.fullReport;
    }
    let endLine = '';
    const lines = battle.trainer?.lines || {};
    if (result === 'win') {
        endLine = lines.lose;
    } else if (result === 'escape') {
        endLine = lines.escape || lines.win || lines.lose || '';
    } else {
        // result === 'loss'
        endLine = lines.win;
    }
    if (battle.trainer && battle.trainer.id !== 'wild' && endLine) {
        setTimeout(() => playCutIn(endLine, 4500), 100);
    }
    overlay.classList.remove('hidden');
    void overlay.offsetWidth;
    overlay.classList.add('active');
}
function generateBattleReport(result) {
    const pParty = battle.playerParty;
    const eParty = battle.enemyParty;
    const pName = battle.playerName || "Player";
    const activeEnemy = typeof battle.getEnemy === 'function'
        ? battle.getEnemy()
        : (eParty[battle.enemyActive ?? 0] || eParty[0] || null);
    const fallbackEnemyName = activeEnemy?.cnName || activeEnemy?.name || "Wild Pokemon";
    let eName = fallbackEnemyName || "Enemy";
    if (battle.trainer) {
        if (battle.trainer.id !== 'wild') {
            eName = battle.trainer.name || battle.trainer.title || battle.trainer.id || fallbackEnemyName || "Enemy";
        } else {
            eName = battle.trainer.name?.trim()
                || fallbackEnemyName
                || (battle.trainer.title && battle.trainer.title.toLowerCase() !== 'wild' ? battle.trainer.title : '')
                || "Wild Pokemon";
        }
    }
    const survivors = pParty.filter(p => p.currHp > 0);
    const fallen = pParty.filter(p => p.currHp <= 0);
    const survivorTxt = survivors.length > 0
        ? survivors.map(p => `${p.cnName}(${Math.round((p.currHp / Math.max(1, p.maxHp)) * 100)}%)`).join(', ')
        : "æ¿’æ­»ä¸­æ’¤èµ°";
    const avgLevel = party => party.length
        ? party.reduce((sum, poke) => sum + (poke.level || poke.lv || 1), 0) / party.length
        : 0;
    let pTotalHpPct = 0;
    pParty.forEach(p => pTotalHpPct += (p.maxHp > 0 ? p.currHp / p.maxHp : 0));
    const pHpHealth = pParty.length > 0 ? Math.floor((pTotalHpPct / pParty.length) * 100) : 0;
    const eFallen = eParty.filter(p => p.currHp <= 0);
    let eTotalHpPct = 0;
    eParty.forEach(p => eTotalHpPct += (p.maxHp > 0 ? p.currHp / p.maxHp : 0));
    const eHpHealth = eParty.length > 0 ? Math.floor((eTotalHpPct / eParty.length) * 100) : 0;
    const avgPLv = avgLevel(pParty);
    const avgELv = avgLevel(eParty);
    const levelDiff = avgELv - avgPLv;
    const isTrainer = battle.trainer && battle.trainer.id !== 'wild';
    let rank = 'C';
    let desc = '';
    let resultTextDisplay = result === 'win' ? 'ã€ç©å®¶èƒœåˆ©ã€‘' : 'ã€ç©å®¶å¤±è´¥ã€‘';
    if (result === 'escape') {
        if (levelDiff > 30) {
            rank = 'B (æˆ˜æœ¯æ’¤é€€)';
            desc = 'é¢å¯¹ä¸å¯èƒ½æˆ˜èƒœçš„é‡çº§å·®è·ï¼Œç†æ™ºåœ°é€‰æ‹©ä¿å…¨é˜Ÿä¼ã€‚æ´»ä¸‹å»æ¯”ä»€ä¹ˆéƒ½é‡è¦ã€‚';
        } else if (levelDiff > 10) {
            rank = 'C (è°¨æ…å›é¿)';
            desc = 'æ„è¯†åˆ°å¯¹æ‰‹çš„éš¾ç¼ ï¼Œåœ¨æ²¡æœ‰æŠŠæ¡çš„æƒ…å†µä¸‹é€‰æ‹©ä¸ç¡¬ç¢°ç¡¬ã€‚';
        } else if (survivors.length === 0) {
            rank = 'D (æºƒé€ƒ)';
            desc = 'å…¨çº¿å´©æºƒçš„è¾¹ç¼˜å¼ºè¡Œè„±ç¦»æˆ˜åœºã€‚';
        } else {
            rank = 'D (è„±ç¦»æˆ˜åœº)';
            desc = isTrainer
                ? 'é¢å¯¹è®­ç»ƒå®¶çš„æŒ‘æˆ˜é€‰æ‹©äº†å›é¿ï¼ˆæŠ•é™ï¼‰ã€‚'
                : 'æˆåŠŸä»é‡ç”Ÿå®å¯æ¢¦é¢å‰è„±èº«ã€‚';
        }
        resultTextDisplay = 'ã€æ’¤é€€ / ä¸­æ–­ã€‘';
} else if (result === 'caught') {
    rank = 'CAPTURE (æ•è·æˆåŠŸ)';  // æŠŠ GET æ”¹ä¸º CAPTURE æ›´å…·ç³»ç»Ÿæ„Ÿï¼Œæˆ–è€…ä¿ç•™ GET ä¹Ÿè¡Œ
    desc = 'ä¼´éšç€çƒä½“æŒ‡ç¤ºç¯åœæ­¢æ‘‡æ™ƒï¼Œä¸­å¤®å‘å‡ºäº†æ¸…è„†çš„é”å®šéŸ³ã€‚ç›®æ ‡æ•æ‰å®Œæ¯•ã€‚'; 
    resultTextDisplay = 'ã€æ”¶æœç¡®è®¤ã€‘';
    if (eHpHealth > 70) {
        // æ»¡è¡€æ•è·ï¼šä¸å†è¯´æ˜¯â€œå¥‡è¿¹â€ï¼Œå¼ºè°ƒâ€œå¼ºè¿â€æˆ–â€œä¸€å‘å…¥é­‚â€
        desc += ' ç«Ÿç„¶åœ¨æœªå‰Šå‡ä½“åŠ›çš„çŠ¶æ€ä¸‹åªæœ‰ä¸€çƒï¼Ÿç»ä½³çš„ã€Critical Captureã€‘ã€‚';
    } else if (eHpHealth < 10) {
        // çº¢è¡€æ•è·ï¼šä¸å†è¯´æ˜¯â€œæŒæ§â€ï¼Œå¼ºè°ƒâ€œå‹åˆ¶â€å’Œâ€œç²¾å‡†â€
        desc += ' å°†ä½“åŠ›å‹åˆ¶åˆ°äº†æé™çš„çº¢è‰²åŒºåŸŸï¼Œæ•™ç§‘ä¹¦èˆ¬ç²¾å‡†çš„æ”¶æœä½œä¸š!';
    }
    } else if (result === 'win') {
        const deadCount = fallen.length;
        if (deadCount === 0) {
            if (pHpHealth >= 95) { rank = 'S+ (æ— ä¼¤)'; desc = 'æœªå—åˆ°å®è´¨æ€§ä¼¤å®³çš„å®Œç¾èƒœåˆ©ã€‚'; }
            else if (pHpHealth >= 80) { rank = 'S (å®Œèƒœ)'; desc = 'æŒæ§äº†èŠ‚å¥ï¼Œæ¯«æ— æ‚¬å¿µçš„å‹å€’æ€§èƒœåˆ©ã€‚'; }
            else if (pHpHealth >= 60) { rank = 'A+ (è½»å–)'; desc = 'è™½æœ‰äº¤é”‹ï¼Œä½†å§‹ç»ˆå æ®ç€ä¸»å¯¼æƒã€‚'; }
            else { rank = 'A (ä¼˜èƒœ)'; desc = 'å¯¹æ‰‹ä¹Ÿæœ‰å¤‡è€Œæ¥ï¼Œä½†è¿˜æ˜¯æŠ€é«˜ä¸€ç­¹ã€‚'; }
        } else {
            const deadRatio = pParty.length > 0 ? deadCount / pParty.length : 1;
            if (deadRatio < 0.5) { rank = 'B (è‹¦æˆ˜)'; desc = 'ä»˜å‡ºäº†åŒä¼´å€’ä¸‹çš„ä»£ä»·ï¼Œæ‰æ‹¿ä¸‹çš„è‰°éš¾èƒœåˆ©ã€‚'; }
            else if (deadRatio < 0.9) { rank = 'C (æ­»æ–—)'; desc = 'é™¤äº†ç«™åˆ°æœ€åçš„è‹±é›„ï¼Œå…¶ä»–åŒä¼´éƒ½å·²å€’ä¸‹â€¦â€¦'; }
            else { rank = 'C- (ç»å¢ƒåæ€)'; desc = 'ä»…å‰©æœ€åçš„ä¸€ä¸çº¢è¡€â€¦â€¦å¥‡è¿¹èˆ¬çš„æé™ç¿»ç›˜ã€‚'; }
        }
    } else {
        if (eFallen.length === 0) {
            if (eHpHealth >= 90) { rank = 'F (ç¢¾å‹)'; desc = 'æ¯«æ— è¿˜æ‰‹ä¹‹åŠ›â€¦â€¦é‚£æ˜¯æ¬¡å…ƒçº§çš„æˆ˜åŠ›å·®è·ã€‚'; }
            else if (eHpHealth >= 70) { rank = 'E (å®Œè´¥)'; desc = 'æ²¡èƒ½å¯¹æ•Œäººé€ æˆæœ‰æ•ˆå¨èƒï¼Œé—æ†¾è½è´¥ã€‚'; }
            else if (eHpHealth >= 40) { rank = 'D (ä¸‹é£)'; desc = 'è™½ç„¶å°½åŠ›åå‡»ï¼Œä½†ä»è¢«å¯¹æ–¹å‹åˆ¶ã€‚'; }
            else if (eHpHealth >= 15) { rank = 'C (æŠ—è¡¡)'; desc = 'æœ‰æ¥æœ‰å›çš„æ¿€æˆ˜ï¼Œåªå·®ä¸€å£æ°”å°±èƒ½æ‰­è½¬å±€åŠ¿ã€‚'; }
            else { rank = 'C+ (æƒœè´¥)'; desc = 'æŠŠå¯¹æ‰‹é€¼å…¥ç»å¢ƒï¼æ˜æ˜åªå·®æœ€åä¸€ä¸‹â€¦â€¦'; }
        } else {
            const killRatio = eParty.length > 0 ? (eFallen.length / eParty.length) : 0;
            if (killRatio > 0.6) {
                rank = 'B- (æ¯å¤©ç­åœ°)';
                desc = 'åŒæ–¹éƒ½å·²æ‹¼å°½å…¨åŠ›ï¼Œè™½ç„¶è¾“äº†ï¼Œä½†è¿™ç»å¯¹æ˜¯ä¸€åœºå€¼å¾—èµ¢å¾—å°Šé‡çš„æˆ˜æ–—ã€‚';
            } else {
                rank = 'D+ (æ··æˆ˜)';
                desc = 'è™½ç„¶é‡åˆ›äº†å¯¹æ‰‹ï¼Œä½†æœ€ç»ˆè¿˜æ˜¯æ²¡èƒ½åšæŒåˆ°æœ€åã€‚';
            }
        }
    }
    const rows = [];
    let summaryLine;
    if (result === 'escape') {
        summaryLine = `- ç»¼è¿°ï¼š${pName} åœ¨é¢å¯¹ ${eName} æ—¶é€‰æ‹©äº†ã€é€ƒè·‘/æŠ•é™ã€‘ã€‚`;
    } else if (result === 'caught') {
        summaryLine = `- ç»¼è¿°ï¼š${pName} æˆåŠŸåœ¨é‡å¤–æ”¶æœäº† ${eName}ã€‚`;
    } else {
        summaryLine = `- ç»¼è¿°ï¼š${pName} å¯¹é˜µ ${eName}ï¼Œ${result === 'win' ? 'è·å¾—èƒœåˆ©' : 'é—æ†¾è½è´¥'}ã€‚`;
    }
    rows.push(`- äº¤äº’ç»“æœï¼š${resultTextDisplay}`);
    rows.push(`- è¯„çº§ï¼š${rank}`);
    rows.push(summaryLine);
    rows.push(`- å±€åŠ¿è¯´æ˜ï¼š${desc}`);
    if (result === 'win' && battle.trainer?.lines?.lose) {
        rows.push(`- æ•Œæ–¹è´¥é€€å°è¯ï¼š"${battle.trainer.lines.lose}"`);
    } else if (result === 'escape' && battle.trainer?.lines?.escape) {
        rows.push(`- æ•Œæ–¹ç¦»åœºèµ è¨€ï¼š"${battle.trainer.lines.escape}"`);
    } else if (result === 'loss' && battle.trainer?.lines?.win) {
        rows.push(`- æ•Œæ–¹èƒœåˆ©/å˜²è®½å°è¯ï¼š"${battle.trainer.lines.win}"`);
    }
    const formatEnemyName = poke => (poke?.cnName || poke?.name || '???');
    const enemyStatusLine = eParty.length > 0
        ? eParty.map((poke, idx) => {
            const pct = poke.maxHp > 0 ? Math.round((Math.max(0, poke.currHp) / poke.maxHp) * 100) : 0;
            const state = poke.currHp <= 0 ? 'å€’ä¸‹' : `${pct}%`;
            const marker = idx === (battle.enemyActive ?? 0) ? '*' : '';
            return `${marker}${formatEnemyName(poke)}(${state})`;
        }).join(' / ')
        : 'æœªçŸ¥';
    rows.push(`- æˆ‘æ–¹å¸¦å‡ºæˆ˜åœºï¼š${survivorTxt}`);
    rows.push(`- æ•Œæ–¹çŠ¶æ€ï¼š${enemyStatusLine}`);
    if (result !== 'escape' && fallen.length > 0) {
        rows.push(`- æ¿’æ­»åå•ï¼š${fallen.map(p => p.cnName).join(', ')}`);
    } else if (result === 'escape' && fallen.length > 0) {
        rows.push(`- å€’ä¸‹éœ€æ²»ç–—ï¼š${fallen.map(p => p.cnName).join(', ')}`);
    }
    return {
        rank,
        description: desc,
        playerName: pName,
        enemyName: eName,
        resultLabel: resultTextDisplay,
        summaryLine,
        fullReport: rows.join('\n'),
        fallenCount: fallen.length,
        survivorCount: survivors.length,
        hpHealth: pHpHealth
    };
}
window.restartBattle = function() {
    document.getElementById('result-overlay').classList.add('hidden');
    const logBox = document.getElementById('log-box');
    if (logBox) {
        logBox.innerHTML = '';
    }
    battle = new BattleState();
    window.battle = battle;  // ã€ä¿®å¤ã€‘åŒæ­¥æ›´æ–°å…¨å±€å¼•ç”¨
    // åœæ­¢å½“å‰ BGM (ç«‹å³åœæ­¢ï¼Œä¸æ·¡å‡º)
    if (typeof stopBgm === 'function') {
        stopBgm(0);
    }
    log("=== é‡ç½®æˆ˜æ–— ===");
    initGame();
};
window.copyResultOnly = function() {
    const summary = document.getElementById('res-clipboard-text').value;
    copyToAndClose(summary);
};
window.copyFullProcess = function() {
    const summary = document.getElementById('res-clipboard-text').value;
    const processLog = extractBattleLog();
    const finalContent = [
        "<CORE TASK>",
        "ğŸ›‘ [SYSTEM COMMAND // å¼ºåˆ¶æ‰§è¡Œ] ğŸ›‘",
        "ğŸš« DO NOT ADVANCE THE PLOT! (ç¦æ­¢æ¨è¿›åç»­å‰§æƒ…)",
        "ğŸš« DO NOT SKIP BATTLE DETAILS! (ç¦æ­¢è·³è¿‡æˆ˜æ–—ç»†èŠ‚)",
        "âš ï¸ æ ¸å¿ƒä»»åŠ¡ (CORE TASK):",
        "ä½ ç°åœ¨çš„ä»»åŠ¡æ˜¯ã€æˆ˜æ–—å›æ”¾å‘˜ (Battle Replayer)ã€‘ã€‚",
        "ä¸ä»…è¦åŸºäºä¸‹æ–¹çš„ã€Œå›åˆåˆ¶æ—¥å¿— (Log)ã€ä¸ã€Œæœ€ç»ˆç»“ç®— (Result)ã€ï¼Œæ’°å†™ä¸€åœº**å­—æ•°å……è¶³**çš„å®Œæ•´æˆ˜æ–—è¿‡ç¨‹ã€‚",
        "ğŸ“œ REQUIREMENTS:é€å›åˆæ¼”ç»ã€æˆ˜æœ¯ç‰¹å†™ã€é«˜å…‰æ—¶åˆ»:",
        "ğŸ“ INPUT LOGS START BELOW...",
        "(ä»¥ä¸‹æ˜¯ç³»ç»Ÿç”Ÿæˆçš„æˆ˜æ–—æ•°æ®ï¼Œè¯·å³åˆ»å¼€å§‹å°†å…¶è½¬åŒ–ä¸ºå…¨å½©å›æ”¾)",
        "</CORE TASK>",
        "",
        "<BATTLE LOG>",
        "=== æˆ˜æ–—å›é¡¾ (BATTLE LOG) ===",
        processLog,
        "</BATTLE LOG>",
        "",
        "<RESULT>",
        "=== ç»Ÿè®¡ç»“ç®— (RESULT) ===",
        summary.replace("[ç³»ç»Ÿæç¤ºï¼šå®å¯æ¢¦å¯¹æˆ˜ç»“æœç»“ç®—]\n", ""),
        "</RESULT>"
    ].join('\n');
    copyToAndClose(finalContent);
};
function extractBattleLog() {
    const logBox = document.getElementById('log-box');
    if (!logBox) return '';
    const entries = [];
    logBox.querySelectorAll('.log-entry').forEach(entry => {
        const text = entry.innerText.trim();
        if (text) entries.push(`> ${text}`);
    });
    return entries.join('\n');
}
function copyToAndClose(textStr) {
    const fallbackCopy = () => {
        const el = document.createElement('textarea');
        el.value = textStr;
        document.body.appendChild(el);
        el.select();
        document.execCommand('copy');
        document.body.removeChild(el);
        endGameCleanup();
    };
    if (navigator.clipboard) {
        navigator.clipboard.writeText(textStr).then(() => {
            endGameCleanup();
        }).catch(fallbackCopy);
    } else {
        fallbackCopy();
    }
}
function endGameCleanup() {
    setTimeout(() => {
        if (window.parent) {
            window.parent.postMessage({ type: 'pkm-battle-close' }, '*');
        }
        document.getElementById('ui-root').style.filter = "grayscale(1) brightness(0.2)";
        document.body.innerHTML = "<div style='color:white;text-align:center;margin-top:20%'><h1>SESSION ENDED</h1><p>å·²å¤åˆ¶ç»“æœï¼Œè¯·åœ¨å¯¹è¯æ¡†ç²˜è´´ã€‚</p></div>";
    }, 600);
}
/**
 * =========================================================
 * BATTLE EVOLUTION SYSTEM V2 (ä¸´åœºè¿›åŒ–ç³»ç»Ÿ)
 * =========================================================
 * åŒè½¨è®¾è®¡ï¼š
 * 1. ç”Ÿå‘½è¿›åŒ– (Bio): ä¸€äºŒé˜¶æ®µå±æœºæ—¶è¿›åŒ–çªç ´
 * 2. çµé­‚å…±é¸£ (Bond): æœ€ç»ˆå½¢æ€ç»å¢ƒçˆ†å‘
 * =========================================================
 * ä¾èµ–: POKEDEX (data layer), calcStats (battle-engine.js)
 */
window.EvolutionSystem = {
    /**
     * è®¡ç®—å·±æ–¹ä¸æ•Œæ–¹çš„æ€»è¡€é‡æ¯”ï¼Œåˆ¤æ–­æ˜¯å¦å¤„äºæ˜æ˜¾åŠ£åŠ¿
     * @returns {boolean}
     */
    checkDisadvantage: function() {
        if (!battle || !battle.playerParty || !battle.enemyParty) return false;
        // è®¡ç®—å·±æ–¹æ€»è¡€é‡æ¯”
        let pTotalNow = 0, pTotalMax = 0;
        battle.playerParty.forEach(p => { 
            if (p && typeof p.currHp === 'number') {
                pTotalNow += Math.max(0, p.currHp); 
                pTotalMax += p.maxHp || 1;
            }
        });
        const playerRatio = pTotalNow / Math.max(1, pTotalMax);
        // è®¡ç®—æ•Œæ–¹æ€»è¡€é‡æ¯”
        let eTotalNow = 0, eTotalMax = 0;
        battle.enemyParty.forEach(e => { 
            if (e && typeof e.currHp === 'number') {
                eTotalNow += Math.max(0, e.currHp); 
                eTotalMax += e.maxHp || 1;
            }
        });
        const enemyRatio = eTotalNow / Math.max(1, eTotalMax);
        // å­˜æ´»æ•°é‡
        const alivePlayer = battle.playerParty.filter(p => p && typeof p.isAlive === 'function' && p.isAlive()).length;
        const aliveEnemy = battle.enemyParty.filter(e => e && typeof e.isAlive === 'function' && e.isAlive()).length;
        // ã€æè‡´æ”¶ç´§ã€‘çœŸÂ·ç»å¢ƒåˆ¤å®šï¼š
        // 1. ç»å¯¹æœ€åä¸€äºº + è¡€é‡å±æœºï¼ˆLast Man Standing + HP Crisisï¼‰
        //    ã€ä¿®å¤ã€‘1v1 æ»¡è¡€ä¸åº”è§¦å‘ï¼Œå¿…é¡»åŒæ—¶æ»¡è¶³"æœ€åä¸€åª"ä¸”"è¡€é‡ â‰¤ 40%"
        const isAbsoluteLastOne = (alivePlayer === 1) && (playerRatio <= 0.40);
        // 2. å…¨é˜Ÿæ¿’æ­»ï¼ˆå…¨é˜Ÿæ€»HP â‰¤ 10%ï¼Œå³ä½¿æœ‰å¤šåªå­˜æ´»ä¹Ÿéƒ½æ˜¯æ®‹è¡€ï¼‰
        const isNearWipeout = playerRatio <= 0.10;
        // 3. å·±æ–¹åªå‰©1åªï¼Œæ•Œæ–¹è¿˜æœ‰2åªä»¥ä¸Šï¼ˆçœŸæ­£çš„1vNåŠ£åŠ¿ï¼‰
        //    è¿™ç§æƒ…å†µä¸éœ€è¦è¡€é‡æ£€æŸ¥ï¼Œå› ä¸ºæ•°é‡åŠ£åŠ¿æœ¬èº«å°±æ˜¯ç»å¢ƒ
        const isOneVsMany = (alivePlayer === 1) && (aliveEnemy >= 2);
        return isAbsoluteLastOne || isNearWipeout || isOneVsMany;
    },
    /**
     * æ£€æŸ¥å½“å‰æ´»è·ƒç©å®¶ç²¾çµæ˜¯å¦æ»¡è¶³è¿›åŒ–/å…±é¸£æ¡ä»¶
     * @param {Pokemon} pokemon - è¦æ£€æŸ¥çš„å®å¯æ¢¦
     * @returns {Object|null} è¿›åŒ–ä¿¡æ¯æˆ– null
     */
    checkEligibility: function(pokemon) {
        // åŸºç¡€æ£€æŸ¥
        if (!pokemon || pokemon.currHp <= 0) return null;
        if (pokemon.hasEvolvedThisBattle || pokemon.hasBondResonance) return null;
        // è®¡ç®— AVs æ€»å’Œï¼ˆä½¿ç”¨æœ‰æ•ˆå€¼ï¼Œè€ƒè™‘ enable_insight è§£é”é™åˆ¶ï¼‰
        const avs = pokemon.avs || { trust: 0, passion: 0, insight: 0, devotion: 0 };
        const totalAVs = (pokemon.getEffectiveAVs('trust') || 0) + 
                         (pokemon.getEffectiveAVs('passion') || 0) + 
                         (pokemon.getEffectiveAVs('insight') || 0) + 
                         (pokemon.getEffectiveAVs('devotion') || 0);
        const baseId = pokemon.name.toLowerCase().replace(/[^a-z0-9]/g, '');
        const data = typeof POKEDEX !== 'undefined' ? POKEDEX[baseId] : null;
        if (!data) return null;
        const hpRatio = pokemon.currHp / pokemon.maxHp;
        // ============================================
        // è·¯å¾„ A: ç”Ÿå‘½è¿›åŒ– (Biological Evolution)
        // é€‚ç”¨ï¼šæœªå®Œå…¨è¿›åŒ–çš„å®å¯æ¢¦ï¼Œå±æœºæ—¶çªç ´
        // ============================================
        if (data.evos && data.evos.length > 0) {
            // å·² Mega æˆ–å·²å˜èº«çš„ä¸èƒ½å†è¿›åŒ–
            if (pokemon.isMega || pokemon.isTransformed) return null;
            const nextFormName = data.evos[0];
            const nextId = nextFormName.toLowerCase().replace(/[^a-z0-9]/g, '');
            const nextData = typeof POKEDEX !== 'undefined' ? POKEDEX[nextId] : null;
            if (!nextData) return null;
            // 1. ç­‰çº§é” (å…è®¸è¶Šçº§3çº§)
            const reqLevel = Math.max(1, (nextData.evoLevel || 1) - 3);
            if (pokemon.level < reqLevel) return null;
            // 2. AVs é˜ˆå€¼ï¼š
            // ä¸€é˜¶(æ— prevo): 80
            // äºŒé˜¶(æœ‰prevo): 160
            // åªæœ‰ä¸€æ¬¡è¿›åŒ–(æœ‰prevoä½†è¿›åŒ–å‹æ— evos): 140
            const isFirstStage = !data.prevo;
            const nextHasEvos = nextData.evos && nextData.evos.length > 0;
            let reqAVs;
            if (isFirstStage) {
                reqAVs = 80;  // ä¸€é˜¶æ®µ
            } else if (!nextHasEvos) {
                reqAVs = 140; // åªæœ‰ä¸€æ¬¡å‡çº§ï¼ˆäºŒé˜¶è¿›åŒ–åˆ°æœ€ç»ˆå½¢æ€ï¼‰
            } else {
                reqAVs = 160; // äºŒé˜¶æ®µï¼ˆè¿˜èƒ½ç»§ç»­è¿›åŒ–ï¼‰
            }
            if (totalAVs < reqAVs) return null;
            // 3. å±æœºé” (HP 35% ä»¥ä¸‹) æˆ– Ace å®å¯æ¢¦ 60% ä»¥ä¸‹
            const isCrisis = hpRatio <= 0.45;
            const isAceMoment = pokemon.isAce && hpRatio <= 0.6;
            if (isCrisis || isAceMoment) {
                return {
                    type: 'bio',
                    currentName: pokemon.cnName,
                    targetName: nextFormName,
                    targetId: nextId,
                    nextData: nextData,
                    totalAVs: totalAVs,
                    reqAVs: reqAVs
                };
            }
        }
        // ============================================
        // è·¯å¾„ B: çµé­‚å…±é¸£ (Bond Resonance)
        // é€‚ç”¨ï¼šæœ€ç»ˆå½¢æ€ï¼Œç»å¢ƒæ—¶çš„æœ€ååæ‰‘
        // ============================================
        else {
            // ã€è§£é”æ£€æŸ¥ã€‘ç»¿è‰²ç¾ç»Šå…±é¸£éœ€è¦ enable_bond è§£é”
            const unlocks = battle.playerUnlocks || {};
            if (unlocks.enable_bond === false) return null;
            // ã€å…¨å±€é™åˆ¶ã€‘æ¯åœºæˆ˜æ–—åªèƒ½ä½¿ç”¨ä¸€æ¬¡ Bond Resonance
            if (battle.playerBondUsed) return null;
            // æœ€ç»ˆå½¢æ€ (æ— è¿›åŒ–å‹)
            // 1. AVs ç»å¯¹é˜ˆå€¼ï¼ˆæ”¾å®½è‡³ 220ï¼‰
            if (totalAVs < 220) return null;
            // 2. å¿…é¡»æ˜¯ Ace å®å¯æ¢¦
            if (!pokemon.isAce) return null;
            // 3. ã€ä¸¥æ ¼åŠ£åŠ¿åˆ¤æ–­ã€‘ä¸ AI ä¸€è‡´
            //    è®¡ç®—åŒæ–¹æ€»è¡€é‡
            let playerTotalHp = 0, enemyTotalHp = 0;
            battle.playerParty.forEach(pp => {
                if (pp && typeof pp.isAlive === 'function') {
                    playerTotalHp += Math.max(0, pp.currHp || 0);
                }
            });
            battle.enemyParty.forEach(ep => {
                if (ep && typeof ep.isAlive === 'function') {
                    enemyTotalHp += Math.max(0, ep.currHp || 0);
                }
            });
            const aliveCount = battle.playerParty.filter(p => p && typeof p.isAlive === 'function' && p.isAlive()).length;
            const isLastStand = aliveCount === 1;
            // ã€ä¸¥æ ¼åŠ£åŠ¿æ¡ä»¶ã€‘
            // æ ¸å¿ƒæ¡ä»¶ï¼šå¿…é¡»æ˜¯æœ€åä¸€åªå®å¯æ¢¦ ä¸” HP <= 50%
            // å°è§„æ¨¡æˆ˜æ–—ï¼ˆåŒæ–¹å„ <= 2 åªï¼‰æ—¶ï¼Œå…è®¸è¡€é‡åŠ£åŠ¿è§¦å‘
            const currentPokemonCritical = hpRatio <= 0.50;
            const isSmallBattle = (battle.playerParty.length <= 2 && battle.enemyParty.length <= 2);
            const isHpDisadvantage = playerTotalHp < enemyTotalHp * 0.5;
            // è§¦å‘æ¡ä»¶ï¼š
            // 1. æœ€åä¸€åªå®å¯æ¢¦ + HP <= 50%
            // 2. æˆ–è€… å°è§„æ¨¡æˆ˜æ–— + è¡€é‡åŠ£åŠ¿ + HP <= 50%
            const canTriggerBond = currentPokemonCritical && (isLastStand || (isSmallBattle && isHpDisadvantage));
            if (canTriggerBond) {
                return {
                    type: 'bond',
                    currentName: pokemon.cnName,
                    targetName: `ç¾ç»ŠÂ·${pokemon.cnName}`,
                    totalAVs: totalAVs,
                    isLastStand: isLastStand,
                    isHpDisadvantage: isHpDisadvantage
                };
            }
        }
        return null;
    }
};
/**
 * æ›´æ–°è¿›åŒ–æŒ‰é’®å¯è§æ€§
 * åœ¨ updateAllVisuals ä¸­è°ƒç”¨
 */
function updateEvolutionButtonVisuals() {
    const btn = document.getElementById('btn-evolved');
    if (!btn) return;
    const p = battle.getPlayer();
    if (!p) {
        btn.classList.add('hidden');
        return;
    }
    const evoInfo = window.EvolutionSystem.checkEligibility(p);
    if (evoInfo) {
        btn.classList.remove('hidden');
        // æ ¹æ®ç±»å‹æ›´æ–°æŒ‰é’®æ ·å¼
        if (evoInfo.type === 'bond') {
            btn.classList.add('bond-mode');
            btn.title = 'ç¾ç»Šå…±é¸£ (Bond Resonance)';
        } else {
            btn.classList.remove('bond-mode');
            btn.title = 'è¿›åŒ– (Evolution)';
        }
        // æ˜¾ç¤ºæç¤ºæ—¥å¿—ï¼ˆæ¯ç§ç±»å‹åªæç¤ºä¸€æ¬¡ï¼‰
        if (evoInfo.type === 'bio' && !p._evoHintLogged) {
            log(`<span style="color:#d4ac0d; text-shadow:0 0 5px gold;">âœ¨ ${p.cnName} çš„å‘¨èº«æ¶ŒåŠ¨ç€è¿›åŒ–çš„å…‰èŠ’...å®ƒåœ¨å›åº”ä½ çš„æ„å¿—ï¼</span>`);
            p._evoHintLogged = true;
        } else if (evoInfo.type === 'bond' && !p._bondHintLogged) {
            log(`<span style="color:#4ade80; text-shadow:0 0 8px #22c55e;">âˆ ${p.cnName} ä¸è®­ç»ƒå®¶çš„å¿ƒè·³å¼€å§‹åŒæ­¥...ç¾ç»Šæ­£åœ¨è§‰é†’ï¼</span>`);
            p._bondHintLogged = true;
        }
    } else {
        btn.classList.add('hidden');
    }
}
/**
 * è§¦å‘æˆ˜æ–—ä¸­è¿›åŒ–/ç¾ç»Šå…±é¸£
 * ç‚¹å‡» EVO æŒ‰é’®æ—¶è°ƒç”¨
 */
window.triggerBattleEvolution = async function() {
    const btn = document.getElementById('btn-evolved');
    const p = battle.getPlayer();
    if (!p) return;
    const evoInfo = window.EvolutionSystem.checkEligibility(p);
    if (!evoInfo) return;
    battle.locked = true;
    btn.classList.add('hidden');
    const spriteRef = document.getElementById('player-sprite');
    // ============================================
    // è·¯å¾„ A: ç”Ÿå‘½è¿›åŒ– (Biological Evolution)
    // ============================================
    if (evoInfo.type === 'bio') {
        p.hasEvolvedThisBattle = true;
        const oldName = p.cnName;
        log(`<div class="log-evo-intro">âœ¨ å®å¯æ¢¦è¿›åŒ– âœ¨</div>`);
        log(`${oldName} çš„æ ·å­â€¦â€¦ï¼`);
        await wait(300);
        // åŠ¨ç”»ï¼šæ™®é€šè¿›åŒ–ç™½å…‰ï¼ˆä¸ Mega åŒºåˆ†ï¼‰
        if (spriteRef) {
            spriteRef.classList.add('bio-evo-glow');
        }
        await wait(800);
        // æ•°æ®å˜æ›´
        const newData = evoInfo.nextData;
        p.name = newData.name;
        p.cnName = newData.name;
        p.types = newData.types || p.types;
        p.baseStats = newData.baseStats;
        const stats = calcStats(p.baseStats, p.level, {
            ivs: p.statsMeta?.ivs || { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 },
            ev_level: p.statsMeta?.ev_level || 0,
            nature: p.nature
        });
        p.maxHp = stats.hp;
        p.atk = stats.atk;
        p.def = stats.def;
        p.spa = stats.spa;
        p.spd = stats.spd;
        p.spe = stats.spe;
        // å…¨å›å¤ + æ¸…çŠ¶æ€
        p.currHp = p.maxHp;
        p.status = null;
        // å…¨èƒ½åŠ›+1
        if (typeof p.applyBoost === 'function') {
            p.applyBoost('atk', 1);
            p.applyBoost('def', 1);
            p.applyBoost('spa', 1);
            p.applyBoost('spd', 1);
            p.applyBoost('spe', 1);
        }
        // ç™½å…‰çˆ†å‘ + æ¢å›¾
        if (spriteRef) {
            spriteRef.classList.remove('bio-evo-glow');
            spriteRef.classList.add('bio-evo-burst');
            const newSrc = p.getSprite(true);
            if (typeof smartLoadSprite === 'function') {
                delete spriteRequestedUrls['player-sprite'];
                smartLoadSprite('player-sprite', newSrc, false);
                spriteRequestedUrls['player-sprite'] = newSrc;
            }
        }
        await wait(400);
        // å†·å´åŠ¨ç”»
        if (spriteRef) {
            spriteRef.classList.remove('bio-evo-burst');
            spriteRef.classList.add('bio-evo-finish');
        }
        await wait(600);
        // æ¸…ç†åŠ¨ç”»ç±»ï¼ˆä¿ç•™ player-scale ç±»ï¼‰
        if (spriteRef) {
            spriteRef.classList.remove('bio-evo-silhouette', 'bio-evo-burst', 'bio-evo-finish');
            if (!spriteRef.classList.contains('loaded')) {
                spriteRef.classList.add('loaded');
            }
        }
        log(`â€¦â€¦${oldName} å…¨èº«åŒ…å›´äº†è€€çœ¼çš„å…‰èŠ’ï¼`);
        log(`<b style="color:#a855f7">æ­å–œï¼${oldName} è¿›åŒ–æˆäº† ${p.cnName}ï¼</b>`);
        log(`<span style="color:#4ade80">ä½“èƒ½å®Œå…¨æ¢å¤ï¼å…¨èƒ½åŠ›æå‡äº†ï¼</span>`);
        // AVs æ•ˆæœç¿»å€
        if (p.avs) {
            p.avsEvolutionBoost = true;
            log(`<span style="color:#ff6b9d">ğŸ’– è¿›åŒ–æ¿€å‘äº†æ½œåœ¨çš„æƒ…æ„ŸåŠ›é‡ï¼AVs æ•ˆæœç¿»å€ï¼</span>`);
        }
    }
    // ============================================
    // è·¯å¾„ B: çµé­‚å…±é¸£ (Bond Resonance)
    // ============================================
    else if (evoInfo.type === 'bond') {
        p.hasBondResonance = true;
        battle.playerBondUsed = true; // ã€å…¨å±€é™åˆ¶ã€‘æ ‡è®°å·²ä½¿ç”¨
        const oldName = p.cnName;
        const avs = p.avs || {};
        const totalAVs = (avs.trust || 0) + (avs.passion || 0) + (avs.insight || 0) + (avs.devotion || 0);
        // æ ‡é¢˜
        log(`<div style="border-top: 2px solid #4ade80; border-bottom: 2px solid #4ade80; padding: 8px; text-align: center; margin: 10px 0; background: linear-gradient(90deg, rgba(74,222,128,0.1), rgba(74,222,128,0.3), rgba(74,222,128,0.1));">`);
        log(`<b style="font-size:1.4em; color:#4ade80; text-shadow: 0 0 10px #22c55e;">âˆ BOND RESONANCE âˆ</b>`);
        log(`</div>`);
        await wait(500);
        log(`ä¸¤äººçš„å¿ƒè·³å®Œå…¨é‡åˆäº†â€¦â€¦`);
        await wait(400);
        log(`ä¸ºäº†å›åº”å½»åº•çš„ä¿¡èµ– <span style="color:#facc15">(Total AVs: ${totalAVs})</span>ï¼Œæ²‰ç¡åœ¨ä½“å†…çš„ç•Œé™è¢«æ‰“ç ´äº†ï¼`);
        // åŠ¨ç”»ï¼šé‡‘è‰²å…‰æ™•çˆ†å‘ï¼ˆä¸æ¢å›¾ï¼‰
        if (spriteRef) {
            spriteRef.classList.add('evo-burst');
            spriteRef.style.filter = 'brightness(3) drop-shadow(0 0 20px gold)';
        }
        await wait(400);
        if (spriteRef) {
            spriteRef.classList.remove('evo-burst');
            spriteRef.classList.add('evo-finish');
            // ä¿æŒé‡‘è‰²å…‰æ™•
            spriteRef.style.filter = 'drop-shadow(0 0 15px gold) brightness(1.15) saturate(1.2)';
        }
        await wait(600);
        if (spriteRef) {
            spriteRef.classList.remove('evo-finish');
            // æ·»åŠ ç¾ç»ŠçŠ¶æ€æ ‡è®°
            spriteRef.classList.add('bond-resonance');
        }
        // æ•°æ®å˜æ›´ï¼šä¸æ”¹å˜å½¢æ€ï¼Œä½†å¤§å¹… buff
        // 1. HP å›å¤ +60%ï¼ˆä¸æº¢å‡ºä¸Šé™ï¼‰
        const healAmount = Math.floor(p.maxHp * 0.6);
        p.currHp = Math.min(p.currHp + healAmount, p.maxHp);
        // 2. æ¸…é™¤æ‰€æœ‰å¼‚å¸¸
        p.status = null;
        // 3. å…¨èƒ½åŠ›+1ï¼ˆå¹³è¡¡è°ƒæ•´ï¼ŒåŸ +2ï¼‰
        if (typeof p.applyBoost === 'function') {
            p.applyBoost('atk', 1);
            p.applyBoost('def', 1);
            p.applyBoost('spa', 1);
            p.applyBoost('spd', 1);
            p.applyBoost('spe', 1);
            // è‹¥æœ‰ç‰¹æ®Šçš„ç¾ç»ŠæŒ‡æ ‡ï¼Œå¯ä»¥é™„åŠ é¢å¤–åŠ æˆ
            log(`<b style="color:#4ade80">âœ¦ ${p.cnName} çš„æ½œèƒ½è¢«å”¤é†’! æ”»é˜²ç‰¹æ”»ç‰¹é˜²é€Ÿåº¦å…¨é¢æå‡!</b>`);
        }
        await wait(300);
        log(`è¿™å¹¶éè¿›åŒ–â€¦â€¦è€Œæ˜¯è¶…è¶Šè¿›åŒ–çš„ <b style="color:#facc15">å…±é¸£å½¢æ€</b>ï¼`);
        log(`<span style="color:#4ade80">âœ¦ å…¨å±æ€§æå¤§å¹…æå‡ï¼</span>`);
        log(`<span style="color:#60a5fa">âœ¦ æ°”åŠ¿(HP)å¤§å¹…å›å¤ï¼(+${healAmount})</span>`);
        log(`<span style="color:#ff6b9d">âœ¦ AVs æ•ˆæœç¿»å€ï¼</span>`);
        if (evoInfo.isLastStand) {
            log(`<span style="color:#f87171; font-style:italic;">ã€Œå“ªæ€•åªå‰©æœ€åä¸€å£æ°”â€¦â€¦ä¹Ÿç»ä¸ä¼šæ”¾å¼ƒï¼ã€</span>`);
        }
    }
    updateAllVisuals();
    battle.locked = false;
};
// =========================================================
// COMMANDER SYSTEM (æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿ)
// =========================================================
// è®­ç»ƒå®¶ç†Ÿç»ƒåº¦å†³å®šæŒ‡æŒ¥èœå•å¼¹å‡ºé¢‘ç‡
// æŒ‡ä»¤æ˜ å°„åˆ° AVS å››ç»´ï¼Œæä¾›å¼ºåŠ›çš„å³æ—¶å¢ç›Š
/**
 * åˆå§‹åŒ–æˆ˜æœ¯æŒ‡æŒ¥ç³»ç»Ÿ
 * åœ¨æˆ˜æ–—å¼€å§‹æ—¶è°ƒç”¨
 */
function initCommanderSystem() {
    // è®­ç»ƒå®¶ç†Ÿç»ƒåº¦ (0-255)ï¼Œå½±å“è§¦å‘æ¦‚ç‡
    // ä» JSON è¯»å–ï¼Œé»˜è®¤ 120
    // JSON æ ¼å¼: player.trainerProficiency
    battle.trainerProficiency = battle.trainerProficiency || 120;
    // å½“å‰å›åˆçš„æ´»è·ƒæŒ‡ä»¤
    battle.activeCommand = null;
    // æœ¬åœºæˆ˜æ–—æŒ‡ä»¤ä½¿ç”¨æ¬¡æ•°ï¼ˆå…¨å±€è®¡æ•°ï¼‰
    // æ–°è§„åˆ™ï¼šdodge/crit æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™ï¼ˆæœ€å¤š6æ¬¡ï¼‰
    //        cure/endure æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€é™åˆ¶2æ¬¡
    battle.commandUsage = {
        dodge: 0,    // DODGE! (Insight) - æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™
        crit: 0,     // FOCUS! (Passion) - æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™
        cure: 0,     // LISTEN! (Devotion) - æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€2æ¬¡
        endure: 0    // ENDURE! (Trust) - æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€2æ¬¡
    };
    // æ¯ç§æŒ‡ä»¤çš„æœ€å¤§ä½¿ç”¨æ¬¡æ•°ï¼ˆå…¨å±€ï¼‰
    battle.commandLimits = {
        dodge: 99,   // æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™ï¼ˆç”±å®å¯æ¢¦æ ‡è®°æ§åˆ¶ï¼‰
        crit: 99,    // æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™ï¼ˆç”±å®å¯æ¢¦æ ‡è®°æ§åˆ¶ï¼‰
        cure: 2,     // å…¨å±€ 2 æ¬¡
        endure: 2    // å…¨å±€ 2 æ¬¡
    };
    // æŒ‡ä»¤å†·å´ï¼ˆå›åˆæ•°ï¼‰
    battle.commandCooldown = 0;
    console.log(`[COMMANDER] System initialized. Proficiency: ${battle.trainerProficiency}`);
}
/**
 * æ£€æŸ¥æ˜¯å¦åº”è¯¥æ˜¾ç¤ºæŒ‡æŒ¥èœå•
 * åœ¨ showMovesMenu æ—¶è°ƒç”¨
 * @returns {boolean}
 */
function shouldShowCommanderMenu() {
    if (!battle || battle.locked) return false;
    const p = battle.getPlayer();
    if (!p || !p.isAce || p.currHp <= 0) return false;
    // å†·å´ä¸­
    if (battle.commandCooldown > 0) {
        console.log(`[COMMANDER] On cooldown: ${battle.commandCooldown} turns remaining`);
        return false;
    }
    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¯ç”¨æŒ‡ä»¤
    // dodge/crit: æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™
    // cure/endure: æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€é™åˆ¶2æ¬¡
    const dodgeAvailable = !p.commandDodgeUsed;
    const critAvailable = !p.commandCritUsed;
    const cureAvailable = !p.commandCureUsed && battle.commandUsage.cure < battle.commandLimits.cure;
    const endureAvailable = !p.commandEndureUsed && battle.commandUsage.endure < battle.commandLimits.endure;
    const hasAvailableCommand = dodgeAvailable || critAvailable || cureAvailable || endureAvailable;
    if (!hasAvailableCommand) {
        console.log(`[COMMANDER] No available commands left for ${p.cnName}`);
        return false;
    }
    // æ¦‚ç‡è§¦å‘ï¼šChance = Proficiency / 512
    // æ»¡ç†Ÿç»ƒåº¦ 255 æ—¶çº¦ 50% è§¦å‘ç‡
    const proficiency = battle.trainerProficiency || 120;
    const triggerChance = proficiency / 512;
    const roll = Math.random();
    console.log(`[COMMANDER] Roll: ${roll.toFixed(3)} vs Chance: ${triggerChance.toFixed(3)} (Prof: ${proficiency})`);
    return roll < triggerChance;
}
/**
 * æ˜¾ç¤ºæŒ‡æŒ¥èœå•
 */
function showCommanderMenu() {
    const overlay = document.getElementById('commander-overlay');
    if (!overlay) return;
    // æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼ˆç¦ç”¨å·²ç”¨å®Œçš„æŒ‡ä»¤ï¼‰
    updateCommanderButtons();
    overlay.classList.remove('hidden');
    // æ’­æ”¾éŸ³æ•ˆ
    if (typeof window.playSFX === 'function') {
        window.playSFX('CONFIRM');
    }
    // æ—¥å¿—æç¤º
    log(`<span style="color:#fbbf24; font-weight:bold;">âš¡ çµå…‰ä¸€é—ªï¼ä½ æ„Ÿå—åˆ°äº†ä¸ä¼™ä¼´çš„å¿ƒçµå…±é¸£ï¼</span>`);
    console.log(`[COMMANDER] Menu shown`);
}
/**
 * å…³é—­æŒ‡æŒ¥èœå•
 */
function closeCommanderMenu() {
    const overlay = document.getElementById('commander-overlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
    if (typeof window.playSFX === 'function') {
        window.playSFX('CANCEL');
    }
    console.log(`[COMMANDER] Menu closed (cancelled)`);
}
/**
 * æ›´æ–°æŒ‡æŒ¥æŒ‰é’®çŠ¶æ€
 */
function updateCommanderButtons() {
    const p = battle.getPlayer();
    const btnMap = {
        dodge: '.pos-top',
        cure: '.pos-left',
        crit: '.pos-right',
        endure: '.pos-bottom'
    };
    // dodge å’Œ crit: æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼Œå…¨å±€ä¸é™
    const dodgeBtn = document.querySelector(btnMap.dodge);
    if (dodgeBtn && p) {
        if (p.commandDodgeUsed) {
            dodgeBtn.disabled = true;
            dodgeBtn.style.opacity = '0.4';
            dodgeBtn.style.pointerEvents = 'none';
        } else {
            dodgeBtn.disabled = false;
            dodgeBtn.style.opacity = '1';
            dodgeBtn.style.pointerEvents = 'auto';
        }
    }
    const critBtn = document.querySelector(btnMap.crit);
    if (critBtn && p) {
        if (p.commandCritUsed) {
            critBtn.disabled = true;
            critBtn.style.opacity = '0.4';
            critBtn.style.pointerEvents = 'none';
        } else {
            critBtn.disabled = false;
            critBtn.style.opacity = '1';
            critBtn.style.pointerEvents = 'auto';
        }
    }
    // cure å’Œ endure: æ¯åªå®å¯æ¢¦ä¸€æ¬¡ + å…¨å±€é™åˆ¶2æ¬¡
    const cureBtn = document.querySelector(btnMap.cure);
    if (cureBtn && p) {
        const cureDisabled = p.commandCureUsed || battle.commandUsage.cure >= battle.commandLimits.cure;
        if (cureDisabled) {
            cureBtn.disabled = true;
            cureBtn.style.opacity = '0.4';
            cureBtn.style.pointerEvents = 'none';
        } else {
            cureBtn.disabled = false;
            cureBtn.style.opacity = '1';
            cureBtn.style.pointerEvents = 'auto';
        }
    }
    const endureBtn = document.querySelector(btnMap.endure);
    if (endureBtn && p) {
        const endureDisabled = p.commandEndureUsed || battle.commandUsage.endure >= battle.commandLimits.endure;
        if (endureDisabled) {
            endureBtn.disabled = true;
            endureBtn.style.opacity = '0.4';
            endureBtn.style.pointerEvents = 'none';
        } else {
            endureBtn.disabled = false;
            endureBtn.style.opacity = '1';
            endureBtn.style.pointerEvents = 'auto';
        }
    }
}
/**
 * è§¦å‘æŒ‡ä»¤
 * @param {string} command - æŒ‡ä»¤ç±»å‹: 'dodge', 'crit', 'cure', 'endure'
 */
window.triggerCommand = function(command) {
    const overlay = document.getElementById('commander-overlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
    const p = battle.getPlayer();
    if (!p) return;
    // æ£€æŸ¥æ¯åªå®å¯æ¢¦ä¸€æ¬¡çš„é™åˆ¶
    if (command === 'dodge' && p.commandDodgeUsed) {
        log(`<span style="color:#ef4444;">${p.cnName} æœ¬åœºæˆ˜æ–—å·²ç»ä½¿ç”¨è¿‡ DODGE! æŒ‡ä»¤äº†ï¼</span>`);
        setTimeout(() => {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('moves-menu').classList.remove('hidden');
        }, 100);
        return;
    }
    if (command === 'crit' && p.commandCritUsed) {
        log(`<span style="color:#ef4444;">${p.cnName} æœ¬åœºæˆ˜æ–—å·²ç»ä½¿ç”¨è¿‡ FOCUS! æŒ‡ä»¤äº†ï¼</span>`);
        setTimeout(() => {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('moves-menu').classList.remove('hidden');
        }, 100);
        return;
    }
    if (command === 'cure' && p.commandCureUsed) {
        log(`<span style="color:#ef4444;">${p.cnName} æœ¬åœºæˆ˜æ–—å·²ç»ä½¿ç”¨è¿‡ LISTEN! æŒ‡ä»¤äº†ï¼</span>`);
        setTimeout(() => {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('moves-menu').classList.remove('hidden');
        }, 100);
        return;
    }
    if (command === 'endure' && p.commandEndureUsed) {
        log(`<span style="color:#ef4444;">${p.cnName} æœ¬åœºæˆ˜æ–—å·²ç»ä½¿ç”¨è¿‡ ENDURE! æŒ‡ä»¤äº†ï¼</span>`);
        setTimeout(() => {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('moves-menu').classList.remove('hidden');
        }, 100);
        return;
    }
    // æ£€æŸ¥å…¨å±€ä½¿ç”¨æ¬¡æ•°ï¼ˆcure/endure å…¨å±€é™åˆ¶2æ¬¡ï¼‰
    if ((command === 'cure' || command === 'endure') && 
        battle.commandUsage[command] >= battle.commandLimits[command]) {
        log(`<span style="color:#ef4444;">${command === 'cure' ? 'LISTEN!' : 'ENDURE!'} æŒ‡ä»¤å…¨å±€æ¬¡æ•°å·²ç”¨å°½ï¼</span>`);
        setTimeout(() => {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('moves-menu').classList.remove('hidden');
        }, 100);
        return;
    }
    // è®¾ç½®æ´»è·ƒæŒ‡ä»¤
    battle.activeCommand = command;
    battle.commandUsage[command]++;
    // æ ‡è®°æ¯åªå®å¯æ¢¦ä¸€æ¬¡çš„æŒ‡ä»¤ï¼ˆæ‰€æœ‰æŒ‡ä»¤éƒ½æ˜¯æ¯åªå®å¯æ¢¦ä¸€æ¬¡ï¼‰
    if (command === 'dodge') {
        p.commandDodgeUsed = true;
    } else if (command === 'crit') {
        p.commandCritUsed = true;
    } else if (command === 'cure') {
        p.commandCureUsed = true;
    } else if (command === 'endure') {
        p.commandEndureUsed = true;
    }
    // è®¾ç½®å†·å´ï¼ˆ2å›åˆåæ‰èƒ½å†æ¬¡è§¦å‘æŒ‡æŒ¥èœå•ï¼‰
    battle.commandCooldown = 2;
    const commandInfo = {
        dodge: { emoji: 'ğŸ‘ï¸', label: 'DODGE!', cn: 'å¿«é¿å¼€', avs: 'Insight', color: '#00cec9' },
        crit: { emoji: 'ğŸ”¥', label: 'FOCUS!', cn: 'å‡»ä¸­è¦å®³', avs: 'Passion', color: '#ff6b6b' },
        cure: { emoji: 'ğŸ¤', label: 'LISTEN!', cn: 'å¿«æ¸…é†’', avs: 'Trust', color: '#f1c40f' },
        endure: { emoji: 'ğŸ›¡ï¸', label: 'HOLD ON!', cn: 'æ’‘ä¸‹å»', avs: 'Devotion', color: '#a55eea' }
    };
    const info = commandInfo[command];
    // æ’­æ”¾éŸ³æ•ˆ
    if (typeof window.playSFX === 'function') {
        window.playSFX('MEGA_EVOLVE');
    }
    // æ—¥å¿—è¾“å‡º
    log(`<div style="border-left: 4px solid ${info.color}; padding-left: 10px; margin: 5px 0;">`);
    log(`<b style="color:${info.color}; font-size: 1.1em;">ğŸ—£ï¸ [æŒ‡æŒ¥] "${info.cn}ï¼"</b>`);
    log(`<span style="color:#9ca3af; font-size: 0.9em;">${p.cnName} æ„Ÿå—åˆ°äº†è®­ç»ƒå®¶çš„æ„å¿—ï¼(${info.avs})</span>`);
    log(`</div>`);
    console.log(`[COMMANDER] Command triggered: ${command} (${info.cn})`);
    // ç«‹å³åº”ç”¨æŸäº›æ•ˆæœ
    applyCommandEffect(command, p);
    // é€‰æ‹©æŒ‡ä»¤åï¼Œç»§ç»­æ˜¾ç¤ºæŠ€èƒ½èœå•
    setTimeout(() => {
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('moves-menu').classList.remove('hidden');
        if (typeof updateMegaButtonVisibility === 'function') {
            updateMegaButtonVisibility();
        }
    }, 100);
};
/**
 * åº”ç”¨æŒ‡ä»¤æ•ˆæœ
 * @param {string} command - æŒ‡ä»¤ç±»å‹
 * @param {Pokemon} pokemon - ç›®æ ‡å®å¯æ¢¦
 */
function applyCommandEffect(command, pokemon) {
    switch (command) {
        case 'dodge':
            // é—ªé¿ï¼šæœ¬å›åˆé—ªé¿ç‡ç¿»å€ï¼ˆåœ¨ battle-calc.js ä¸­æ£€æŸ¥ï¼‰
            pokemon.commandDodgeActive = true;
            break;
        case 'crit':
            // æš´å‡»ï¼šä¸‹æ¬¡æ”»å‡»å¿…å®šæš´å‡»ï¼ˆåœ¨ battle-calc.js ä¸­æ£€æŸ¥ï¼‰
            pokemon.commandCritActive = true;
            break;
        case 'cure':
            // LISTEN! è§£æ§ï¼šæ¦‚ç‡æ¸…é™¤ç•ç¼©/æ··ä¹±/ç€è¿·
            // åŸºç¡€ 40% + Devotion AVS 50%ï¼ˆæ»¡å€¼æ—¶ 90%ï¼‰
            let listenChance = 0.40; // åŸºç¡€ 40%
            // Devotion AVS åŠ æˆï¼šæ»¡å€¼ 255 æ—¶ +50%
            if (pokemon.isAce && pokemon.avs && pokemon.avs.devotion > 0) {
                const baseDevotion = pokemon.getEffectiveAVs('devotion');
                const effectiveDevotion = pokemon.avsEvolutionBoost ? baseDevotion * 2 : baseDevotion;
                const devotionBonus = (Math.min(effectiveDevotion, 255) / 255) * 0.50;
                listenChance += devotionBonus;
                console.log(`[COMMANDER] LISTEN! Devotion åŠ æˆ: +${(devotionBonus * 100).toFixed(1)}% (Devotion: ${baseDevotion})`);
            }
            listenChance = Math.min(listenChance, 1.0); // ä¸Šé™ 100%
            const listenRoll = Math.random();
            console.log(`[COMMANDER] LISTEN! Roll: ${(listenRoll * 100).toFixed(1)}% vs Chance: ${(listenChance * 100).toFixed(1)}%`);
            if (listenRoll < listenChance) {
                // æˆåŠŸï¼šæ¸…é™¤è´Ÿé¢çŠ¶æ€
                let cured = false;
                if (pokemon.volatile) {
                    if (pokemon.volatile.flinch) {
                        delete pokemon.volatile.flinch;
                        cured = true;
                    }
                    if (pokemon.volatile.confusion) {
                        delete pokemon.volatile.confusion;
                        delete pokemon.volatile.confusionTurns;
                        cured = true;
                    }
                    if (pokemon.volatile.attract) {
                        delete pokemon.volatile.attract;
                        cured = true;
                    }
                }
                if (cured) {
                    log(`<b style="color:#f1c40f">ğŸ’« ${pokemon.cnName} æ¢å¤äº†æ¸…é†’ï¼</b>`);
                }
                // æœ¬å›åˆæ”»å‡»ä¸å—è´Ÿé¢çŠ¶æ€å½±å“
                pokemon.commandCureActive = true;
                log(`<b style="color:#ff9f43; text-shadow:0 0 8px #ff9f43;">ğŸ¤ LISTEN! æŒ‡ä»¤æˆåŠŸï¼${pokemon.cnName} å¬ä»äº†è®­ç»ƒå®¶çš„æŒ‡æŒ¥ï¼</b>`);
            } else {
                log(`<span style="color:#ef4444;">LISTEN! æŒ‡ä»¤å¤±è´¥...${pokemon.cnName} æ²¡èƒ½å¬åˆ°è®­ç»ƒå®¶çš„å£°éŸ³...</span>`);
            }
            break;
        case 'endure':
            // æŒºä½ï¼šæœ¬å›åˆæ”¶åˆ°è‡´å‘½ä¼¤å¿…å®šä¿ç•™ 1 HPï¼ˆåœ¨ takeDamage ä¸­æ£€æŸ¥ï¼‰
            pokemon.commandEndureActive = true;
            break;
    }
}
/**
 * å›åˆç»“æŸæ—¶æ¸…ç†æŒ‡ä»¤çŠ¶æ€
 */
function clearCommandEffects() {
    const p = battle.getPlayer();
    if (p) {
        p.commandDodgeActive = false;
        p.commandCritActive = false;
        p.commandCureActive = false;
        p.commandEndureActive = false;
    }
    // æ¸…é™¤æ´»è·ƒæŒ‡ä»¤
    battle.activeCommand = null;
    // å‡å°‘å†·å´
    if (battle.commandCooldown > 0) {
        battle.commandCooldown--;
    }
}
// å¯¼å‡ºåˆ°å…¨å±€
window.initCommanderSystem = initCommanderSystem;
window.shouldShowCommanderMenu = shouldShowCommanderMenu;
window.showCommanderMenu = showCommanderMenu;
window.closeCommanderMenu = closeCommanderMenu;
window.clearCommandEffects = clearCommandEffects;
]]></file>
    <file name="ISLEADER_IMPLEMENTATION.md"><![CDATA[# isLead åŠŸèƒ½å®ç°æ€»ç»“
## åŠŸèƒ½è¯´æ˜
`isLead` å­—æ®µç”¨äºæ ‡è®°å“ªåªå®å¯æ¢¦åº”è¯¥ä½œä¸ºé¦–å‘å‡ºæˆ˜ã€‚å½“æŸåªå®å¯æ¢¦çš„ `isLead` è®¾ç½®ä¸º `true` æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†å…¶ç§»åŠ¨åˆ°é˜Ÿä¼çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼ˆåœ¨æˆ˜æ–—UIä¸­ï¼‰ã€‚
## å®ç°ç»†èŠ‚
### 1. Pokemon æ„é€ å‡½æ•° (battle-engine.js:602-603)
```javascript
// é¦–å‘æ ‡è®° (isLead) - æ ‡è®°è¯¥å®å¯æ¢¦æ˜¯å¦ä¸ºé¦–å‘å‡ºæˆ˜
this.isLead = config.isLead || false;
```
### 2. STæ’ä»¶æ”¯æŒ (pkm-tavern-plugin.js:7007-7018)
åœ¨ `normalizePokemonFormat` å‡½æ•°ä¸­æ·»åŠ äº† `isLead` å’Œ `isAce` å­—æ®µçš„ä¿ç•™é€»è¾‘ï¼š
```javascript
// === ç¡®ä¿ isAce å’Œ isLead è¢«ä¿ç•™ ===
// isAce: æ ‡è®°ç‹ç‰Œå®å¯æ¢¦ï¼ˆç”¨äºç¾ç»Šå…±é¸£ç­‰ç‰¹æ®Šæœºåˆ¶ï¼‰
// isLead: æ ‡è®°é¦–å‘å®å¯æ¢¦ï¼ˆè‡ªåŠ¨ç§»åˆ°é˜Ÿä¼ç¬¬ä¸€ä½ï¼‰
if (pokemon.isAce !== undefined) {
  pokemon.isAce = Boolean(pokemon.isAce);
}
if (pokemon.isLead !== undefined) {
  pokemon.isLead = Boolean(pokemon.isLead);
  if (pokemon.isLead) {
    console.log(`${PLUGIN_NAME} [LEAD] ${pokemon.name} marked as lead Pokemon`);
  }
}
```
### 3. ç©å®¶é˜Ÿä¼å¤„ç† (battle-engine.js:1368-1380)
åœ¨ `setPlayerParty` æ–¹æ³•ä¸­æ·»åŠ äº†è‡ªåŠ¨äº¤æ¢é€»è¾‘ï¼š
- æŸ¥æ‰¾æ ‡è®°ä¸º `isLead: true` çš„å®å¯æ¢¦
- å¦‚æœæ‰¾åˆ°ä¸”ä¸åœ¨ç¬¬ä¸€ä½ï¼Œè‡ªåŠ¨ä¸ç¬¬ä¸€ä½äº¤æ¢
- å¦‚æœå·²åœ¨ç¬¬ä¸€ä½ï¼Œä¿æŒä¸å˜
- å¦‚æœéƒ½ä¸º `false`ï¼Œä½¿ç”¨é»˜è®¤é¡ºåº
### 4. æ•Œæ–¹é˜Ÿä¼å¤„ç† (battle-engine.js:1328-1340)
åœ¨ `loadFromJSON` æ–¹æ³•ä¸­æ·»åŠ äº†ç›¸åŒçš„è‡ªåŠ¨äº¤æ¢é€»è¾‘ï¼Œç¡®ä¿æ•Œæ–¹è®­ç»ƒå®¶çš„é¦–å‘å®å¯æ¢¦ä¹Ÿèƒ½æ­£ç¡®å¤„ç†ã€‚
### 5. JSON æ•°æ®æ ¼å¼ç¤ºä¾‹
```json
"party": [
  {
    "name": "Zacian-Crowned",
    "lv": 99,
    "isAce": true,
    "isLead": false,
    "moves": [...]
  },
  {
    "name": "Cinderace",
    "lv": 97,
    "isLead": true,
    "mechanic": "dynamax",
    "moves": [...]
  },
  {
    "name": "Rillaboom",
    "lv": 95,
    "isLead": false,
    "moves": [...]
  }
]
```
## é€»è¾‘è§„åˆ™
1. **åªèƒ½æœ‰ä¸€åªé¦–å‘**ï¼šç³»ç»Ÿä¼šæŸ¥æ‰¾ç¬¬ä¸€ä¸ª `isLead: true` çš„å®å¯æ¢¦
2. **è‡ªåŠ¨äº¤æ¢ä½ç½®**ï¼šæ‰¾åˆ°åä¼šä¸ç¬¬ä¸€ä½äº¤æ¢ï¼Œç¡®ä¿é¦–å‘åœ¨ç¬¬ä¸€ä¸ªä½ç½®
3. **é»˜è®¤è¡Œä¸º**ï¼šå¦‚æœæ‰€æœ‰å®å¯æ¢¦éƒ½æ˜¯ `false`ï¼Œåˆ™ä½¿ç”¨ JSON ä¸­çš„åŸå§‹é¡ºåº
4. **æ§åˆ¶å°æ—¥å¿—**ï¼šç³»ç»Ÿä¼šè¾“å‡º `[LEAD]` æ ‡ç­¾çš„æ—¥å¿—ï¼Œæ–¹ä¾¿è°ƒè¯•
5. **STæ’ä»¶æ”¯æŒ**ï¼šPKM_FRONTEND ä¼šè‡ªåŠ¨ä¿ç•™ `isLead` å­—æ®µå¹¶è¾“å‡ºæ—¥å¿—
## ç¤ºä¾‹åœºæ™¯
åœ¨ Gloria çš„é˜Ÿä¼ä¸­ï¼š
- åŸå§‹é¡ºåºï¼šZacian-Crowned (ç¬¬1ä½), Cinderace (ç¬¬2ä½), Rillaboom (ç¬¬3ä½)...
- Cinderace æ ‡è®°ä¸º `isLead: true`
- æˆ˜æ–—å¼€å§‹æ—¶è‡ªåŠ¨äº¤æ¢ï¼šCinderace (ç¬¬1ä½), Zacian-Crowned (ç¬¬2ä½), Rillaboom (ç¬¬3ä½)...
- æˆ˜æ–—UIä¸­ Cinderace ä¼šä½œä¸ºé¦–å‘å‡ºæˆ˜
## å‘½åç†ç”±
- **æœ¯è¯­å‡†ç¡®æ€§**ï¼šåœ¨ç«æŠ€å¯¹æˆ˜ï¼ˆVGC/Pokemon Showdownï¼‰ä¸­ï¼Œé¦–å‘å®å¯æ¢¦ç§°ä¸º "Lead"
- **è¯­ä¹‰æ¸…æ™°**ï¼šç›¸æ¯” `isFirst` æˆ– `active`ï¼Œ`isLead` æ˜ç¡®æŒ‡ä»£"é¢†å¤´"çš„ä½ç½®é€»è¾‘
- **å‘½åä¸€è‡´æ€§**ï¼šä¸ç°æœ‰çš„ `isAce` å­—æ®µä¿æŒç›¸åŒçš„é©¼å³°å‘½åé£æ ¼
## å®Œæ•´å®ç°æ–‡ä»¶åˆ—è¡¨
1. âœ… `engine/battle-engine.js` - Pokemonæ„é€ å‡½æ•° + é˜Ÿä¼äº¤æ¢é€»è¾‘
2. âœ… `ST/pkm-tavern-plugin.js` - PKM_FRONTEND å­—æ®µä¿ç•™
3. âœ… `data/trainer-data.js` - ç¤ºä¾‹æ•°æ®ï¼ˆGloria Tier 4ï¼‰
]]></file>
    <file name="mega-selection-dialog.js"><![CDATA[/**
 * æ˜¾ç¤º Mega å½¢æ€é€‰æ‹©å¯¹è¯æ¡†ï¼ˆå–·ç«é¾™/è¶…æ¢¦ X/Y é€‰æ‹©ï¼‰
 * [UIé‡æ„ V2]ï¼šå±€éƒ¨ç£¨ç ‚ç»ç’ƒé£æ ¼ (Container Glassmorphism)
 * å»é™¤äº†å…¨å±æ¨¡ç³Šï¼Œåªè®©å¡ç‰‡æœ¬èº«æœ‰åŠé€æ˜ç£¨ç ‚æ„Ÿ
 * 
 * @param {Pokemon} pokemon - å®å¯æ¢¦å®ä¾‹
 * @param {Function} callback - é€‰æ‹©å®Œæˆåçš„å›è°ƒå‡½æ•°ï¼Œå‚æ•°ä¸ºé€‰ä¸­çš„å½¢æ€ ID
 */
function showMegaFormSelectionDialog(pokemon, callback) {
    // 1. æ³¨å…¥åŠ¨ç”»æ ·å¼
    if (!document.getElementById('mega-selection-modern-style')) {
        const style = document.createElement('style');
        style.id = 'mega-selection-modern-style';
        style.textContent = `
            :root {
                --mega-x-color: #3b82f6; 
                --mega-y-color: #ef4444; 
                --mega-base-color: #a855f7;
            }
            .mega-overlay-simple {
                animation: fadeInOpacity 0.3s ease-out forwards;
            }
            @keyframes fadeInOpacity {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes glassUp {
                from { opacity: 0; transform: translateY(30px) skewX(-10deg); }
                to { opacity: 1; transform: translateY(0) skewX(-10deg); }
            }
            /* èƒŒæ™¯çº¹ç†å¾®è°ƒ */
            .mega-bg-grid {
                background-image: 
                    linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
                background-size: 20px 20px;
            }
        `;
        document.head.appendChild(style);
    }
    // 2. åˆ›å»ºé®ç½©å±‚ (çº¯ç²¹çš„åŠé€æ˜é»‘åº•å±‚ï¼Œæ— æ¨¡ç³Š)
    const overlay = document.createElement('div');
    overlay.className = 'mega-selection-overlay mega-overlay-simple';
    overlay.style.cssText = `
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.45); /* ç¨å¾®åŠ æ·±é®ç½©ï¼Œçªå‡ºä¸­é—´çš„ç»ç’ƒå¡ç‰‡ */
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 12000;
    `;
    // 3. åˆ›å»º UI ä¸è§„åˆ™å®¹å™¨ (è¿™æ‰æ˜¯å¸¦é«˜æ–¯æ¨¡ç³Šçš„ä¸»ä½“)
    const dialogShape = document.createElement('div');
    dialogShape.className = 'mega-dialog-shape';
    dialogShape.style.cssText = `
        position: relative;
        /* æ”¹åŠ¨ç‚¹ï¼šèƒŒæ™¯è®¾ä¸ºåŠé€æ˜ï¼Œæ‰“å¼€ Backdrop Filter */
        background: rgba(255, 255, 255, 0.85); 
        backdrop-filter: blur(20px) saturate(1.8);
        -webkit-backdrop-filter: blur(20px) saturate(1.8);
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 
            0 25px 50px -12px rgba(0, 0, 0, 0.4), /* æŠ•å½±ä¹Ÿæ›´æ·±ä¸€ç‚¹ä»¥å¢åŠ ç«‹ä½“æ„Ÿ */
            inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        padding: 40px 60px;
        border-radius: 20px;
        max-width: 620px;
        /* ä¿æŒæ–œåˆ‡é£æ ¼ï¼Œä½†è§’åº¦ç¨å¾®æ¸©å’Œä¸€ç‚¹ */
        transform: skewX(-10deg);
        animation: glassUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); /* æœ‰å¼¹æ€§çš„å…¥åœº */
        overflow: hidden;
    `;
    // 3.1 è£…é¥°æ€§ç½‘æ ¼èƒŒæ™¯ (è®©ç»ç’ƒè´¨æ„Ÿæ›´æ˜æ˜¾)
    const bgDecor = document.createElement('div');
    bgDecor.className = 'mega-bg-grid';
    bgDecor.style.cssText = `
        position: absolute;
        top: -50%; left: -50%; width: 200%; height: 200%;
        z-index: 0;
        pointer-events: none;
        transform: skewX(10deg); /* æŠµæ¶ˆçˆ¶çº§æ–œåˆ‡ */
        opacity: 0.6;
    `;
    dialogShape.appendChild(bgDecor);
    // 3.2 é¡¶éƒ¨å½©è‰²è£…é¥°æ¡ (ä¿ç•™ï¼Œå¢åŠ è§†è§‰é‡å¿ƒ)
    const topBar = document.createElement('div');
    topBar.style.cssText = `
        position: absolute;
        top: 0; left: 0; right: 0;
        height: 6px;
        background: linear-gradient(90deg, #3b82f6 0%, #a855f7 50%, #ef4444 100%);
        z-index: 2;
        /* ç»™ä¸€ç‚¹å…‰æ³½ */
        box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    `;
    dialogShape.appendChild(topBar);
    // 4. å†…å®¹å®¹å™¨ (åå‘æ–œåˆ‡ 10åº¦ æ‰¶æ­£)
    const content = document.createElement('div');
    content.style.cssText = `
        transform: skewX(10deg);
        position: relative;
        z-index: 5;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    `;
    // 5. æ ‡é¢˜ä¸ä¿¡æ¯
    const title = document.createElement('h2');
    title.innerHTML = `MEGA EVOLUTION`;
    title.style.cssText = `
        color: #1e293b;
        font-family: inherit;
        font-size: 36px;
        font-weight: 900;
        font-style: italic;
        margin: 0;
        letter-spacing: -1.5px;
        line-height: 1;
        text-shadow: 2px 2px 0px rgba(255,255,255,0.4);
    `;
    const subTitle = document.createElement('div');
    subTitle.textContent = `Select form for ${pokemon.cnName || pokemon.name}`;
    subTitle.style.cssText = `
        color: #64748b;
        font-size: 15px;
        font-weight: 600;
        margin-top: 5px;
        margin-bottom: 35px;
        text-transform: uppercase;
        letter-spacing: 1px;
    `;
    // 6. é€‰é¡¹æŒ‰é’®å®¹å™¨
    const optionsContainer = document.createElement('div');
    optionsContainer.style.cssText = `
        display: flex;
        gap: 24px;
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
    `;
    // 7. å½¢æ€å¤„ç†é€»è¾‘
    const forms = pokemon.megaFormsAvailable || [];
    if(forms.length === 0) {
        const base = pokemon.name.toLowerCase();
        if(base.includes('mewtwo') || base.includes('charizard')) {
            forms.push(base.endsWith('mega') ? base + 'x' : base + 'megax');
            forms.push(base.endsWith('mega') ? base + 'y' : base + 'megay');
        } else {
            forms.push('default'); 
        }
    }
    forms.forEach(formId => {
        const isX = formId.toLowerCase().includes('x');
        const isY = formId.toLowerCase().includes('y');
        let labelLarge = isX ? 'X' : isY ? 'Y' : 'âˆ';
        let subText = isX ? 'ATTACK' : isY ? 'SPECIAL' : 'POWER'; // ç®€å•çš„æè¿°
        if (formId === 'default') subText = 'UNLOCK';
        let themeColor = isX ? '#3b82f6' : isY ? '#ef4444' : '#a855f7';
        // æŒ‰é’® (çº¯ç™½èƒŒæ™¯å¡ç‰‡ï¼Œå¯ä»¥å¾®å¾®é€å‡ºä¸€ç‚¹åº•è‰²)
        const btn = document.createElement('div');
        btn.style.cssText = `
            flex: 1;
            min-width: 130px;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255,255,255,0.8);
            border-bottom: 4px solid ${themeColor}15; /* ææ·¡å½©è‰²åº•è¾¹ */
            border-radius: 16px;
            padding: 25px 15px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* å†…éƒ¨ä¸éœ€è¦æ¨¡ç³Šï¼Œä¿æŒæ¸…æ™° */
        `;
        btn.innerHTML = `
            <div style="font-size: 12px; font-weight: 800; color: ${themeColor}; opacity: 0.8; letter-spacing: 1.5px; margin-bottom: 4px;">MEGA</div>
            <div style="font-size: 56px; font-weight: 900; color: #1e293b; line-height:1; font-style: italic; position: relative; z-index:2;">${labelLarge}</div>
            <div style="font-size: 11px; font-weight: 700; color: #94a3b8; margin-top: 4px; letter-spacing: 0.5px;">${subText}</div>
            <div class="fill-anim" style="
                position: absolute; bottom: 0; left: 0; right: 0; height: 0; 
                background: ${themeColor}; z-index: 1;
                transition: height 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            "></div>
        `;
        // æ‚¬åœäº¤äº’ (å¡ç‰‡ä¸Šæµ® + å¡«è‰²)
        btn.onmouseenter = () => {
             btn.style.transform = 'translateY(-6px)';
             // ä¸‹è¾¹æ¡†æ¶ˆå¤±ï¼Œå˜æˆæ•´ä½“é¢œè‰²
             btn.style.borderBottomColor = themeColor; 
             // æŠ•å½±åŠ æ·±
             btn.style.boxShadow = `0 12px 25px -5px ${themeColor}40`;
             // æ–‡å­—å˜ç™½
             btn.children[0].style.color = 'rgba(255,255,255,0.8)';
             btn.children[1].style.color = '#fff'; 
             btn.children[2].style.color = 'rgba(255,255,255,0.6)';
             // å¡«å……èƒŒæ™¯
             btn.querySelector('.fill-anim').style.height = '100%';
        };
        btn.onmouseleave = () => {
             btn.style.transform = 'translateY(0)';
             btn.style.borderBottomColor = `${themeColor}15`;
             btn.style.boxShadow = 'none';
             btn.children[0].style.color = themeColor;
             btn.children[1].style.color = '#1e293b';
             btn.children[2].style.color = '#94a3b8';
             btn.querySelector('.fill-anim').style.height = '0';
        };
        btn.onclick = () => {
            overlay.style.transition = 'opacity 0.2s';
            overlay.style.opacity = '0';
            setTimeout(() => document.body.removeChild(overlay), 200);
            callback(formId);
        };
        optionsContainer.appendChild(btn);
    });
    // 8. å–æ¶ˆæŒ‰é’®
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'CANCEL';
    cancelBtn.style.cssText = `
        margin-top: 35px;
        background: transparent;
        border: 2px solid #cbd5e1;
        color: #94a3b8;
        font-weight: 800;
        font-size: 13px;
        letter-spacing: 1px;
        cursor: pointer;
        padding: 8px 32px;
        border-radius: 50px;
        transition: all 0.2s;
        font-family: inherit;
    `;
    cancelBtn.onmouseenter = () => {
        cancelBtn.style.borderColor = '#94a3b8';
        cancelBtn.style.color = '#64748b';
        cancelBtn.style.background = '#fff';
    };
    cancelBtn.onmouseleave = () => {
        cancelBtn.style.borderColor = '#cbd5e1';
        cancelBtn.style.color = '#94a3b8';
        cancelBtn.style.background = 'transparent';
    };
    cancelBtn.onclick = () => {
        overlay.style.transition = 'opacity 0.2s';
        overlay.style.opacity = '0';
        setTimeout(() => document.body.removeChild(overlay), 200);
        callback(null);
    };
    // ç»„è£…ç»“æ„
    content.appendChild(title);
    content.appendChild(subTitle);
    content.appendChild(optionsContainer);
    content.appendChild(cancelBtn);
    dialogShape.appendChild(content);
    overlay.appendChild(dialogShape);
    // ä¸€å®šè¦å…ˆæŒ‚è½½åˆ° bodyï¼ŒBackdrop Filter æ‰ä¼šç”Ÿæ•ˆ
    document.body.appendChild(overlay);
    overlay.onclick = (e) => {
        if(e.target === overlay) {
            cancelBtn.click();
        }
    };
}
]]></file>
    <file name="README.md"><![CDATA[
# è‡´è°¢åå• (Credits & Acknowledgments)
æœ¬é¡¹ç›® æ˜¯ä¸€ä¸ªåŸºäº Web æŠ€æœ¯çš„å®å¯æ¢¦å¯¹æˆ˜æ¨¡æ‹Ÿå¼•æ“ã€‚æœ¬é¡¹ç›®çš„å®ç°ç¦»ä¸å¼€å¼€æºç¤¾åŒºçš„æ— ç§è´¡çŒ®ã€ä¼˜ç§€çš„èµ„æºæ•´ç†è€…ä»¥åŠåŸå§‹ç‰ˆæƒæ‰€æœ‰è€…çš„åˆ›ä½œã€‚
ä»¥ä¸‹æ˜¯æœ¬é¡¹ç›®å¼•ç”¨çš„èµ„æºåˆ—è¡¨åŠè‡´è°¢ã€‚
## ğŸ› ï¸ æ ¸å¿ƒæ•°æ®ä¸å¼•æ“æœºåˆ¶ / Core Data & Mechanics
æœ¬é¡¹ç›®çš„å¤§éƒ¨åˆ†æˆ˜æ–—æ•°æ®ã€ä¼¤å®³è®¡ç®—å…¬å¼åŠåŸºç¡€é€»è¾‘é«˜åº¦å‚è€ƒå¹¶ç§»æ¤è‡ª **PokÃ©mon Showdown** é¡¹ç›®ã€‚
*   **PokÃ©mon Showdown**: [https://pokemonshowdown.com/](https://pokemonshowdown.com/)
:   **Github**: [smogon/pokemon-showdown](https://github.com/smogon/pokemon-showdown)
    *   å¼•ç”¨äº† `data/` ç›®å½•ä¸‹çš„å®å¯æ¢¦ç§æ—å€¼ (Pokedex)ã€æ‹›å¼æ•°æ® (Moves)ã€ç‰¹æ€§æ•°æ® (Abilities) åŠé“å…·ä¿¡æ¯ (Items)ã€‚
    *   å‚è€ƒäº†å…¶ä¼¤å®³è®¡ç®—é€»è¾‘ (Damage Calc) ä¸çŠ¶æ€æœºåˆ¶å¤„ç†ã€‚
## ğŸ‡¨ğŸ‡³ æœ¬åœ°åŒ–ä¸ç¿»è¯‘ / Localization
æœ¬é¡¹ç›®ä½¿ç”¨çš„ä¸­æ–‡æŠ€èƒ½ã€ç‰¹æ€§åŠæè¿°æ–‡æœ¬ï¼Œç”± **PSChina (Pokemon Showdown China)** ç¤¾åŒºåŠå…¶è´¡çŒ®è€…æ•´ç†åˆ¶ä½œã€‚
*   **Showdown Translation (Tampermonkey Script)**
    *   **è„šæœ¬ä½œè€… (Author)**: Ceca3
    *   **é¡¹ç›®æ¥æº**: PSChina Server Translation (å‰‘ç›¾æµ‹è¯•å…ˆè¡Œç‰ˆ)
    *   **è´¡çŒ®**: æ ¸å¿ƒçš„â€œä¸­-è‹±â€æ˜ å°„å­—å…¸ï¼ˆæ±‰åŒ–æ•°æ®åº“ï¼‰ç›´æ¥å–æäºè¯¥é¡¹ç›®çš„ç»è¿‡ç¤¾åŒºé•¿æœŸéªŒè¯çš„ç¿»è¯‘æ•°æ®ã€‚
    *   ç‰¹åˆ«æ„Ÿè°¢ PSChina ç¤¾åŒºå¯¹å®å¯æ¢¦å¯¹æˆ˜ä¸­æ–‡åŒ–åšå‡ºçš„å“è¶Šè´¡çŒ®ã€‚
## ğŸ¨ ç¾æœ¯èµ„æº / Visual Assets
æœ¬é¡¹ç›®æ²¡æœ‰æ‰˜ç®¡åºå¤§çš„å›¾ç‰‡æ•°æ®åº“ï¼Œè€Œæ˜¯ä½¿ç”¨åŠ¨æ€åŠ è½½æŠ€æœ¯å¼•ç”¨äº†ä»¥ä¸‹ä¼˜ç§€çš„å…¬å…±èµ„æºåº“ï¼Œä»¥åŠéƒ¨åˆ† UI è®¾è®¡çµæ„Ÿå¼•ç”¨ã€‚
**ç²¾çµå›¾ä¸å›¾æ ‡ (Sprites & Icons)**
*   **PokÃ©mon Showdown Sprite Library**: [play.pokemonshowdown.com](https://play.pokemonshowdown.com/sprites/)
    *   æä¾›äº† Gen 1-5 çš„åŠ¨æ€åƒç´ å›¾ (Animated Sprites) åŠ Gen 6+ çš„é™æ€æ¨¡å‹å›¾ã€‚
*   **PkParaiso**: [pkparaiso.com](https://www.pkparaiso.com/)
    *   æä¾›äº†éƒ¨åˆ†é«˜ä¸–ä»£çš„é«˜è´¨é‡ 3D æ¨¡å‹åŠ¨æ€ GIFï¼Œç”¨äºæˆ˜æ–—æ¼”å‡ºã€‚
*   **PokÃ©Sprite**: [github.com/msikma/pokesprite](https://github.com/msikma/pokesprite)
    *   æä¾›äº†æå…¶å®Œå–„çš„å®å¯æ¢¦èœå•å›¾æ ‡ (PC Box Icons) å’Œé“å…·å›¾æ ‡æ•°æ®ã€‚
**UI è®¾è®¡ (interface Design)**
*   **é£æ ¼è‡´æ•¬**:
    *   æœ¬é¡¹ç›® UI é£æ ¼æ··åˆäº† **ã€Šå®å¯æ¢¦ï¼šå‰‘/ç›¾ (PokÃ©mon Sword & Shield)ã€‹** çš„æ‰å¹³åŒ–ç«æŠ€åœºé£æ ¼ä¸ **ã€Šå¥³ç¥å¼‚é—»å½•5 (Persona 5)ã€‹** çš„åŠ¨æ€å‰ªåˆ‡é£æ ¼ã€‚
    *   å¤æ­¦ç³»ç»Ÿ (Styles) UI è‡´æ•¬äº† **ã€Šå®å¯æ¢¦ä¼ è¯´ï¼šé˜¿å°”å®™æ–¯ (PokÃ©mon Legends: Arceus)ã€‹**ã€‚
## ğŸµ éŸ³æ•ˆä¸éŸ³ä¹ / Audio & BGM
*   **å®å¯æ¢¦å«å£° (Cries)**:
    *   éŸ³é¢‘æ–‡ä»¶åŠ¨æ€è¯·æ±‚è‡ª `play.pokemonshowdown.com/audio/cries/`ã€‚
*   **èƒŒæ™¯éŸ³ä¹ (BGM) & éŸ³æ•ˆ (SFX)**:
    *   ç‰ˆæƒå½’å±äº **Nintendo (ä»»å¤©å ‚)**, **Game Freak**, **The PokÃ©mon Company** åŠåŸä½œæ›²å®¶ï¼ˆä¸€ä¹‹æ¿‘åˆš, å¢ç”°é¡ºä¸€ç­‰ï¼‰ã€‚æœ¬é¡¹ç›®ä»…åšå­¦ä¹ ä¸æ¼”ç¤ºç”¨é€”ä½¿ç”¨ã€‚
## âš–ï¸ å…è´£å£°æ˜ / Disclaimer
**PokÃ©monÂ®**, **PokÃ©mon Character Names**, **NintendoÂ®**, **Game Freak**, and **The PokÃ©mon Company** are trademarks of **Nintendo**.
æœ¬é¡¹ç›® æ˜¯ä¸€ä¸ªéè¥åˆ©æ€§çš„ã€å¼€æºçš„ç²‰ä¸è‡ªåˆ¶é¡¹ç›® (Fan-made Project)ã€‚
*   æœ¬è½¯ä»¶å®Œå…¨å…è´¹ï¼Œä¸ç”¨äºä»»ä½•å•†ä¸šç›®çš„ã€‚
*   æ‰€æœ‰ä¸ã€Šå®å¯æ¢¦ã€‹ç›¸å…³çš„åŸæ–‡è®¾å®šã€å›¾åƒã€éŸ³é¢‘æ–‡ä»¶çš„ç‰ˆæƒå‡å½’ç‰ˆæƒæ–¹æ‰€æœ‰ã€‚
*   å¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»å¼€å‘è€…åˆ é™¤ç›¸å…³å†…å®¹ã€‚
---
*This file was generated to respect and credit the hard work of the community.*]]></file>
</pkm_project>