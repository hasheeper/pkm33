# ERA 变量框架：增删改指令用法指南

本文档旨在为角色卡/世界书作者和相关插件开发者提供 ERA 变量框架中 `<VariableInsert>`、`<VariableEdit>` 和 `<VariableDelete>` 三个核心指令的详细用法和逻辑说明。

## 目录

1. [`<VariableInsert>` (插入)](#variableinsert-插入)
2. [`<VariableEdit>` (更新)](#variableedit-更新)
3. [`<VariableDelete>` (删除)](#variabledelete-删除)
4. [综合示例](#综合示例)

---

## `<VariableInsert>` (插入)

**用途**: 向变量中 **添加新数据**。这是一个 **非破坏性** 操作，它绝不会修改或覆盖任何已经存在的数据。

### 核心行为

- **只增不改**: `insert` 只会在不存在的路径上创建新的属性和值。如果一个路径已经有值了，`insert` 会跳过对该路径的操作。
- **补充结构**: 如果指令中的父路径已经存在，`insert` 会在该父路径下补充新的子属性。

### `template` (模板) 的使用

`insert` 支持使用 `$template` 来为新创建的对象预设一个默认结构。模板本身也可以包含 `$meta` 属性。

- **何时使用**: 当 `insert` 创建一个全新的对象时，它会寻找可用的模板，并将模板与指令中的数据合并后存入变量。**`template` 对象本身的内容就是缺省值**
- **模板的继承与覆盖**:
  - 如果一个父元素定义了模板，那么在向其 **直接** 子元素插入新数据时，会自动应用父模板。
  - **如果子元素自身也定义了模板，则子元素的模板会优先于父模板。**
- **模板优先级**: 综合来看，模板的查找遵循以下优先级：
    1. **变量中已有的模板**: 如果要插入的路径的父级已经定义了 `$template`，将优先使用它。
    2. **继承的模板**: 如果父级没有，则会使用从更上层节点继承下来的模板。
    3. **指令中自带的模板**: 仅当以上两者都不存在时，才会使用本次 `insert` 指令中提供的 `$template`。

### 示例：复杂的模板继承与覆盖

**第 1 步: 定义一个带模板的结构**

- **指令**:

  ```xml
  <VariableInsert>
  {
    "guild": {
      "$template": {
        "rank": "Rookie",
        "contribution": 0,
        "$meta": { "updatable": true }
      }
    }
  }
  </VariableInsert>
  ```

- **逻辑**: 创建 `guild` 结构，并为其定义一个模板。这个模板将应用于未来直接添加到 `guild` 下的新成员。

**第 2 步: 使用模板插入新成员**

- **指令**:

  ```xml
  <VariableInsert>
  {
    "guild": {
      "Alex": { "class": "Warrior" },
    }
  }
  </VariableInsert>
  ```

- **逻辑**:
    1. 插入 `Alex` 作为 `guild` 的直接子节点。它继承了父级 `guild` 的模板。
- **最终 `guild` 的值**:

  ```json
  {
    "guild": {
      "Alex": {
        "class": "Warrior",
        "rank": "Rookie",
        "contribution": 0,
        "$meta": { "updatable": true }
      }
    }
  }
  ```

### `$meta.unInsertAble`（插入保护）

- **作用**：在目标节点的 `$meta` 中写入 `unInsertAble`，即可为该节点及其层级配置 **禁止新增** 的规则，根节点同样适用。
- **`"all"`**：除 `$meta` 自身外，拒绝一切递归插入；只允许显式修改 `$meta`（例如清空或删除 `unInsertAble`）来解除保护。
- **`"self"`**：禁止在当前节点下新增任何“直属子属性”键，但允许对已存在的键继续递归插入或修改已有内容。
- **修改 `$meta` 默认放行**：针对 `$meta` 的写入被视为合法维护操作，因此可以在保护开启后单独更新 `$meta` 字段以调整配置。
- **根节点同样生效**：`applyInsertAtLevel` 在 basePath 为 `''` 时也会读取 `$meta.unInsertAble`，因此只需在根对象写入即可保护整个变量树。

---

## `<VariableEdit>` (更新)

**用途**: **修改已存在的数据**。这是一个 **破坏性** 操作，它会直接用新值覆盖目标路径的旧值。

### 核心行为

- **只改不增**: `edit` 只会修改已经存在的路径。如果指令中指定的路径不存在，操作将被跳过。
- **直接覆盖**: `edit` 会用指令中提供的新值完全替换掉目标路径上的旧值。
- **完整日志**: 即使指令提供的新值与旧值相同，`edit` 依然会执行写入并记录日志。

### `$meta.updatable` (可更新) 的使用

- **`updatable: false`**: 在变量的 `$meta` 中将此项设为 `false`，该变量及其所有子孙变量（跨层级）都将受到保护，无法被更新。
- **默认行为**: 如果不设置 `updatable`，则默认为 `true`（允许更新）。
- **如何解除保护**: 只要 `edit` 指令中 **包含了** 将 `$meta.updatable` 的值从 `false` 改为 `true` 的部分，保护就会被解除，并且 同一个指令中的其他有效更新也会被一并执行，注意，updatable的保护不包含防删除。

### 示例

**示例 1: 常规更新**

- **变量**:

  ```json
  { "player": { "hp": 100 } }
  ```

- **指令**: `<VariableEdit>{ "player": { "hp": 90 } }</VariableEdit>`
- **结果**:

  ```json
  { "player": { "hp": 90 } }
  ```

**示例 2: 尝试更新受保护的变量 (失败)**

- **变量**:

  ```json
  { "player": { "hp": 100, "$meta": { "updatable": false } } }
  ```

- **指令**: `<VariableEdit>{ "player": { "hp": 90 } }</VariableEdit>`
- **结果**: 无变化，因为 `player` 节点受保护。

**示例 3: 解除保护并同时更新其他属性**

- **变量**: (同上)
- **指令**:

  ```xml
  <VariableEdit>
  {
    "player": {
      "hp": 80,
      "$meta": { "updatable": true }
    }
  }
  </VariableEdit>
  ```

- **逻辑**: 指令中包含了将 `updatable` 改为 `true` 的部分，满足解除保护的条件。因此，对 `hp` 的更新和对 `$meta` 的更新都会被成功执行。
- **结果**:

  ```json
  { "player": { "hp": 80, "$meta": { "updatable": true } } }
  ```

---

## `<VariableDelete>` (删除)

**用途**: **删除已存在的数据**。这是一个 **破坏性** 操作。

### 核心行为

- **删除节点本身**: 在指令中，使用一个 **空对象 `{}`** 作为值，表示要删除该键对应的整个节点。
- **删除子节点**: 在指令中，使用一个 **非空对象** 作为值，表示要继续深入，去删除更深层级的子节点。

### `$meta.necessary` (必要性) 的使用

- **`"self"`**: 保护当前节点 **不被直接删除**，但其子节点 **可以被删除**。
- **`"all"`**: 保护当前节点及其所有子孙节点不被任何删除操作影响。
- **如何解除保护**: 只要 `delete` 指令中 **包含了** 删除 `$meta` 对象本身或删除 `$meta.necessary` 属性的逻辑，保护就会被解除，并且 **同一个指令中的其他有效删除也会被一并执行**。

### 示例

**示例 1: `necessary: "self"` 的区别**

- **变量**:

  ```json
  { "user": { "name": "Alex", "stats": { "str": 10 }, "$meta": { "necessary": "self" } } }
  ```

- **指令 1 (删除子节点 - 成功)**: `<VariableDelete>{ "user": { "stats": {} } }</VariableDelete>`
  - **结果**:

    ```json
    { "user": { "name": "Alex", "$meta": { "necessary": "self" } } }
    ```

- **指令 2 (删除自身 - 失败)**: `<VariableDelete>{ "user": {} }</VariableDelete>`
  - **结果**: 无变化。

**示例 2: `necessary: "all"` 的保护**

- **变量**:

  ```json
  { "user": { "name": "Alex", "stats": { "str": 10 }, "$meta": { "necessary": "all" } } }
  ```

- **指令 (删除子节点 - 失败)**: `<VariableDelete>{ "user": { "stats": {} } }</VariableDelete>`
  - **结果**: 无变化。

**示例 3: 解除保护并同时删除其他属性**

- **变量**: (同上)
- **指令**:

  ```xml
  <VariableDelete>
  {
    "user": {
      "stats": {},
      "$meta": { "necessary": {} }
    }
  }
  </VariableDelete>
  ```

- **逻辑**: 指令中包含了删除 `necessary` 属性的逻辑，满足解除保护的条件。因此，对 `stats` 的删除和对 `$meta.necessary` 的删除都会被成功执行。
- **结果**:

  ```json
  { "user": { "name": "Alex", "$meta": {} } }
  ```

---

## 综合示例

本章节将通过一个连续的场景，完整地展示三个指令如何协同工作。

### 1. 初始化世界状态

首先，我们使用一个复杂的 `<VariableInsert>` 指令来初始化整个世界的变量结构。

- **指令**:

  ```xml
  <VariableInsert>
  {
    "world_state": {
      "capital": {
        "type": "city",
        "population": 1000,
        "description": "The bustling capital city.",
        "$meta": {
          "updatable": false,
          "necessary": "all"
        }
      },
      "characters": {
        "$template": {
            "level": 1,
            "hp": 10,
            "inventory": [],
            "$meta": { "necessary": "self" }
          }
      },
      "game_version": "1.0.0"
    }
  }
  </VariableInsert>
  ```

- **逻辑**: 创建了一个 `world_state` 对象。`capital` 被 `meta` 保护。`characters` 定义了一个模板，用于之后创建的新角色。

### 2. 后续操作：`<VariableInsert>`

- **场景 A: 成功 - 应用父节点模板**
  - **指令**: `<VariableInsert>{ "world_state": { "characters": { "player": { "hp": 15 } } } }</VariableInsert>`
  - **逻辑**: `player` 是新角色，应用了 `characters` 下的模板。指令中的 `hp: 15` 覆盖了模板中的 `hp: 10`。
  - **结果**: `player` 对象被创建为:

    ```json
    {
      "level": 1,
      "hp": 15,
      "inventory": [],
      "$meta": { "necessary": "self" }
    }
    ```

- **场景 B: 半失败 - $template已存在，无法插入，也自然无法使用**
  - **指令**:

    ```xml
    <VariableInsert>
    {
      "world_state": {
        "characters": {
          "$template": { 
            "level": 99, "hp": 9999, "$meta": { "necessary": "all" }
          },
          "final_boss": { "hp": 8888 }
        }
      }
    }
    </VariableInsert>
    ```

  - **逻辑**: insert无法插入已存在的值。
  - **结果**: `final_boss` 对象被创建为:

    ```json
    {
      "level": 1,
      "hp": 8888,
      "inventory": [],
      "$meta": { "necessary": "all" }
    }
    ```

- **场景 C: 成功 - 模板的嵌套使用**
  - **前置操作**: 首先，我们通过 `edit` 在 `characters` 的 `$template` 中，同时定义一个“原型模板”（直接包含 `level` 等属性）和一个针对 `npc_guard` 的“特异性模板”。

    ```xml
    <VariableInsert>
    {
      "world_state": {
        "characters": {
          "$template": {
            "follower": {
              "$template":{
                "level":10,
                "hp":200,
                "faction":"None",
                "sex":"female"
              }
            }
          }
        }
      }
    }
    </VariableInsert>
    ```

  - **指令**:

    ```xml
    <VariableInsert>
    {
      "world_state": {
        "characters": {
          "player": {
            "follower":{
            }
          }
        }
      }
    }
    {
      "world_state": {
        "characters": {
          "player": {
            "follower":{
              "lili":{
                "level":1
              },
              "cityGuard":{}
            }
          }
        }
      }
    }
    </VariableInsert>

  - **逻辑**:
    1. 在 `follower` 层级，其模板定义了,但是系统检测到playwer无follower（因为plawer的插入在follower模板的构造之前）。所以直接试图使用follwer内部的模板是无效的。必须先为player插入follwer，而后再为follower插入值，即可应用模板。
    2. 当插入 `lili` 时用指令中的 `level: 1` 覆盖原型中的默认值。
  - **结果**: `player.follower` 的数据最终变为：

    ```json
    {
      "lili": {
        "level": 1,
        "hp": 200,
        "faction": "None",
        "sex": "female"
      },
      "cityGuard": {
        "level": 5,
        "hp": 50,
        "faction": "None",
        "sex": "female"
      }
    }
    ```

- **场景 D: 失败 - 路径已存在**
  - **指令**: `<VariableInsert>{ "world_state": { "game_version": "1.0.1" } }</VariableInsert>`
  - **逻辑**: `game_version` 路径已存在，`insert` 不会覆盖它。
  - **结果**: 无变化。

### 3. 后续操作：`<VariableEdit>`

- **场景 A: 失败 - 路径受 `updatable: false` 保护**
  - **指令**: `<VariableEdit>{ "world_state": { "capital": { "population": 1001 } } }</VariableEdit>`
  - **逻辑**: `capital` 节点受 `updatable: false` 保护，操作被阻止。
  - **结果**: 无变化。

- **场景 B: 成功 - 解除保护并同时更新**
  - **指令**: `<VariableEdit>{ "world_state": { "capital": { "population": 1002, "$meta": { "updatable": true } } } }</VariableEdit>`
  - **逻辑**: 指令中包含了解除保护的部分，因此对 `population` 的更新也被一并执行。
  - **结果**: `capital` 的 `population` 变为 `1002`，`updatable` 变为 `true`。

- **场景 C: 失败 - 路径不存在**
  - **指令**: `<VariableEdit>{ "world_state": { "lost_city": { "population": 1 } } }</VariableEdit>`
  - **逻辑**: `lost_city` 路径不存在，`edit` 只修改已存在路径，操作跳过。
  - **结果**: 无变化。

### 4. 后续操作：`<VariableDelete>`

- **场景 A: 失败 - 路径受 `necessary: "all"` 保护**
  - **指令**: `<VariableDelete>{ "world_state": { "capital": { "description": {} } } }</VariableDelete>`
  - **逻辑**: `capital` 节点受 `necessary: "all"` 保护，其所有子节点都无法被删除。
  - **结果**: 无变化。

- **场景 B: 成功 - 删除受 `necessary: "self"` 保护的节点的子节点**
  - **指令**: `<VariableDelete>{ "world_state": { "characters": { "player": { "inventory": {} } } } }</VariableDelete>`
  - **逻辑**: `player` 受 `self` 保护，意味着它自身不能被直接删除，但其子节点 `inventory` 可以。
  - **结果**: `player` 对象中的 `inventory` 属性被删除。

- **场景 C: 成功 - 解除保护并同时删除**
  - **指令**: `<VariableDelete>{ "world_state": { "characters": { "final_boss": { "hp": {}, "$meta": {} } } } }</VariableDelete>`
  - **逻辑**: `final_boss` 受 `all` 保护。但指令中包含了删除 `$meta` 的豁免操作，因此对 `hp` 的删除也被一并执行。
  - **结果**: `final_boss` 对象中的 `hp` 和 `$meta` 属性都被删除。

  <variable_rule>
# ERA 变量操作规则

- **无变化则不操作**: 当变量信息与故事发展相比没有变化时，禁止生成任何指令块。
- **新增则 `Insert`**: 当出现全新的角色、物品、状态或信息时，必须使用 `<VariableInsert>`。
- **修改则 `Update`**: 当已有的数据需要更新其值时（如等级提升、状态改变），必须使用 `<VariableEdit>`。
- **移除则 `Delete`**: 当数据被明确地消耗、移除或销毁时，必须使用 `<VariableDelete>`。

## 指令核心规则
- **`<VariableInsert>`**:
    - **只增不改**: 用于添加新数据，它绝不会覆盖任何已经存在的数据。
- **`<VariableEdit>`**:
    - **只改不增**: 用于修改已存在的数据，它绝不会在不存在的路径上创建新数据。
- **`<VariableDelete>`**:
    - **删除节点**: 在指令中，使用一个 **空对象 `{}`** 作为值，表示要删除该键对应的整个节点。

</variable_rule>

<format_request>
你必须根据有关要求及变量现有状态，补完 `<VariableThink>` 及 `<VariableInsert>`、`<VariableEdit>`、`<VariableDelete>` 等指令块。

**严格遵守以下流程**:

1.  **输出正文**:
    -   首先，生成本次回复的正文内容。

2.  **输出思考与指令**:
    -   在正文内容之后，必须立即输出 `<VariableThink>` 块，并在其中进行思考。
    -   在 `<VariableThink>` 块之后，必须立即输出一个或多个指令块 (`<VariableInsert>`、`<VariableEdit>`、`<VariableDelete>`)。

3.  **格式要求**:
    -   所有指令块的内容都必须是 **严格合法** 的 JSON 格式。
    -   所有 JSON 的键（key）都必须使用双引号 `"`。
    -   严格遵循 `<variable_rule>` 中定义的所有规则。

# ** 回复内容必须仿照格式示例，以该格式回复；必须包含意图分析、变量变更分析和操作计划，以及操作计划计划生成的完整`<VariableInsert>`或`<VariableEdit>`的标签代码块来实现对ERA变量的维护 **

即，必须保证最终输出格式为：
  {其他内容（如正文）和格式}

  <VariableThink>
    1.  **意图分析**: {变量更新意图}
    2.  **操作计划**:
      - {操作意图}
  </VariableThink>
  <VariableInsert>
  {Insert的JSON格式变量,严格遵守变量路径}
  </VariableInsert>
  <VariableEdit>
  {Edit的JSON格式变量,严格遵守变量路径}
  </VariableEdit>

### 格式示例
  {其他内容（如正文）和格式...}

  <VariableThink>
  1.  **意图分析**: 故事中出现了一个新角色 "Elara"，需要将其添加到 `characters` 对象中。同时，主角 "player" 的 `hp` 从 15 减少到了 10。
  2.  **操作计划**:
      -   生成一个 `<VariableInsert>` 块来添加新角色 "Elara"。
      -   生成一个 `<VariableEdit>` 块来更新 "player" 的 `hp`。
  </VariableThink>
  <VariableInsert>
  {
    "characters": {
      "Elara": {
        "class": "Archer"
      }
    }
  }
  </VariableInsert>
  <VariableEdit>
  {
    "characters": {
      "player": {
        "hp": 10
      }
    }
  }
  </VariableEdit>
</format_request>

# 如何在消息尾部稳定生成HTML状态栏

对于希望在每条AI生成的消息末尾稳定渲染自定义HTML状态栏的作者来说，ERA变量框架提供了一个专门的设置来实现此功能。

## 实现步骤

1. **打开ERA设置面板**
    * 在酒馆界面右下角，找到并点击ERA的 **悬浮球** 图标，即可打开设置面板。
    * **如果看不到悬浮球**：请前往酒馆助手的脚本库，找到ERA变量框架脚本，检查其设置中的 `开启悬浮球` 选项是否被关闭了。请确保它是开启状态。

2. **开启符号生成功能**
    * 在ERA设置面板中，找到并启用 **`在ai消息尾部生成特殊符号`** 这个选项。
    * （可选）你可以自定义 **`特殊符号值`** 选项，默认值为 `<StatusPlaceHolderImpl/>`。这个值就是ERA框架会自动添加到消息末尾的符号。

3. **在酒馆中设置正则表达式替换**
    * 现在，ERA框架会确保每条AI生成的消息末尾都包含你设定的特殊符号。你需要在酒馆的 **正则表达式** 设置中，添加一条规则来将这个符号替换为你的HTML状态栏代码。
    * 前往酒馆的 `扩展功能` -> `正则表达式` 菜单。
    * 点击 `添加新的正则表达式` 并填写以下字段：
        * **匹配 (Match)**: 填入你的 **`特殊符号值`**。例如，如果使用默认值，就填 `<StatusPlaceHolderImpl/>`。
        * **替换 (Replace)**: 填入你想要显示的 **HTML状态栏代码**。这段代码可以包含ERA宏来动态显示变量。

    **替换 (Replace) 字段示例:**

    关于替换字段中使用的HTML代码，请参考本目录下的 **`状态栏HTML示例.html`** 文件。

    你可以将该文件中的全部内容复制并粘贴到酒馆正则表达式的“替换 (Replace)”字段中。

    **特别注意**：在粘贴HTML代码到“替换 (Replace)”字段时，必须使用Markdown的HTML代码围栏将其包裹起来，如下所示，否则酒馆助手可能无法正确解析：

    ``````
    ```html
    (这里粘贴你的完整HTML代码)
    ```
    ``````

    * 确保勾选 `启用`，然后保存设置。

## 重要提醒

* **符号生成逻辑**: ERA框架只会在AI生成的消息中 **不存在** 对应特殊符号时，才会在末尾添加它。因此，如果你发现某个消息末尾没有生成符号，请首先检查该消息内容本身是否已经包含了这个符号。

* **配合ERA宏使用**: 如果你的HTML状态栏中使用了ERA宏（例如 `{{ERA:player.hp}}`）来动态获取数据，为了确保每次状态栏都能显示最新的变量值，你 **必须** 在ERA设置中开启 **`强制重载功能`**。这会强制ERA在每次消息生成时都重新渲染包含宏的部分，确保数据实时更新。如果你不希望每次都强制重载，可以参考 **`进阶角色卡构建需要阅读和使用的文件`** 目录下的文档，了解更灵活的数据更新方式。

通过以上步骤，你就可以实现一个稳定、可靠且能动态更新的HTML状态栏。

---

### 进阶用法：通过监听事件更新

如果你不希望使用“强制重载”功能，或者想要实现更复杂的交互，可以不使用ERA宏，而是通过编写JavaScript脚本来监听ERA的 `era:writeDone` 事件，从而手动更新状态栏。

这种方法性能更好，也更灵活。详细实现请参考 **`进阶角色卡构建需要阅读和使用的文件`** 目录下的 **`动态更新状态栏示例.html`** 文件。
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>状态栏</title>
  <style>
    /* 
      建议将此 <style> 块和下面的 <div class="era-statusbar">...</div> 一起
      复制到酒馆正则表达式的“替换 (Replace)”字段中。
    */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');

    body {
      /* 设置一个基础字体，但主要样式由 .era-statusbar 控制 */
      font-family: 'Noto Sans SC', sans-serif;
      margin: 0;
      padding: 0;
      background-color: transparent; /* 确保背景透明，以便融入酒馆UI */
    }

    .era-statusbar {
      color: #E0E0E0;
      background: linear-gradient(145deg, #2c3e50, #34495e);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      border: 1px solid #4a6278;
      overflow: hidden; /* 确保子元素不会溢出圆角 */
    }

    .era-statusbar-header {
      display: flex;
      align-items: center;
      border-bottom: 1px solid #4a6278;
      padding-bottom: 10px;
      margin-bottom: 12px;
    }

    .era-statusbar-header h4 {
      margin: 0;
      font-size: 1.1em;
      font-weight: 700;
      color: #1abc9c; /* 高亮标题颜色 */
      text-shadow: 0 0 5px rgba(26, 188, 156, 0.5);
    }

    .era-statusbar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }

    .era-statusbar-item {
      background-color: rgba(255, 255, 255, 0.05);
      padding: 8px 12px;
      border-radius: 8px;
    }

    .era-statusbar-item-label {
      font-size: 0.85em;
      color: #bdc3c7;
      margin-bottom: 4px;
    }

    .era-statusbar-item-value {
      font-size: 1em;
      font-weight: 700;
      color: #ecf0f1;
    }
  </style>
</head>
<body>
  <div class="era-statusbar">
    <div class="era-statusbar-header">
      <h4>角色状态</h4>
    </div>
    <div class="era-statusbar-grid">
      <div class="era-statusbar-item">
        <div class="era-statusbar-item-label">生命值</div>
        <div class="era-statusbar-item-value">{{ERA:player.hp}} / {{ERA:player.max_hp}}</div>
      </div>
      <div class="era-statusbar-item">
        <div class="era-statusbar-item-label">金钱</div>
        <div class="era-statusbar-item-value">{{ERA:player.gold}} G</div>
      </div>
      <!-- 您可以在这里添加更多状态项 -->
      <!--
      <div class="era-statusbar-item">
        <div class="era-statusbar-item-label">魔力值</div>
        <div class="era-statusbar-item-value">{{ERA:player.mp}} / {{ERA:player.max_mp}}</div>
      </div>
      -->
    </div>
  </div>
</body>
</html>
[系统提示：以下是动态生成的世界状态报告，请根据此信息进行回应。]

# 世界状态报告

## 一、游戏概览

*   **当前游戏版本**: `{{ERA:world_state.game_version}}`
    {{// 用法说明 (方法一：ERA 宏): //}}
    {{// 这是最基础的 ERA 宏用法。`ERA:path.to.variable` 会被自动替换为 chat 变量中对应路径的值。 //}}
    {{// 此处，它会显示 `world_state.game_version` 的值。 //}}
    {{// 这种方式最简单直观，适用于直接展示变量。 //}}

## 二、首都信息

我们的故事发生在一个名为 **{{ERA:world_state.capital.type}}** 的宏伟城市。

*   **城市人口**: 目前约有 **{{ERA:world_state.capital.population}}** 名居民。
*   **城市描述**: {{ERA:world_state.capital.description}}

## 三、角色创建规则
{{// 用法说明 (ERA 宏处理对象): //}}
{{// 如果 ERA 宏查询的路径指向一个对象或数组，它会自动被转换成一个 JSON 字符串。 //}}
{{// 下面的宏将展示 `world_state.characters.$template` 这个对象的内容。 //}}
在这个世界中，所有新角色都遵循以下基础模板：
```json
{{ERA:world_state.characters.$template}}
```

## 四、完整的世界状态数据 (ERA 宏获取)
{{// 用法说明 (ERA 宏获取完整数据): //}}
{{// 这是获取完整数据的推荐方式，因为它更简洁且由 ERA 框架原生支持。//}}

### 纯净数据 (不含 $)
```json
{{ERA:$ALLDATA}}
```

### 原始数据 (包含 $)
```json
{{ERA-withmeta:$ALLDATA}}
# ERA 变量体系操作提示 (示例模版)

以下规则说明了在故事推进过程中，AI 应当如何使用 ERA 的 `<VariableInsert>`、`<VariableEdit>`、`<VariableDelete>` 来维护游戏变量。

请始终遵守以下操作规范：

1. **只使用 ERA 提供的三种指令** (`Insert`/`Edit`/`Delete`)。
2. **保证操作的时机与剧情逻辑一致**。

---

## :earth_africa: world_state.capital (首都信息)

* **规则 1**：首都的基础信息 (`type`、`population`、`description`) 在初始化后通常不应修改。

  * `capital` 节点受保护，AI 不得随意使用 `<VariableEdit>` 或 `<VariableDelete>` 改动此部分。
  * 如果确有剧情需要（例如人口随剧情发展发生变化），必须先显式解除保护 (`$meta.updatable=true`)，然后再执行修改。

---

## :adult: characters (角色信息)

* **规则 2**：当故事中**出现新角色**时，必须立刻使用 `<VariableInsert>` 在 `characters` 下创建该角色节点。

  * 新角色应至少包含：
    {
      "level": 1,
      "hp": 10,
      "inventory": []
    }
  * 角色的基础属性（如姓名、职业、初始状态）应当在插入时一并写入。

* **规则 3**：当角色状态发生变化时（如 HP 减少、等级提升、背包物品增加），应使用 `<VariableEdit>` 更新对应路径。

  * 示例：角色受伤时 → `<VariableEdit>{ "characters": { "Alex": { "hp": 8 } } }</VariableEdit>`
  * 示例：角色获得新物品时 → `<VariableEdit>{ "characters": { "Alex": { "inventory": ["Potion"] } } }</VariableEdit>`

* **规则 4**：当角色永久离开故事（死亡/消失/彻底退场）时，允许使用 `<VariableDelete>` 删除该角色节点。

  * 但只能在必要时清空部分属性，或者在剧情确凿时先移除 `$meta.necessary` 再删除整个角色。

---

## :gear: game_version (游戏版本)

* **规则 5**：`game_version` 用于标记游戏进度版本。

  * 通常只允许在进行 **全局重大更新** 时，通过 `<VariableEdit>` 修改。
  * 例如：剧情进入第二章时 → `<VariableEdit>{ "world_state": { "game_version": "2.0.0" } }</VariableEdit>`

---

# 总体逻辑提示

* **新增元素 → Insert**
* **已存在元素发生变化 → Edit**
* **元素彻底移除 → Delete**

AI 应当在叙事中根据这些规则同步变量，确保 ERA 的状态始终与玩家所见剧情一致。
# 进阶用法：EJS 模板与动态数据

当简单的宏无法满足需求时（例如，需要条件判断、循环或更复杂的数据处理），您可以在世界书中使用 EJS (Embedded JavaScript) 模板。

## 一、动态情报 (EJS 示例)
{{// 用法说明 (方法二：EJS 模板): //}}
{{// 当需要更复杂的逻辑时，可以使用 EJS 模板。下面的示例将所有逻辑包裹在一个立即调用的异步函数中。//}}
{{// 这种模式 `<%= await (async () => { ... })() %>` 可以创建局部作用域，避免变量污染，是编写复杂 EJS 逻辑的最佳实践。//}}
<%= await (async () => {
  try {
    let output = '<capital_dynamic_report>\n  capital_status:\n';
    const population = getvar('stat_data.world_state.capital.population', { scope: 'local' });

    if (typeof population === 'number') {
      if (population >= 1000) {
        output += '    - 首都人口已达 ' + population + '，是一个繁荣的大都会。商业活动频繁，文化交流兴盛。';
      } else if (population >= 500) {
        output += '    - 首都人口为 ' + population + '，规模可观，是一个重要的区域中心。';
      } else {
        output += '    - 首都当前人口为 ' + population + '，是一个宁静的小型城市，充满发展潜力。';
      }
    } else {
      output += '    - 无法获取准确的人口数据。';
    }
    
    output += '\n</capital_dynamic_report>';
    return output;
  } catch (e) {
    return '[EJS 脚本错误 (动态情报)]: ' + (e?.message || e);
  }
})() %>

## 二、完整的世界状态数据 (EJS 示例)

### 2.1 使用 EJS 模板获取
{{// 用法说明 (EJS 模板输出完整对象): //}}
<%= await (async () => {
  try {
    const worldState = getvar('stat_data.world_state', { scope: 'local', clone: true });
    if (worldState) {
      return JSON.stringify(worldState, null, 2);
    } else {
      return "[错误: 未能从聊天变量中找到 world_state。]";
    }
  } catch (e) {
    return `[EJS 脚本错误 (完整状态)]: ${e?.message || e}`;
  }
})() %>
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>动态更新状态栏</title>
    <style>
      /* 
      这是一个进阶示例，演示如何通过监听 ERA 事件来动态更新状态栏，
      从而避免使用 ERA 宏和“强制重载”功能。
    */
      @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');

      body {
        font-family: 'Noto Sans SC', sans-serif;
        margin: 0;
        padding: 0;
        background-color: transparent;
      }

      .era-statusbar {
        color: #e0e0e0;
        background: linear-gradient(145deg, #2c3e50, #34495e);
        border-radius: 12px;
        padding: 16px;
        margin-top: 20px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        border: 1px solid #4a6278;
        overflow: hidden;
      }

      .era-statusbar-header {
        display: flex;
        align-items: center;
        border-bottom: 1px solid #4a6278;
        padding-bottom: 10px;
        margin-bottom: 12px;
      }

      .era-statusbar-header h4 {
        margin: 0;
        font-size: 1.1em;
        font-weight: 700;
        color: #1abc9c;
        text-shadow: 0 0 5px rgba(26, 188, 156, 0.5);
      }

      .era-statusbar-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }

      .era-statusbar-item {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 8px 12px;
        border-radius: 8px;
      }

      .era-statusbar-item-label {
        font-size: 0.85em;
        color: #bdc3c7;
        margin-bottom: 4px;
      }

      .era-statusbar-item-value {
        font-size: 1em;
        font-weight: 700;
        color: #ecf0f1;
      }
    </style>
  </head>
  <body>
    <div class="era-statusbar">
      <div class="era-statusbar-header">
        <h4>角色状态</h4>
      </div>
      <div class="era-statusbar-grid">
        <div class="era-statusbar-item">
          <div class="era-statusbar-item-label">生命值</div>
          <div class="era-statusbar-item-value" id="player-hp">-- / --</div>
        </div>
        <div class="era-statusbar-item">
          <div class="era-statusbar-item-label">金钱</div>
          <div class="era-statusbar-item-value" id="player-gold">-- G</div>
        </div>
      </div>
    </div>

    <script>
      // 确保在 DOM 完全加载后再执行脚本
      document.addEventListener('DOMContentLoaded', () => {
        // 获取需要更新的 DOM 元素
        const hpElement = document.getElementById('player-hp');
        const goldElement = document.getElementById('player-gold');

        /**
         * 更新 UI 的函数
         * @param {object} stat - 从 era:writeDone 事件中获取的 statWithoutMeta 对象
         */
        function updateUI(stat) {
          // 使用 lodash 的 _.get 方法安全地获取嵌套属性，如果路径不存在则提供默认值
          const hp = _.get(stat, 'player.hp', '--');
          const maxHp = _.get(stat, 'player.max_hp', '--');
          const gold = _.get(stat, 'player.gold', '--');

          // 更新 DOM 元素的内容
          if (hpElement) {
            hpElement.textContent = `${hp} / ${maxHp}`;
          }
          if (goldElement) {
            goldElement.textContent = `${gold} G`;
          }
        }

        // 监听 ERA 框架的变量写入完成事件
        // 这是动态更新数据的核心
        eventOn('era:writeDone', detail => {
          console.log('ERA:writeDone event received:', detail);
          // 使用 statWithoutMeta 来更新 UI，它是不包含 ERA 内部字段的纯净数据
          if (detail && detail.statWithoutMeta) {
            updateUI(detail.statWithoutMeta);
          }
        });

        // 在脚本加载时，主动请求一次当前变量状态，用于初始化UI
        // ERA 会以一个 era:writeDone 事件来响应这个请求
        console.log('Requesting initial ERA variables...');
        eventEmit('era:requestWriteDone');
      });
    </script>
  </body>
</html>
# 如何设计和说明你的 ERA 变量系统（快速入门）

本文档旨在帮助你——角色卡作者——用最简单的方式，为你的角色卡设计一套清晰、可维护的变量系统，并指导你如何向 AI 说明这套系统，以便 AI 能够正确地理解和操作它们。

---

## 第一步：在开场白中初始化你的变量

变量系统的第一步是在角色卡的**开场白**（First Message）中使用 `<VariableInsert>` 标签定义所有变量的初始状态。这是 AI 理解你的数据结构的起点。

**核心建议**：使用**对象**来管理物品集合（如背包），而不是数组。对象同样支持增删改，且更容易与 ERA 的模板功能（进阶）结合。

这是一个典型的角色扮演游戏（RPG）变量结构，你可以直接复制并根据你的需求修改。

```json
<VariableInsert>
{
  "player": {
    "name": "勇者",
    "level": 1,
    "hp": 100,
    "max_hp": 100,
    "mp": 50,
    "max_mp": 50,
    "stats": {
      "strength": 10,
      "agility": 8,
      "intelligence": 5
    }
  },
  "inventory": {
    "item_001": {
      "name": "初级治疗药水",
      "quantity": 3
    }
  },
  "game_time": {
    "day": 1,
    "hour": 8
  },
  "world_state": {
    "location": "起始的村庄",
    "npcs": {
      "npc_001": { "name": "村民A", "mood": "平常" },
      "npc_002": { "name": "卫兵B", "mood": "警惕" }
    }
  }
}
</VariableInsert>
```

在将以上示例变量初始化复制入开场白后，请开启一个新聊天以使其生效

---

## 第二步：在世界书中向 AI 说明你的设计

这是至关重要的一步。你需要在一个专门的世界书条目中，用自然语言向 AI 解释你的变量系统。这将极大地影响 AI 生成变量操作指令的准确性。

**目标条目**：`ERA变量意图说明`

**核心技巧**：在条目开头使用 `{{ERA:$ALLDATA}}` 宏。这会自动将当前所有变量的最新状态（JSON格式）展示给 AI，让它在做决策时总能看到最新数据。

以下是一个根据上述变量结构编写的“ERA变量意图说明”示例。

# ERA 变量意图说明

这是当前所有变量的状态：
{{ERA:$ALLDATA}}

## 变量意图解释

### 玩家 (`player`)

- `player.hp`: 玩家当前生命值。受伤时减少，使用药水或休息时恢复。不能超过 `player.max_hp`。
- `player.level`: 玩家等级。通常在获得足够经验值后提升。
- `player.stats`: 玩家的核心属性，影响战斗和检定。

### 背包 (`inventory`)

- 这是一个**对象**，存放玩家拥有的物品。每个物品都是一个键值对，键是物品的唯一ID（如 `item_001`），值是物品信息。
- **特殊规则**: 当向背包中添加物品时，如果是同名物品，应优先增加已有物品的 `quantity`（数量），而不是添加一个新物品。

### 游戏时间 (`game_time`)

- `day`, `hour`: 分别代表天和小时。
- **特殊规则**: 时间会随着剧情自然流逝。`hour` 达到 24 时归零并使 `day` 加 1。

### 世界状态 (`world_state`)

- `location`: 玩家当前所在的地点。
- `npcs`: 一个对象，包含当前场景中所有重要的 NPC。键是 NPC 的唯一 ID，值是他们的状态信息。
  - **更新NPC状态**: 当与NPC互动后，应更新其内部状态，如`mood`（心情）。例如，如果玩家帮助了村民A，他的心情可能会变为“感激”。
  - **新增NPC**: 当新的NPC进入场景时，应在`npcs`对象中为他们添加一个新的条目，并分配一个唯一的ID（如`npc_003`）。
  - **移除NPC**: 当NPC离开场景时，应从`npcs`对象中删除对应的条目。

---

## 需要更强大的功能？

本文档只涵盖了最基础的变量设置。如果你需要实现更进阶的功能，例如：

- 使用模板来创建标准化的物品
- 为变量增加保护限制以防止ai的更新错误破坏结构。
- 使用宏和ejs脚本优化提示词、降低token、实现更复杂的状态栏功能

请阅读以下文档：

- `构建era角色卡需要阅读和使用的文件/ERA_document.md`
- `进阶角色卡构建需要阅读和使用的文件/EJS与动态数据示例.txt`